var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/.pnpm/orderedmap@2.1.1/node_modules/orderedmap/dist/index.cjs
var require_dist = __commonJS({
  "node_modules/.pnpm/orderedmap@2.1.1/node_modules/orderedmap/dist/index.cjs"(exports2, module2) {
    "use strict";
    function OrderedMap(content) {
      this.content = content;
    }
    OrderedMap.prototype = {
      constructor: OrderedMap,
      find: function(key) {
        for (var i = 0; i < this.content.length; i += 2)
          if (this.content[i] === key) return i;
        return -1;
      },
      // :: (string) → ?any
      // Retrieve the value stored under `key`, or return undefined when
      // no such key exists.
      get: function(key) {
        var found = this.find(key);
        return found == -1 ? void 0 : this.content[found + 1];
      },
      // :: (string, any, ?string) → OrderedMap
      // Create a new map by replacing the value of `key` with a new
      // value, or adding a binding to the end of the map. If `newKey` is
      // given, the key of the binding will be replaced with that key.
      update: function(key, value, newKey) {
        var self2 = newKey && newKey != key ? this.remove(newKey) : this;
        var found = self2.find(key), content = self2.content.slice();
        if (found == -1) {
          content.push(newKey || key, value);
        } else {
          content[found + 1] = value;
          if (newKey) content[found] = newKey;
        }
        return new OrderedMap(content);
      },
      // :: (string) → OrderedMap
      // Return a map with the given key removed, if it existed.
      remove: function(key) {
        var found = this.find(key);
        if (found == -1) return this;
        var content = this.content.slice();
        content.splice(found, 2);
        return new OrderedMap(content);
      },
      // :: (string, any) → OrderedMap
      // Add a new key to the start of the map.
      addToStart: function(key, value) {
        return new OrderedMap([key, value].concat(this.remove(key).content));
      },
      // :: (string, any) → OrderedMap
      // Add a new key to the end of the map.
      addToEnd: function(key, value) {
        var content = this.remove(key).content.slice();
        content.push(key, value);
        return new OrderedMap(content);
      },
      // :: (string, string, any) → OrderedMap
      // Add a key after the given key. If `place` is not found, the new
      // key is added to the end.
      addBefore: function(place, key, value) {
        var without = this.remove(key), content = without.content.slice();
        var found = without.find(place);
        content.splice(found == -1 ? content.length : found, 0, key, value);
        return new OrderedMap(content);
      },
      // :: ((key: string, value: any))
      // Call the given function for each key/value pair in the map, in
      // order.
      forEach: function(f) {
        for (var i = 0; i < this.content.length; i += 2)
          f(this.content[i], this.content[i + 1]);
      },
      // :: (union<Object, OrderedMap>) → OrderedMap
      // Create a new map by prepending the keys in this map that don't
      // appear in `map` before the keys in `map`.
      prepend: function(map) {
        map = OrderedMap.from(map);
        if (!map.size) return this;
        return new OrderedMap(map.content.concat(this.subtract(map).content));
      },
      // :: (union<Object, OrderedMap>) → OrderedMap
      // Create a new map by appending the keys in this map that don't
      // appear in `map` after the keys in `map`.
      append: function(map) {
        map = OrderedMap.from(map);
        if (!map.size) return this;
        return new OrderedMap(this.subtract(map).content.concat(map.content));
      },
      // :: (union<Object, OrderedMap>) → OrderedMap
      // Create a map containing all the keys in this map that don't
      // appear in `map`.
      subtract: function(map) {
        var result = this;
        map = OrderedMap.from(map);
        for (var i = 0; i < map.content.length; i += 2)
          result = result.remove(map.content[i]);
        return result;
      },
      // :: () → Object
      // Turn ordered map into a plain object.
      toObject: function() {
        var result = {};
        this.forEach(function(key, value) {
          result[key] = value;
        });
        return result;
      },
      // :: number
      // The amount of keys in this map.
      get size() {
        return this.content.length >> 1;
      }
    };
    OrderedMap.from = function(value) {
      if (value instanceof OrderedMap) return value;
      var content = [];
      if (value) for (var prop in value) content.push(prop, value[prop]);
      return new OrderedMap(content);
    };
    module2.exports = OrderedMap;
  }
});

// node_modules/.pnpm/prosemirror-model@1.25.4/node_modules/prosemirror-model/dist/index.cjs
var require_dist2 = __commonJS({
  "node_modules/.pnpm/prosemirror-model@1.25.4/node_modules/prosemirror-model/dist/index.cjs"(exports2) {
    "use strict";
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it) o = it;
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n() {
            if (i >= o.length) return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e) {
            throw _e;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = it.call(o);
      }, n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e2) {
        didErr = true;
        err = _e2;
      }, f: function f() {
        try {
          if (!normalCompletion && it["return"] != null) it["return"]();
        } finally {
          if (didErr) throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
      return arr2;
    }
    function _get() {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get.bind();
      } else {
        _get = function _get2(target, property, receiver) {
          var base = _superPropBase(target, property);
          if (!base) return;
          var desc = Object.getOwnPropertyDescriptor(base, property);
          if (desc.get) {
            return desc.get.call(arguments.length < 3 ? target : receiver);
          }
          return desc.value;
        };
      }
      return _get.apply(this, arguments);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null) break;
      }
      return object;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      Object.defineProperty(subClass, "prototype", { writable: false });
      if (superClass) _setPrototypeOf(subClass, superClass);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
      _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
        if (Class2 === null || !_isNativeFunction(Class2)) return Class2;
        if (typeof Class2 !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
          if (_cache.has(Class2)) return _cache.get(Class2);
          _cache.set(Class2, Wrapper);
        }
        function Wrapper() {
          return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
        }
        Wrapper.prototype = Object.create(Class2.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } });
        return _setPrototypeOf(Wrapper, Class2);
      };
      return _wrapNativeSuper(Class);
    }
    function _construct(Parent, args, Class) {
      if (_isNativeReflectConstruct()) {
        _construct = Reflect.construct.bind();
      } else {
        _construct = function _construct2(Parent2, args2, Class2) {
          var a = [null];
          a.push.apply(a, args2);
          var Constructor = Function.bind.apply(Parent2, a);
          var instance = new Constructor();
          if (Class2) _setPrototypeOf(instance, Class2.prototype);
          return instance;
        };
      }
      return _construct.apply(null, arguments);
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _isNativeFunction(fn) {
      try {
        return Function.toString.call(fn).indexOf("[native code]") !== -1;
      } catch (e) {
        return typeof fn === "function";
      }
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return _typeof(key) === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (_typeof(input) !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (_typeof(res) !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var OrderedMap = require_dist();
    function _findDiffStart(a, b, pos) {
      for (var i = 0; ; i++) {
        if (i == a.childCount || i == b.childCount) return a.childCount == b.childCount ? null : pos;
        var childA = a.child(i), childB = b.child(i);
        if (childA == childB) {
          pos += childA.nodeSize;
          continue;
        }
        if (!childA.sameMarkup(childB)) return pos;
        if (childA.isText && childA.text != childB.text) {
          for (var j = 0; childA.text[j] == childB.text[j]; j++) pos++;
          return pos;
        }
        if (childA.content.size || childB.content.size) {
          var inner = _findDiffStart(childA.content, childB.content, pos + 1);
          if (inner != null) return inner;
        }
        pos += childA.nodeSize;
      }
    }
    function _findDiffEnd(a, b, posA, posB) {
      for (var iA = a.childCount, iB = b.childCount; ; ) {
        if (iA == 0 || iB == 0) return iA == iB ? null : {
          a: posA,
          b: posB
        };
        var childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize;
        if (childA == childB) {
          posA -= size;
          posB -= size;
          continue;
        }
        if (!childA.sameMarkup(childB)) return {
          a: posA,
          b: posB
        };
        if (childA.isText && childA.text != childB.text) {
          var same = 0, minSize = Math.min(childA.text.length, childB.text.length);
          while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
            same++;
            posA--;
            posB--;
          }
          return {
            a: posA,
            b: posB
          };
        }
        if (childA.content.size || childB.content.size) {
          var inner = _findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);
          if (inner) return inner;
        }
        posA -= size;
        posB -= size;
      }
    }
    var Fragment2 = (function() {
      function Fragment3(content, size) {
        _classCallCheck(this, Fragment3);
        this.content = content;
        this.size = size || 0;
        if (size == null) for (var i = 0; i < content.length; i++) this.size += content[i].nodeSize;
      }
      _createClass(Fragment3, [{
        key: "nodesBetween",
        value: function nodesBetween(from, to, f) {
          var nodeStart = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
          var parent = arguments.length > 4 ? arguments[4] : void 0;
          for (var i = 0, pos = 0; pos < to; i++) {
            var child = this.content[i], end = pos + child.nodeSize;
            if (end > from && f(child, nodeStart + pos, parent || null, i) !== false && child.content.size) {
              var start = pos + 1;
              child.nodesBetween(Math.max(0, from - start), Math.min(child.content.size, to - start), f, nodeStart + start);
            }
            pos = end;
          }
        }
      }, {
        key: "descendants",
        value: function descendants(f) {
          this.nodesBetween(0, this.size, f);
        }
      }, {
        key: "textBetween",
        value: function textBetween(from, to, blockSeparator, leafText) {
          var text = "", first = true;
          this.nodesBetween(from, to, function(node, pos) {
            var nodeText = node.isText ? node.text.slice(Math.max(from, pos) - pos, to - pos) : !node.isLeaf ? "" : leafText ? typeof leafText === "function" ? leafText(node) : leafText : node.type.spec.leafText ? node.type.spec.leafText(node) : "";
            if (node.isBlock && (node.isLeaf && nodeText || node.isTextblock) && blockSeparator) {
              if (first) first = false;
              else text += blockSeparator;
            }
            text += nodeText;
          }, 0);
          return text;
        }
      }, {
        key: "append",
        value: function append(other) {
          if (!other.size) return this;
          if (!this.size) return other;
          var last = this.lastChild, first = other.firstChild, content = this.content.slice(), i = 0;
          if (last.isText && last.sameMarkup(first)) {
            content[content.length - 1] = last.withText(last.text + first.text);
            i = 1;
          }
          for (; i < other.content.length; i++) content.push(other.content[i]);
          return new Fragment3(content, this.size + other.size);
        }
      }, {
        key: "cut",
        value: function cut(from) {
          var to = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.size;
          if (from == 0 && to == this.size) return this;
          var result = [], size = 0;
          if (to > from) for (var i = 0, pos = 0; pos < to; i++) {
            var child = this.content[i], end = pos + child.nodeSize;
            if (end > from) {
              if (pos < from || end > to) {
                if (child.isText) child = child.cut(Math.max(0, from - pos), Math.min(child.text.length, to - pos));
                else child = child.cut(Math.max(0, from - pos - 1), Math.min(child.content.size, to - pos - 1));
              }
              result.push(child);
              size += child.nodeSize;
            }
            pos = end;
          }
          return new Fragment3(result, size);
        }
      }, {
        key: "cutByIndex",
        value: function cutByIndex(from, to) {
          if (from == to) return Fragment3.empty;
          if (from == 0 && to == this.content.length) return this;
          return new Fragment3(this.content.slice(from, to));
        }
      }, {
        key: "replaceChild",
        value: function replaceChild(index, node) {
          var current = this.content[index];
          if (current == node) return this;
          var copy2 = this.content.slice();
          var size = this.size + node.nodeSize - current.nodeSize;
          copy2[index] = node;
          return new Fragment3(copy2, size);
        }
      }, {
        key: "addToStart",
        value: function addToStart(node) {
          return new Fragment3([node].concat(this.content), this.size + node.nodeSize);
        }
      }, {
        key: "addToEnd",
        value: function addToEnd(node) {
          return new Fragment3(this.content.concat(node), this.size + node.nodeSize);
        }
      }, {
        key: "eq",
        value: function eq(other) {
          if (this.content.length != other.content.length) return false;
          for (var i = 0; i < this.content.length; i++) if (!this.content[i].eq(other.content[i])) return false;
          return true;
        }
      }, {
        key: "firstChild",
        get: function get2() {
          return this.content.length ? this.content[0] : null;
        }
      }, {
        key: "lastChild",
        get: function get2() {
          return this.content.length ? this.content[this.content.length - 1] : null;
        }
      }, {
        key: "childCount",
        get: function get2() {
          return this.content.length;
        }
      }, {
        key: "child",
        value: function child(index) {
          var found2 = this.content[index];
          if (!found2) throw new RangeError("Index " + index + " out of range for " + this);
          return found2;
        }
      }, {
        key: "maybeChild",
        value: function maybeChild(index) {
          return this.content[index] || null;
        }
      }, {
        key: "forEach",
        value: function forEach(f) {
          for (var i = 0, p = 0; i < this.content.length; i++) {
            var child = this.content[i];
            f(child, p, i);
            p += child.nodeSize;
          }
        }
      }, {
        key: "findDiffStart",
        value: function findDiffStart(other) {
          var pos = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
          return _findDiffStart(this, other, pos);
        }
      }, {
        key: "findDiffEnd",
        value: function findDiffEnd(other) {
          var pos = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.size;
          var otherPos = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : other.size;
          return _findDiffEnd(this, other, pos, otherPos);
        }
      }, {
        key: "findIndex",
        value: function findIndex(pos) {
          if (pos == 0) return retIndex(0, pos);
          if (pos == this.size) return retIndex(this.content.length, pos);
          if (pos > this.size || pos < 0) throw new RangeError("Position ".concat(pos, " outside of fragment (").concat(this, ")"));
          for (var i = 0, curPos = 0; ; i++) {
            var cur = this.child(i), end = curPos + cur.nodeSize;
            if (end >= pos) {
              if (end == pos) return retIndex(i + 1, end);
              return retIndex(i, curPos);
            }
            curPos = end;
          }
        }
      }, {
        key: "toString",
        value: function toString() {
          return "<" + this.toStringInner() + ">";
        }
      }, {
        key: "toStringInner",
        value: function toStringInner() {
          return this.content.join(", ");
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          return this.content.length ? this.content.map(function(n) {
            return n.toJSON();
          }) : null;
        }
      }], [{
        key: "fromJSON",
        value: function fromJSON(schema, value) {
          if (!value) return Fragment3.empty;
          if (!Array.isArray(value)) throw new RangeError("Invalid input for Fragment.fromJSON");
          return new Fragment3(value.map(schema.nodeFromJSON));
        }
      }, {
        key: "fromArray",
        value: function fromArray(array) {
          if (!array.length) return Fragment3.empty;
          var joined, size = 0;
          for (var i = 0; i < array.length; i++) {
            var node = array[i];
            size += node.nodeSize;
            if (i && node.isText && array[i - 1].sameMarkup(node)) {
              if (!joined) joined = array.slice(0, i);
              joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);
            } else if (joined) {
              joined.push(node);
            }
          }
          return new Fragment3(joined || array, size);
        }
      }, {
        key: "from",
        value: function from(nodes) {
          if (!nodes) return Fragment3.empty;
          if (nodes instanceof Fragment3) return nodes;
          if (Array.isArray(nodes)) return this.fromArray(nodes);
          if (nodes.attrs) return new Fragment3([nodes], nodes.nodeSize);
          throw new RangeError("Can not convert " + nodes + " to a Fragment" + (nodes.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
        }
      }]);
      return Fragment3;
    })();
    Fragment2.empty = new Fragment2([], 0);
    var found = {
      index: 0,
      offset: 0
    };
    function retIndex(index, offset) {
      found.index = index;
      found.offset = offset;
      return found;
    }
    function compareDeep(a, b) {
      if (a === b) return true;
      if (!(a && _typeof(a) == "object") || !(b && _typeof(b) == "object")) return false;
      var array = Array.isArray(a);
      if (Array.isArray(b) != array) return false;
      if (array) {
        if (a.length != b.length) return false;
        for (var i = 0; i < a.length; i++) if (!compareDeep(a[i], b[i])) return false;
      } else {
        for (var p in a) if (!(p in b) || !compareDeep(a[p], b[p])) return false;
        for (var _p in b) if (!(_p in a)) return false;
      }
      return true;
    }
    var Mark = (function() {
      function Mark2(type2, attrs) {
        _classCallCheck(this, Mark2);
        this.type = type2;
        this.attrs = attrs;
      }
      _createClass(Mark2, [{
        key: "addToSet",
        value: function addToSet(set) {
          var copy2, placed = false;
          for (var i = 0; i < set.length; i++) {
            var other = set[i];
            if (this.eq(other)) return set;
            if (this.type.excludes(other.type)) {
              if (!copy2) copy2 = set.slice(0, i);
            } else if (other.type.excludes(this.type)) {
              return set;
            } else {
              if (!placed && other.type.rank > this.type.rank) {
                if (!copy2) copy2 = set.slice(0, i);
                copy2.push(this);
                placed = true;
              }
              if (copy2) copy2.push(other);
            }
          }
          if (!copy2) copy2 = set.slice();
          if (!placed) copy2.push(this);
          return copy2;
        }
      }, {
        key: "removeFromSet",
        value: function removeFromSet(set) {
          for (var i = 0; i < set.length; i++) if (this.eq(set[i])) return set.slice(0, i).concat(set.slice(i + 1));
          return set;
        }
      }, {
        key: "isInSet",
        value: function isInSet(set) {
          for (var i = 0; i < set.length; i++) if (this.eq(set[i])) return true;
          return false;
        }
      }, {
        key: "eq",
        value: function eq(other) {
          return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          var obj = {
            type: this.type.name
          };
          for (var _ in this.attrs) {
            obj.attrs = this.attrs;
            break;
          }
          return obj;
        }
      }], [{
        key: "fromJSON",
        value: function fromJSON(schema, json) {
          if (!json) throw new RangeError("Invalid input for Mark.fromJSON");
          var type2 = schema.marks[json.type];
          if (!type2) throw new RangeError("There is no mark type ".concat(json.type, " in this schema"));
          var mark = type2.create(json.attrs);
          type2.checkAttrs(mark.attrs);
          return mark;
        }
      }, {
        key: "sameSet",
        value: function sameSet(a, b) {
          if (a == b) return true;
          if (a.length != b.length) return false;
          for (var i = 0; i < a.length; i++) if (!a[i].eq(b[i])) return false;
          return true;
        }
      }, {
        key: "setFrom",
        value: function setFrom(marks) {
          if (!marks || Array.isArray(marks) && marks.length == 0) return Mark2.none;
          if (marks instanceof Mark2) return [marks];
          var copy2 = marks.slice();
          copy2.sort(function(a, b) {
            return a.type.rank - b.type.rank;
          });
          return copy2;
        }
      }]);
      return Mark2;
    })();
    Mark.none = [];
    var ReplaceError = (function(_Error) {
      _inherits(ReplaceError2, _Error);
      var _super = _createSuper(ReplaceError2);
      function ReplaceError2() {
        _classCallCheck(this, ReplaceError2);
        return _super.apply(this, arguments);
      }
      return _createClass(ReplaceError2);
    })(_wrapNativeSuper(Error));
    var Slice = (function() {
      function Slice2(content, openStart, openEnd) {
        _classCallCheck(this, Slice2);
        this.content = content;
        this.openStart = openStart;
        this.openEnd = openEnd;
      }
      _createClass(Slice2, [{
        key: "size",
        get: function get2() {
          return this.content.size - this.openStart - this.openEnd;
        }
      }, {
        key: "insertAt",
        value: function insertAt(pos, fragment) {
          var content = insertInto(this.content, pos + this.openStart, fragment);
          return content && new Slice2(content, this.openStart, this.openEnd);
        }
      }, {
        key: "removeBetween",
        value: function removeBetween(from, to) {
          return new Slice2(removeRange(this.content, from + this.openStart, to + this.openStart), this.openStart, this.openEnd);
        }
      }, {
        key: "eq",
        value: function eq(other) {
          return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
        }
      }, {
        key: "toString",
        value: function toString() {
          return this.content + "(" + this.openStart + "," + this.openEnd + ")";
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          if (!this.content.size) return null;
          var json = {
            content: this.content.toJSON()
          };
          if (this.openStart > 0) json.openStart = this.openStart;
          if (this.openEnd > 0) json.openEnd = this.openEnd;
          return json;
        }
      }], [{
        key: "fromJSON",
        value: function fromJSON(schema, json) {
          if (!json) return Slice2.empty;
          var openStart = json.openStart || 0, openEnd = json.openEnd || 0;
          if (typeof openStart != "number" || typeof openEnd != "number") throw new RangeError("Invalid input for Slice.fromJSON");
          return new Slice2(Fragment2.fromJSON(schema, json.content), openStart, openEnd);
        }
      }, {
        key: "maxOpen",
        value: function maxOpen(fragment) {
          var openIsolating = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
          var openStart = 0, openEnd = 0;
          for (var n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild) openStart++;
          for (var _n = fragment.lastChild; _n && !_n.isLeaf && (openIsolating || !_n.type.spec.isolating); _n = _n.lastChild) openEnd++;
          return new Slice2(fragment, openStart, openEnd);
        }
      }]);
      return Slice2;
    })();
    Slice.empty = new Slice(Fragment2.empty, 0, 0);
    function removeRange(content, from, to) {
      var _content$findIndex = content.findIndex(from), index = _content$findIndex.index, offset = _content$findIndex.offset, child = content.maybeChild(index);
      var _content$findIndex2 = content.findIndex(to), indexTo = _content$findIndex2.index, offsetTo = _content$findIndex2.offset;
      if (offset == from || child.isText) {
        if (offsetTo != to && !content.child(indexTo).isText) throw new RangeError("Removing non-flat range");
        return content.cut(0, from).append(content.cut(to));
      }
      if (index != indexTo) throw new RangeError("Removing non-flat range");
      return content.replaceChild(index, child.copy(removeRange(child.content, from - offset - 1, to - offset - 1)));
    }
    function insertInto(content, dist, insert, parent) {
      var _content$findIndex3 = content.findIndex(dist), index = _content$findIndex3.index, offset = _content$findIndex3.offset, child = content.maybeChild(index);
      if (offset == dist || child.isText) {
        if (parent && !parent.canReplace(index, index, insert)) return null;
        return content.cut(0, dist).append(insert).append(content.cut(dist));
      }
      var inner = insertInto(child.content, dist - offset - 1, insert, child);
      return inner && content.replaceChild(index, child.copy(inner));
    }
    function _replace($from, $to, slice) {
      if (slice.openStart > $from.depth) throw new ReplaceError("Inserted content deeper than insertion position");
      if ($from.depth - slice.openStart != $to.depth - slice.openEnd) throw new ReplaceError("Inconsistent open depths");
      return replaceOuter($from, $to, slice, 0);
    }
    function replaceOuter($from, $to, slice, depth) {
      var index = $from.index(depth), node = $from.node(depth);
      if (index == $to.index(depth) && depth < $from.depth - slice.openStart) {
        var inner = replaceOuter($from, $to, slice, depth + 1);
        return node.copy(node.content.replaceChild(index, inner));
      } else if (!slice.content.size) {
        return close(node, replaceTwoWay($from, $to, depth));
      } else if (!slice.openStart && !slice.openEnd && $from.depth == depth && $to.depth == depth) {
        var parent = $from.parent, content = parent.content;
        return close(parent, content.cut(0, $from.parentOffset).append(slice.content).append(content.cut($to.parentOffset)));
      } else {
        var _prepareSliceForRepla = prepareSliceForReplace(slice, $from), start = _prepareSliceForRepla.start, end = _prepareSliceForRepla.end;
        return close(node, replaceThreeWay($from, start, end, $to, depth));
      }
    }
    function checkJoin(main, sub) {
      if (!sub.type.compatibleContent(main.type)) throw new ReplaceError("Cannot join " + sub.type.name + " onto " + main.type.name);
    }
    function joinable($before, $after, depth) {
      var node = $before.node(depth);
      checkJoin(node, $after.node(depth));
      return node;
    }
    function addNode(child, target) {
      var last = target.length - 1;
      if (last >= 0 && child.isText && child.sameMarkup(target[last])) target[last] = child.withText(target[last].text + child.text);
      else target.push(child);
    }
    function addRange($start, $end, depth, target) {
      var node = ($end || $start).node(depth);
      var startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount;
      if ($start) {
        startIndex = $start.index(depth);
        if ($start.depth > depth) {
          startIndex++;
        } else if ($start.textOffset) {
          addNode($start.nodeAfter, target);
          startIndex++;
        }
      }
      for (var i = startIndex; i < endIndex; i++) addNode(node.child(i), target);
      if ($end && $end.depth == depth && $end.textOffset) addNode($end.nodeBefore, target);
    }
    function close(node, content) {
      node.type.checkContent(content);
      return node.copy(content);
    }
    function replaceThreeWay($from, $start, $end, $to, depth) {
      var openStart = $from.depth > depth && joinable($from, $start, depth + 1);
      var openEnd = $to.depth > depth && joinable($end, $to, depth + 1);
      var content = [];
      addRange(null, $from, depth, content);
      if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
        checkJoin(openStart, openEnd);
        addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);
      } else {
        if (openStart) addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content);
        addRange($start, $end, depth, content);
        if (openEnd) addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content);
      }
      addRange($to, null, depth, content);
      return new Fragment2(content);
    }
    function replaceTwoWay($from, $to, depth) {
      var content = [];
      addRange(null, $from, depth, content);
      if ($from.depth > depth) {
        var type2 = joinable($from, $to, depth + 1);
        addNode(close(type2, replaceTwoWay($from, $to, depth + 1)), content);
      }
      addRange($to, null, depth, content);
      return new Fragment2(content);
    }
    function prepareSliceForReplace(slice, $along) {
      var extra = $along.depth - slice.openStart, parent = $along.node(extra);
      var node = parent.copy(slice.content);
      for (var i = extra - 1; i >= 0; i--) node = $along.node(i).copy(Fragment2.from(node));
      return {
        start: node.resolveNoCache(slice.openStart + extra),
        end: node.resolveNoCache(node.content.size - slice.openEnd - extra)
      };
    }
    var ResolvedPos = (function() {
      function ResolvedPos2(pos, path, parentOffset) {
        _classCallCheck(this, ResolvedPos2);
        this.pos = pos;
        this.path = path;
        this.parentOffset = parentOffset;
        this.depth = path.length / 3 - 1;
      }
      _createClass(ResolvedPos2, [{
        key: "resolveDepth",
        value: function resolveDepth(val) {
          if (val == null) return this.depth;
          if (val < 0) return this.depth + val;
          return val;
        }
      }, {
        key: "parent",
        get: function get2() {
          return this.node(this.depth);
        }
      }, {
        key: "doc",
        get: function get2() {
          return this.node(0);
        }
      }, {
        key: "node",
        value: function node(depth) {
          return this.path[this.resolveDepth(depth) * 3];
        }
      }, {
        key: "index",
        value: function index(depth) {
          return this.path[this.resolveDepth(depth) * 3 + 1];
        }
      }, {
        key: "indexAfter",
        value: function indexAfter(depth) {
          depth = this.resolveDepth(depth);
          return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
        }
      }, {
        key: "start",
        value: function start(depth) {
          depth = this.resolveDepth(depth);
          return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
        }
      }, {
        key: "end",
        value: function end(depth) {
          depth = this.resolveDepth(depth);
          return this.start(depth) + this.node(depth).content.size;
        }
      }, {
        key: "before",
        value: function before(depth) {
          depth = this.resolveDepth(depth);
          if (!depth) throw new RangeError("There is no position before the top-level node");
          return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
        }
      }, {
        key: "after",
        value: function after(depth) {
          depth = this.resolveDepth(depth);
          if (!depth) throw new RangeError("There is no position after the top-level node");
          return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
        }
      }, {
        key: "textOffset",
        get: function get2() {
          return this.pos - this.path[this.path.length - 1];
        }
      }, {
        key: "nodeAfter",
        get: function get2() {
          var parent = this.parent, index = this.index(this.depth);
          if (index == parent.childCount) return null;
          var dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index);
          return dOff ? parent.child(index).cut(dOff) : child;
        }
      }, {
        key: "nodeBefore",
        get: function get2() {
          var index = this.index(this.depth);
          var dOff = this.pos - this.path[this.path.length - 1];
          if (dOff) return this.parent.child(index).cut(0, dOff);
          return index == 0 ? null : this.parent.child(index - 1);
        }
      }, {
        key: "posAtIndex",
        value: function posAtIndex(index, depth) {
          depth = this.resolveDepth(depth);
          var node = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
          for (var i = 0; i < index; i++) pos += node.child(i).nodeSize;
          return pos;
        }
      }, {
        key: "marks",
        value: function marks() {
          var parent = this.parent, index = this.index();
          if (parent.content.size == 0) return Mark.none;
          if (this.textOffset) return parent.child(index).marks;
          var main = parent.maybeChild(index - 1), other = parent.maybeChild(index);
          if (!main) {
            var tmp = main;
            main = other;
            other = tmp;
          }
          var marks2 = main.marks;
          for (var i = 0; i < marks2.length; i++) if (marks2[i].type.spec.inclusive === false && (!other || !marks2[i].isInSet(other.marks))) marks2 = marks2[i--].removeFromSet(marks2);
          return marks2;
        }
      }, {
        key: "marksAcross",
        value: function marksAcross($end) {
          var after = this.parent.maybeChild(this.index());
          if (!after || !after.isInline) return null;
          var marks = after.marks, next = $end.parent.maybeChild($end.index());
          for (var i = 0; i < marks.length; i++) if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks))) marks = marks[i--].removeFromSet(marks);
          return marks;
        }
      }, {
        key: "sharedDepth",
        value: function sharedDepth(pos) {
          for (var depth = this.depth; depth > 0; depth--) if (this.start(depth) <= pos && this.end(depth) >= pos) return depth;
          return 0;
        }
      }, {
        key: "blockRange",
        value: function blockRange() {
          var other = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this;
          var pred = arguments.length > 1 ? arguments[1] : void 0;
          if (other.pos < this.pos) return other.blockRange(this);
          for (var d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--) if (other.pos <= this.end(d) && (!pred || pred(this.node(d)))) return new NodeRange(this, other, d);
          return null;
        }
      }, {
        key: "sameParent",
        value: function sameParent(other) {
          return this.pos - this.parentOffset == other.pos - other.parentOffset;
        }
      }, {
        key: "max",
        value: function max2(other) {
          return other.pos > this.pos ? other : this;
        }
      }, {
        key: "min",
        value: function min2(other) {
          return other.pos < this.pos ? other : this;
        }
      }, {
        key: "toString",
        value: function toString() {
          var str = "";
          for (var i = 1; i <= this.depth; i++) str += (str ? "/" : "") + this.node(i).type.name + "_" + this.index(i - 1);
          return str + ":" + this.parentOffset;
        }
      }], [{
        key: "resolve",
        value: function resolve(doc2, pos) {
          if (!(pos >= 0 && pos <= doc2.content.size)) throw new RangeError("Position " + pos + " out of range");
          var path = [];
          var start = 0, parentOffset = pos;
          for (var node = doc2; ; ) {
            var _node$content$findInd = node.content.findIndex(parentOffset), index = _node$content$findInd.index, offset = _node$content$findInd.offset;
            var rem = parentOffset - offset;
            path.push(node, index, start + offset);
            if (!rem) break;
            node = node.child(index);
            if (node.isText) break;
            parentOffset = rem - 1;
            start += offset + 1;
          }
          return new ResolvedPos2(pos, path, parentOffset);
        }
      }, {
        key: "resolveCached",
        value: function resolveCached(doc2, pos) {
          var cache = resolveCache.get(doc2);
          if (cache) {
            for (var i = 0; i < cache.elts.length; i++) {
              var elt = cache.elts[i];
              if (elt.pos == pos) return elt;
            }
          } else {
            resolveCache.set(doc2, cache = new ResolveCache());
          }
          var result = cache.elts[cache.i] = ResolvedPos2.resolve(doc2, pos);
          cache.i = (cache.i + 1) % resolveCacheSize;
          return result;
        }
      }]);
      return ResolvedPos2;
    })();
    var ResolveCache = _createClass(function ResolveCache2() {
      _classCallCheck(this, ResolveCache2);
      this.elts = [];
      this.i = 0;
    });
    var resolveCacheSize = 12;
    var resolveCache = /* @__PURE__ */ new WeakMap();
    var NodeRange = (function() {
      function NodeRange2($from, $to, depth) {
        _classCallCheck(this, NodeRange2);
        this.$from = $from;
        this.$to = $to;
        this.depth = depth;
      }
      _createClass(NodeRange2, [{
        key: "start",
        get: function get2() {
          return this.$from.before(this.depth + 1);
        }
      }, {
        key: "end",
        get: function get2() {
          return this.$to.after(this.depth + 1);
        }
      }, {
        key: "parent",
        get: function get2() {
          return this.$from.node(this.depth);
        }
      }, {
        key: "startIndex",
        get: function get2() {
          return this.$from.index(this.depth);
        }
      }, {
        key: "endIndex",
        get: function get2() {
          return this.$to.indexAfter(this.depth);
        }
      }]);
      return NodeRange2;
    })();
    var emptyAttrs = /* @__PURE__ */ Object.create(null);
    var Node2 = (function() {
      function Node3(type2, attrs, content) {
        var marks = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Mark.none;
        _classCallCheck(this, Node3);
        this.type = type2;
        this.attrs = attrs;
        this.marks = marks;
        this.content = content || Fragment2.empty;
      }
      _createClass(Node3, [{
        key: "children",
        get: function get2() {
          return this.content.content;
        }
      }, {
        key: "nodeSize",
        get: function get2() {
          return this.isLeaf ? 1 : 2 + this.content.size;
        }
      }, {
        key: "childCount",
        get: function get2() {
          return this.content.childCount;
        }
      }, {
        key: "child",
        value: function child(index) {
          return this.content.child(index);
        }
      }, {
        key: "maybeChild",
        value: function maybeChild(index) {
          return this.content.maybeChild(index);
        }
      }, {
        key: "forEach",
        value: function forEach(f) {
          this.content.forEach(f);
        }
      }, {
        key: "nodesBetween",
        value: function nodesBetween(from, to, f) {
          var startPos = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
          this.content.nodesBetween(from, to, f, startPos, this);
        }
      }, {
        key: "descendants",
        value: function descendants(f) {
          this.nodesBetween(0, this.content.size, f);
        }
      }, {
        key: "textContent",
        get: function get2() {
          return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
        }
      }, {
        key: "textBetween",
        value: function textBetween(from, to, blockSeparator, leafText) {
          return this.content.textBetween(from, to, blockSeparator, leafText);
        }
      }, {
        key: "firstChild",
        get: function get2() {
          return this.content.firstChild;
        }
      }, {
        key: "lastChild",
        get: function get2() {
          return this.content.lastChild;
        }
      }, {
        key: "eq",
        value: function eq(other) {
          return this == other || this.sameMarkup(other) && this.content.eq(other.content);
        }
      }, {
        key: "sameMarkup",
        value: function sameMarkup(other) {
          return this.hasMarkup(other.type, other.attrs, other.marks);
        }
      }, {
        key: "hasMarkup",
        value: function hasMarkup(type2, attrs, marks) {
          return this.type == type2 && compareDeep(this.attrs, attrs || type2.defaultAttrs || emptyAttrs) && Mark.sameSet(this.marks, marks || Mark.none);
        }
      }, {
        key: "copy",
        value: function copy2() {
          var content = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
          if (content == this.content) return this;
          return new Node3(this.type, this.attrs, content, this.marks);
        }
      }, {
        key: "mark",
        value: function mark(marks) {
          return marks == this.marks ? this : new Node3(this.type, this.attrs, this.content, marks);
        }
      }, {
        key: "cut",
        value: function cut(from) {
          var to = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.content.size;
          if (from == 0 && to == this.content.size) return this;
          return this.copy(this.content.cut(from, to));
        }
      }, {
        key: "slice",
        value: function slice(from) {
          var to = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.content.size;
          var includeParents = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
          if (from == to) return Slice.empty;
          var $from = this.resolve(from), $to = this.resolve(to);
          var depth = includeParents ? 0 : $from.sharedDepth(to);
          var start = $from.start(depth), node = $from.node(depth);
          var content = node.content.cut($from.pos - start, $to.pos - start);
          return new Slice(content, $from.depth - depth, $to.depth - depth);
        }
      }, {
        key: "replace",
        value: function replace(from, to, slice) {
          return _replace(this.resolve(from), this.resolve(to), slice);
        }
      }, {
        key: "nodeAt",
        value: function nodeAt(pos) {
          for (var node = this; ; ) {
            var _node$content$findInd2 = node.content.findIndex(pos), index = _node$content$findInd2.index, offset = _node$content$findInd2.offset;
            node = node.maybeChild(index);
            if (!node) return null;
            if (offset == pos || node.isText) return node;
            pos -= offset + 1;
          }
        }
      }, {
        key: "childAfter",
        value: function childAfter(pos) {
          var _this$content$findInd = this.content.findIndex(pos), index = _this$content$findInd.index, offset = _this$content$findInd.offset;
          return {
            node: this.content.maybeChild(index),
            index,
            offset
          };
        }
      }, {
        key: "childBefore",
        value: function childBefore(pos) {
          if (pos == 0) return {
            node: null,
            index: 0,
            offset: 0
          };
          var _this$content$findInd2 = this.content.findIndex(pos), index = _this$content$findInd2.index, offset = _this$content$findInd2.offset;
          if (offset < pos) return {
            node: this.content.child(index),
            index,
            offset
          };
          var node = this.content.child(index - 1);
          return {
            node,
            index: index - 1,
            offset: offset - node.nodeSize
          };
        }
      }, {
        key: "resolve",
        value: function resolve(pos) {
          return ResolvedPos.resolveCached(this, pos);
        }
      }, {
        key: "resolveNoCache",
        value: function resolveNoCache(pos) {
          return ResolvedPos.resolve(this, pos);
        }
      }, {
        key: "rangeHasMark",
        value: function rangeHasMark(from, to, type2) {
          var found2 = false;
          if (to > from) this.nodesBetween(from, to, function(node) {
            if (type2.isInSet(node.marks)) found2 = true;
            return !found2;
          });
          return found2;
        }
      }, {
        key: "isBlock",
        get: function get2() {
          return this.type.isBlock;
        }
      }, {
        key: "isTextblock",
        get: function get2() {
          return this.type.isTextblock;
        }
      }, {
        key: "inlineContent",
        get: function get2() {
          return this.type.inlineContent;
        }
      }, {
        key: "isInline",
        get: function get2() {
          return this.type.isInline;
        }
      }, {
        key: "isText",
        get: function get2() {
          return this.type.isText;
        }
      }, {
        key: "isLeaf",
        get: function get2() {
          return this.type.isLeaf;
        }
      }, {
        key: "isAtom",
        get: function get2() {
          return this.type.isAtom;
        }
      }, {
        key: "toString",
        value: function toString() {
          if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this);
          var name = this.type.name;
          if (this.content.size) name += "(" + this.content.toStringInner() + ")";
          return wrapMarks(this.marks, name);
        }
      }, {
        key: "contentMatchAt",
        value: function contentMatchAt(index) {
          var match = this.type.contentMatch.matchFragment(this.content, 0, index);
          if (!match) throw new Error("Called contentMatchAt on a node with invalid content");
          return match;
        }
      }, {
        key: "canReplace",
        value: function canReplace(from, to) {
          var replacement = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Fragment2.empty;
          var start = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
          var end = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : replacement.childCount;
          var one = this.contentMatchAt(from).matchFragment(replacement, start, end);
          var two = one && one.matchFragment(this.content, to);
          if (!two || !two.validEnd) return false;
          for (var i = start; i < end; i++) if (!this.type.allowsMarks(replacement.child(i).marks)) return false;
          return true;
        }
      }, {
        key: "canReplaceWith",
        value: function canReplaceWith(from, to, type2, marks) {
          if (marks && !this.type.allowsMarks(marks)) return false;
          var start = this.contentMatchAt(from).matchType(type2);
          var end = start && start.matchFragment(this.content, to);
          return end ? end.validEnd : false;
        }
      }, {
        key: "canAppend",
        value: function canAppend(other) {
          if (other.content.size) return this.canReplace(this.childCount, this.childCount, other.content);
          else return this.type.compatibleContent(other.type);
        }
      }, {
        key: "check",
        value: function check() {
          this.type.checkContent(this.content);
          this.type.checkAttrs(this.attrs);
          var copy2 = Mark.none;
          for (var i = 0; i < this.marks.length; i++) {
            var mark = this.marks[i];
            mark.type.checkAttrs(mark.attrs);
            copy2 = mark.addToSet(copy2);
          }
          if (!Mark.sameSet(copy2, this.marks)) throw new RangeError("Invalid collection of marks for node ".concat(this.type.name, ": ").concat(this.marks.map(function(m) {
            return m.type.name;
          })));
          this.content.forEach(function(node) {
            return node.check();
          });
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          var obj = {
            type: this.type.name
          };
          for (var _ in this.attrs) {
            obj.attrs = this.attrs;
            break;
          }
          if (this.content.size) obj.content = this.content.toJSON();
          if (this.marks.length) obj.marks = this.marks.map(function(n) {
            return n.toJSON();
          });
          return obj;
        }
      }], [{
        key: "fromJSON",
        value: function fromJSON(schema, json) {
          if (!json) throw new RangeError("Invalid input for Node.fromJSON");
          var marks = void 0;
          if (json.marks) {
            if (!Array.isArray(json.marks)) throw new RangeError("Invalid mark data for Node.fromJSON");
            marks = json.marks.map(schema.markFromJSON);
          }
          if (json.type == "text") {
            if (typeof json.text != "string") throw new RangeError("Invalid text node in JSON");
            return schema.text(json.text, marks);
          }
          var content = Fragment2.fromJSON(schema, json.content);
          var node = schema.nodeType(json.type).create(json.attrs, content, marks);
          node.type.checkAttrs(node.attrs);
          return node;
        }
      }]);
      return Node3;
    })();
    Node2.prototype.text = void 0;
    var TextNode = (function(_Node) {
      _inherits(TextNode2, _Node);
      var _super2 = _createSuper(TextNode2);
      function TextNode2(type2, attrs, content, marks) {
        var _this;
        _classCallCheck(this, TextNode2);
        _this = _super2.call(this, type2, attrs, null, marks);
        if (!content) throw new RangeError("Empty text nodes are not allowed");
        _this.text = content;
        return _this;
      }
      _createClass(TextNode2, [{
        key: "toString",
        value: function toString() {
          if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this);
          return wrapMarks(this.marks, JSON.stringify(this.text));
        }
      }, {
        key: "textContent",
        get: function get2() {
          return this.text;
        }
      }, {
        key: "textBetween",
        value: function textBetween(from, to) {
          return this.text.slice(from, to);
        }
      }, {
        key: "nodeSize",
        get: function get2() {
          return this.text.length;
        }
      }, {
        key: "mark",
        value: function mark(marks) {
          return marks == this.marks ? this : new TextNode2(this.type, this.attrs, this.text, marks);
        }
      }, {
        key: "withText",
        value: function withText(text) {
          if (text == this.text) return this;
          return new TextNode2(this.type, this.attrs, text, this.marks);
        }
      }, {
        key: "cut",
        value: function cut() {
          var from = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
          var to = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.text.length;
          if (from == 0 && to == this.text.length) return this;
          return this.withText(this.text.slice(from, to));
        }
      }, {
        key: "eq",
        value: function eq(other) {
          return this.sameMarkup(other) && this.text == other.text;
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          var base = _get(_getPrototypeOf(TextNode2.prototype), "toJSON", this).call(this);
          base.text = this.text;
          return base;
        }
      }]);
      return TextNode2;
    })(Node2);
    function wrapMarks(marks, str) {
      for (var i = marks.length - 1; i >= 0; i--) str = marks[i].type.name + "(" + str + ")";
      return str;
    }
    var ContentMatch = (function() {
      function ContentMatch2(validEnd) {
        _classCallCheck(this, ContentMatch2);
        this.validEnd = validEnd;
        this.next = [];
        this.wrapCache = [];
      }
      _createClass(ContentMatch2, [{
        key: "matchType",
        value: function matchType(type2) {
          for (var i = 0; i < this.next.length; i++) if (this.next[i].type == type2) return this.next[i].next;
          return null;
        }
      }, {
        key: "matchFragment",
        value: function matchFragment(frag) {
          var start = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
          var end = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : frag.childCount;
          var cur = this;
          for (var i = start; cur && i < end; i++) cur = cur.matchType(frag.child(i).type);
          return cur;
        }
      }, {
        key: "inlineContent",
        get: function get2() {
          return this.next.length != 0 && this.next[0].type.isInline;
        }
      }, {
        key: "defaultType",
        get: function get2() {
          for (var i = 0; i < this.next.length; i++) {
            var type2 = this.next[i].type;
            if (!(type2.isText || type2.hasRequiredAttrs())) return type2;
          }
          return null;
        }
      }, {
        key: "compatible",
        value: function compatible(other) {
          for (var i = 0; i < this.next.length; i++) for (var j = 0; j < other.next.length; j++) if (this.next[i].type == other.next[j].type) return true;
          return false;
        }
      }, {
        key: "fillBefore",
        value: function fillBefore(after) {
          var toEnd = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          var startIndex = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
          var seen = [this];
          function search(match, types2) {
            var finished = match.matchFragment(after, startIndex);
            if (finished && (!toEnd || finished.validEnd)) return Fragment2.from(types2.map(function(tp) {
              return tp.createAndFill();
            }));
            for (var i = 0; i < match.next.length; i++) {
              var _match$next$i = match.next[i], type2 = _match$next$i.type, next = _match$next$i.next;
              if (!(type2.isText || type2.hasRequiredAttrs()) && seen.indexOf(next) == -1) {
                seen.push(next);
                var _found = search(next, types2.concat(type2));
                if (_found) return _found;
              }
            }
            return null;
          }
          return search(this, []);
        }
      }, {
        key: "findWrapping",
        value: function findWrapping(target) {
          for (var i = 0; i < this.wrapCache.length; i += 2) if (this.wrapCache[i] == target) return this.wrapCache[i + 1];
          var computed = this.computeWrapping(target);
          this.wrapCache.push(target, computed);
          return computed;
        }
      }, {
        key: "computeWrapping",
        value: function computeWrapping(target) {
          var seen = /* @__PURE__ */ Object.create(null), active = [{
            match: this,
            type: null,
            via: null
          }];
          while (active.length) {
            var current = active.shift(), match = current.match;
            if (match.matchType(target)) {
              var result = [];
              for (var obj = current; obj.type; obj = obj.via) result.push(obj.type);
              return result.reverse();
            }
            for (var i = 0; i < match.next.length; i++) {
              var _match$next$i2 = match.next[i], type2 = _match$next$i2.type, next = _match$next$i2.next;
              if (!type2.isLeaf && !type2.hasRequiredAttrs() && !(type2.name in seen) && (!current.type || next.validEnd)) {
                active.push({
                  match: type2.contentMatch,
                  type: type2,
                  via: current
                });
                seen[type2.name] = true;
              }
            }
          }
          return null;
        }
      }, {
        key: "edgeCount",
        get: function get2() {
          return this.next.length;
        }
      }, {
        key: "edge",
        value: function edge(n) {
          if (n >= this.next.length) throw new RangeError("There's no ".concat(n, "th edge in this content match"));
          return this.next[n];
        }
      }, {
        key: "toString",
        value: function toString() {
          var seen = [];
          function scan(m) {
            seen.push(m);
            for (var i = 0; i < m.next.length; i++) if (seen.indexOf(m.next[i].next) == -1) scan(m.next[i].next);
          }
          scan(this);
          return seen.map(function(m, i) {
            var out = i + (m.validEnd ? "*" : " ") + " ";
            for (var _i = 0; _i < m.next.length; _i++) out += (_i ? ", " : "") + m.next[_i].type.name + "->" + seen.indexOf(m.next[_i].next);
            return out;
          }).join("\n");
        }
      }], [{
        key: "parse",
        value: function parse(string, nodeTypes) {
          var stream = new TokenStream(string, nodeTypes);
          if (stream.next == null) return ContentMatch2.empty;
          var expr = parseExpr(stream);
          if (stream.next) stream.err("Unexpected trailing text");
          var match = dfa(nfa(expr));
          checkForDeadEnds(match, stream);
          return match;
        }
      }]);
      return ContentMatch2;
    })();
    ContentMatch.empty = new ContentMatch(true);
    var TokenStream = (function() {
      function TokenStream2(string, nodeTypes) {
        _classCallCheck(this, TokenStream2);
        this.string = string;
        this.nodeTypes = nodeTypes;
        this.inline = null;
        this.pos = 0;
        this.tokens = string.split(/\s*(?=\b|\W|$)/);
        if (this.tokens[this.tokens.length - 1] == "") this.tokens.pop();
        if (this.tokens[0] == "") this.tokens.shift();
      }
      _createClass(TokenStream2, [{
        key: "next",
        get: function get2() {
          return this.tokens[this.pos];
        }
      }, {
        key: "eat",
        value: function eat(tok) {
          return this.next == tok && (this.pos++ || true);
        }
      }, {
        key: "err",
        value: function err(str) {
          throw new SyntaxError(str + " (in content expression '" + this.string + "')");
        }
      }]);
      return TokenStream2;
    })();
    function parseExpr(stream) {
      var exprs = [];
      do {
        exprs.push(parseExprSeq(stream));
      } while (stream.eat("|"));
      return exprs.length == 1 ? exprs[0] : {
        type: "choice",
        exprs
      };
    }
    function parseExprSeq(stream) {
      var exprs = [];
      do {
        exprs.push(parseExprSubscript(stream));
      } while (stream.next && stream.next != ")" && stream.next != "|");
      return exprs.length == 1 ? exprs[0] : {
        type: "seq",
        exprs
      };
    }
    function parseExprSubscript(stream) {
      var expr = parseExprAtom(stream);
      for (; ; ) {
        if (stream.eat("+")) expr = {
          type: "plus",
          expr
        };
        else if (stream.eat("*")) expr = {
          type: "star",
          expr
        };
        else if (stream.eat("?")) expr = {
          type: "opt",
          expr
        };
        else if (stream.eat("{")) expr = parseExprRange(stream, expr);
        else break;
      }
      return expr;
    }
    function parseNum(stream) {
      if (/\D/.test(stream.next)) stream.err("Expected number, got '" + stream.next + "'");
      var result = Number(stream.next);
      stream.pos++;
      return result;
    }
    function parseExprRange(stream, expr) {
      var min2 = parseNum(stream), max2 = min2;
      if (stream.eat(",")) {
        if (stream.next != "}") max2 = parseNum(stream);
        else max2 = -1;
      }
      if (!stream.eat("}")) stream.err("Unclosed braced range");
      return {
        type: "range",
        min: min2,
        max: max2,
        expr
      };
    }
    function resolveName(stream, name) {
      var types2 = stream.nodeTypes, type2 = types2[name];
      if (type2) return [type2];
      var result = [];
      for (var typeName in types2) {
        var _type = types2[typeName];
        if (_type.isInGroup(name)) result.push(_type);
      }
      if (result.length == 0) stream.err("No node type or group '" + name + "' found");
      return result;
    }
    function parseExprAtom(stream) {
      if (stream.eat("(")) {
        var expr = parseExpr(stream);
        if (!stream.eat(")")) stream.err("Missing closing paren");
        return expr;
      } else if (!/\W/.test(stream.next)) {
        var exprs = resolveName(stream, stream.next).map(function(type2) {
          if (stream.inline == null) stream.inline = type2.isInline;
          else if (stream.inline != type2.isInline) stream.err("Mixing inline and block content");
          return {
            type: "name",
            value: type2
          };
        });
        stream.pos++;
        return exprs.length == 1 ? exprs[0] : {
          type: "choice",
          exprs
        };
      } else {
        stream.err("Unexpected token '" + stream.next + "'");
      }
    }
    function nfa(expr) {
      var nfa2 = [[]];
      connect(compile(expr, 0), node());
      return nfa2;
      function node() {
        return nfa2.push([]) - 1;
      }
      function edge(from, to, term) {
        var edge2 = {
          term,
          to
        };
        nfa2[from].push(edge2);
        return edge2;
      }
      function connect(edges, to) {
        edges.forEach(function(edge2) {
          return edge2.to = to;
        });
      }
      function compile(expr2, from) {
        if (expr2.type == "choice") {
          return expr2.exprs.reduce(function(out, expr3) {
            return out.concat(compile(expr3, from));
          }, []);
        } else if (expr2.type == "seq") {
          for (var i = 0; ; i++) {
            var next = compile(expr2.exprs[i], from);
            if (i == expr2.exprs.length - 1) return next;
            connect(next, from = node());
          }
        } else if (expr2.type == "star") {
          var loop = node();
          edge(from, loop);
          connect(compile(expr2.expr, loop), loop);
          return [edge(loop)];
        } else if (expr2.type == "plus") {
          var _loop = node();
          connect(compile(expr2.expr, from), _loop);
          connect(compile(expr2.expr, _loop), _loop);
          return [edge(_loop)];
        } else if (expr2.type == "opt") {
          return [edge(from)].concat(compile(expr2.expr, from));
        } else if (expr2.type == "range") {
          var cur = from;
          for (var _i2 = 0; _i2 < expr2.min; _i2++) {
            var _next = node();
            connect(compile(expr2.expr, cur), _next);
            cur = _next;
          }
          if (expr2.max == -1) {
            connect(compile(expr2.expr, cur), cur);
          } else {
            for (var _i3 = expr2.min; _i3 < expr2.max; _i3++) {
              var _next2 = node();
              edge(cur, _next2);
              connect(compile(expr2.expr, cur), _next2);
              cur = _next2;
            }
          }
          return [edge(cur)];
        } else if (expr2.type == "name") {
          return [edge(from, void 0, expr2.value)];
        } else {
          throw new Error("Unknown expr type");
        }
      }
    }
    function cmp(a, b) {
      return b - a;
    }
    function nullFrom(nfa2, node) {
      var result = [];
      scan(node);
      return result.sort(cmp);
      function scan(node2) {
        var edges = nfa2[node2];
        if (edges.length == 1 && !edges[0].term) return scan(edges[0].to);
        result.push(node2);
        for (var i = 0; i < edges.length; i++) {
          var _edges$i = edges[i], term = _edges$i.term, to = _edges$i.to;
          if (!term && result.indexOf(to) == -1) scan(to);
        }
      }
    }
    function dfa(nfa2) {
      var labeled = /* @__PURE__ */ Object.create(null);
      return explore(nullFrom(nfa2, 0));
      function explore(states) {
        var out = [];
        states.forEach(function(node) {
          nfa2[node].forEach(function(_ref) {
            var term = _ref.term, to = _ref.to;
            if (!term) return;
            var set;
            for (var i2 = 0; i2 < out.length; i2++) if (out[i2][0] == term) set = out[i2][1];
            nullFrom(nfa2, to).forEach(function(node2) {
              if (!set) out.push([term, set = []]);
              if (set.indexOf(node2) == -1) set.push(node2);
            });
          });
        });
        var state2 = labeled[states.join(",")] = new ContentMatch(states.indexOf(nfa2.length - 1) > -1);
        for (var i = 0; i < out.length; i++) {
          var _states = out[i][1].sort(cmp);
          state2.next.push({
            type: out[i][0],
            next: labeled[_states.join(",")] || explore(_states)
          });
        }
        return state2;
      }
    }
    function checkForDeadEnds(match, stream) {
      for (var i = 0, work = [match]; i < work.length; i++) {
        var state2 = work[i], dead = !state2.validEnd, nodes = [];
        for (var j = 0; j < state2.next.length; j++) {
          var _state$next$j = state2.next[j], type2 = _state$next$j.type, next = _state$next$j.next;
          nodes.push(type2.name);
          if (dead && !(type2.isText || type2.hasRequiredAttrs())) dead = false;
          if (work.indexOf(next) == -1) work.push(next);
        }
        if (dead) stream.err("Only non-generatable nodes (" + nodes.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
      }
    }
    function defaultAttrs(attrs) {
      var defaults = /* @__PURE__ */ Object.create(null);
      for (var attrName in attrs) {
        var attr = attrs[attrName];
        if (!attr.hasDefault) return null;
        defaults[attrName] = attr["default"];
      }
      return defaults;
    }
    function _computeAttrs(attrs, value) {
      var built = /* @__PURE__ */ Object.create(null);
      for (var name in attrs) {
        var given = value && value[name];
        if (given === void 0) {
          var attr = attrs[name];
          if (attr.hasDefault) given = attr["default"];
          else throw new RangeError("No value supplied for attribute " + name);
        }
        built[name] = given;
      }
      return built;
    }
    function _checkAttrs(attrs, values, type2, name) {
      for (var _name in values) if (!(_name in attrs)) throw new RangeError("Unsupported attribute ".concat(_name, " for ").concat(type2, " of type ").concat(_name));
      for (var _name2 in attrs) {
        var attr = attrs[_name2];
        if (attr.validate) attr.validate(values[_name2]);
      }
    }
    function initAttrs(typeName, attrs) {
      var result = /* @__PURE__ */ Object.create(null);
      if (attrs) for (var name in attrs) result[name] = new Attribute(typeName, name, attrs[name]);
      return result;
    }
    var NodeType = (function() {
      function NodeType2(name, schema, spec) {
        _classCallCheck(this, NodeType2);
        this.name = name;
        this.schema = schema;
        this.spec = spec;
        this.markSet = null;
        this.groups = spec.group ? spec.group.split(" ") : [];
        this.attrs = initAttrs(name, spec.attrs);
        this.defaultAttrs = defaultAttrs(this.attrs);
        this.contentMatch = null;
        this.inlineContent = null;
        this.isBlock = !(spec.inline || name == "text");
        this.isText = name == "text";
      }
      _createClass(NodeType2, [{
        key: "isInline",
        get: function get2() {
          return !this.isBlock;
        }
      }, {
        key: "isTextblock",
        get: function get2() {
          return this.isBlock && this.inlineContent;
        }
      }, {
        key: "isLeaf",
        get: function get2() {
          return this.contentMatch == ContentMatch.empty;
        }
      }, {
        key: "isAtom",
        get: function get2() {
          return this.isLeaf || !!this.spec.atom;
        }
      }, {
        key: "isInGroup",
        value: function isInGroup(group) {
          return this.groups.indexOf(group) > -1;
        }
      }, {
        key: "whitespace",
        get: function get2() {
          return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
        }
      }, {
        key: "hasRequiredAttrs",
        value: function hasRequiredAttrs() {
          for (var n in this.attrs) if (this.attrs[n].isRequired) return true;
          return false;
        }
      }, {
        key: "compatibleContent",
        value: function compatibleContent(other) {
          return this == other || this.contentMatch.compatible(other.contentMatch);
        }
      }, {
        key: "computeAttrs",
        value: function computeAttrs(attrs) {
          if (!attrs && this.defaultAttrs) return this.defaultAttrs;
          else return _computeAttrs(this.attrs, attrs);
        }
      }, {
        key: "create",
        value: function create() {
          var attrs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
          var content = arguments.length > 1 ? arguments[1] : void 0;
          var marks = arguments.length > 2 ? arguments[2] : void 0;
          if (this.isText) throw new Error("NodeType.create can't construct text nodes");
          return new Node2(this, this.computeAttrs(attrs), Fragment2.from(content), Mark.setFrom(marks));
        }
      }, {
        key: "createChecked",
        value: function createChecked() {
          var attrs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
          var content = arguments.length > 1 ? arguments[1] : void 0;
          var marks = arguments.length > 2 ? arguments[2] : void 0;
          content = Fragment2.from(content);
          this.checkContent(content);
          return new Node2(this, this.computeAttrs(attrs), content, Mark.setFrom(marks));
        }
      }, {
        key: "createAndFill",
        value: function createAndFill() {
          var attrs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
          var content = arguments.length > 1 ? arguments[1] : void 0;
          var marks = arguments.length > 2 ? arguments[2] : void 0;
          attrs = this.computeAttrs(attrs);
          content = Fragment2.from(content);
          if (content.size) {
            var before = this.contentMatch.fillBefore(content);
            if (!before) return null;
            content = before.append(content);
          }
          var matched = this.contentMatch.matchFragment(content);
          var after = matched && matched.fillBefore(Fragment2.empty, true);
          if (!after) return null;
          return new Node2(this, attrs, content.append(after), Mark.setFrom(marks));
        }
      }, {
        key: "validContent",
        value: function validContent(content) {
          var result = this.contentMatch.matchFragment(content);
          if (!result || !result.validEnd) return false;
          for (var i = 0; i < content.childCount; i++) if (!this.allowsMarks(content.child(i).marks)) return false;
          return true;
        }
      }, {
        key: "checkContent",
        value: function checkContent(content) {
          if (!this.validContent(content)) throw new RangeError("Invalid content for node ".concat(this.name, ": ").concat(content.toString().slice(0, 50)));
        }
      }, {
        key: "checkAttrs",
        value: function checkAttrs(attrs) {
          _checkAttrs(this.attrs, attrs, "node", this.name);
        }
      }, {
        key: "allowsMarkType",
        value: function allowsMarkType(markType) {
          return this.markSet == null || this.markSet.indexOf(markType) > -1;
        }
      }, {
        key: "allowsMarks",
        value: function allowsMarks(marks) {
          if (this.markSet == null) return true;
          for (var i = 0; i < marks.length; i++) if (!this.allowsMarkType(marks[i].type)) return false;
          return true;
        }
      }, {
        key: "allowedMarks",
        value: function allowedMarks(marks) {
          if (this.markSet == null) return marks;
          var copy2;
          for (var i = 0; i < marks.length; i++) {
            if (!this.allowsMarkType(marks[i].type)) {
              if (!copy2) copy2 = marks.slice(0, i);
            } else if (copy2) {
              copy2.push(marks[i]);
            }
          }
          return !copy2 ? marks : copy2.length ? copy2 : Mark.none;
        }
      }], [{
        key: "compile",
        value: function compile(nodes, schema) {
          var result = /* @__PURE__ */ Object.create(null);
          nodes.forEach(function(name, spec) {
            return result[name] = new NodeType2(name, schema, spec);
          });
          var topType = schema.spec.topNode || "doc";
          if (!result[topType]) throw new RangeError("Schema is missing its top node type ('" + topType + "')");
          if (!result.text) throw new RangeError("Every schema needs a 'text' type");
          for (var _ in result.text.attrs) throw new RangeError("The text node type should not have attributes");
          return result;
        }
      }]);
      return NodeType2;
    })();
    function validateType(typeName, attrName, type2) {
      var types2 = type2.split("|");
      return function(value) {
        var name = value === null ? "null" : _typeof(value);
        if (types2.indexOf(name) < 0) throw new RangeError("Expected value of type ".concat(types2, " for attribute ").concat(attrName, " on type ").concat(typeName, ", got ").concat(name));
      };
    }
    var Attribute = (function() {
      function Attribute2(typeName, attrName, options) {
        _classCallCheck(this, Attribute2);
        this.hasDefault = Object.prototype.hasOwnProperty.call(options, "default");
        this["default"] = options["default"];
        this.validate = typeof options.validate == "string" ? validateType(typeName, attrName, options.validate) : options.validate;
      }
      _createClass(Attribute2, [{
        key: "isRequired",
        get: function get2() {
          return !this.hasDefault;
        }
      }]);
      return Attribute2;
    })();
    var MarkType = (function() {
      function MarkType2(name, rank, schema, spec) {
        _classCallCheck(this, MarkType2);
        this.name = name;
        this.rank = rank;
        this.schema = schema;
        this.spec = spec;
        this.attrs = initAttrs(name, spec.attrs);
        this.excluded = null;
        var defaults = defaultAttrs(this.attrs);
        this.instance = defaults ? new Mark(this, defaults) : null;
      }
      _createClass(MarkType2, [{
        key: "create",
        value: function create() {
          var attrs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
          if (!attrs && this.instance) return this.instance;
          return new Mark(this, _computeAttrs(this.attrs, attrs));
        }
      }, {
        key: "removeFromSet",
        value: function removeFromSet(set) {
          for (var i = 0; i < set.length; i++) if (set[i].type == this) {
            set = set.slice(0, i).concat(set.slice(i + 1));
            i--;
          }
          return set;
        }
      }, {
        key: "isInSet",
        value: function isInSet(set) {
          for (var i = 0; i < set.length; i++) if (set[i].type == this) return set[i];
        }
      }, {
        key: "checkAttrs",
        value: function checkAttrs(attrs) {
          _checkAttrs(this.attrs, attrs, "mark", this.name);
        }
      }, {
        key: "excludes",
        value: function excludes(other) {
          return this.excluded.indexOf(other) > -1;
        }
      }], [{
        key: "compile",
        value: function compile(marks, schema) {
          var result = /* @__PURE__ */ Object.create(null), rank = 0;
          marks.forEach(function(name, spec) {
            return result[name] = new MarkType2(name, rank++, schema, spec);
          });
          return result;
        }
      }]);
      return MarkType2;
    })();
    var Schema = (function() {
      function Schema2(spec) {
        var _this2 = this;
        _classCallCheck(this, Schema2);
        this.linebreakReplacement = null;
        this.cached = /* @__PURE__ */ Object.create(null);
        var instanceSpec = this.spec = {};
        for (var prop in spec) instanceSpec[prop] = spec[prop];
        instanceSpec.nodes = OrderedMap.from(spec.nodes), instanceSpec.marks = OrderedMap.from(spec.marks || {}), this.nodes = NodeType.compile(this.spec.nodes, this);
        this.marks = MarkType.compile(this.spec.marks, this);
        var contentExprCache = /* @__PURE__ */ Object.create(null);
        for (var _prop in this.nodes) {
          if (_prop in this.marks) throw new RangeError(_prop + " can not be both a node and a mark");
          var type2 = this.nodes[_prop], contentExpr = type2.spec.content || "", markExpr = type2.spec.marks;
          type2.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));
          type2.inlineContent = type2.contentMatch.inlineContent;
          if (type2.spec.linebreakReplacement) {
            if (this.linebreakReplacement) throw new RangeError("Multiple linebreak nodes defined");
            if (!type2.isInline || !type2.isLeaf) throw new RangeError("Linebreak replacement nodes must be inline leaf nodes");
            this.linebreakReplacement = type2;
          }
          type2.markSet = markExpr == "_" ? null : markExpr ? gatherMarks(this, markExpr.split(" ")) : markExpr == "" || !type2.inlineContent ? [] : null;
        }
        for (var _prop2 in this.marks) {
          var _type2 = this.marks[_prop2], excl = _type2.spec.excludes;
          _type2.excluded = excl == null ? [_type2] : excl == "" ? [] : gatherMarks(this, excl.split(" "));
        }
        this.nodeFromJSON = function(json) {
          return Node2.fromJSON(_this2, json);
        };
        this.markFromJSON = function(json) {
          return Mark.fromJSON(_this2, json);
        };
        this.topNodeType = this.nodes[this.spec.topNode || "doc"];
        this.cached.wrappings = /* @__PURE__ */ Object.create(null);
      }
      _createClass(Schema2, [{
        key: "node",
        value: function node(type2) {
          var attrs = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
          var content = arguments.length > 2 ? arguments[2] : void 0;
          var marks = arguments.length > 3 ? arguments[3] : void 0;
          if (typeof type2 == "string") type2 = this.nodeType(type2);
          else if (!(type2 instanceof NodeType)) throw new RangeError("Invalid node type: " + type2);
          else if (type2.schema != this) throw new RangeError("Node type from different schema used (" + type2.name + ")");
          return type2.createChecked(attrs, content, marks);
        }
      }, {
        key: "text",
        value: function text(_text, marks) {
          var type2 = this.nodes.text;
          return new TextNode(type2, type2.defaultAttrs, _text, Mark.setFrom(marks));
        }
      }, {
        key: "mark",
        value: function mark(type2, attrs) {
          if (typeof type2 == "string") type2 = this.marks[type2];
          return type2.create(attrs);
        }
      }, {
        key: "nodeType",
        value: function nodeType(name) {
          var found2 = this.nodes[name];
          if (!found2) throw new RangeError("Unknown node type: " + name);
          return found2;
        }
      }]);
      return Schema2;
    })();
    function gatherMarks(schema, marks) {
      var found2 = [];
      for (var i = 0; i < marks.length; i++) {
        var name = marks[i], mark = schema.marks[name], ok = mark;
        if (mark) {
          found2.push(mark);
        } else {
          for (var prop in schema.marks) {
            var _mark = schema.marks[prop];
            if (name == "_" || _mark.spec.group && _mark.spec.group.split(" ").indexOf(name) > -1) found2.push(ok = _mark);
          }
        }
        if (!ok) throw new SyntaxError("Unknown mark type: '" + marks[i] + "'");
      }
      return found2;
    }
    function isTagRule(rule) {
      return rule.tag != null;
    }
    function isStyleRule(rule) {
      return rule.style != null;
    }
    var DOMParser = (function() {
      function DOMParser2(schema, rules) {
        var _this3 = this;
        _classCallCheck(this, DOMParser2);
        this.schema = schema;
        this.rules = rules;
        this.tags = [];
        this.styles = [];
        var matchedStyles = this.matchedStyles = [];
        rules.forEach(function(rule) {
          if (isTagRule(rule)) {
            _this3.tags.push(rule);
          } else if (isStyleRule(rule)) {
            var prop = /[^=]*/.exec(rule.style)[0];
            if (matchedStyles.indexOf(prop) < 0) matchedStyles.push(prop);
            _this3.styles.push(rule);
          }
        });
        this.normalizeLists = !this.tags.some(function(r) {
          if (!/^(ul|ol)\b/.test(r.tag) || !r.node) return false;
          var node = schema.nodes[r.node];
          return node.contentMatch.matchType(node);
        });
      }
      _createClass(DOMParser2, [{
        key: "parse",
        value: function parse(dom) {
          var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var context = new ParseContext(this, options, false);
          context.addAll(dom, Mark.none, options.from, options.to);
          return context.finish();
        }
      }, {
        key: "parseSlice",
        value: function parseSlice(dom) {
          var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var context = new ParseContext(this, options, true);
          context.addAll(dom, Mark.none, options.from, options.to);
          return Slice.maxOpen(context.finish());
        }
      }, {
        key: "matchTag",
        value: function matchTag(dom, context, after) {
          for (var i = after ? this.tags.indexOf(after) + 1 : 0; i < this.tags.length; i++) {
            var rule = this.tags[i];
            if (matches(dom, rule.tag) && (rule.namespace === void 0 || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {
              if (rule.getAttrs) {
                var result = rule.getAttrs(dom);
                if (result === false) continue;
                rule.attrs = result || void 0;
              }
              return rule;
            }
          }
        }
      }, {
        key: "matchStyle",
        value: function matchStyle(prop, value, context, after) {
          for (var i = after ? this.styles.indexOf(after) + 1 : 0; i < this.styles.length; i++) {
            var rule = this.styles[i], style = rule.style;
            if (style.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || style.length > prop.length && (style.charCodeAt(prop.length) != 61 || style.slice(prop.length + 1) != value)) continue;
            if (rule.getAttrs) {
              var result = rule.getAttrs(value);
              if (result === false) continue;
              rule.attrs = result || void 0;
            }
            return rule;
          }
        }
      }], [{
        key: "schemaRules",
        value: function schemaRules(schema) {
          var result = [];
          function insert(rule) {
            var priority = rule.priority == null ? 50 : rule.priority, i = 0;
            for (; i < result.length; i++) {
              var next = result[i], nextPriority = next.priority == null ? 50 : next.priority;
              if (nextPriority < priority) break;
            }
            result.splice(i, 0, rule);
          }
          var _loop2 = function _loop22(name2) {
            var rules = schema.marks[name2].spec.parseDOM;
            if (rules) rules.forEach(function(rule) {
              insert(rule = copy(rule));
              if (!(rule.mark || rule.ignore || rule.clearMark)) rule.mark = name2;
            });
          };
          for (var name in schema.marks) {
            _loop2(name);
          }
          var _loop3 = function _loop32(_name32) {
            var rules = schema.nodes[_name32].spec.parseDOM;
            if (rules) rules.forEach(function(rule) {
              insert(rule = copy(rule));
              if (!(rule.node || rule.ignore || rule.mark)) rule.node = _name32;
            });
          };
          for (var _name3 in schema.nodes) {
            _loop3(_name3);
          }
          return result;
        }
      }, {
        key: "fromSchema",
        value: function fromSchema(schema) {
          return schema.cached.domParser || (schema.cached.domParser = new DOMParser2(schema, DOMParser2.schemaRules(schema)));
        }
      }]);
      return DOMParser2;
    })();
    var blockTags = {
      address: true,
      article: true,
      aside: true,
      blockquote: true,
      canvas: true,
      dd: true,
      div: true,
      dl: true,
      fieldset: true,
      figcaption: true,
      figure: true,
      footer: true,
      form: true,
      h1: true,
      h2: true,
      h3: true,
      h4: true,
      h5: true,
      h6: true,
      header: true,
      hgroup: true,
      hr: true,
      li: true,
      noscript: true,
      ol: true,
      output: true,
      p: true,
      pre: true,
      section: true,
      table: true,
      tfoot: true,
      ul: true
    };
    var ignoreTags = {
      head: true,
      noscript: true,
      object: true,
      script: true,
      style: true,
      title: true
    };
    var listTags = {
      ol: true,
      ul: true
    };
    var OPT_PRESERVE_WS = 1;
    var OPT_PRESERVE_WS_FULL = 2;
    var OPT_OPEN_LEFT = 4;
    function wsOptionsFor(type2, preserveWhitespace, base) {
      if (preserveWhitespace != null) return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL : 0);
      return type2 && type2.whitespace == "pre" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base & ~OPT_OPEN_LEFT;
    }
    var NodeContext = (function() {
      function NodeContext2(type2, attrs, marks, solid, match, options) {
        _classCallCheck(this, NodeContext2);
        this.type = type2;
        this.attrs = attrs;
        this.marks = marks;
        this.solid = solid;
        this.options = options;
        this.content = [];
        this.activeMarks = Mark.none;
        this.match = match || (options & OPT_OPEN_LEFT ? null : type2.contentMatch);
      }
      _createClass(NodeContext2, [{
        key: "findWrapping",
        value: function findWrapping(node) {
          if (!this.match) {
            if (!this.type) return [];
            var fill = this.type.contentMatch.fillBefore(Fragment2.from(node));
            if (fill) {
              this.match = this.type.contentMatch.matchFragment(fill);
            } else {
              var start = this.type.contentMatch, wrap;
              if (wrap = start.findWrapping(node.type)) {
                this.match = start;
                return wrap;
              } else {
                return null;
              }
            }
          }
          return this.match.findWrapping(node.type);
        }
      }, {
        key: "finish",
        value: function finish(openEnd) {
          if (!(this.options & OPT_PRESERVE_WS)) {
            var last = this.content[this.content.length - 1], m;
            if (last && last.isText && (m = /[ \t\r\n\u000c]+$/.exec(last.text))) {
              var text = last;
              if (last.text.length == m[0].length) this.content.pop();
              else this.content[this.content.length - 1] = text.withText(text.text.slice(0, text.text.length - m[0].length));
            }
          }
          var content = Fragment2.from(this.content);
          if (!openEnd && this.match) content = content.append(this.match.fillBefore(Fragment2.empty, true));
          return this.type ? this.type.create(this.attrs, content, this.marks) : content;
        }
      }, {
        key: "inlineContext",
        value: function inlineContext(node) {
          if (this.type) return this.type.inlineContent;
          if (this.content.length) return this.content[0].isInline;
          return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase());
        }
      }]);
      return NodeContext2;
    })();
    var ParseContext = (function() {
      function ParseContext2(parser, options, isOpen) {
        _classCallCheck(this, ParseContext2);
        this.parser = parser;
        this.options = options;
        this.isOpen = isOpen;
        this.open = 0;
        this.localPreserveWS = false;
        var topNode = options.topNode, topContext;
        var topOptions = wsOptionsFor(null, options.preserveWhitespace, 0) | (isOpen ? OPT_OPEN_LEFT : 0);
        if (topNode) topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, true, options.topMatch || topNode.type.contentMatch, topOptions);
        else if (isOpen) topContext = new NodeContext(null, null, Mark.none, true, null, topOptions);
        else topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, true, null, topOptions);
        this.nodes = [topContext];
        this.find = options.findPositions;
        this.needsBlock = false;
      }
      _createClass(ParseContext2, [{
        key: "top",
        get: function get2() {
          return this.nodes[this.open];
        }
      }, {
        key: "addDOM",
        value: function addDOM(dom, marks) {
          if (dom.nodeType == 3) this.addTextNode(dom, marks);
          else if (dom.nodeType == 1) this.addElement(dom, marks);
        }
      }, {
        key: "addTextNode",
        value: function addTextNode(dom, marks) {
          var value = dom.nodeValue;
          var top = this.top, preserveWS = top.options & OPT_PRESERVE_WS_FULL ? "full" : this.localPreserveWS || (top.options & OPT_PRESERVE_WS) > 0;
          var schema = this.parser.schema;
          if (preserveWS === "full" || top.inlineContext(dom) || /[^ \t\r\n\u000c]/.test(value)) {
            if (!preserveWS) {
              value = value.replace(/[ \t\r\n\u000c]+/g, " ");
              if (/^[ \t\r\n\u000c]/.test(value) && this.open == this.nodes.length - 1) {
                var nodeBefore = top.content[top.content.length - 1];
                var domNodeBefore = dom.previousSibling;
                if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == "BR" || nodeBefore.isText && /[ \t\r\n\u000c]$/.test(nodeBefore.text)) value = value.slice(1);
              }
            } else if (preserveWS === "full") {
              value = value.replace(/\r\n?/g, "\n");
            } else if (schema.linebreakReplacement && /[\r\n]/.test(value) && this.top.findWrapping(schema.linebreakReplacement.create())) {
              var lines = value.split(/\r?\n|\r/);
              for (var i = 0; i < lines.length; i++) {
                if (i) this.insertNode(schema.linebreakReplacement.create(), marks, true);
                if (lines[i]) this.insertNode(schema.text(lines[i]), marks, !/\S/.test(lines[i]));
              }
              value = "";
            } else {
              value = value.replace(/\r?\n|\r/g, " ");
            }
            if (value) this.insertNode(schema.text(value), marks, !/\S/.test(value));
            this.findInText(dom);
          } else {
            this.findInside(dom);
          }
        }
      }, {
        key: "addElement",
        value: function addElement(dom, marks, matchAfter) {
          var outerWS = this.localPreserveWS, top = this.top;
          if (dom.tagName == "PRE" || /pre/.test(dom.style && dom.style.whiteSpace)) this.localPreserveWS = true;
          var name = dom.nodeName.toLowerCase(), ruleID;
          if (listTags.hasOwnProperty(name) && this.parser.normalizeLists) normalizeList(dom);
          var rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));
          out: if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {
            this.findInside(dom);
            this.ignoreFallback(dom, marks);
          } else if (!rule || rule.skip || rule.closeParent) {
            if (rule && rule.closeParent) this.open = Math.max(0, this.open - 1);
            else if (rule && rule.skip.nodeType) dom = rule.skip;
            var sync, oldNeedsBlock = this.needsBlock;
            if (blockTags.hasOwnProperty(name)) {
              if (top.content.length && top.content[0].isInline && this.open) {
                this.open--;
                top = this.top;
              }
              sync = true;
              if (!top.type) this.needsBlock = true;
            } else if (!dom.firstChild) {
              this.leafFallback(dom, marks);
              break out;
            }
            var innerMarks = rule && rule.skip ? marks : this.readStyles(dom, marks);
            if (innerMarks) this.addAll(dom, innerMarks);
            if (sync) this.sync(top);
            this.needsBlock = oldNeedsBlock;
          } else {
            var _innerMarks = this.readStyles(dom, marks);
            if (_innerMarks) this.addElementByRule(dom, rule, _innerMarks, rule.consuming === false ? ruleID : void 0);
          }
          this.localPreserveWS = outerWS;
        }
      }, {
        key: "leafFallback",
        value: function leafFallback(dom, marks) {
          if (dom.nodeName == "BR" && this.top.type && this.top.type.inlineContent) this.addTextNode(dom.ownerDocument.createTextNode("\n"), marks);
        }
      }, {
        key: "ignoreFallback",
        value: function ignoreFallback(dom, marks) {
          if (dom.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent)) this.findPlace(this.parser.schema.text("-"), marks, true);
        }
      }, {
        key: "readStyles",
        value: function readStyles(dom, marks) {
          var _this4 = this;
          var styles2 = dom.style;
          if (styles2 && styles2.length) for (var i = 0; i < this.parser.matchedStyles.length; i++) {
            var name = this.parser.matchedStyles[i], value = styles2.getPropertyValue(name);
            if (value) {
              var _loop4 = function _loop42(_after) {
                var rule = _this4.parser.matchStyle(name, value, _this4, _after);
                if (!rule) {
                  after = _after;
                  return 0;
                }
                if (rule.ignore) return {
                  v: null
                };
                if (rule.clearMark) marks = marks.filter(function(m) {
                  return !rule.clearMark(m);
                });
                else marks = marks.concat(_this4.parser.schema.marks[rule.mark].create(rule.attrs));
                if (rule.consuming === false) _after = rule;
                else {
                  after = _after;
                  return 0;
                }
                after = _after;
              }, _ret;
              for (var after = void 0; ; ) {
                _ret = _loop4(after);
                if (_ret === 0) break;
                if (_ret) return _ret.v;
              }
            }
          }
          return marks;
        }
      }, {
        key: "addElementByRule",
        value: function addElementByRule(dom, rule, marks, continueAfter) {
          var _this5 = this;
          var sync, nodeType;
          if (rule.node) {
            nodeType = this.parser.schema.nodes[rule.node];
            if (!nodeType.isLeaf) {
              var inner = this.enter(nodeType, rule.attrs || null, marks, rule.preserveWhitespace);
              if (inner) {
                sync = true;
                marks = inner;
              }
            } else if (!this.insertNode(nodeType.create(rule.attrs), marks, dom.nodeName == "BR")) {
              this.leafFallback(dom, marks);
            }
          } else {
            var markType = this.parser.schema.marks[rule.mark];
            marks = marks.concat(markType.create(rule.attrs));
          }
          var startIn = this.top;
          if (nodeType && nodeType.isLeaf) {
            this.findInside(dom);
          } else if (continueAfter) {
            this.addElement(dom, marks, continueAfter);
          } else if (rule.getContent) {
            this.findInside(dom);
            rule.getContent(dom, this.parser.schema).forEach(function(node) {
              return _this5.insertNode(node, marks, false);
            });
          } else {
            var contentDOM = dom;
            if (typeof rule.contentElement == "string") contentDOM = dom.querySelector(rule.contentElement);
            else if (typeof rule.contentElement == "function") contentDOM = rule.contentElement(dom);
            else if (rule.contentElement) contentDOM = rule.contentElement;
            this.findAround(dom, contentDOM, true);
            this.addAll(contentDOM, marks);
            this.findAround(dom, contentDOM, false);
          }
          if (sync && this.sync(startIn)) this.open--;
        }
      }, {
        key: "addAll",
        value: function addAll(parent, marks, startIndex, endIndex) {
          var index = startIndex || 0;
          for (var dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end = endIndex == null ? null : parent.childNodes[endIndex]; dom != end; dom = dom.nextSibling, ++index) {
            this.findAtPoint(parent, index);
            this.addDOM(dom, marks);
          }
          this.findAtPoint(parent, index);
        }
      }, {
        key: "findPlace",
        value: function findPlace(node, marks, cautious) {
          var route, sync;
          for (var depth = this.open, penalty = 0; depth >= 0; depth--) {
            var cx = this.nodes[depth];
            var _found2 = cx.findWrapping(node);
            if (_found2 && (!route || route.length > _found2.length + penalty)) {
              route = _found2;
              sync = cx;
              if (!_found2.length) break;
            }
            if (cx.solid) {
              if (cautious) break;
              penalty += 2;
            }
          }
          if (!route) return null;
          this.sync(sync);
          for (var i = 0; i < route.length; i++) marks = this.enterInner(route[i], null, marks, false);
          return marks;
        }
      }, {
        key: "insertNode",
        value: function insertNode(node, marks, cautious) {
          if (node.isInline && this.needsBlock && !this.top.type) {
            var block = this.textblockFromContext();
            if (block) marks = this.enterInner(block, null, marks);
          }
          var innerMarks = this.findPlace(node, marks, cautious);
          if (innerMarks) {
            this.closeExtra();
            var top = this.top;
            if (top.match) top.match = top.match.matchType(node.type);
            var nodeMarks = Mark.none;
            var _iterator = _createForOfIteratorHelper(innerMarks.concat(node.marks)), _step;
            try {
              for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                var m = _step.value;
                if (top.type ? top.type.allowsMarkType(m.type) : markMayApply(m.type, node.type)) nodeMarks = m.addToSet(nodeMarks);
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }
            top.content.push(node.mark(nodeMarks));
            return true;
          }
          return false;
        }
      }, {
        key: "enter",
        value: function enter(type2, attrs, marks, preserveWS) {
          var innerMarks = this.findPlace(type2.create(attrs), marks, false);
          if (innerMarks) innerMarks = this.enterInner(type2, attrs, marks, true, preserveWS);
          return innerMarks;
        }
      }, {
        key: "enterInner",
        value: function enterInner(type2, attrs, marks) {
          var solid = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
          var preserveWS = arguments.length > 4 ? arguments[4] : void 0;
          this.closeExtra();
          var top = this.top;
          top.match = top.match && top.match.matchType(type2);
          var options = wsOptionsFor(type2, preserveWS, top.options);
          if (top.options & OPT_OPEN_LEFT && top.content.length == 0) options |= OPT_OPEN_LEFT;
          var applyMarks = Mark.none;
          marks = marks.filter(function(m) {
            if (top.type ? top.type.allowsMarkType(m.type) : markMayApply(m.type, type2)) {
              applyMarks = m.addToSet(applyMarks);
              return false;
            }
            return true;
          });
          this.nodes.push(new NodeContext(type2, attrs, applyMarks, solid, null, options));
          this.open++;
          return marks;
        }
      }, {
        key: "closeExtra",
        value: function closeExtra() {
          var openEnd = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
          var i = this.nodes.length - 1;
          if (i > this.open) {
            for (; i > this.open; i--) this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd));
            this.nodes.length = this.open + 1;
          }
        }
      }, {
        key: "finish",
        value: function finish() {
          this.open = 0;
          this.closeExtra(this.isOpen);
          return this.nodes[0].finish(!!(this.isOpen || this.options.topOpen));
        }
      }, {
        key: "sync",
        value: function sync(to) {
          for (var i = this.open; i >= 0; i--) {
            if (this.nodes[i] == to) {
              this.open = i;
              return true;
            } else if (this.localPreserveWS) {
              this.nodes[i].options |= OPT_PRESERVE_WS;
            }
          }
          return false;
        }
      }, {
        key: "currentPos",
        get: function get2() {
          this.closeExtra();
          var pos = 0;
          for (var i = this.open; i >= 0; i--) {
            var content = this.nodes[i].content;
            for (var j = content.length - 1; j >= 0; j--) pos += content[j].nodeSize;
            if (i) pos++;
          }
          return pos;
        }
      }, {
        key: "findAtPoint",
        value: function findAtPoint(parent, offset) {
          if (this.find) for (var i = 0; i < this.find.length; i++) {
            if (this.find[i].node == parent && this.find[i].offset == offset) this.find[i].pos = this.currentPos;
          }
        }
      }, {
        key: "findInside",
        value: function findInside(parent) {
          if (this.find) for (var i = 0; i < this.find.length; i++) {
            if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) this.find[i].pos = this.currentPos;
          }
        }
      }, {
        key: "findAround",
        value: function findAround(parent, content, before) {
          if (parent != content && this.find) for (var i = 0; i < this.find.length; i++) {
            if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {
              var pos = content.compareDocumentPosition(this.find[i].node);
              if (pos & (before ? 2 : 4)) this.find[i].pos = this.currentPos;
            }
          }
        }
      }, {
        key: "findInText",
        value: function findInText(textNode) {
          if (this.find) for (var i = 0; i < this.find.length; i++) {
            if (this.find[i].node == textNode) this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset);
          }
        }
      }, {
        key: "matchesContext",
        value: function matchesContext(context) {
          var _this6 = this;
          if (context.indexOf("|") > -1) return context.split(/\s*\|\s*/).some(this.matchesContext, this);
          var parts = context.split("/");
          var option = this.options.context;
          var useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
          var minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);
          var match = function match2(i, depth) {
            for (; i >= 0; i--) {
              var part = parts[i];
              if (part == "") {
                if (i == parts.length - 1 || i == 0) continue;
                for (; depth >= minDepth; depth--) if (match2(i - 1, depth)) return true;
                return false;
              } else {
                var next = depth > 0 || depth == 0 && useRoot ? _this6.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;
                if (!next || next.name != part && !next.isInGroup(part)) return false;
                depth--;
              }
            }
            return true;
          };
          return match(parts.length - 1, this.open);
        }
      }, {
        key: "textblockFromContext",
        value: function textblockFromContext() {
          var $context = this.options.context;
          if ($context) for (var d = $context.depth; d >= 0; d--) {
            var deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;
            if (deflt && deflt.isTextblock && deflt.defaultAttrs) return deflt;
          }
          for (var name in this.parser.schema.nodes) {
            var type2 = this.parser.schema.nodes[name];
            if (type2.isTextblock && type2.defaultAttrs) return type2;
          }
        }
      }]);
      return ParseContext2;
    })();
    function normalizeList(dom) {
      for (var child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {
        var name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;
        if (name && listTags.hasOwnProperty(name) && prevItem) {
          prevItem.appendChild(child);
          child = prevItem;
        } else if (name == "li") {
          prevItem = child;
        } else if (name) {
          prevItem = null;
        }
      }
    }
    function matches(dom, selector) {
      return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);
    }
    function copy(obj) {
      var copy2 = {};
      for (var prop in obj) copy2[prop] = obj[prop];
      return copy2;
    }
    function markMayApply(markType, nodeType) {
      var nodes = nodeType.schema.nodes;
      var _loop5 = function _loop52() {
        var parent = nodes[name];
        if (!parent.allowsMarkType(markType)) return 0;
        var seen = [], scan = function scan2(match) {
          seen.push(match);
          for (var i = 0; i < match.edgeCount; i++) {
            var _match$edge = match.edge(i), type2 = _match$edge.type, next = _match$edge.next;
            if (type2 == nodeType) return true;
            if (seen.indexOf(next) < 0 && scan2(next)) return true;
          }
        };
        if (scan(parent.contentMatch)) return {
          v: true
        };
      }, _ret2;
      for (var name in nodes) {
        _ret2 = _loop5();
        if (_ret2 === 0) continue;
        if (_ret2) return _ret2.v;
      }
    }
    var DOMSerializer = (function() {
      function DOMSerializer2(nodes, marks) {
        _classCallCheck(this, DOMSerializer2);
        this.nodes = nodes;
        this.marks = marks;
      }
      _createClass(DOMSerializer2, [{
        key: "serializeFragment",
        value: function serializeFragment(fragment) {
          var _this7 = this;
          var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var target = arguments.length > 2 ? arguments[2] : void 0;
          if (!target) target = doc(options).createDocumentFragment();
          var top = target, active = [];
          fragment.forEach(function(node) {
            if (active.length || node.marks.length) {
              var keep = 0, rendered = 0;
              while (keep < active.length && rendered < node.marks.length) {
                var next = node.marks[rendered];
                if (!_this7.marks[next.type.name]) {
                  rendered++;
                  continue;
                }
                if (!next.eq(active[keep][0]) || next.type.spec.spanning === false) break;
                keep++;
                rendered++;
              }
              while (keep < active.length) top = active.pop()[1];
              while (rendered < node.marks.length) {
                var add = node.marks[rendered++];
                var markDOM = _this7.serializeMark(add, node.isInline, options);
                if (markDOM) {
                  active.push([add, top]);
                  top.appendChild(markDOM.dom);
                  top = markDOM.contentDOM || markDOM.dom;
                }
              }
            }
            top.appendChild(_this7.serializeNodeInner(node, options));
          });
          return target;
        }
      }, {
        key: "serializeNodeInner",
        value: function serializeNodeInner(node, options) {
          var _renderSpec2 = _renderSpec(doc(options), this.nodes[node.type.name](node), null, node.attrs), dom = _renderSpec2.dom, contentDOM = _renderSpec2.contentDOM;
          if (contentDOM) {
            if (node.isLeaf) throw new RangeError("Content hole not allowed in a leaf node spec");
            this.serializeFragment(node.content, options, contentDOM);
          }
          return dom;
        }
      }, {
        key: "serializeNode",
        value: function serializeNode(node) {
          var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var dom = this.serializeNodeInner(node, options);
          for (var i = node.marks.length - 1; i >= 0; i--) {
            var wrap = this.serializeMark(node.marks[i], node.isInline, options);
            if (wrap) {
              (wrap.contentDOM || wrap.dom).appendChild(dom);
              dom = wrap.dom;
            }
          }
          return dom;
        }
      }, {
        key: "serializeMark",
        value: function serializeMark(mark, inline) {
          var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          var toDOM = this.marks[mark.type.name];
          return toDOM && _renderSpec(doc(options), toDOM(mark, inline), null, mark.attrs);
        }
      }], [{
        key: "renderSpec",
        value: function renderSpec(doc2, structure) {
          var xmlNS = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
          var blockArraysIn = arguments.length > 3 ? arguments[3] : void 0;
          return _renderSpec(doc2, structure, xmlNS, blockArraysIn);
        }
      }, {
        key: "fromSchema",
        value: function fromSchema(schema) {
          return schema.cached.domSerializer || (schema.cached.domSerializer = new DOMSerializer2(this.nodesFromSchema(schema), this.marksFromSchema(schema)));
        }
      }, {
        key: "nodesFromSchema",
        value: function nodesFromSchema(schema) {
          var result = gatherToDOM(schema.nodes);
          if (!result.text) result.text = function(node) {
            return node.text;
          };
          return result;
        }
      }, {
        key: "marksFromSchema",
        value: function marksFromSchema(schema) {
          return gatherToDOM(schema.marks);
        }
      }]);
      return DOMSerializer2;
    })();
    function gatherToDOM(obj) {
      var result = {};
      for (var name in obj) {
        var toDOM = obj[name].spec.toDOM;
        if (toDOM) result[name] = toDOM;
      }
      return result;
    }
    function doc(options) {
      return options.document || window.document;
    }
    var suspiciousAttributeCache = /* @__PURE__ */ new WeakMap();
    function suspiciousAttributes(attrs) {
      var value = suspiciousAttributeCache.get(attrs);
      if (value === void 0) suspiciousAttributeCache.set(attrs, value = suspiciousAttributesInner(attrs));
      return value;
    }
    function suspiciousAttributesInner(attrs) {
      var result = null;
      function scan(value) {
        if (value && _typeof(value) == "object") {
          if (Array.isArray(value)) {
            if (typeof value[0] == "string") {
              if (!result) result = [];
              result.push(value);
            } else {
              for (var i = 0; i < value.length; i++) scan(value[i]);
            }
          } else {
            for (var prop in value) scan(value[prop]);
          }
        }
      }
      scan(attrs);
      return result;
    }
    function _renderSpec(doc2, structure, xmlNS, blockArraysIn) {
      if (typeof structure == "string") return {
        dom: doc2.createTextNode(structure)
      };
      if (structure.nodeType != null) return {
        dom: structure
      };
      if (structure.dom && structure.dom.nodeType != null) return structure;
      var tagName = structure[0], suspicious;
      if (typeof tagName != "string") throw new RangeError("Invalid array passed to renderSpec");
      if (blockArraysIn && (suspicious = suspiciousAttributes(blockArraysIn)) && suspicious.indexOf(structure) > -1) throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.");
      var space = tagName.indexOf(" ");
      if (space > 0) {
        xmlNS = tagName.slice(0, space);
        tagName = tagName.slice(space + 1);
      }
      var contentDOM;
      var dom = xmlNS ? doc2.createElementNS(xmlNS, tagName) : doc2.createElement(tagName);
      var attrs = structure[1], start = 1;
      if (attrs && _typeof(attrs) == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {
        start = 2;
        for (var name in attrs) if (attrs[name] != null) {
          var _space = name.indexOf(" ");
          if (_space > 0) dom.setAttributeNS(name.slice(0, _space), name.slice(_space + 1), attrs[name]);
          else if (name == "style" && dom.style) dom.style.cssText = attrs[name];
          else dom.setAttribute(name, attrs[name]);
        }
      }
      for (var i = start; i < structure.length; i++) {
        var child = structure[i];
        if (child === 0) {
          if (i < structure.length - 1 || i > start) throw new RangeError("Content hole must be the only child of its parent node");
          return {
            dom,
            contentDOM: dom
          };
        } else {
          var _renderSpec3 = _renderSpec(doc2, child, xmlNS, blockArraysIn), inner = _renderSpec3.dom, innerContent = _renderSpec3.contentDOM;
          dom.appendChild(inner);
          if (innerContent) {
            if (contentDOM) throw new RangeError("Multiple content holes");
            contentDOM = innerContent;
          }
        }
      }
      return {
        dom,
        contentDOM
      };
    }
    exports2.ContentMatch = ContentMatch;
    exports2.DOMParser = DOMParser;
    exports2.DOMSerializer = DOMSerializer;
    exports2.Fragment = Fragment2;
    exports2.Mark = Mark;
    exports2.MarkType = MarkType;
    exports2.Node = Node2;
    exports2.NodeRange = NodeRange;
    exports2.NodeType = NodeType;
    exports2.ReplaceError = ReplaceError;
    exports2.ResolvedPos = ResolvedPos;
    exports2.Schema = Schema;
    exports2.Slice = Slice;
  }
});

// node_modules/.pnpm/prosemirror-transform@1.10.5/node_modules/prosemirror-transform/dist/index.cjs
var require_dist3 = __commonJS({
  "node_modules/.pnpm/prosemirror-transform@1.10.5/node_modules/prosemirror-transform/dist/index.cjs"(exports2) {
    "use strict";
    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
      _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
        if (Class2 === null || !_isNativeFunction(Class2)) return Class2;
        if (typeof Class2 !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
          if (_cache.has(Class2)) return _cache.get(Class2);
          _cache.set(Class2, Wrapper);
        }
        function Wrapper() {
          return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
        }
        Wrapper.prototype = Object.create(Class2.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } });
        return _setPrototypeOf(Wrapper, Class2);
      };
      return _wrapNativeSuper(Class);
    }
    function _construct(Parent, args, Class) {
      if (_isNativeReflectConstruct()) {
        _construct = Reflect.construct.bind();
      } else {
        _construct = function _construct2(Parent2, args2, Class2) {
          var a = [null];
          a.push.apply(a, args2);
          var Constructor = Function.bind.apply(Parent2, a);
          var instance = new Constructor();
          if (Class2) _setPrototypeOf(instance, Class2.prototype);
          return instance;
        };
      }
      return _construct.apply(null, arguments);
    }
    function _isNativeFunction(fn) {
      try {
        return Function.toString.call(fn).indexOf("[native code]") !== -1;
      } catch (e) {
        return typeof fn === "function";
      }
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      Object.defineProperty(subClass, "prototype", { writable: false });
      if (superClass) _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return _typeof(key) === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (_typeof(input) !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (_typeof(res) !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var prosemirrorModel = require_dist2();
    var lower16 = 65535;
    var factor16 = Math.pow(2, 16);
    function makeRecover(index, offset) {
      return index + offset * factor16;
    }
    function recoverIndex(value) {
      return value & lower16;
    }
    function recoverOffset(value) {
      return (value - (value & lower16)) / factor16;
    }
    var DEL_BEFORE = 1;
    var DEL_AFTER = 2;
    var DEL_ACROSS = 4;
    var DEL_SIDE = 8;
    var MapResult = (function() {
      function MapResult2(pos, delInfo, recover) {
        _classCallCheck(this, MapResult2);
        this.pos = pos;
        this.delInfo = delInfo;
        this.recover = recover;
      }
      _createClass(MapResult2, [{
        key: "deleted",
        get: function get2() {
          return (this.delInfo & DEL_SIDE) > 0;
        }
      }, {
        key: "deletedBefore",
        get: function get2() {
          return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0;
        }
      }, {
        key: "deletedAfter",
        get: function get2() {
          return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0;
        }
      }, {
        key: "deletedAcross",
        get: function get2() {
          return (this.delInfo & DEL_ACROSS) > 0;
        }
      }]);
      return MapResult2;
    })();
    var StepMap = (function() {
      function StepMap2(ranges) {
        var inverted = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        _classCallCheck(this, StepMap2);
        this.ranges = ranges;
        this.inverted = inverted;
        if (!ranges.length && StepMap2.empty) return StepMap2.empty;
      }
      _createClass(StepMap2, [{
        key: "recover",
        value: function recover(value) {
          var diff = 0, index = recoverIndex(value);
          if (!this.inverted) for (var i = 0; i < index; i++) diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
          return this.ranges[index * 3] + diff + recoverOffset(value);
        }
      }, {
        key: "mapResult",
        value: function mapResult(pos) {
          var assoc = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
          return this._map(pos, assoc, false);
        }
      }, {
        key: "map",
        value: function map(pos) {
          var assoc = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
          return this._map(pos, assoc, true);
        }
      }, {
        key: "_map",
        value: function _map(pos, assoc, simple) {
          var diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
          for (var i = 0; i < this.ranges.length; i += 3) {
            var start = this.ranges[i] - (this.inverted ? diff : 0);
            if (start > pos) break;
            var oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end = start + oldSize;
            if (pos <= end) {
              var side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc;
              var result = start + diff + (side < 0 ? 0 : newSize);
              if (simple) return result;
              var recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i / 3, pos - start);
              var del = pos == start ? DEL_AFTER : pos == end ? DEL_BEFORE : DEL_ACROSS;
              if (assoc < 0 ? pos != start : pos != end) del |= DEL_SIDE;
              return new MapResult(result, del, recover);
            }
            diff += newSize - oldSize;
          }
          return simple ? pos + diff : new MapResult(pos + diff, 0, null);
        }
      }, {
        key: "touches",
        value: function touches(pos, recover) {
          var diff = 0, index = recoverIndex(recover);
          var oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
          for (var i = 0; i < this.ranges.length; i += 3) {
            var start = this.ranges[i] - (this.inverted ? diff : 0);
            if (start > pos) break;
            var oldSize = this.ranges[i + oldIndex], end = start + oldSize;
            if (pos <= end && i == index * 3) return true;
            diff += this.ranges[i + newIndex] - oldSize;
          }
          return false;
        }
      }, {
        key: "forEach",
        value: function forEach(f) {
          var oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
          for (var i = 0, diff = 0; i < this.ranges.length; i += 3) {
            var start = this.ranges[i], oldStart = start - (this.inverted ? diff : 0), newStart = start + (this.inverted ? 0 : diff);
            var oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex];
            f(oldStart, oldStart + oldSize, newStart, newStart + newSize);
            diff += newSize - oldSize;
          }
        }
      }, {
        key: "invert",
        value: function invert() {
          return new StepMap2(this.ranges, !this.inverted);
        }
      }, {
        key: "toString",
        value: function toString() {
          return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
        }
      }], [{
        key: "offset",
        value: function offset(n) {
          return n == 0 ? StepMap2.empty : new StepMap2(n < 0 ? [0, -n, 0] : [0, 0, n]);
        }
      }]);
      return StepMap2;
    })();
    StepMap.empty = new StepMap([]);
    var Mapping = (function() {
      function Mapping2(maps, mirror) {
        var from = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        var to = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : maps ? maps.length : 0;
        _classCallCheck(this, Mapping2);
        this.mirror = mirror;
        this.from = from;
        this.to = to;
        this._maps = maps || [];
        this.ownData = !(maps || mirror);
      }
      _createClass(Mapping2, [{
        key: "maps",
        get: function get2() {
          return this._maps;
        }
      }, {
        key: "slice",
        value: function slice() {
          var from = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
          var to = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.maps.length;
          return new Mapping2(this._maps, this.mirror, from, to);
        }
      }, {
        key: "appendMap",
        value: function appendMap(map, mirrors) {
          if (!this.ownData) {
            this._maps = this._maps.slice();
            this.mirror = this.mirror && this.mirror.slice();
            this.ownData = true;
          }
          this.to = this._maps.push(map);
          if (mirrors != null) this.setMirror(this._maps.length - 1, mirrors);
        }
      }, {
        key: "appendMapping",
        value: function appendMapping(mapping) {
          for (var i = 0, startSize = this._maps.length; i < mapping._maps.length; i++) {
            var mirr = mapping.getMirror(i);
            this.appendMap(mapping._maps[i], mirr != null && mirr < i ? startSize + mirr : void 0);
          }
        }
      }, {
        key: "getMirror",
        value: function getMirror(n) {
          if (this.mirror) {
            for (var i = 0; i < this.mirror.length; i++) if (this.mirror[i] == n) return this.mirror[i + (i % 2 ? -1 : 1)];
          }
        }
      }, {
        key: "setMirror",
        value: function setMirror(n, m) {
          if (!this.mirror) this.mirror = [];
          this.mirror.push(n, m);
        }
      }, {
        key: "appendMappingInverted",
        value: function appendMappingInverted(mapping) {
          for (var i = mapping.maps.length - 1, totalSize = this._maps.length + mapping._maps.length; i >= 0; i--) {
            var mirr = mapping.getMirror(i);
            this.appendMap(mapping._maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : void 0);
          }
        }
      }, {
        key: "invert",
        value: function invert() {
          var inverse = new Mapping2();
          inverse.appendMappingInverted(this);
          return inverse;
        }
      }, {
        key: "map",
        value: function map(pos) {
          var assoc = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
          if (this.mirror) return this._map(pos, assoc, true);
          for (var i = this.from; i < this.to; i++) pos = this._maps[i].map(pos, assoc);
          return pos;
        }
      }, {
        key: "mapResult",
        value: function mapResult(pos) {
          var assoc = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
          return this._map(pos, assoc, false);
        }
      }, {
        key: "_map",
        value: function _map(pos, assoc, simple) {
          var delInfo = 0;
          for (var i = this.from; i < this.to; i++) {
            var map = this._maps[i], result = map.mapResult(pos, assoc);
            if (result.recover != null) {
              var corr = this.getMirror(i);
              if (corr != null && corr > i && corr < this.to) {
                i = corr;
                pos = this._maps[corr].recover(result.recover);
                continue;
              }
            }
            delInfo |= result.delInfo;
            pos = result.pos;
          }
          return simple ? pos : new MapResult(pos, delInfo, null);
        }
      }]);
      return Mapping2;
    })();
    var stepsByID = /* @__PURE__ */ Object.create(null);
    var Step = (function() {
      function Step2() {
        _classCallCheck(this, Step2);
      }
      _createClass(Step2, [{
        key: "getMap",
        value: function getMap() {
          return StepMap.empty;
        }
      }, {
        key: "merge",
        value: function merge(other) {
          return null;
        }
      }], [{
        key: "fromJSON",
        value: function fromJSON(schema, json) {
          if (!json || !json.stepType) throw new RangeError("Invalid input for Step.fromJSON");
          var type2 = stepsByID[json.stepType];
          if (!type2) throw new RangeError("No step type ".concat(json.stepType, " defined"));
          return type2.fromJSON(schema, json);
        }
      }, {
        key: "jsonID",
        value: function jsonID(id, stepClass) {
          if (id in stepsByID) throw new RangeError("Duplicate use of step JSON ID " + id);
          stepsByID[id] = stepClass;
          stepClass.prototype.jsonID = id;
          return stepClass;
        }
      }]);
      return Step2;
    })();
    var StepResult = (function() {
      function StepResult2(doc, failed) {
        _classCallCheck(this, StepResult2);
        this.doc = doc;
        this.failed = failed;
      }
      _createClass(StepResult2, null, [{
        key: "ok",
        value: function ok(doc) {
          return new StepResult2(doc, null);
        }
      }, {
        key: "fail",
        value: function fail(message) {
          return new StepResult2(null, message);
        }
      }, {
        key: "fromReplace",
        value: function fromReplace(doc, from, to, slice) {
          try {
            return StepResult2.ok(doc.replace(from, to, slice));
          } catch (e) {
            if (e instanceof prosemirrorModel.ReplaceError) return StepResult2.fail(e.message);
            throw e;
          }
        }
      }]);
      return StepResult2;
    })();
    function mapFragment(fragment, f, parent) {
      var mapped = [];
      for (var i = 0; i < fragment.childCount; i++) {
        var child = fragment.child(i);
        if (child.content.size) child = child.copy(mapFragment(child.content, f, child));
        if (child.isInline) child = f(child, parent, i);
        mapped.push(child);
      }
      return prosemirrorModel.Fragment.fromArray(mapped);
    }
    var AddMarkStep = (function(_Step) {
      _inherits(AddMarkStep2, _Step);
      var _super = _createSuper(AddMarkStep2);
      function AddMarkStep2(from, to, mark) {
        var _this;
        _classCallCheck(this, AddMarkStep2);
        _this = _super.call(this);
        _this.from = from;
        _this.to = to;
        _this.mark = mark;
        return _this;
      }
      _createClass(AddMarkStep2, [{
        key: "apply",
        value: function apply(doc) {
          var _this2 = this;
          var oldSlice = doc.slice(this.from, this.to), $from = doc.resolve(this.from);
          var parent = $from.node($from.sharedDepth(this.to));
          var slice = new prosemirrorModel.Slice(mapFragment(oldSlice.content, function(node, parent2) {
            if (!node.isAtom || !parent2.type.allowsMarkType(_this2.mark.type)) return node;
            return node.mark(_this2.mark.addToSet(node.marks));
          }, parent), oldSlice.openStart, oldSlice.openEnd);
          return StepResult.fromReplace(doc, this.from, this.to, slice);
        }
      }, {
        key: "invert",
        value: function invert() {
          return new RemoveMarkStep(this.from, this.to, this.mark);
        }
      }, {
        key: "map",
        value: function map(mapping) {
          var from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
          if (from.deleted && to.deleted || from.pos >= to.pos) return null;
          return new AddMarkStep2(from.pos, to.pos, this.mark);
        }
      }, {
        key: "merge",
        value: function merge(other) {
          if (other instanceof AddMarkStep2 && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from) return new AddMarkStep2(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
          return null;
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          return {
            stepType: "addMark",
            mark: this.mark.toJSON(),
            from: this.from,
            to: this.to
          };
        }
      }], [{
        key: "fromJSON",
        value: function fromJSON(schema, json) {
          if (typeof json.from != "number" || typeof json.to != "number") throw new RangeError("Invalid input for AddMarkStep.fromJSON");
          return new AddMarkStep2(json.from, json.to, schema.markFromJSON(json.mark));
        }
      }]);
      return AddMarkStep2;
    })(Step);
    Step.jsonID("addMark", AddMarkStep);
    var RemoveMarkStep = (function(_Step2) {
      _inherits(RemoveMarkStep2, _Step2);
      var _super2 = _createSuper(RemoveMarkStep2);
      function RemoveMarkStep2(from, to, mark) {
        var _this3;
        _classCallCheck(this, RemoveMarkStep2);
        _this3 = _super2.call(this);
        _this3.from = from;
        _this3.to = to;
        _this3.mark = mark;
        return _this3;
      }
      _createClass(RemoveMarkStep2, [{
        key: "apply",
        value: function apply(doc) {
          var _this4 = this;
          var oldSlice = doc.slice(this.from, this.to);
          var slice = new prosemirrorModel.Slice(mapFragment(oldSlice.content, function(node) {
            return node.mark(_this4.mark.removeFromSet(node.marks));
          }, doc), oldSlice.openStart, oldSlice.openEnd);
          return StepResult.fromReplace(doc, this.from, this.to, slice);
        }
      }, {
        key: "invert",
        value: function invert() {
          return new AddMarkStep(this.from, this.to, this.mark);
        }
      }, {
        key: "map",
        value: function map(mapping) {
          var from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
          if (from.deleted && to.deleted || from.pos >= to.pos) return null;
          return new RemoveMarkStep2(from.pos, to.pos, this.mark);
        }
      }, {
        key: "merge",
        value: function merge(other) {
          if (other instanceof RemoveMarkStep2 && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from) return new RemoveMarkStep2(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
          return null;
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          return {
            stepType: "removeMark",
            mark: this.mark.toJSON(),
            from: this.from,
            to: this.to
          };
        }
      }], [{
        key: "fromJSON",
        value: function fromJSON(schema, json) {
          if (typeof json.from != "number" || typeof json.to != "number") throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
          return new RemoveMarkStep2(json.from, json.to, schema.markFromJSON(json.mark));
        }
      }]);
      return RemoveMarkStep2;
    })(Step);
    Step.jsonID("removeMark", RemoveMarkStep);
    var AddNodeMarkStep = (function(_Step3) {
      _inherits(AddNodeMarkStep2, _Step3);
      var _super3 = _createSuper(AddNodeMarkStep2);
      function AddNodeMarkStep2(pos, mark) {
        var _this5;
        _classCallCheck(this, AddNodeMarkStep2);
        _this5 = _super3.call(this);
        _this5.pos = pos;
        _this5.mark = mark;
        return _this5;
      }
      _createClass(AddNodeMarkStep2, [{
        key: "apply",
        value: function apply(doc) {
          var node = doc.nodeAt(this.pos);
          if (!node) return StepResult.fail("No node at mark step's position");
          var updated = node.type.create(node.attrs, null, this.mark.addToSet(node.marks));
          return StepResult.fromReplace(doc, this.pos, this.pos + 1, new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
        }
      }, {
        key: "invert",
        value: function invert(doc) {
          var node = doc.nodeAt(this.pos);
          if (node) {
            var newSet = this.mark.addToSet(node.marks);
            if (newSet.length == node.marks.length) {
              for (var i = 0; i < node.marks.length; i++) if (!node.marks[i].isInSet(newSet)) return new AddNodeMarkStep2(this.pos, node.marks[i]);
              return new AddNodeMarkStep2(this.pos, this.mark);
            }
          }
          return new RemoveNodeMarkStep(this.pos, this.mark);
        }
      }, {
        key: "map",
        value: function map(mapping) {
          var pos = mapping.mapResult(this.pos, 1);
          return pos.deletedAfter ? null : new AddNodeMarkStep2(pos.pos, this.mark);
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          return {
            stepType: "addNodeMark",
            pos: this.pos,
            mark: this.mark.toJSON()
          };
        }
      }], [{
        key: "fromJSON",
        value: function fromJSON(schema, json) {
          if (typeof json.pos != "number") throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
          return new AddNodeMarkStep2(json.pos, schema.markFromJSON(json.mark));
        }
      }]);
      return AddNodeMarkStep2;
    })(Step);
    Step.jsonID("addNodeMark", AddNodeMarkStep);
    var RemoveNodeMarkStep = (function(_Step4) {
      _inherits(RemoveNodeMarkStep2, _Step4);
      var _super4 = _createSuper(RemoveNodeMarkStep2);
      function RemoveNodeMarkStep2(pos, mark) {
        var _this6;
        _classCallCheck(this, RemoveNodeMarkStep2);
        _this6 = _super4.call(this);
        _this6.pos = pos;
        _this6.mark = mark;
        return _this6;
      }
      _createClass(RemoveNodeMarkStep2, [{
        key: "apply",
        value: function apply(doc) {
          var node = doc.nodeAt(this.pos);
          if (!node) return StepResult.fail("No node at mark step's position");
          var updated = node.type.create(node.attrs, null, this.mark.removeFromSet(node.marks));
          return StepResult.fromReplace(doc, this.pos, this.pos + 1, new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
        }
      }, {
        key: "invert",
        value: function invert(doc) {
          var node = doc.nodeAt(this.pos);
          if (!node || !this.mark.isInSet(node.marks)) return this;
          return new AddNodeMarkStep(this.pos, this.mark);
        }
      }, {
        key: "map",
        value: function map(mapping) {
          var pos = mapping.mapResult(this.pos, 1);
          return pos.deletedAfter ? null : new RemoveNodeMarkStep2(pos.pos, this.mark);
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          return {
            stepType: "removeNodeMark",
            pos: this.pos,
            mark: this.mark.toJSON()
          };
        }
      }], [{
        key: "fromJSON",
        value: function fromJSON(schema, json) {
          if (typeof json.pos != "number") throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
          return new RemoveNodeMarkStep2(json.pos, schema.markFromJSON(json.mark));
        }
      }]);
      return RemoveNodeMarkStep2;
    })(Step);
    Step.jsonID("removeNodeMark", RemoveNodeMarkStep);
    var ReplaceStep = (function(_Step5) {
      _inherits(ReplaceStep2, _Step5);
      var _super5 = _createSuper(ReplaceStep2);
      function ReplaceStep2(from, to, slice) {
        var _this7;
        var structure = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
        _classCallCheck(this, ReplaceStep2);
        _this7 = _super5.call(this);
        _this7.from = from;
        _this7.to = to;
        _this7.slice = slice;
        _this7.structure = structure;
        return _this7;
      }
      _createClass(ReplaceStep2, [{
        key: "apply",
        value: function apply(doc) {
          if (this.structure && contentBetween(doc, this.from, this.to)) return StepResult.fail("Structure replace would overwrite content");
          return StepResult.fromReplace(doc, this.from, this.to, this.slice);
        }
      }, {
        key: "getMap",
        value: function getMap() {
          return new StepMap([this.from, this.to - this.from, this.slice.size]);
        }
      }, {
        key: "invert",
        value: function invert(doc) {
          return new ReplaceStep2(this.from, this.from + this.slice.size, doc.slice(this.from, this.to));
        }
      }, {
        key: "map",
        value: function map(mapping) {
          var from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
          if (from.deletedAcross && to.deletedAcross) return null;
          return new ReplaceStep2(from.pos, Math.max(from.pos, to.pos), this.slice, this.structure);
        }
      }, {
        key: "merge",
        value: function merge(other) {
          if (!(other instanceof ReplaceStep2) || other.structure || this.structure) return null;
          if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {
            var slice = this.slice.size + other.slice.size == 0 ? prosemirrorModel.Slice.empty : new prosemirrorModel.Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);
            return new ReplaceStep2(this.from, this.to + (other.to - other.from), slice, this.structure);
          } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {
            var _slice = this.slice.size + other.slice.size == 0 ? prosemirrorModel.Slice.empty : new prosemirrorModel.Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);
            return new ReplaceStep2(other.from, this.to, _slice, this.structure);
          } else {
            return null;
          }
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          var json = {
            stepType: "replace",
            from: this.from,
            to: this.to
          };
          if (this.slice.size) json.slice = this.slice.toJSON();
          if (this.structure) json.structure = true;
          return json;
        }
      }], [{
        key: "fromJSON",
        value: function fromJSON(schema, json) {
          if (typeof json.from != "number" || typeof json.to != "number") throw new RangeError("Invalid input for ReplaceStep.fromJSON");
          return new ReplaceStep2(json.from, json.to, prosemirrorModel.Slice.fromJSON(schema, json.slice), !!json.structure);
        }
      }]);
      return ReplaceStep2;
    })(Step);
    Step.jsonID("replace", ReplaceStep);
    var ReplaceAroundStep = (function(_Step6) {
      _inherits(ReplaceAroundStep2, _Step6);
      var _super6 = _createSuper(ReplaceAroundStep2);
      function ReplaceAroundStep2(from, to, gapFrom, gapTo, slice, insert) {
        var _this8;
        var structure = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : false;
        _classCallCheck(this, ReplaceAroundStep2);
        _this8 = _super6.call(this);
        _this8.from = from;
        _this8.to = to;
        _this8.gapFrom = gapFrom;
        _this8.gapTo = gapTo;
        _this8.slice = slice;
        _this8.insert = insert;
        _this8.structure = structure;
        return _this8;
      }
      _createClass(ReplaceAroundStep2, [{
        key: "apply",
        value: function apply(doc) {
          if (this.structure && (contentBetween(doc, this.from, this.gapFrom) || contentBetween(doc, this.gapTo, this.to))) return StepResult.fail("Structure gap-replace would overwrite content");
          var gap = doc.slice(this.gapFrom, this.gapTo);
          if (gap.openStart || gap.openEnd) return StepResult.fail("Gap is not a flat range");
          var inserted = this.slice.insertAt(this.insert, gap.content);
          if (!inserted) return StepResult.fail("Content does not fit in gap");
          return StepResult.fromReplace(doc, this.from, this.to, inserted);
        }
      }, {
        key: "getMap",
        value: function getMap() {
          return new StepMap([this.from, this.gapFrom - this.from, this.insert, this.gapTo, this.to - this.gapTo, this.slice.size - this.insert]);
        }
      }, {
        key: "invert",
        value: function invert(doc) {
          var gap = this.gapTo - this.gapFrom;
          return new ReplaceAroundStep2(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
        }
      }, {
        key: "map",
        value: function map(mapping) {
          var from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
          var gapFrom = this.from == this.gapFrom ? from.pos : mapping.map(this.gapFrom, -1);
          var gapTo = this.to == this.gapTo ? to.pos : mapping.map(this.gapTo, 1);
          if (from.deletedAcross && to.deletedAcross || gapFrom < from.pos || gapTo > to.pos) return null;
          return new ReplaceAroundStep2(from.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          var json = {
            stepType: "replaceAround",
            from: this.from,
            to: this.to,
            gapFrom: this.gapFrom,
            gapTo: this.gapTo,
            insert: this.insert
          };
          if (this.slice.size) json.slice = this.slice.toJSON();
          if (this.structure) json.structure = true;
          return json;
        }
      }], [{
        key: "fromJSON",
        value: function fromJSON(schema, json) {
          if (typeof json.from != "number" || typeof json.to != "number" || typeof json.gapFrom != "number" || typeof json.gapTo != "number" || typeof json.insert != "number") throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
          return new ReplaceAroundStep2(json.from, json.to, json.gapFrom, json.gapTo, prosemirrorModel.Slice.fromJSON(schema, json.slice), json.insert, !!json.structure);
        }
      }]);
      return ReplaceAroundStep2;
    })(Step);
    Step.jsonID("replaceAround", ReplaceAroundStep);
    function contentBetween(doc, from, to) {
      var $from = doc.resolve(from), dist = to - from, depth = $from.depth;
      while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {
        depth--;
        dist--;
      }
      if (dist > 0) {
        var next = $from.node(depth).maybeChild($from.indexAfter(depth));
        while (dist > 0) {
          if (!next || next.isLeaf) return true;
          next = next.firstChild;
          dist--;
        }
      }
      return false;
    }
    function _addMark(tr, from, to, mark) {
      var removed = [], added = [];
      var removing, adding;
      tr.doc.nodesBetween(from, to, function(node, pos, parent) {
        if (!node.isInline) return;
        var marks = node.marks;
        if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {
          var start = Math.max(pos, from), end = Math.min(pos + node.nodeSize, to);
          var newSet = mark.addToSet(marks);
          for (var i = 0; i < marks.length; i++) {
            if (!marks[i].isInSet(newSet)) {
              if (removing && removing.to == start && removing.mark.eq(marks[i])) removing.to = end;
              else removed.push(removing = new RemoveMarkStep(start, end, marks[i]));
            }
          }
          if (adding && adding.to == start) adding.to = end;
          else added.push(adding = new AddMarkStep(start, end, mark));
        }
      });
      removed.forEach(function(s) {
        return tr.step(s);
      });
      added.forEach(function(s) {
        return tr.step(s);
      });
    }
    function _removeMark(tr, from, to, mark) {
      var matched = [], step = 0;
      tr.doc.nodesBetween(from, to, function(node, pos) {
        if (!node.isInline) return;
        step++;
        var toRemove = null;
        if (mark instanceof prosemirrorModel.MarkType) {
          var set = node.marks, found;
          while (found = mark.isInSet(set)) {
            (toRemove || (toRemove = [])).push(found);
            set = found.removeFromSet(set);
          }
        } else if (mark) {
          if (mark.isInSet(node.marks)) toRemove = [mark];
        } else {
          toRemove = node.marks;
        }
        if (toRemove && toRemove.length) {
          var end = Math.min(pos + node.nodeSize, to);
          for (var i = 0; i < toRemove.length; i++) {
            var style = toRemove[i], _found = void 0;
            for (var j = 0; j < matched.length; j++) {
              var m = matched[j];
              if (m.step == step - 1 && style.eq(matched[j].style)) _found = m;
            }
            if (_found) {
              _found.to = end;
              _found.step = step;
            } else {
              matched.push({
                style,
                from: Math.max(pos, from),
                to: end,
                step
              });
            }
          }
        }
      });
      matched.forEach(function(m) {
        return tr.step(new RemoveMarkStep(m.from, m.to, m.style));
      });
    }
    function _clearIncompatible(tr, pos, parentType) {
      var match = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : parentType.contentMatch;
      var clearNewlines = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
      var node = tr.doc.nodeAt(pos);
      var replSteps = [], cur = pos + 1;
      for (var i = 0; i < node.childCount; i++) {
        var child = node.child(i), end = cur + child.nodeSize;
        var allowed = match.matchType(child.type);
        if (!allowed) {
          replSteps.push(new ReplaceStep(cur, end, prosemirrorModel.Slice.empty));
        } else {
          match = allowed;
          for (var j = 0; j < child.marks.length; j++) if (!parentType.allowsMarkType(child.marks[j].type)) tr.step(new RemoveMarkStep(cur, end, child.marks[j]));
          if (clearNewlines && child.isText && parentType.whitespace != "pre") {
            var m = void 0, newline = /\r?\n|\r/g, slice = void 0;
            while (m = newline.exec(child.text)) {
              if (!slice) slice = new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(parentType.schema.text(" ", parentType.allowedMarks(child.marks))), 0, 0);
              replSteps.push(new ReplaceStep(cur + m.index, cur + m.index + m[0].length, slice));
            }
          }
        }
        cur = end;
      }
      if (!match.validEnd) {
        var fill = match.fillBefore(prosemirrorModel.Fragment.empty, true);
        tr.replace(cur, cur, new prosemirrorModel.Slice(fill, 0, 0));
      }
      for (var _i = replSteps.length - 1; _i >= 0; _i--) tr.step(replSteps[_i]);
    }
    function canCut(node, start, end) {
      return (start == 0 || node.canReplace(start, node.childCount)) && (end == node.childCount || node.canReplace(0, end));
    }
    function liftTarget(range2) {
      var parent = range2.parent;
      var content = parent.content.cutByIndex(range2.startIndex, range2.endIndex);
      for (var depth = range2.depth, contentBefore = 0, contentAfter = 0; ; --depth) {
        var node = range2.$from.node(depth);
        var index = range2.$from.index(depth) + contentBefore, endIndex = range2.$to.indexAfter(depth) - contentAfter;
        if (depth < range2.depth && node.canReplace(index, endIndex, content)) return depth;
        if (depth == 0 || node.type.spec.isolating || !canCut(node, index, endIndex)) break;
        if (index) contentBefore = 1;
        if (endIndex < node.childCount) contentAfter = 1;
      }
      return null;
    }
    function _lift(tr, range2, target) {
      var $from = range2.$from, $to = range2.$to, depth = range2.depth;
      var gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);
      var start = gapStart, end = gapEnd;
      var before = prosemirrorModel.Fragment.empty, openStart = 0;
      for (var d = depth, splitting = false; d > target; d--) if (splitting || $from.index(d) > 0) {
        splitting = true;
        before = prosemirrorModel.Fragment.from($from.node(d).copy(before));
        openStart++;
      } else {
        start--;
      }
      var after = prosemirrorModel.Fragment.empty, openEnd = 0;
      for (var _d = depth, _splitting = false; _d > target; _d--) if (_splitting || $to.after(_d + 1) < $to.end(_d)) {
        _splitting = true;
        after = prosemirrorModel.Fragment.from($to.node(_d).copy(after));
        openEnd++;
      } else {
        end++;
      }
      tr.step(new ReplaceAroundStep(start, end, gapStart, gapEnd, new prosemirrorModel.Slice(before.append(after), openStart, openEnd), before.size - openStart, true));
    }
    function findWrapping(range2, nodeType) {
      var attrs = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      var innerRange = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : range2;
      var around = findWrappingOutside(range2, nodeType);
      var inner = around && findWrappingInside(innerRange, nodeType);
      if (!inner) return null;
      return around.map(withAttrs).concat({
        type: nodeType,
        attrs
      }).concat(inner.map(withAttrs));
    }
    function withAttrs(type2) {
      return {
        type: type2,
        attrs: null
      };
    }
    function findWrappingOutside(range2, type2) {
      var parent = range2.parent, startIndex = range2.startIndex, endIndex = range2.endIndex;
      var around = parent.contentMatchAt(startIndex).findWrapping(type2);
      if (!around) return null;
      var outer = around.length ? around[0] : type2;
      return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;
    }
    function findWrappingInside(range2, type2) {
      var parent = range2.parent, startIndex = range2.startIndex, endIndex = range2.endIndex;
      var inner = parent.child(startIndex);
      var inside = type2.contentMatch.findWrapping(inner.type);
      if (!inside) return null;
      var lastType = inside.length ? inside[inside.length - 1] : type2;
      var innerMatch = lastType.contentMatch;
      for (var i = startIndex; innerMatch && i < endIndex; i++) innerMatch = innerMatch.matchType(parent.child(i).type);
      if (!innerMatch || !innerMatch.validEnd) return null;
      return inside;
    }
    function _wrap2(tr, range2, wrappers) {
      var content = prosemirrorModel.Fragment.empty;
      for (var i = wrappers.length - 1; i >= 0; i--) {
        if (content.size) {
          var match = wrappers[i].type.contentMatch.matchFragment(content);
          if (!match || !match.validEnd) throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
        }
        content = prosemirrorModel.Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));
      }
      var start = range2.start, end = range2.end;
      tr.step(new ReplaceAroundStep(start, end, start, end, new prosemirrorModel.Slice(content, 0, 0), wrappers.length, true));
    }
    function _setBlockType(tr, from, to, type2, attrs) {
      if (!type2.isTextblock) throw new RangeError("Type given to setBlockType should be a textblock");
      var mapFrom = tr.steps.length;
      tr.doc.nodesBetween(from, to, function(node, pos) {
        var attrsHere = typeof attrs == "function" ? attrs(node) : attrs;
        if (node.isTextblock && !node.hasMarkup(type2, attrsHere) && canChangeType(tr.doc, tr.mapping.slice(mapFrom).map(pos), type2)) {
          var convertNewlines = null;
          if (type2.schema.linebreakReplacement) {
            var pre = type2.whitespace == "pre", supportLinebreak = !!type2.contentMatch.matchType(type2.schema.linebreakReplacement);
            if (pre && !supportLinebreak) convertNewlines = false;
            else if (!pre && supportLinebreak) convertNewlines = true;
          }
          if (convertNewlines === false) replaceLinebreaks(tr, node, pos, mapFrom);
          _clearIncompatible(tr, tr.mapping.slice(mapFrom).map(pos, 1), type2, void 0, convertNewlines === null);
          var mapping = tr.mapping.slice(mapFrom);
          var startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1);
          tr.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(type2.create(attrsHere, null, node.marks)), 0, 0), 1, true));
          if (convertNewlines === true) replaceNewlines(tr, node, pos, mapFrom);
          return false;
        }
      });
    }
    function replaceNewlines(tr, node, pos, mapFrom) {
      node.forEach(function(child, offset) {
        if (child.isText) {
          var m, newline = /\r?\n|\r/g;
          while (m = newline.exec(child.text)) {
            var start = tr.mapping.slice(mapFrom).map(pos + 1 + offset + m.index);
            tr.replaceWith(start, start + 1, node.type.schema.linebreakReplacement.create());
          }
        }
      });
    }
    function replaceLinebreaks(tr, node, pos, mapFrom) {
      node.forEach(function(child, offset) {
        if (child.type == child.type.schema.linebreakReplacement) {
          var start = tr.mapping.slice(mapFrom).map(pos + 1 + offset);
          tr.replaceWith(start, start + 1, node.type.schema.text("\n"));
        }
      });
    }
    function canChangeType(doc, pos, type2) {
      var $pos = doc.resolve(pos), index = $pos.index();
      return $pos.parent.canReplaceWith(index, index + 1, type2);
    }
    function _setNodeMarkup(tr, pos, type2, attrs, marks) {
      var node = tr.doc.nodeAt(pos);
      if (!node) throw new RangeError("No node at given position");
      if (!type2) type2 = node.type;
      var newNode = type2.create(attrs, null, marks || node.marks);
      if (node.isLeaf) return tr.replaceWith(pos, pos + node.nodeSize, newNode);
      if (!type2.validContent(node.content)) throw new RangeError("Invalid content for node type " + type2.name);
      tr.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1, new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(newNode), 0, 0), 1, true));
    }
    function canSplit(doc, pos) {
      var depth = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      var typesAfter = arguments.length > 3 ? arguments[3] : void 0;
      var $pos = doc.resolve(pos), base = $pos.depth - depth;
      var innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;
      if (base < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount))) return false;
      for (var d = $pos.depth - 1, i = depth - 2; d > base; d--, i--) {
        var node = $pos.node(d), _index = $pos.index(d);
        if (node.type.spec.isolating) return false;
        var rest = node.content.cutByIndex(_index, node.childCount);
        var overrideChild = typesAfter && typesAfter[i + 1];
        if (overrideChild) rest = rest.replaceChild(0, overrideChild.type.create(overrideChild.attrs));
        var after = typesAfter && typesAfter[i] || node;
        if (!node.canReplace(_index + 1, node.childCount) || !after.type.validContent(rest)) return false;
      }
      var index = $pos.indexAfter(base);
      var baseType = typesAfter && typesAfter[0];
      return $pos.node(base).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base + 1).type);
    }
    function _split(tr, pos) {
      var depth = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      var typesAfter = arguments.length > 3 ? arguments[3] : void 0;
      var $pos = tr.doc.resolve(pos), before = prosemirrorModel.Fragment.empty, after = prosemirrorModel.Fragment.empty;
      for (var d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {
        before = prosemirrorModel.Fragment.from($pos.node(d).copy(before));
        var typeAfter = typesAfter && typesAfter[i];
        after = prosemirrorModel.Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));
      }
      tr.step(new ReplaceStep(pos, pos, new prosemirrorModel.Slice(before.append(after), depth, depth), true));
    }
    function canJoin(doc, pos) {
      var $pos = doc.resolve(pos), index = $pos.index();
      return joinable($pos.nodeBefore, $pos.nodeAfter) && $pos.parent.canReplace(index, index + 1);
    }
    function canAppendWithSubstitutedLinebreaks(a, b) {
      if (!b.content.size) a.type.compatibleContent(b.type);
      var match = a.contentMatchAt(a.childCount);
      var linebreakReplacement = a.type.schema.linebreakReplacement;
      for (var i = 0; i < b.childCount; i++) {
        var child = b.child(i);
        var type2 = child.type == linebreakReplacement ? a.type.schema.nodes.text : child.type;
        match = match.matchType(type2);
        if (!match) return false;
        if (!a.type.allowsMarks(child.marks)) return false;
      }
      return match.validEnd;
    }
    function joinable(a, b) {
      return !!(a && b && !a.isLeaf && canAppendWithSubstitutedLinebreaks(a, b));
    }
    function joinPoint(doc, pos) {
      var dir = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -1;
      var $pos = doc.resolve(pos);
      for (var d = $pos.depth; ; d--) {
        var before = void 0, after = void 0, index = $pos.index(d);
        if (d == $pos.depth) {
          before = $pos.nodeBefore;
          after = $pos.nodeAfter;
        } else if (dir > 0) {
          before = $pos.node(d + 1);
          index++;
          after = $pos.node(d).maybeChild(index);
        } else {
          before = $pos.node(d).maybeChild(index - 1);
          after = $pos.node(d + 1);
        }
        if (before && !before.isTextblock && joinable(before, after) && $pos.node(d).canReplace(index, index + 1)) return pos;
        if (d == 0) break;
        pos = dir < 0 ? $pos.before(d) : $pos.after(d);
      }
    }
    function _join(tr, pos, depth) {
      var convertNewlines = null;
      var linebreakReplacement = tr.doc.type.schema.linebreakReplacement;
      var $before = tr.doc.resolve(pos - depth), beforeType = $before.node().type;
      if (linebreakReplacement && beforeType.inlineContent) {
        var pre = beforeType.whitespace == "pre";
        var supportLinebreak = !!beforeType.contentMatch.matchType(linebreakReplacement);
        if (pre && !supportLinebreak) convertNewlines = false;
        else if (!pre && supportLinebreak) convertNewlines = true;
      }
      var mapFrom = tr.steps.length;
      if (convertNewlines === false) {
        var $after = tr.doc.resolve(pos + depth);
        replaceLinebreaks(tr, $after.node(), $after.before(), mapFrom);
      }
      if (beforeType.inlineContent) _clearIncompatible(tr, pos + depth - 1, beforeType, $before.node().contentMatchAt($before.index()), convertNewlines == null);
      var mapping = tr.mapping.slice(mapFrom), start = mapping.map(pos - depth);
      tr.step(new ReplaceStep(start, mapping.map(pos + depth, -1), prosemirrorModel.Slice.empty, true));
      if (convertNewlines === true) {
        var $full = tr.doc.resolve(start);
        replaceNewlines(tr, $full.node(), $full.before(), tr.steps.length);
      }
      return tr;
    }
    function insertPoint(doc, pos, nodeType) {
      var $pos = doc.resolve(pos);
      if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType)) return pos;
      if ($pos.parentOffset == 0) for (var d = $pos.depth - 1; d >= 0; d--) {
        var index = $pos.index(d);
        if ($pos.node(d).canReplaceWith(index, index, nodeType)) return $pos.before(d + 1);
        if (index > 0) return null;
      }
      if ($pos.parentOffset == $pos.parent.content.size) for (var _d2 = $pos.depth - 1; _d2 >= 0; _d2--) {
        var _index2 = $pos.indexAfter(_d2);
        if ($pos.node(_d2).canReplaceWith(_index2, _index2, nodeType)) return $pos.after(_d2 + 1);
        if (_index2 < $pos.node(_d2).childCount) return null;
      }
      return null;
    }
    function dropPoint(doc, pos, slice) {
      var $pos = doc.resolve(pos);
      if (!slice.content.size) return pos;
      var content = slice.content;
      for (var i = 0; i < slice.openStart; i++) content = content.firstChild.content;
      for (var pass = 1; pass <= (slice.openStart == 0 && slice.size ? 2 : 1); pass++) {
        for (var d = $pos.depth; d >= 0; d--) {
          var bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;
          var insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);
          var parent = $pos.node(d), fits = false;
          if (pass == 1) {
            fits = parent.canReplace(insertPos, insertPos, content);
          } else {
            var wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);
            fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);
          }
          if (fits) return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1);
        }
      }
      return null;
    }
    function replaceStep(doc, from) {
      var to = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : from;
      var slice = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : prosemirrorModel.Slice.empty;
      if (from == to && !slice.size) return null;
      var $from = doc.resolve(from), $to = doc.resolve(to);
      if (fitsTrivially($from, $to, slice)) return new ReplaceStep(from, to, slice);
      return new Fitter($from, $to, slice).fit();
    }
    function fitsTrivially($from, $to, slice) {
      return !slice.openStart && !slice.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice.content);
    }
    var Fitter = (function() {
      function Fitter2($from, $to, unplaced) {
        _classCallCheck(this, Fitter2);
        this.$from = $from;
        this.$to = $to;
        this.unplaced = unplaced;
        this.frontier = [];
        this.placed = prosemirrorModel.Fragment.empty;
        for (var i = 0; i <= $from.depth; i++) {
          var node = $from.node(i);
          this.frontier.push({
            type: node.type,
            match: node.contentMatchAt($from.indexAfter(i))
          });
        }
        for (var _i2 = $from.depth; _i2 > 0; _i2--) this.placed = prosemirrorModel.Fragment.from($from.node(_i2).copy(this.placed));
      }
      _createClass(Fitter2, [{
        key: "depth",
        get: function get2() {
          return this.frontier.length - 1;
        }
      }, {
        key: "fit",
        value: function fit() {
          while (this.unplaced.size) {
            var fit2 = this.findFittable();
            if (fit2) this.placeNodes(fit2);
            else this.openMore() || this.dropNode();
          }
          var moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;
          var $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));
          if (!$to) return null;
          var content = this.placed, openStart = $from.depth, openEnd = $to.depth;
          while (openStart && openEnd && content.childCount == 1) {
            content = content.firstChild.content;
            openStart--;
            openEnd--;
          }
          var slice = new prosemirrorModel.Slice(content, openStart, openEnd);
          if (moveInline > -1) return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice, placedSize);
          if (slice.size || $from.pos != this.$to.pos) return new ReplaceStep($from.pos, $to.pos, slice);
          return null;
        }
      }, {
        key: "findFittable",
        value: function findFittable() {
          var startDepth = this.unplaced.openStart;
          for (var cur = this.unplaced.content, d = 0, openEnd = this.unplaced.openEnd; d < startDepth; d++) {
            var node = cur.firstChild;
            if (cur.childCount > 1) openEnd = 0;
            if (node.type.spec.isolating && openEnd <= d) {
              startDepth = d;
              break;
            }
            cur = node.content;
          }
          for (var pass = 1; pass <= 2; pass++) {
            for (var sliceDepth = pass == 1 ? startDepth : this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {
              var fragment = void 0, parent = null;
              if (sliceDepth) {
                parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;
                fragment = parent.content;
              } else {
                fragment = this.unplaced.content;
              }
              var first = fragment.firstChild;
              for (var frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {
                var _this$frontier$fronti = this.frontier[frontierDepth], type2 = _this$frontier$fronti.type, match = _this$frontier$fronti.match, _wrap = void 0, inject = null;
                if (pass == 1 && (first ? match.matchType(first.type) || (inject = match.fillBefore(prosemirrorModel.Fragment.from(first), false)) : parent && type2.compatibleContent(parent.type))) return {
                  sliceDepth,
                  frontierDepth,
                  parent,
                  inject
                };
                else if (pass == 2 && first && (_wrap = match.findWrapping(first.type))) return {
                  sliceDepth,
                  frontierDepth,
                  parent,
                  wrap: _wrap
                };
                if (parent && match.matchType(parent.type)) break;
              }
            }
          }
        }
      }, {
        key: "openMore",
        value: function openMore() {
          var _this$unplaced = this.unplaced, content = _this$unplaced.content, openStart = _this$unplaced.openStart, openEnd = _this$unplaced.openEnd;
          var inner = contentAt(content, openStart);
          if (!inner.childCount || inner.firstChild.isLeaf) return false;
          this.unplaced = new prosemirrorModel.Slice(content, openStart + 1, Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));
          return true;
        }
      }, {
        key: "dropNode",
        value: function dropNode() {
          var _this$unplaced2 = this.unplaced, content = _this$unplaced2.content, openStart = _this$unplaced2.openStart, openEnd = _this$unplaced2.openEnd;
          var inner = contentAt(content, openStart);
          if (inner.childCount <= 1 && openStart > 0) {
            var openAtEnd = content.size - openStart <= openStart + inner.size;
            this.unplaced = new prosemirrorModel.Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);
          } else {
            this.unplaced = new prosemirrorModel.Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);
          }
        }
      }, {
        key: "placeNodes",
        value: function placeNodes(_ref) {
          var sliceDepth = _ref.sliceDepth, frontierDepth = _ref.frontierDepth, parent = _ref.parent, inject = _ref.inject, wrap = _ref.wrap;
          while (this.depth > frontierDepth) this.closeFrontierNode();
          if (wrap) for (var i = 0; i < wrap.length; i++) this.openFrontierNode(wrap[i]);
          var slice = this.unplaced, fragment = parent ? parent.content : slice.content;
          var openStart = slice.openStart - sliceDepth;
          var taken = 0, add = [];
          var _this$frontier$fronti2 = this.frontier[frontierDepth], match = _this$frontier$fronti2.match, type2 = _this$frontier$fronti2.type;
          if (inject) {
            for (var _i3 = 0; _i3 < inject.childCount; _i3++) add.push(inject.child(_i3));
            match = match.matchFragment(inject);
          }
          var openEndCount = fragment.size + sliceDepth - (slice.content.size - slice.openEnd);
          while (taken < fragment.childCount) {
            var next = fragment.child(taken), matches = match.matchType(next.type);
            if (!matches) break;
            taken++;
            if (taken > 1 || openStart == 0 || next.content.size) {
              match = matches;
              add.push(closeNodeStart(next.mark(type2.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));
            }
          }
          var toEnd = taken == fragment.childCount;
          if (!toEnd) openEndCount = -1;
          this.placed = addToFragment(this.placed, frontierDepth, prosemirrorModel.Fragment.from(add));
          this.frontier[frontierDepth].match = match;
          if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1) this.closeFrontierNode();
          for (var _i4 = 0, cur = fragment; _i4 < openEndCount; _i4++) {
            var node = cur.lastChild;
            this.frontier.push({
              type: node.type,
              match: node.contentMatchAt(node.childCount)
            });
            cur = node.content;
          }
          this.unplaced = !toEnd ? new prosemirrorModel.Slice(dropFromFragment(slice.content, sliceDepth, taken), slice.openStart, slice.openEnd) : sliceDepth == 0 ? prosemirrorModel.Slice.empty : new prosemirrorModel.Slice(dropFromFragment(slice.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice.openEnd : sliceDepth - 1);
        }
      }, {
        key: "mustMoveInline",
        value: function mustMoveInline() {
          if (!this.$to.parent.isTextblock) return -1;
          var top = this.frontier[this.depth], level;
          if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth) return -1;
          var depth = this.$to.depth, after = this.$to.after(depth);
          while (depth > 1 && after == this.$to.end(--depth)) ++after;
          return after;
        }
      }, {
        key: "findCloseLevel",
        value: function findCloseLevel($to) {
          scan: for (var i = Math.min(this.depth, $to.depth); i >= 0; i--) {
            var _this$frontier$i = this.frontier[i], match = _this$frontier$i.match, type2 = _this$frontier$i.type;
            var dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));
            var fit = contentAfterFits($to, i, type2, match, dropInner);
            if (!fit) continue;
            for (var d = i - 1; d >= 0; d--) {
              var _this$frontier$d = this.frontier[d], _match = _this$frontier$d.match, _type = _this$frontier$d.type;
              var matches = contentAfterFits($to, d, _type, _match, true);
              if (!matches || matches.childCount) continue scan;
            }
            return {
              depth: i,
              fit,
              move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to
            };
          }
        }
      }, {
        key: "close",
        value: function close($to) {
          var close2 = this.findCloseLevel($to);
          if (!close2) return null;
          while (this.depth > close2.depth) this.closeFrontierNode();
          if (close2.fit.childCount) this.placed = addToFragment(this.placed, close2.depth, close2.fit);
          $to = close2.move;
          for (var d = close2.depth + 1; d <= $to.depth; d++) {
            var node = $to.node(d), add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d));
            this.openFrontierNode(node.type, node.attrs, add);
          }
          return $to;
        }
      }, {
        key: "openFrontierNode",
        value: function openFrontierNode(type2) {
          var attrs = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
          var content = arguments.length > 2 ? arguments[2] : void 0;
          var top = this.frontier[this.depth];
          top.match = top.match.matchType(type2);
          this.placed = addToFragment(this.placed, this.depth, prosemirrorModel.Fragment.from(type2.create(attrs, content)));
          this.frontier.push({
            type: type2,
            match: type2.contentMatch
          });
        }
      }, {
        key: "closeFrontierNode",
        value: function closeFrontierNode() {
          var open = this.frontier.pop();
          var add = open.match.fillBefore(prosemirrorModel.Fragment.empty, true);
          if (add.childCount) this.placed = addToFragment(this.placed, this.frontier.length, add);
        }
      }]);
      return Fitter2;
    })();
    function dropFromFragment(fragment, depth, count) {
      if (depth == 0) return fragment.cutByIndex(count, fragment.childCount);
      return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)));
    }
    function addToFragment(fragment, depth, content) {
      if (depth == 0) return fragment.append(content);
      return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)));
    }
    function contentAt(fragment, depth) {
      for (var i = 0; i < depth; i++) fragment = fragment.firstChild.content;
      return fragment;
    }
    function closeNodeStart(node, openStart, openEnd) {
      if (openStart <= 0) return node;
      var frag = node.content;
      if (openStart > 1) frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));
      if (openStart > 0) {
        frag = node.type.contentMatch.fillBefore(frag).append(frag);
        if (openEnd <= 0) frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(prosemirrorModel.Fragment.empty, true));
      }
      return node.copy(frag);
    }
    function contentAfterFits($to, depth, type2, match, open) {
      var node = $to.node(depth), index = open ? $to.indexAfter(depth) : $to.index(depth);
      if (index == node.childCount && !type2.compatibleContent(node.type)) return null;
      var fit = match.fillBefore(node.content, true, index);
      return fit && !invalidMarks(type2, node.content, index) ? fit : null;
    }
    function invalidMarks(type2, fragment, start) {
      for (var i = start; i < fragment.childCount; i++) if (!type2.allowsMarks(fragment.child(i).marks)) return true;
      return false;
    }
    function definesContent(type2) {
      return type2.spec.defining || type2.spec.definingForContent;
    }
    function _replaceRange(tr, from, to, slice) {
      if (!slice.size) return tr.deleteRange(from, to);
      var $from = tr.doc.resolve(from), $to = tr.doc.resolve(to);
      if (fitsTrivially($from, $to, slice)) return tr.step(new ReplaceStep(from, to, slice));
      var targetDepths = coveredDepths($from, $to);
      if (targetDepths[targetDepths.length - 1] == 0) targetDepths.pop();
      var preferredTarget = -($from.depth + 1);
      targetDepths.unshift(preferredTarget);
      for (var d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {
        var spec = $from.node(d).type.spec;
        if (spec.defining || spec.definingAsContext || spec.isolating) break;
        if (targetDepths.indexOf(d) > -1) preferredTarget = d;
        else if ($from.before(d) == pos) targetDepths.splice(1, 0, -d);
      }
      var preferredTargetIndex = targetDepths.indexOf(preferredTarget);
      var leftNodes = [], preferredDepth = slice.openStart;
      for (var content = slice.content, i = 0; ; i++) {
        var node = content.firstChild;
        leftNodes.push(node);
        if (i == slice.openStart) break;
        content = node.content;
      }
      for (var _d3 = preferredDepth - 1; _d3 >= 0; _d3--) {
        var leftNode = leftNodes[_d3], def = definesContent(leftNode.type);
        if (def && !leftNode.sameMarkup($from.node(Math.abs(preferredTarget) - 1))) preferredDepth = _d3;
        else if (def || !leftNode.type.isTextblock) break;
      }
      for (var j = slice.openStart; j >= 0; j--) {
        var openDepth = (j + preferredDepth + 1) % (slice.openStart + 1);
        var insert = leftNodes[openDepth];
        if (!insert) continue;
        for (var _i5 = 0; _i5 < targetDepths.length; _i5++) {
          var targetDepth = targetDepths[(_i5 + preferredTargetIndex) % targetDepths.length], expand = true;
          if (targetDepth < 0) {
            expand = false;
            targetDepth = -targetDepth;
          }
          var parent = $from.node(targetDepth - 1), index = $from.index(targetDepth - 1);
          if (parent.canReplaceWith(index, index, insert.type, insert.marks)) return tr.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to, new prosemirrorModel.Slice(closeFragment(slice.content, 0, slice.openStart, openDepth), openDepth, slice.openEnd));
        }
      }
      var startSteps = tr.steps.length;
      for (var _i6 = targetDepths.length - 1; _i6 >= 0; _i6--) {
        tr.replace(from, to, slice);
        if (tr.steps.length > startSteps) break;
        var depth = targetDepths[_i6];
        if (depth < 0) continue;
        from = $from.before(depth);
        to = $to.after(depth);
      }
    }
    function closeFragment(fragment, depth, oldOpen, newOpen, parent) {
      if (depth < oldOpen) {
        var first = fragment.firstChild;
        fragment = fragment.replaceChild(0, first.copy(closeFragment(first.content, depth + 1, oldOpen, newOpen, first)));
      }
      if (depth > newOpen) {
        var match = parent.contentMatchAt(0);
        var start = match.fillBefore(fragment).append(fragment);
        fragment = start.append(match.matchFragment(start).fillBefore(prosemirrorModel.Fragment.empty, true));
      }
      return fragment;
    }
    function _replaceRangeWith(tr, from, to, node) {
      if (!node.isInline && from == to && tr.doc.resolve(from).parent.content.size) {
        var point = insertPoint(tr.doc, from, node.type);
        if (point != null) from = to = point;
      }
      tr.replaceRange(from, to, new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(node), 0, 0));
    }
    function _deleteRange(tr, from, to) {
      var $from = tr.doc.resolve(from), $to = tr.doc.resolve(to);
      var covered = coveredDepths($from, $to);
      for (var i = 0; i < covered.length; i++) {
        var depth = covered[i], last = i == covered.length - 1;
        if (last && depth == 0 || $from.node(depth).type.contentMatch.validEnd) return tr["delete"]($from.start(depth), $to.end(depth));
        if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1)))) return tr["delete"]($from.before(depth), $to.after(depth));
      }
      for (var d = 1; d <= $from.depth && d <= $to.depth; d++) {
        if (from - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d && $from.start(d - 1) == $to.start(d - 1) && $from.node(d - 1).canReplace($from.index(d - 1), $to.index(d - 1))) return tr["delete"]($from.before(d), to);
      }
      tr["delete"](from, to);
    }
    function coveredDepths($from, $to) {
      var result = [], minDepth = Math.min($from.depth, $to.depth);
      for (var d = minDepth; d >= 0; d--) {
        var start = $from.start(d);
        if (start < $from.pos - ($from.depth - d) || $to.end(d) > $to.pos + ($to.depth - d) || $from.node(d).type.spec.isolating || $to.node(d).type.spec.isolating) break;
        if (start == $to.start(d) || d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent && d && $to.start(d - 1) == start - 1) result.push(d);
      }
      return result;
    }
    var AttrStep = (function(_Step7) {
      _inherits(AttrStep2, _Step7);
      var _super7 = _createSuper(AttrStep2);
      function AttrStep2(pos, attr, value) {
        var _this9;
        _classCallCheck(this, AttrStep2);
        _this9 = _super7.call(this);
        _this9.pos = pos;
        _this9.attr = attr;
        _this9.value = value;
        return _this9;
      }
      _createClass(AttrStep2, [{
        key: "apply",
        value: function apply(doc) {
          var node = doc.nodeAt(this.pos);
          if (!node) return StepResult.fail("No node at attribute step's position");
          var attrs = /* @__PURE__ */ Object.create(null);
          for (var name in node.attrs) attrs[name] = node.attrs[name];
          attrs[this.attr] = this.value;
          var updated = node.type.create(attrs, null, node.marks);
          return StepResult.fromReplace(doc, this.pos, this.pos + 1, new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
        }
      }, {
        key: "getMap",
        value: function getMap() {
          return StepMap.empty;
        }
      }, {
        key: "invert",
        value: function invert(doc) {
          return new AttrStep2(this.pos, this.attr, doc.nodeAt(this.pos).attrs[this.attr]);
        }
      }, {
        key: "map",
        value: function map(mapping) {
          var pos = mapping.mapResult(this.pos, 1);
          return pos.deletedAfter ? null : new AttrStep2(pos.pos, this.attr, this.value);
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          return {
            stepType: "attr",
            pos: this.pos,
            attr: this.attr,
            value: this.value
          };
        }
      }], [{
        key: "fromJSON",
        value: function fromJSON(schema, json) {
          if (typeof json.pos != "number" || typeof json.attr != "string") throw new RangeError("Invalid input for AttrStep.fromJSON");
          return new AttrStep2(json.pos, json.attr, json.value);
        }
      }]);
      return AttrStep2;
    })(Step);
    Step.jsonID("attr", AttrStep);
    var DocAttrStep = (function(_Step8) {
      _inherits(DocAttrStep2, _Step8);
      var _super8 = _createSuper(DocAttrStep2);
      function DocAttrStep2(attr, value) {
        var _this10;
        _classCallCheck(this, DocAttrStep2);
        _this10 = _super8.call(this);
        _this10.attr = attr;
        _this10.value = value;
        return _this10;
      }
      _createClass(DocAttrStep2, [{
        key: "apply",
        value: function apply(doc) {
          var attrs = /* @__PURE__ */ Object.create(null);
          for (var name in doc.attrs) attrs[name] = doc.attrs[name];
          attrs[this.attr] = this.value;
          var updated = doc.type.create(attrs, doc.content, doc.marks);
          return StepResult.ok(updated);
        }
      }, {
        key: "getMap",
        value: function getMap() {
          return StepMap.empty;
        }
      }, {
        key: "invert",
        value: function invert(doc) {
          return new DocAttrStep2(this.attr, doc.attrs[this.attr]);
        }
      }, {
        key: "map",
        value: function map(mapping) {
          return this;
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          return {
            stepType: "docAttr",
            attr: this.attr,
            value: this.value
          };
        }
      }], [{
        key: "fromJSON",
        value: function fromJSON(schema, json) {
          if (typeof json.attr != "string") throw new RangeError("Invalid input for DocAttrStep.fromJSON");
          return new DocAttrStep2(json.attr, json.value);
        }
      }]);
      return DocAttrStep2;
    })(Step);
    Step.jsonID("docAttr", DocAttrStep);
    exports2.TransformError = (function(_Error) {
      _inherits(TransformError, _Error);
      var _super9 = _createSuper(TransformError);
      function TransformError() {
        _classCallCheck(this, TransformError);
        return _super9.apply(this, arguments);
      }
      return _createClass(TransformError);
    })(_wrapNativeSuper(Error));
    exports2.TransformError = function TransformError(message) {
      var err = Error.call(this, message);
      err.__proto__ = TransformError.prototype;
      return err;
    };
    exports2.TransformError.prototype = Object.create(Error.prototype);
    exports2.TransformError.prototype.constructor = exports2.TransformError;
    exports2.TransformError.prototype.name = "TransformError";
    var Transform = (function() {
      function Transform2(doc) {
        _classCallCheck(this, Transform2);
        this.doc = doc;
        this.steps = [];
        this.docs = [];
        this.mapping = new Mapping();
      }
      _createClass(Transform2, [{
        key: "before",
        get: function get2() {
          return this.docs.length ? this.docs[0] : this.doc;
        }
      }, {
        key: "step",
        value: function step(_step) {
          var result = this.maybeStep(_step);
          if (result.failed) throw new exports2.TransformError(result.failed);
          return this;
        }
      }, {
        key: "maybeStep",
        value: function maybeStep(step) {
          var result = step.apply(this.doc);
          if (!result.failed) this.addStep(step, result.doc);
          return result;
        }
      }, {
        key: "docChanged",
        get: function get2() {
          return this.steps.length > 0;
        }
      }, {
        key: "addStep",
        value: function addStep(step, doc) {
          this.docs.push(this.doc);
          this.steps.push(step);
          this.mapping.appendMap(step.getMap());
          this.doc = doc;
        }
      }, {
        key: "replace",
        value: function replace(from) {
          var to = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : from;
          var slice = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : prosemirrorModel.Slice.empty;
          var step = replaceStep(this.doc, from, to, slice);
          if (step) this.step(step);
          return this;
        }
      }, {
        key: "replaceWith",
        value: function replaceWith(from, to, content) {
          return this.replace(from, to, new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(content), 0, 0));
        }
      }, {
        key: "delete",
        value: function _delete(from, to) {
          return this.replace(from, to, prosemirrorModel.Slice.empty);
        }
      }, {
        key: "insert",
        value: function insert(pos, content) {
          return this.replaceWith(pos, pos, content);
        }
      }, {
        key: "replaceRange",
        value: function replaceRange(from, to, slice) {
          _replaceRange(this, from, to, slice);
          return this;
        }
      }, {
        key: "replaceRangeWith",
        value: function replaceRangeWith(from, to, node) {
          _replaceRangeWith(this, from, to, node);
          return this;
        }
      }, {
        key: "deleteRange",
        value: function deleteRange(from, to) {
          _deleteRange(this, from, to);
          return this;
        }
      }, {
        key: "lift",
        value: function lift(range2, target) {
          _lift(this, range2, target);
          return this;
        }
      }, {
        key: "join",
        value: function join(pos) {
          var depth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
          _join(this, pos, depth);
          return this;
        }
      }, {
        key: "wrap",
        value: function wrap(range2, wrappers) {
          _wrap2(this, range2, wrappers);
          return this;
        }
      }, {
        key: "setBlockType",
        value: function setBlockType(from) {
          var to = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : from;
          var type2 = arguments.length > 2 ? arguments[2] : void 0;
          var attrs = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
          _setBlockType(this, from, to, type2, attrs);
          return this;
        }
      }, {
        key: "setNodeMarkup",
        value: function setNodeMarkup(pos, type2) {
          var attrs = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
          var marks = arguments.length > 3 ? arguments[3] : void 0;
          _setNodeMarkup(this, pos, type2, attrs, marks);
          return this;
        }
      }, {
        key: "setNodeAttribute",
        value: function setNodeAttribute(pos, attr, value) {
          this.step(new AttrStep(pos, attr, value));
          return this;
        }
      }, {
        key: "setDocAttribute",
        value: function setDocAttribute(attr, value) {
          this.step(new DocAttrStep(attr, value));
          return this;
        }
      }, {
        key: "addNodeMark",
        value: function addNodeMark(pos, mark) {
          this.step(new AddNodeMarkStep(pos, mark));
          return this;
        }
      }, {
        key: "removeNodeMark",
        value: function removeNodeMark(pos, mark) {
          var node = this.doc.nodeAt(pos);
          if (!node) throw new RangeError("No node at position " + pos);
          if (mark instanceof prosemirrorModel.Mark) {
            if (mark.isInSet(node.marks)) this.step(new RemoveNodeMarkStep(pos, mark));
          } else {
            var set = node.marks, found, steps = [];
            while (found = mark.isInSet(set)) {
              steps.push(new RemoveNodeMarkStep(pos, found));
              set = found.removeFromSet(set);
            }
            for (var i = steps.length - 1; i >= 0; i--) this.step(steps[i]);
          }
          return this;
        }
      }, {
        key: "split",
        value: function split(pos) {
          var depth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
          var typesAfter = arguments.length > 2 ? arguments[2] : void 0;
          _split(this, pos, depth, typesAfter);
          return this;
        }
      }, {
        key: "addMark",
        value: function addMark(from, to, mark) {
          _addMark(this, from, to, mark);
          return this;
        }
      }, {
        key: "removeMark",
        value: function removeMark(from, to, mark) {
          _removeMark(this, from, to, mark);
          return this;
        }
      }, {
        key: "clearIncompatible",
        value: function clearIncompatible(pos, parentType, match) {
          _clearIncompatible(this, pos, parentType, match);
          return this;
        }
      }]);
      return Transform2;
    })();
    exports2.AddMarkStep = AddMarkStep;
    exports2.AddNodeMarkStep = AddNodeMarkStep;
    exports2.AttrStep = AttrStep;
    exports2.DocAttrStep = DocAttrStep;
    exports2.MapResult = MapResult;
    exports2.Mapping = Mapping;
    exports2.RemoveMarkStep = RemoveMarkStep;
    exports2.RemoveNodeMarkStep = RemoveNodeMarkStep;
    exports2.ReplaceAroundStep = ReplaceAroundStep;
    exports2.ReplaceStep = ReplaceStep;
    exports2.Step = Step;
    exports2.StepMap = StepMap;
    exports2.StepResult = StepResult;
    exports2.Transform = Transform;
    exports2.canJoin = canJoin;
    exports2.canSplit = canSplit;
    exports2.dropPoint = dropPoint;
    exports2.findWrapping = findWrapping;
    exports2.insertPoint = insertPoint;
    exports2.joinPoint = joinPoint;
    exports2.liftTarget = liftTarget;
    exports2.replaceStep = replaceStep;
  }
});

// node_modules/.pnpm/@tiptap+pm@3.11.0/node_modules/@tiptap/pm/dist/transform/index.cjs
var require_transform = __commonJS({
  "node_modules/.pnpm/@tiptap+pm@3.11.0/node_modules/@tiptap/pm/dist/transform/index.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function _createStarExport(obj) {
      Object.keys(obj).filter((key) => key !== "default" && key !== "__esModule").forEach((key) => {
        if (exports2.hasOwnProperty(key)) {
          return;
        }
        Object.defineProperty(exports2, key, { enumerable: true, configurable: true, get: () => obj[key] });
      });
    }
    var _prosemirrortransform = require_dist3();
    _createStarExport(_prosemirrortransform);
  }
});

// node_modules/.pnpm/prosemirror-state@1.4.4/node_modules/prosemirror-state/dist/index.cjs
var require_dist4 = __commonJS({
  "node_modules/.pnpm/prosemirror-state@1.4.4/node_modules/prosemirror-state/dist/index.cjs"(exports2) {
    "use strict";
    function _get() {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get.bind();
      } else {
        _get = function _get2(target, property, receiver) {
          var base = _superPropBase(target, property);
          if (!base) return;
          var desc = Object.getOwnPropertyDescriptor(base, property);
          if (desc.get) {
            return desc.get.call(arguments.length < 3 ? target : receiver);
          }
          return desc.value;
        };
      }
      return _get.apply(this, arguments);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null) break;
      }
      return object;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      Object.defineProperty(subClass, "prototype", { writable: false });
      if (superClass) _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return _typeof(key) === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (_typeof(input) !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (_typeof(res) !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var prosemirrorModel = require_dist2();
    var prosemirrorTransform = require_dist3();
    var classesById = /* @__PURE__ */ Object.create(null);
    var Selection = (function() {
      function Selection2($anchor, $head, ranges) {
        _classCallCheck(this, Selection2);
        this.$anchor = $anchor;
        this.$head = $head;
        this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];
      }
      _createClass(Selection2, [{
        key: "anchor",
        get: function get2() {
          return this.$anchor.pos;
        }
      }, {
        key: "head",
        get: function get2() {
          return this.$head.pos;
        }
      }, {
        key: "from",
        get: function get2() {
          return this.$from.pos;
        }
      }, {
        key: "to",
        get: function get2() {
          return this.$to.pos;
        }
      }, {
        key: "$from",
        get: function get2() {
          return this.ranges[0].$from;
        }
      }, {
        key: "$to",
        get: function get2() {
          return this.ranges[0].$to;
        }
      }, {
        key: "empty",
        get: function get2() {
          var ranges = this.ranges;
          for (var i = 0; i < ranges.length; i++) if (ranges[i].$from.pos != ranges[i].$to.pos) return false;
          return true;
        }
      }, {
        key: "content",
        value: function content() {
          return this.$from.doc.slice(this.from, this.to, true);
        }
      }, {
        key: "replace",
        value: function replace(tr) {
          var content = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : prosemirrorModel.Slice.empty;
          var lastNode = content.content.lastChild, lastParent = null;
          for (var i = 0; i < content.openEnd; i++) {
            lastParent = lastNode;
            lastNode = lastNode.lastChild;
          }
          var mapFrom = tr.steps.length, ranges = this.ranges;
          for (var _i = 0; _i < ranges.length; _i++) {
            var _ranges$_i = ranges[_i], $from = _ranges$_i.$from, $to = _ranges$_i.$to, mapping = tr.mapping.slice(mapFrom);
            tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), _i ? prosemirrorModel.Slice.empty : content);
            if (_i == 0) selectionToInsertionEnd(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);
          }
        }
      }, {
        key: "replaceWith",
        value: function replaceWith(tr, node) {
          var mapFrom = tr.steps.length, ranges = this.ranges;
          for (var i = 0; i < ranges.length; i++) {
            var _ranges$i = ranges[i], $from = _ranges$i.$from, $to = _ranges$i.$to, mapping = tr.mapping.slice(mapFrom);
            var from = mapping.map($from.pos), to = mapping.map($to.pos);
            if (i) {
              tr.deleteRange(from, to);
            } else {
              tr.replaceRangeWith(from, to, node);
              selectionToInsertionEnd(tr, mapFrom, node.isInline ? -1 : 1);
            }
          }
        }
      }, {
        key: "getBookmark",
        value: function getBookmark() {
          return TextSelection.between(this.$anchor, this.$head).getBookmark();
        }
      }], [{
        key: "findFrom",
        value: function findFrom($pos, dir) {
          var textOnly = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
          var inner = $pos.parent.inlineContent ? new TextSelection($pos) : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);
          if (inner) return inner;
          for (var depth = $pos.depth - 1; depth >= 0; depth--) {
            var found = dir < 0 ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);
            if (found) return found;
          }
          return null;
        }
      }, {
        key: "near",
        value: function near($pos) {
          var bias = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
          return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));
        }
      }, {
        key: "atStart",
        value: function atStart(doc) {
          return findSelectionIn(doc, doc, 0, 0, 1) || new AllSelection(doc);
        }
      }, {
        key: "atEnd",
        value: function atEnd(doc) {
          return findSelectionIn(doc, doc, doc.content.size, doc.childCount, -1) || new AllSelection(doc);
        }
      }, {
        key: "fromJSON",
        value: function fromJSON(doc, json) {
          if (!json || !json.type) throw new RangeError("Invalid input for Selection.fromJSON");
          var cls = classesById[json.type];
          if (!cls) throw new RangeError("No selection type ".concat(json.type, " defined"));
          return cls.fromJSON(doc, json);
        }
      }, {
        key: "jsonID",
        value: function jsonID(id, selectionClass) {
          if (id in classesById) throw new RangeError("Duplicate use of selection JSON ID " + id);
          classesById[id] = selectionClass;
          selectionClass.prototype.jsonID = id;
          return selectionClass;
        }
      }]);
      return Selection2;
    })();
    Selection.prototype.visible = true;
    var SelectionRange = _createClass(function SelectionRange2($from, $to) {
      _classCallCheck(this, SelectionRange2);
      this.$from = $from;
      this.$to = $to;
    });
    var warnedAboutTextSelection = false;
    function checkTextSelection($pos) {
      if (!warnedAboutTextSelection && !$pos.parent.inlineContent) {
        warnedAboutTextSelection = true;
        console["warn"]("TextSelection endpoint not pointing into a node with inline content (" + $pos.parent.type.name + ")");
      }
    }
    var TextSelection = (function(_Selection) {
      _inherits(TextSelection2, _Selection);
      var _super = _createSuper(TextSelection2);
      function TextSelection2($anchor) {
        var $head = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : $anchor;
        _classCallCheck(this, TextSelection2);
        checkTextSelection($anchor);
        checkTextSelection($head);
        return _super.call(this, $anchor, $head);
      }
      _createClass(TextSelection2, [{
        key: "$cursor",
        get: function get2() {
          return this.$anchor.pos == this.$head.pos ? this.$head : null;
        }
      }, {
        key: "map",
        value: function map(doc, mapping) {
          var $head = doc.resolve(mapping.map(this.head));
          if (!$head.parent.inlineContent) return Selection.near($head);
          var $anchor = doc.resolve(mapping.map(this.anchor));
          return new TextSelection2($anchor.parent.inlineContent ? $anchor : $head, $head);
        }
      }, {
        key: "replace",
        value: function replace(tr) {
          var content = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : prosemirrorModel.Slice.empty;
          _get(_getPrototypeOf(TextSelection2.prototype), "replace", this).call(this, tr, content);
          if (content == prosemirrorModel.Slice.empty) {
            var marks = this.$from.marksAcross(this.$to);
            if (marks) tr.ensureMarks(marks);
          }
        }
      }, {
        key: "eq",
        value: function eq(other) {
          return other instanceof TextSelection2 && other.anchor == this.anchor && other.head == this.head;
        }
      }, {
        key: "getBookmark",
        value: function getBookmark() {
          return new TextBookmark(this.anchor, this.head);
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          return {
            type: "text",
            anchor: this.anchor,
            head: this.head
          };
        }
      }], [{
        key: "fromJSON",
        value: function fromJSON(doc, json) {
          if (typeof json.anchor != "number" || typeof json.head != "number") throw new RangeError("Invalid input for TextSelection.fromJSON");
          return new TextSelection2(doc.resolve(json.anchor), doc.resolve(json.head));
        }
      }, {
        key: "create",
        value: function create(doc, anchor) {
          var head = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : anchor;
          var $anchor = doc.resolve(anchor);
          return new this($anchor, head == anchor ? $anchor : doc.resolve(head));
        }
      }, {
        key: "between",
        value: function between($anchor, $head, bias) {
          var dPos = $anchor.pos - $head.pos;
          if (!bias || dPos) bias = dPos >= 0 ? 1 : -1;
          if (!$head.parent.inlineContent) {
            var found = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);
            if (found) $head = found.$head;
            else return Selection.near($head, bias);
          }
          if (!$anchor.parent.inlineContent) {
            if (dPos == 0) {
              $anchor = $head;
            } else {
              $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;
              if ($anchor.pos < $head.pos != dPos < 0) $anchor = $head;
            }
          }
          return new TextSelection2($anchor, $head);
        }
      }]);
      return TextSelection2;
    })(Selection);
    Selection.jsonID("text", TextSelection);
    var TextBookmark = (function() {
      function TextBookmark2(anchor, head) {
        _classCallCheck(this, TextBookmark2);
        this.anchor = anchor;
        this.head = head;
      }
      _createClass(TextBookmark2, [{
        key: "map",
        value: function map(mapping) {
          return new TextBookmark2(mapping.map(this.anchor), mapping.map(this.head));
        }
      }, {
        key: "resolve",
        value: function resolve(doc) {
          return TextSelection.between(doc.resolve(this.anchor), doc.resolve(this.head));
        }
      }]);
      return TextBookmark2;
    })();
    var NodeSelection = (function(_Selection2) {
      _inherits(NodeSelection2, _Selection2);
      var _super2 = _createSuper(NodeSelection2);
      function NodeSelection2($pos) {
        var _this;
        _classCallCheck(this, NodeSelection2);
        var node = $pos.nodeAfter;
        var $end = $pos.node(0).resolve($pos.pos + node.nodeSize);
        _this = _super2.call(this, $pos, $end);
        _this.node = node;
        return _this;
      }
      _createClass(NodeSelection2, [{
        key: "map",
        value: function map(doc, mapping) {
          var _mapping$mapResult = mapping.mapResult(this.anchor), deleted = _mapping$mapResult.deleted, pos = _mapping$mapResult.pos;
          var $pos = doc.resolve(pos);
          if (deleted) return Selection.near($pos);
          return new NodeSelection2($pos);
        }
      }, {
        key: "content",
        value: function content() {
          return new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(this.node), 0, 0);
        }
      }, {
        key: "eq",
        value: function eq(other) {
          return other instanceof NodeSelection2 && other.anchor == this.anchor;
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          return {
            type: "node",
            anchor: this.anchor
          };
        }
      }, {
        key: "getBookmark",
        value: function getBookmark() {
          return new NodeBookmark(this.anchor);
        }
      }], [{
        key: "fromJSON",
        value: function fromJSON(doc, json) {
          if (typeof json.anchor != "number") throw new RangeError("Invalid input for NodeSelection.fromJSON");
          return new NodeSelection2(doc.resolve(json.anchor));
        }
      }, {
        key: "create",
        value: function create(doc, from) {
          return new NodeSelection2(doc.resolve(from));
        }
      }, {
        key: "isSelectable",
        value: function isSelectable(node) {
          return !node.isText && node.type.spec.selectable !== false;
        }
      }]);
      return NodeSelection2;
    })(Selection);
    NodeSelection.prototype.visible = false;
    Selection.jsonID("node", NodeSelection);
    var NodeBookmark = (function() {
      function NodeBookmark2(anchor) {
        _classCallCheck(this, NodeBookmark2);
        this.anchor = anchor;
      }
      _createClass(NodeBookmark2, [{
        key: "map",
        value: function map(mapping) {
          var _mapping$mapResult2 = mapping.mapResult(this.anchor), deleted = _mapping$mapResult2.deleted, pos = _mapping$mapResult2.pos;
          return deleted ? new TextBookmark(pos, pos) : new NodeBookmark2(pos);
        }
      }, {
        key: "resolve",
        value: function resolve(doc) {
          var $pos = doc.resolve(this.anchor), node = $pos.nodeAfter;
          if (node && NodeSelection.isSelectable(node)) return new NodeSelection($pos);
          return Selection.near($pos);
        }
      }]);
      return NodeBookmark2;
    })();
    var AllSelection = (function(_Selection3) {
      _inherits(AllSelection2, _Selection3);
      var _super3 = _createSuper(AllSelection2);
      function AllSelection2(doc) {
        _classCallCheck(this, AllSelection2);
        return _super3.call(this, doc.resolve(0), doc.resolve(doc.content.size));
      }
      _createClass(AllSelection2, [{
        key: "replace",
        value: function replace(tr) {
          var content = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : prosemirrorModel.Slice.empty;
          if (content == prosemirrorModel.Slice.empty) {
            tr["delete"](0, tr.doc.content.size);
            var sel = Selection.atStart(tr.doc);
            if (!sel.eq(tr.selection)) tr.setSelection(sel);
          } else {
            _get(_getPrototypeOf(AllSelection2.prototype), "replace", this).call(this, tr, content);
          }
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          return {
            type: "all"
          };
        }
      }, {
        key: "map",
        value: function map(doc) {
          return new AllSelection2(doc);
        }
      }, {
        key: "eq",
        value: function eq(other) {
          return other instanceof AllSelection2;
        }
      }, {
        key: "getBookmark",
        value: function getBookmark() {
          return AllBookmark;
        }
      }], [{
        key: "fromJSON",
        value: function fromJSON(doc) {
          return new AllSelection2(doc);
        }
      }]);
      return AllSelection2;
    })(Selection);
    Selection.jsonID("all", AllSelection);
    var AllBookmark = {
      map: function map() {
        return this;
      },
      resolve: function resolve(doc) {
        return new AllSelection(doc);
      }
    };
    function findSelectionIn(doc, node, pos, index, dir) {
      var text = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : false;
      if (node.inlineContent) return TextSelection.create(doc, pos);
      for (var i = index - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {
        var child = node.child(i);
        if (!child.isAtom) {
          var inner = findSelectionIn(doc, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text);
          if (inner) return inner;
        } else if (!text && NodeSelection.isSelectable(child)) {
          return NodeSelection.create(doc, pos - (dir < 0 ? child.nodeSize : 0));
        }
        pos += child.nodeSize * dir;
      }
      return null;
    }
    function selectionToInsertionEnd(tr, startLen, bias) {
      var last = tr.steps.length - 1;
      if (last < startLen) return;
      var step = tr.steps[last];
      if (!(step instanceof prosemirrorTransform.ReplaceStep || step instanceof prosemirrorTransform.ReplaceAroundStep)) return;
      var map = tr.mapping.maps[last], end;
      map.forEach(function(_from, _to, _newFrom, newTo) {
        if (end == null) end = newTo;
      });
      tr.setSelection(Selection.near(tr.doc.resolve(end), bias));
    }
    var UPDATED_SEL = 1;
    var UPDATED_MARKS = 2;
    var UPDATED_SCROLL = 4;
    var Transaction = (function(_prosemirrorTransform) {
      _inherits(Transaction2, _prosemirrorTransform);
      var _super4 = _createSuper(Transaction2);
      function Transaction2(state2) {
        var _this2;
        _classCallCheck(this, Transaction2);
        _this2 = _super4.call(this, state2.doc);
        _this2.curSelectionFor = 0;
        _this2.updated = 0;
        _this2.meta = /* @__PURE__ */ Object.create(null);
        _this2.time = Date.now();
        _this2.curSelection = state2.selection;
        _this2.storedMarks = state2.storedMarks;
        return _this2;
      }
      _createClass(Transaction2, [{
        key: "selection",
        get: function get2() {
          if (this.curSelectionFor < this.steps.length) {
            this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));
            this.curSelectionFor = this.steps.length;
          }
          return this.curSelection;
        }
      }, {
        key: "setSelection",
        value: function setSelection(selection) {
          if (selection.$from.doc != this.doc) throw new RangeError("Selection passed to setSelection must point at the current document");
          this.curSelection = selection;
          this.curSelectionFor = this.steps.length;
          this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;
          this.storedMarks = null;
          return this;
        }
      }, {
        key: "selectionSet",
        get: function get2() {
          return (this.updated & UPDATED_SEL) > 0;
        }
      }, {
        key: "setStoredMarks",
        value: function setStoredMarks(marks) {
          this.storedMarks = marks;
          this.updated |= UPDATED_MARKS;
          return this;
        }
      }, {
        key: "ensureMarks",
        value: function ensureMarks(marks) {
          if (!prosemirrorModel.Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks)) this.setStoredMarks(marks);
          return this;
        }
      }, {
        key: "addStoredMark",
        value: function addStoredMark(mark) {
          return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()));
        }
      }, {
        key: "removeStoredMark",
        value: function removeStoredMark(mark) {
          return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()));
        }
      }, {
        key: "storedMarksSet",
        get: function get2() {
          return (this.updated & UPDATED_MARKS) > 0;
        }
      }, {
        key: "addStep",
        value: function addStep(step, doc) {
          _get(_getPrototypeOf(Transaction2.prototype), "addStep", this).call(this, step, doc);
          this.updated = this.updated & ~UPDATED_MARKS;
          this.storedMarks = null;
        }
      }, {
        key: "setTime",
        value: function setTime(time) {
          this.time = time;
          return this;
        }
      }, {
        key: "replaceSelection",
        value: function replaceSelection(slice) {
          this.selection.replace(this, slice);
          return this;
        }
      }, {
        key: "replaceSelectionWith",
        value: function replaceSelectionWith(node) {
          var inheritMarks = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
          var selection = this.selection;
          if (inheritMarks) node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : selection.$from.marksAcross(selection.$to) || prosemirrorModel.Mark.none));
          selection.replaceWith(this, node);
          return this;
        }
      }, {
        key: "deleteSelection",
        value: function deleteSelection() {
          this.selection.replace(this);
          return this;
        }
      }, {
        key: "insertText",
        value: function insertText(text, from, to) {
          var schema = this.doc.type.schema;
          if (from == null) {
            if (!text) return this.deleteSelection();
            return this.replaceSelectionWith(schema.text(text), true);
          } else {
            if (to == null) to = from;
            if (!text) return this.deleteRange(from, to);
            var marks = this.storedMarks;
            if (!marks) {
              var $from = this.doc.resolve(from);
              marks = to == from ? $from.marks() : $from.marksAcross(this.doc.resolve(to));
            }
            this.replaceRangeWith(from, to, schema.text(text, marks));
            if (!this.selection.empty && this.selection.to == from + text.length) this.setSelection(Selection.near(this.selection.$to));
            return this;
          }
        }
      }, {
        key: "setMeta",
        value: function setMeta(key, value) {
          this.meta[typeof key == "string" ? key : key.key] = value;
          return this;
        }
      }, {
        key: "getMeta",
        value: function getMeta(key) {
          return this.meta[typeof key == "string" ? key : key.key];
        }
      }, {
        key: "isGeneric",
        get: function get2() {
          for (var _ in this.meta) return false;
          return true;
        }
      }, {
        key: "scrollIntoView",
        value: function scrollIntoView() {
          this.updated |= UPDATED_SCROLL;
          return this;
        }
      }, {
        key: "scrolledIntoView",
        get: function get2() {
          return (this.updated & UPDATED_SCROLL) > 0;
        }
      }]);
      return Transaction2;
    })(prosemirrorTransform.Transform);
    function bind(f, self2) {
      return !self2 || !f ? f : f.bind(self2);
    }
    var FieldDesc = _createClass(function FieldDesc2(name, desc, self2) {
      _classCallCheck(this, FieldDesc2);
      this.name = name;
      this.init = bind(desc.init, self2);
      this.apply = bind(desc.apply, self2);
    });
    var baseFields = [new FieldDesc("doc", {
      init: function init(config) {
        return config.doc || config.schema.topNodeType.createAndFill();
      },
      apply: function apply(tr) {
        return tr.doc;
      }
    }), new FieldDesc("selection", {
      init: function init(config, instance) {
        return config.selection || Selection.atStart(instance.doc);
      },
      apply: function apply(tr) {
        return tr.selection;
      }
    }), new FieldDesc("storedMarks", {
      init: function init(config) {
        return config.storedMarks || null;
      },
      apply: function apply(tr, _marks, _old, state2) {
        return state2.selection.$cursor ? tr.storedMarks : null;
      }
    }), new FieldDesc("scrollToSelection", {
      init: function init() {
        return 0;
      },
      apply: function apply(tr, prev) {
        return tr.scrolledIntoView ? prev + 1 : prev;
      }
    })];
    var Configuration = _createClass(function Configuration2(schema, plugins) {
      var _this3 = this;
      _classCallCheck(this, Configuration2);
      this.schema = schema;
      this.plugins = [];
      this.pluginsByKey = /* @__PURE__ */ Object.create(null);
      this.fields = baseFields.slice();
      if (plugins) plugins.forEach(function(plugin) {
        if (_this3.pluginsByKey[plugin.key]) throw new RangeError("Adding different instances of a keyed plugin (" + plugin.key + ")");
        _this3.plugins.push(plugin);
        _this3.pluginsByKey[plugin.key] = plugin;
        if (plugin.spec.state) _this3.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin));
      });
    });
    var EditorState = (function() {
      function EditorState2(config) {
        _classCallCheck(this, EditorState2);
        this.config = config;
      }
      _createClass(EditorState2, [{
        key: "schema",
        get: function get2() {
          return this.config.schema;
        }
      }, {
        key: "plugins",
        get: function get2() {
          return this.config.plugins;
        }
      }, {
        key: "apply",
        value: function apply(tr) {
          return this.applyTransaction(tr).state;
        }
      }, {
        key: "filterTransaction",
        value: function filterTransaction(tr) {
          var ignore = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1;
          for (var i = 0; i < this.config.plugins.length; i++) if (i != ignore) {
            var plugin = this.config.plugins[i];
            if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this)) return false;
          }
          return true;
        }
      }, {
        key: "applyTransaction",
        value: function applyTransaction(rootTr) {
          if (!this.filterTransaction(rootTr)) return {
            state: this,
            transactions: []
          };
          var trs = [rootTr], newState = this.applyInner(rootTr), seen = null;
          for (; ; ) {
            var haveNew = false;
            for (var i = 0; i < this.config.plugins.length; i++) {
              var plugin = this.config.plugins[i];
              if (plugin.spec.appendTransaction) {
                var n = seen ? seen[i].n : 0, oldState = seen ? seen[i].state : this;
                var tr = n < trs.length && plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);
                if (tr && newState.filterTransaction(tr, i)) {
                  tr.setMeta("appendedTransaction", rootTr);
                  if (!seen) {
                    seen = [];
                    for (var j = 0; j < this.config.plugins.length; j++) seen.push(j < i ? {
                      state: newState,
                      n: trs.length
                    } : {
                      state: this,
                      n: 0
                    });
                  }
                  trs.push(tr);
                  newState = newState.applyInner(tr);
                  haveNew = true;
                }
                if (seen) seen[i] = {
                  state: newState,
                  n: trs.length
                };
              }
            }
            if (!haveNew) return {
              state: newState,
              transactions: trs
            };
          }
        }
      }, {
        key: "applyInner",
        value: function applyInner(tr) {
          if (!tr.before.eq(this.doc)) throw new RangeError("Applying a mismatched transaction");
          var newInstance = new EditorState2(this.config), fields = this.config.fields;
          for (var i = 0; i < fields.length; i++) {
            var field = fields[i];
            newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance);
          }
          return newInstance;
        }
      }, {
        key: "tr",
        get: function get2() {
          return new Transaction(this);
        }
      }, {
        key: "reconfigure",
        value: function reconfigure(config) {
          var $config = new Configuration(this.schema, config.plugins);
          var fields = $config.fields, instance = new EditorState2($config);
          for (var i = 0; i < fields.length; i++) {
            var name = fields[i].name;
            instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config, instance);
          }
          return instance;
        }
      }, {
        key: "toJSON",
        value: function toJSON(pluginFields) {
          var result = {
            doc: this.doc.toJSON(),
            selection: this.selection.toJSON()
          };
          if (this.storedMarks) result.storedMarks = this.storedMarks.map(function(m) {
            return m.toJSON();
          });
          if (pluginFields && _typeof(pluginFields) == "object") for (var prop in pluginFields) {
            if (prop == "doc" || prop == "selection") throw new RangeError("The JSON fields `doc` and `selection` are reserved");
            var plugin = pluginFields[prop], state2 = plugin.spec.state;
            if (state2 && state2.toJSON) result[prop] = state2.toJSON.call(plugin, this[plugin.key]);
          }
          return result;
        }
      }], [{
        key: "create",
        value: function create(config) {
          var $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins);
          var instance = new EditorState2($config);
          for (var i = 0; i < $config.fields.length; i++) instance[$config.fields[i].name] = $config.fields[i].init(config, instance);
          return instance;
        }
      }, {
        key: "fromJSON",
        value: function fromJSON(config, json, pluginFields) {
          if (!json) throw new RangeError("Invalid input for EditorState.fromJSON");
          if (!config.schema) throw new RangeError("Required config field 'schema' missing");
          var $config = new Configuration(config.schema, config.plugins);
          var instance = new EditorState2($config);
          $config.fields.forEach(function(field) {
            if (field.name == "doc") {
              instance.doc = prosemirrorModel.Node.fromJSON(config.schema, json.doc);
            } else if (field.name == "selection") {
              instance.selection = Selection.fromJSON(instance.doc, json.selection);
            } else if (field.name == "storedMarks") {
              if (json.storedMarks) instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON);
            } else {
              if (pluginFields) for (var prop in pluginFields) {
                var plugin = pluginFields[prop], state2 = plugin.spec.state;
                if (plugin.key == field.name && state2 && state2.fromJSON && Object.prototype.hasOwnProperty.call(json, prop)) {
                  instance[field.name] = state2.fromJSON.call(plugin, config, json[prop], instance);
                  return;
                }
              }
              instance[field.name] = field.init(config, instance);
            }
          });
          return instance;
        }
      }]);
      return EditorState2;
    })();
    function bindProps(obj, self2, target) {
      for (var prop in obj) {
        var val = obj[prop];
        if (val instanceof Function) val = val.bind(self2);
        else if (prop == "handleDOMEvents") val = bindProps(val, self2, {});
        target[prop] = val;
      }
      return target;
    }
    var Plugin2 = (function() {
      function Plugin3(spec) {
        _classCallCheck(this, Plugin3);
        this.spec = spec;
        this.props = {};
        if (spec.props) bindProps(spec.props, this, this.props);
        this.key = spec.key ? spec.key.key : createKey("plugin");
      }
      _createClass(Plugin3, [{
        key: "getState",
        value: function getState(state2) {
          return state2[this.key];
        }
      }]);
      return Plugin3;
    })();
    var keys = /* @__PURE__ */ Object.create(null);
    function createKey(name) {
      if (name in keys) return name + "$" + ++keys[name];
      keys[name] = 0;
      return name + "$";
    }
    var PluginKey = (function() {
      function PluginKey2() {
        var name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "key";
        _classCallCheck(this, PluginKey2);
        this.key = createKey(name);
      }
      _createClass(PluginKey2, [{
        key: "get",
        value: function get2(state2) {
          return state2.config.pluginsByKey[this.key];
        }
      }, {
        key: "getState",
        value: function getState(state2) {
          return state2[this.key];
        }
      }]);
      return PluginKey2;
    })();
    exports2.AllSelection = AllSelection;
    exports2.EditorState = EditorState;
    exports2.NodeSelection = NodeSelection;
    exports2.Plugin = Plugin2;
    exports2.PluginKey = PluginKey;
    exports2.Selection = Selection;
    exports2.SelectionRange = SelectionRange;
    exports2.TextSelection = TextSelection;
    exports2.Transaction = Transaction;
  }
});

// node_modules/.pnpm/prosemirror-commands@1.7.1/node_modules/prosemirror-commands/dist/index.cjs
var require_dist5 = __commonJS({
  "node_modules/.pnpm/prosemirror-commands@1.7.1/node_modules/prosemirror-commands/dist/index.cjs"(exports2) {
    "use strict";
    var prosemirrorTransform = require_dist3();
    var prosemirrorModel = require_dist2();
    var prosemirrorState = require_dist4();
    var deleteSelection = function deleteSelection2(state2, dispatch) {
      if (state2.selection.empty) return false;
      if (dispatch) dispatch(state2.tr.deleteSelection().scrollIntoView());
      return true;
    };
    function atBlockStart(state2, view) {
      var $cursor = state2.selection.$cursor;
      if (!$cursor || (view ? !view.endOfTextblock("backward", state2) : $cursor.parentOffset > 0)) return null;
      return $cursor;
    }
    var joinBackward = function joinBackward2(state2, dispatch, view) {
      var $cursor = atBlockStart(state2, view);
      if (!$cursor) return false;
      var $cut = findCutBefore($cursor);
      if (!$cut) {
        var range2 = $cursor.blockRange(), target = range2 && prosemirrorTransform.liftTarget(range2);
        if (target == null) return false;
        if (dispatch) dispatch(state2.tr.lift(range2, target).scrollIntoView());
        return true;
      }
      var before = $cut.nodeBefore;
      if (deleteBarrier(state2, $cut, dispatch, -1)) return true;
      if ($cursor.parent.content.size == 0 && (textblockAt(before, "end") || prosemirrorState.NodeSelection.isSelectable(before))) {
        for (var depth = $cursor.depth; ; depth--) {
          var delStep = prosemirrorTransform.replaceStep(state2.doc, $cursor.before(depth), $cursor.after(depth), prosemirrorModel.Slice.empty);
          if (delStep && delStep.slice.size < delStep.to - delStep.from) {
            if (dispatch) {
              var tr = state2.tr.step(delStep);
              tr.setSelection(textblockAt(before, "end") ? prosemirrorState.Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1) : prosemirrorState.NodeSelection.create(tr.doc, $cut.pos - before.nodeSize));
              dispatch(tr.scrollIntoView());
            }
            return true;
          }
          if (depth == 1 || $cursor.node(depth - 1).childCount > 1) break;
        }
      }
      if (before.isAtom && $cut.depth == $cursor.depth - 1) {
        if (dispatch) dispatch(state2.tr["delete"]($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());
        return true;
      }
      return false;
    };
    var joinTextblockBackward = function joinTextblockBackward2(state2, dispatch, view) {
      var $cursor = atBlockStart(state2, view);
      if (!$cursor) return false;
      var $cut = findCutBefore($cursor);
      return $cut ? joinTextblocksAround(state2, $cut, dispatch) : false;
    };
    var joinTextblockForward = function joinTextblockForward2(state2, dispatch, view) {
      var $cursor = atBlockEnd(state2, view);
      if (!$cursor) return false;
      var $cut = findCutAfter($cursor);
      return $cut ? joinTextblocksAround(state2, $cut, dispatch) : false;
    };
    function joinTextblocksAround(state2, $cut, dispatch) {
      var before = $cut.nodeBefore, beforeText = before, beforePos = $cut.pos - 1;
      for (; !beforeText.isTextblock; beforePos--) {
        if (beforeText.type.spec.isolating) return false;
        var child = beforeText.lastChild;
        if (!child) return false;
        beforeText = child;
      }
      var after = $cut.nodeAfter, afterText = after, afterPos = $cut.pos + 1;
      for (; !afterText.isTextblock; afterPos++) {
        if (afterText.type.spec.isolating) return false;
        var _child = afterText.firstChild;
        if (!_child) return false;
        afterText = _child;
      }
      var step = prosemirrorTransform.replaceStep(state2.doc, beforePos, afterPos, prosemirrorModel.Slice.empty);
      if (!step || step.from != beforePos || step instanceof prosemirrorTransform.ReplaceStep && step.slice.size >= afterPos - beforePos) return false;
      if (dispatch) {
        var tr = state2.tr.step(step);
        tr.setSelection(prosemirrorState.TextSelection.create(tr.doc, beforePos));
        dispatch(tr.scrollIntoView());
      }
      return true;
    }
    function textblockAt(node, side) {
      var only = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      for (var scan = node; scan; scan = side == "start" ? scan.firstChild : scan.lastChild) {
        if (scan.isTextblock) return true;
        if (only && scan.childCount != 1) return false;
      }
      return false;
    }
    var selectNodeBackward = function selectNodeBackward2(state2, dispatch, view) {
      var _state$selection = state2.selection, $head = _state$selection.$head, empty = _state$selection.empty, $cut = $head;
      if (!empty) return false;
      if ($head.parent.isTextblock) {
        if (view ? !view.endOfTextblock("backward", state2) : $head.parentOffset > 0) return false;
        $cut = findCutBefore($head);
      }
      var node = $cut && $cut.nodeBefore;
      if (!node || !prosemirrorState.NodeSelection.isSelectable(node)) return false;
      if (dispatch) dispatch(state2.tr.setSelection(prosemirrorState.NodeSelection.create(state2.doc, $cut.pos - node.nodeSize)).scrollIntoView());
      return true;
    };
    function findCutBefore($pos) {
      if (!$pos.parent.type.spec.isolating) for (var i = $pos.depth - 1; i >= 0; i--) {
        if ($pos.index(i) > 0) return $pos.doc.resolve($pos.before(i + 1));
        if ($pos.node(i).type.spec.isolating) break;
      }
      return null;
    }
    function atBlockEnd(state2, view) {
      var $cursor = state2.selection.$cursor;
      if (!$cursor || (view ? !view.endOfTextblock("forward", state2) : $cursor.parentOffset < $cursor.parent.content.size)) return null;
      return $cursor;
    }
    var joinForward = function joinForward2(state2, dispatch, view) {
      var $cursor = atBlockEnd(state2, view);
      if (!$cursor) return false;
      var $cut = findCutAfter($cursor);
      if (!$cut) return false;
      var after = $cut.nodeAfter;
      if (deleteBarrier(state2, $cut, dispatch, 1)) return true;
      if ($cursor.parent.content.size == 0 && (textblockAt(after, "start") || prosemirrorState.NodeSelection.isSelectable(after))) {
        var delStep = prosemirrorTransform.replaceStep(state2.doc, $cursor.before(), $cursor.after(), prosemirrorModel.Slice.empty);
        if (delStep && delStep.slice.size < delStep.to - delStep.from) {
          if (dispatch) {
            var tr = state2.tr.step(delStep);
            tr.setSelection(textblockAt(after, "start") ? prosemirrorState.Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1) : prosemirrorState.NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)));
            dispatch(tr.scrollIntoView());
          }
          return true;
        }
      }
      if (after.isAtom && $cut.depth == $cursor.depth - 1) {
        if (dispatch) dispatch(state2.tr["delete"]($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());
        return true;
      }
      return false;
    };
    var selectNodeForward = function selectNodeForward2(state2, dispatch, view) {
      var _state$selection2 = state2.selection, $head = _state$selection2.$head, empty = _state$selection2.empty, $cut = $head;
      if (!empty) return false;
      if ($head.parent.isTextblock) {
        if (view ? !view.endOfTextblock("forward", state2) : $head.parentOffset < $head.parent.content.size) return false;
        $cut = findCutAfter($head);
      }
      var node = $cut && $cut.nodeAfter;
      if (!node || !prosemirrorState.NodeSelection.isSelectable(node)) return false;
      if (dispatch) dispatch(state2.tr.setSelection(prosemirrorState.NodeSelection.create(state2.doc, $cut.pos)).scrollIntoView());
      return true;
    };
    function findCutAfter($pos) {
      if (!$pos.parent.type.spec.isolating) for (var i = $pos.depth - 1; i >= 0; i--) {
        var parent = $pos.node(i);
        if ($pos.index(i) + 1 < parent.childCount) return $pos.doc.resolve($pos.after(i + 1));
        if (parent.type.spec.isolating) break;
      }
      return null;
    }
    var joinUp = function joinUp2(state2, dispatch) {
      var sel = state2.selection, nodeSel = sel instanceof prosemirrorState.NodeSelection, point;
      if (nodeSel) {
        if (sel.node.isTextblock || !prosemirrorTransform.canJoin(state2.doc, sel.from)) return false;
        point = sel.from;
      } else {
        point = prosemirrorTransform.joinPoint(state2.doc, sel.from, -1);
        if (point == null) return false;
      }
      if (dispatch) {
        var tr = state2.tr.join(point);
        if (nodeSel) tr.setSelection(prosemirrorState.NodeSelection.create(tr.doc, point - state2.doc.resolve(point).nodeBefore.nodeSize));
        dispatch(tr.scrollIntoView());
      }
      return true;
    };
    var joinDown = function joinDown2(state2, dispatch) {
      var sel = state2.selection, point;
      if (sel instanceof prosemirrorState.NodeSelection) {
        if (sel.node.isTextblock || !prosemirrorTransform.canJoin(state2.doc, sel.to)) return false;
        point = sel.to;
      } else {
        point = prosemirrorTransform.joinPoint(state2.doc, sel.to, 1);
        if (point == null) return false;
      }
      if (dispatch) dispatch(state2.tr.join(point).scrollIntoView());
      return true;
    };
    var lift = function lift2(state2, dispatch) {
      var _state$selection3 = state2.selection, $from = _state$selection3.$from, $to = _state$selection3.$to;
      var range2 = $from.blockRange($to), target = range2 && prosemirrorTransform.liftTarget(range2);
      if (target == null) return false;
      if (dispatch) dispatch(state2.tr.lift(range2, target).scrollIntoView());
      return true;
    };
    var newlineInCode = function newlineInCode2(state2, dispatch) {
      var _state$selection4 = state2.selection, $head = _state$selection4.$head, $anchor = _state$selection4.$anchor;
      if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) return false;
      if (dispatch) dispatch(state2.tr.insertText("\n").scrollIntoView());
      return true;
    };
    function defaultBlockAt(match) {
      for (var i = 0; i < match.edgeCount; i++) {
        var _match$edge = match.edge(i), type2 = _match$edge.type;
        if (type2.isTextblock && !type2.hasRequiredAttrs()) return type2;
      }
      return null;
    }
    var exitCode = function exitCode2(state2, dispatch) {
      var _state$selection5 = state2.selection, $head = _state$selection5.$head, $anchor = _state$selection5.$anchor;
      if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) return false;
      var above = $head.node(-1), after = $head.indexAfter(-1), type2 = defaultBlockAt(above.contentMatchAt(after));
      if (!type2 || !above.canReplaceWith(after, after, type2)) return false;
      if (dispatch) {
        var pos = $head.after(), tr = state2.tr.replaceWith(pos, pos, type2.createAndFill());
        tr.setSelection(prosemirrorState.Selection.near(tr.doc.resolve(pos), 1));
        dispatch(tr.scrollIntoView());
      }
      return true;
    };
    var createParagraphNear = function createParagraphNear2(state2, dispatch) {
      var sel = state2.selection, $from = sel.$from, $to = sel.$to;
      if (sel instanceof prosemirrorState.AllSelection || $from.parent.inlineContent || $to.parent.inlineContent) return false;
      var type2 = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));
      if (!type2 || !type2.isTextblock) return false;
      if (dispatch) {
        var side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;
        var tr = state2.tr.insert(side, type2.createAndFill());
        tr.setSelection(prosemirrorState.TextSelection.create(tr.doc, side + 1));
        dispatch(tr.scrollIntoView());
      }
      return true;
    };
    var liftEmptyBlock = function liftEmptyBlock2(state2, dispatch) {
      var $cursor = state2.selection.$cursor;
      if (!$cursor || $cursor.parent.content.size) return false;
      if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {
        var before = $cursor.before();
        if (prosemirrorTransform.canSplit(state2.doc, before)) {
          if (dispatch) dispatch(state2.tr.split(before).scrollIntoView());
          return true;
        }
      }
      var range2 = $cursor.blockRange(), target = range2 && prosemirrorTransform.liftTarget(range2);
      if (target == null) return false;
      if (dispatch) dispatch(state2.tr.lift(range2, target).scrollIntoView());
      return true;
    };
    function splitBlockAs(splitNode) {
      return function(state2, dispatch) {
        var _state$selection6 = state2.selection, $from = _state$selection6.$from, $to = _state$selection6.$to;
        if (state2.selection instanceof prosemirrorState.NodeSelection && state2.selection.node.isBlock) {
          if (!$from.parentOffset || !prosemirrorTransform.canSplit(state2.doc, $from.pos)) return false;
          if (dispatch) dispatch(state2.tr.split($from.pos).scrollIntoView());
          return true;
        }
        if (!$from.depth) return false;
        var types2 = [];
        var splitDepth, deflt, atEnd = false, atStart = false;
        for (var d = $from.depth; ; d--) {
          var node = $from.node(d);
          if (node.isBlock) {
            atEnd = $from.end(d) == $from.pos + ($from.depth - d);
            atStart = $from.start(d) == $from.pos - ($from.depth - d);
            deflt = defaultBlockAt($from.node(d - 1).contentMatchAt($from.indexAfter(d - 1)));
            var splitType = splitNode && splitNode($to.parent, atEnd, $from);
            types2.unshift(splitType || (atEnd && deflt ? {
              type: deflt
            } : null));
            splitDepth = d;
            break;
          } else {
            if (d == 1) return false;
            types2.unshift(null);
          }
        }
        var tr = state2.tr;
        if (state2.selection instanceof prosemirrorState.TextSelection || state2.selection instanceof prosemirrorState.AllSelection) tr.deleteSelection();
        var splitPos = tr.mapping.map($from.pos);
        var can = prosemirrorTransform.canSplit(tr.doc, splitPos, types2.length, types2);
        if (!can) {
          types2[0] = deflt ? {
            type: deflt
          } : null;
          can = prosemirrorTransform.canSplit(tr.doc, splitPos, types2.length, types2);
        }
        if (!can) return false;
        tr.split(splitPos, types2.length, types2);
        if (!atEnd && atStart && $from.node(splitDepth).type != deflt) {
          var first = tr.mapping.map($from.before(splitDepth)), $first = tr.doc.resolve(first);
          if (deflt && $from.node(splitDepth - 1).canReplaceWith($first.index(), $first.index() + 1, deflt)) tr.setNodeMarkup(tr.mapping.map($from.before(splitDepth)), deflt);
        }
        if (dispatch) dispatch(tr.scrollIntoView());
        return true;
      };
    }
    var splitBlock = splitBlockAs();
    var splitBlockKeepMarks = function splitBlockKeepMarks2(state2, dispatch) {
      return splitBlock(state2, dispatch && function(tr) {
        var marks = state2.storedMarks || state2.selection.$to.parentOffset && state2.selection.$from.marks();
        if (marks) tr.ensureMarks(marks);
        dispatch(tr);
      });
    };
    var selectParentNode = function selectParentNode2(state2, dispatch) {
      var _state$selection7 = state2.selection, $from = _state$selection7.$from, to = _state$selection7.to, pos;
      var same = $from.sharedDepth(to);
      if (same == 0) return false;
      pos = $from.before(same);
      if (dispatch) dispatch(state2.tr.setSelection(prosemirrorState.NodeSelection.create(state2.doc, pos)));
      return true;
    };
    var selectAll = function selectAll2(state2, dispatch) {
      if (dispatch) dispatch(state2.tr.setSelection(new prosemirrorState.AllSelection(state2.doc)));
      return true;
    };
    function joinMaybeClear(state2, $pos, dispatch) {
      var before = $pos.nodeBefore, after = $pos.nodeAfter, index = $pos.index();
      if (!before || !after || !before.type.compatibleContent(after.type)) return false;
      if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {
        if (dispatch) dispatch(state2.tr["delete"]($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());
        return true;
      }
      if (!$pos.parent.canReplace(index, index + 1) || !(after.isTextblock || prosemirrorTransform.canJoin(state2.doc, $pos.pos))) return false;
      if (dispatch) dispatch(state2.tr.join($pos.pos).scrollIntoView());
      return true;
    }
    function deleteBarrier(state2, $cut, dispatch, dir) {
      var before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match;
      var isolated = before.type.spec.isolating || after.type.spec.isolating;
      if (!isolated && joinMaybeClear(state2, $cut, dispatch)) return true;
      var canDelAfter = !isolated && $cut.parent.canReplace($cut.index(), $cut.index() + 1);
      if (canDelAfter && (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) && match.matchType(conn[0] || after.type).validEnd) {
        if (dispatch) {
          var end = $cut.pos + after.nodeSize, wrap = prosemirrorModel.Fragment.empty;
          for (var i = conn.length - 1; i >= 0; i--) wrap = prosemirrorModel.Fragment.from(conn[i].create(null, wrap));
          wrap = prosemirrorModel.Fragment.from(before.copy(wrap));
          var tr = state2.tr.step(new prosemirrorTransform.ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new prosemirrorModel.Slice(wrap, 1, 0), conn.length, true));
          var $joinAt = tr.doc.resolve(end + 2 * conn.length);
          if ($joinAt.nodeAfter && $joinAt.nodeAfter.type == before.type && prosemirrorTransform.canJoin(tr.doc, $joinAt.pos)) tr.join($joinAt.pos);
          dispatch(tr.scrollIntoView());
        }
        return true;
      }
      var selAfter = after.type.spec.isolating || dir > 0 && isolated ? null : prosemirrorState.Selection.findFrom($cut, 1);
      var range2 = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range2 && prosemirrorTransform.liftTarget(range2);
      if (target != null && target >= $cut.depth) {
        if (dispatch) dispatch(state2.tr.lift(range2, target).scrollIntoView());
        return true;
      }
      if (canDelAfter && textblockAt(after, "start", true) && textblockAt(before, "end")) {
        var at = before, _wrap = [];
        for (; ; ) {
          _wrap.push(at);
          if (at.isTextblock) break;
          at = at.lastChild;
        }
        var afterText = after, afterDepth = 1;
        for (; !afterText.isTextblock; afterText = afterText.firstChild) afterDepth++;
        if (at.canReplace(at.childCount, at.childCount, afterText.content)) {
          if (dispatch) {
            var _end = prosemirrorModel.Fragment.empty;
            for (var _i = _wrap.length - 1; _i >= 0; _i--) _end = prosemirrorModel.Fragment.from(_wrap[_i].copy(_end));
            var _tr = state2.tr.step(new prosemirrorTransform.ReplaceAroundStep($cut.pos - _wrap.length, $cut.pos + after.nodeSize, $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth, new prosemirrorModel.Slice(_end, _wrap.length, 0), 0, true));
            dispatch(_tr.scrollIntoView());
          }
          return true;
        }
      }
      return false;
    }
    function selectTextblockSide(side) {
      return function(state2, dispatch) {
        var sel = state2.selection, $pos = side < 0 ? sel.$from : sel.$to;
        var depth = $pos.depth;
        while ($pos.node(depth).isInline) {
          if (!depth) return false;
          depth--;
        }
        if (!$pos.node(depth).isTextblock) return false;
        if (dispatch) dispatch(state2.tr.setSelection(prosemirrorState.TextSelection.create(state2.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));
        return true;
      };
    }
    var selectTextblockStart = selectTextblockSide(-1);
    var selectTextblockEnd = selectTextblockSide(1);
    function wrapIn(nodeType) {
      var attrs = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      return function(state2, dispatch) {
        var _state$selection8 = state2.selection, $from = _state$selection8.$from, $to = _state$selection8.$to;
        var range2 = $from.blockRange($to), wrapping = range2 && prosemirrorTransform.findWrapping(range2, nodeType, attrs);
        if (!wrapping) return false;
        if (dispatch) dispatch(state2.tr.wrap(range2, wrapping).scrollIntoView());
        return true;
      };
    }
    function setBlockType(nodeType) {
      var attrs = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      return function(state2, dispatch) {
        var applicable = false;
        for (var i = 0; i < state2.selection.ranges.length && !applicable; i++) {
          var _state$selection$rang = state2.selection.ranges[i], from = _state$selection$rang.$from.pos, to = _state$selection$rang.$to.pos;
          state2.doc.nodesBetween(from, to, function(node, pos) {
            if (applicable) return false;
            if (!node.isTextblock || node.hasMarkup(nodeType, attrs)) return;
            if (node.type == nodeType) {
              applicable = true;
            } else {
              var $pos = state2.doc.resolve(pos), index = $pos.index();
              applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType);
            }
          });
        }
        if (!applicable) return false;
        if (dispatch) {
          var tr = state2.tr;
          for (var _i2 = 0; _i2 < state2.selection.ranges.length; _i2++) {
            var _state$selection$rang2 = state2.selection.ranges[_i2], _from = _state$selection$rang2.$from.pos, _to = _state$selection$rang2.$to.pos;
            tr.setBlockType(_from, _to, nodeType, attrs);
          }
          dispatch(tr.scrollIntoView());
        }
        return true;
      };
    }
    function markApplies(doc, ranges, type2, enterAtoms) {
      var _loop = function _loop2() {
        var _ranges$i = ranges[i], $from = _ranges$i.$from, $to = _ranges$i.$to;
        var can = $from.depth == 0 ? doc.inlineContent && doc.type.allowsMarkType(type2) : false;
        doc.nodesBetween($from.pos, $to.pos, function(node, pos) {
          if (can || !enterAtoms && node.isAtom && node.isInline && pos >= $from.pos && pos + node.nodeSize <= $to.pos) return false;
          can = node.inlineContent && node.type.allowsMarkType(type2);
        });
        if (can) return {
          v: true
        };
      }, _ret;
      for (var i = 0; i < ranges.length; i++) {
        _ret = _loop();
        if (_ret) return _ret.v;
      }
      return false;
    }
    function removeInlineAtoms(ranges) {
      var result = [];
      var _loop2 = function _loop22() {
        var _ranges$i2 = ranges[i], $from = _ranges$i2.$from, $to = _ranges$i2.$to;
        $from.doc.nodesBetween($from.pos, $to.pos, function(node, pos) {
          if (node.isAtom && node.content.size && node.isInline && pos >= $from.pos && pos + node.nodeSize <= $to.pos) {
            if (pos + 1 > $from.pos) result.push(new prosemirrorState.SelectionRange($from, $from.doc.resolve(pos + 1)));
            $from = $from.doc.resolve(pos + 1 + node.content.size);
            return false;
          }
        });
        if ($from.pos < $to.pos) result.push(new prosemirrorState.SelectionRange($from, $to));
      };
      for (var i = 0; i < ranges.length; i++) {
        _loop2();
      }
      return result;
    }
    function toggleMark(markType) {
      var attrs = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      var options = arguments.length > 2 ? arguments[2] : void 0;
      var removeWhenPresent = (options && options.removeWhenPresent) !== false;
      var enterAtoms = (options && options.enterInlineAtoms) !== false;
      var dropSpace = !(options && options.includeWhitespace);
      return function(state2, dispatch) {
        var _state$selection9 = state2.selection, empty = _state$selection9.empty, $cursor = _state$selection9.$cursor, ranges = _state$selection9.ranges;
        if (empty && !$cursor || !markApplies(state2.doc, ranges, markType, enterAtoms)) return false;
        if (dispatch) {
          if ($cursor) {
            if (markType.isInSet(state2.storedMarks || $cursor.marks())) dispatch(state2.tr.removeStoredMark(markType));
            else dispatch(state2.tr.addStoredMark(markType.create(attrs)));
          } else {
            var add, tr = state2.tr;
            if (!enterAtoms) ranges = removeInlineAtoms(ranges);
            if (removeWhenPresent) {
              add = !ranges.some(function(r) {
                return state2.doc.rangeHasMark(r.$from.pos, r.$to.pos, markType);
              });
            } else {
              add = !ranges.every(function(r) {
                var missing = false;
                tr.doc.nodesBetween(r.$from.pos, r.$to.pos, function(node, pos, parent) {
                  if (missing) return false;
                  missing = !markType.isInSet(node.marks) && !!parent && parent.type.allowsMarkType(markType) && !(node.isText && /^\s*$/.test(node.textBetween(Math.max(0, r.$from.pos - pos), Math.min(node.nodeSize, r.$to.pos - pos))));
                });
                return !missing;
              });
            }
            for (var i = 0; i < ranges.length; i++) {
              var _ranges$i3 = ranges[i], $from = _ranges$i3.$from, $to = _ranges$i3.$to;
              if (!add) {
                tr.removeMark($from.pos, $to.pos, markType);
              } else {
                var from = $from.pos, to = $to.pos, start = $from.nodeAfter, end = $to.nodeBefore;
                var spaceStart = dropSpace && start && start.isText ? /^\s*/.exec(start.text)[0].length : 0;
                var spaceEnd = dropSpace && end && end.isText ? /\s*$/.exec(end.text)[0].length : 0;
                if (from + spaceStart < to) {
                  from += spaceStart;
                  to -= spaceEnd;
                }
                tr.addMark(from, to, markType.create(attrs));
              }
            }
            dispatch(tr.scrollIntoView());
          }
        }
        return true;
      };
    }
    function wrapDispatchForJoin(dispatch, isJoinable) {
      return function(tr) {
        if (!tr.isGeneric) return dispatch(tr);
        var ranges = [];
        for (var i = 0; i < tr.mapping.maps.length; i++) {
          var map = tr.mapping.maps[i];
          for (var j = 0; j < ranges.length; j++) ranges[j] = map.map(ranges[j]);
          map.forEach(function(_s, _e, from2, to2) {
            return ranges.push(from2, to2);
          });
        }
        var joinable = [];
        for (var _i3 = 0; _i3 < ranges.length; _i3 += 2) {
          var from = ranges[_i3], to = ranges[_i3 + 1];
          var $from = tr.doc.resolve(from), depth = $from.sharedDepth(to), parent = $from.node(depth);
          for (var index = $from.indexAfter(depth), pos = $from.after(depth + 1); pos <= to; ++index) {
            var after = parent.maybeChild(index);
            if (!after) break;
            if (index && joinable.indexOf(pos) == -1) {
              var before = parent.child(index - 1);
              if (before.type == after.type && isJoinable(before, after)) joinable.push(pos);
            }
            pos += after.nodeSize;
          }
        }
        joinable.sort(function(a, b) {
          return a - b;
        });
        for (var _i4 = joinable.length - 1; _i4 >= 0; _i4--) {
          if (prosemirrorTransform.canJoin(tr.doc, joinable[_i4])) tr.join(joinable[_i4]);
        }
        dispatch(tr);
      };
    }
    function autoJoin(command, isJoinable) {
      var canJoin = Array.isArray(isJoinable) ? function(node) {
        return isJoinable.indexOf(node.type.name) > -1;
      } : isJoinable;
      return function(state2, dispatch, view) {
        return command(state2, dispatch && wrapDispatchForJoin(dispatch, canJoin), view);
      };
    }
    function chainCommands() {
      for (var _len = arguments.length, commands2 = new Array(_len), _key = 0; _key < _len; _key++) {
        commands2[_key] = arguments[_key];
      }
      return function(state2, dispatch, view) {
        for (var i = 0; i < commands2.length; i++) if (commands2[i](state2, dispatch, view)) return true;
        return false;
      };
    }
    var backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward);
    var del = chainCommands(deleteSelection, joinForward, selectNodeForward);
    var pcBaseKeymap = {
      "Enter": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),
      "Mod-Enter": exitCode,
      "Backspace": backspace,
      "Mod-Backspace": backspace,
      "Shift-Backspace": backspace,
      "Delete": del,
      "Mod-Delete": del,
      "Mod-a": selectAll
    };
    var macBaseKeymap = {
      "Ctrl-h": pcBaseKeymap["Backspace"],
      "Alt-Backspace": pcBaseKeymap["Mod-Backspace"],
      "Ctrl-d": pcBaseKeymap["Delete"],
      "Ctrl-Alt-Backspace": pcBaseKeymap["Mod-Delete"],
      "Alt-Delete": pcBaseKeymap["Mod-Delete"],
      "Alt-d": pcBaseKeymap["Mod-Delete"],
      "Ctrl-a": selectTextblockStart,
      "Ctrl-e": selectTextblockEnd
    };
    for (key in pcBaseKeymap) macBaseKeymap[key] = pcBaseKeymap[key];
    var key;
    var mac = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os != "undefined" && os.platform ? os.platform() == "darwin" : false;
    var baseKeymap = mac ? macBaseKeymap : pcBaseKeymap;
    exports2.autoJoin = autoJoin;
    exports2.baseKeymap = baseKeymap;
    exports2.chainCommands = chainCommands;
    exports2.createParagraphNear = createParagraphNear;
    exports2.deleteSelection = deleteSelection;
    exports2.exitCode = exitCode;
    exports2.joinBackward = joinBackward;
    exports2.joinDown = joinDown;
    exports2.joinForward = joinForward;
    exports2.joinTextblockBackward = joinTextblockBackward;
    exports2.joinTextblockForward = joinTextblockForward;
    exports2.joinUp = joinUp;
    exports2.lift = lift;
    exports2.liftEmptyBlock = liftEmptyBlock;
    exports2.macBaseKeymap = macBaseKeymap;
    exports2.newlineInCode = newlineInCode;
    exports2.pcBaseKeymap = pcBaseKeymap;
    exports2.selectAll = selectAll;
    exports2.selectNodeBackward = selectNodeBackward;
    exports2.selectNodeForward = selectNodeForward;
    exports2.selectParentNode = selectParentNode;
    exports2.selectTextblockEnd = selectTextblockEnd;
    exports2.selectTextblockStart = selectTextblockStart;
    exports2.setBlockType = setBlockType;
    exports2.splitBlock = splitBlock;
    exports2.splitBlockAs = splitBlockAs;
    exports2.splitBlockKeepMarks = splitBlockKeepMarks;
    exports2.toggleMark = toggleMark;
    exports2.wrapIn = wrapIn;
  }
});

// node_modules/.pnpm/@tiptap+pm@3.11.0/node_modules/@tiptap/pm/dist/commands/index.cjs
var require_commands = __commonJS({
  "node_modules/.pnpm/@tiptap+pm@3.11.0/node_modules/@tiptap/pm/dist/commands/index.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function _createStarExport(obj) {
      Object.keys(obj).filter((key) => key !== "default" && key !== "__esModule").forEach((key) => {
        if (exports2.hasOwnProperty(key)) {
          return;
        }
        Object.defineProperty(exports2, key, { enumerable: true, configurable: true, get: () => obj[key] });
      });
    }
    var _prosemirrorcommands = require_dist5();
    _createStarExport(_prosemirrorcommands);
  }
});

// node_modules/.pnpm/@tiptap+pm@3.11.0/node_modules/@tiptap/pm/dist/state/index.cjs
var require_state = __commonJS({
  "node_modules/.pnpm/@tiptap+pm@3.11.0/node_modules/@tiptap/pm/dist/state/index.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function _createStarExport(obj) {
      Object.keys(obj).filter((key) => key !== "default" && key !== "__esModule").forEach((key) => {
        if (exports2.hasOwnProperty(key)) {
          return;
        }
        Object.defineProperty(exports2, key, { enumerable: true, configurable: true, get: () => obj[key] });
      });
    }
    var _prosemirrorstate = require_dist4();
    _createStarExport(_prosemirrorstate);
  }
});

// node_modules/.pnpm/@tiptap+pm@3.11.0/node_modules/@tiptap/pm/dist/model/index.cjs
var require_model = __commonJS({
  "node_modules/.pnpm/@tiptap+pm@3.11.0/node_modules/@tiptap/pm/dist/model/index.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function _createStarExport(obj) {
      Object.keys(obj).filter((key) => key !== "default" && key !== "__esModule").forEach((key) => {
        if (exports2.hasOwnProperty(key)) {
          return;
        }
        Object.defineProperty(exports2, key, { enumerable: true, configurable: true, get: () => obj[key] });
      });
    }
    var _prosemirrormodel = require_dist2();
    _createStarExport(_prosemirrormodel);
  }
});

// node_modules/.pnpm/prosemirror-schema-list@1.5.1/node_modules/prosemirror-schema-list/dist/index.cjs
var require_dist6 = __commonJS({
  "node_modules/.pnpm/prosemirror-schema-list@1.5.1/node_modules/prosemirror-schema-list/dist/index.cjs"(exports2) {
    "use strict";
    var prosemirrorTransform = require_dist3();
    var prosemirrorModel = require_dist2();
    var prosemirrorState = require_dist4();
    var olDOM = ["ol", 0];
    var ulDOM = ["ul", 0];
    var liDOM = ["li", 0];
    var orderedList = {
      attrs: {
        order: {
          "default": 1,
          validate: "number"
        }
      },
      parseDOM: [{
        tag: "ol",
        getAttrs: function getAttrs(dom) {
          return {
            order: dom.hasAttribute("start") ? +dom.getAttribute("start") : 1
          };
        }
      }],
      toDOM: function toDOM(node) {
        return node.attrs.order == 1 ? olDOM : ["ol", {
          start: node.attrs.order
        }, 0];
      }
    };
    var bulletList = {
      parseDOM: [{
        tag: "ul"
      }],
      toDOM: function toDOM() {
        return ulDOM;
      }
    };
    var listItem = {
      parseDOM: [{
        tag: "li"
      }],
      toDOM: function toDOM() {
        return liDOM;
      },
      defining: true
    };
    function add(obj, props) {
      var copy = {};
      for (var prop in obj) copy[prop] = obj[prop];
      for (var _prop in props) copy[_prop] = props[_prop];
      return copy;
    }
    function addListNodes(nodes, itemContent, listGroup) {
      return nodes.append({
        ordered_list: add(orderedList, {
          content: "list_item+",
          group: listGroup
        }),
        bullet_list: add(bulletList, {
          content: "list_item+",
          group: listGroup
        }),
        list_item: add(listItem, {
          content: itemContent
        })
      });
    }
    function wrapInList(listType) {
      var attrs = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      return function(state2, dispatch) {
        var _state$selection = state2.selection, $from = _state$selection.$from, $to = _state$selection.$to;
        var range2 = $from.blockRange($to);
        if (!range2) return false;
        var tr = dispatch ? state2.tr : null;
        if (!wrapRangeInList(tr, range2, listType, attrs)) return false;
        if (dispatch) dispatch(tr.scrollIntoView());
        return true;
      };
    }
    function wrapRangeInList(tr, range2, listType) {
      var attrs = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      var doJoin = false, outerRange = range2, doc = range2.$from.doc;
      if (range2.depth >= 2 && range2.$from.node(range2.depth - 1).type.compatibleContent(listType) && range2.startIndex == 0) {
        if (range2.$from.index(range2.depth - 1) == 0) return false;
        var $insert = doc.resolve(range2.start - 2);
        outerRange = new prosemirrorModel.NodeRange($insert, $insert, range2.depth);
        if (range2.endIndex < range2.parent.childCount) range2 = new prosemirrorModel.NodeRange(range2.$from, doc.resolve(range2.$to.end(range2.depth)), range2.depth);
        doJoin = true;
      }
      var wrap = prosemirrorTransform.findWrapping(outerRange, listType, attrs, range2);
      if (!wrap) return false;
      if (tr) doWrapInList(tr, range2, wrap, doJoin, listType);
      return true;
    }
    function doWrapInList(tr, range2, wrappers, joinBefore, listType) {
      var content = prosemirrorModel.Fragment.empty;
      for (var i = wrappers.length - 1; i >= 0; i--) content = prosemirrorModel.Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));
      tr.step(new prosemirrorTransform.ReplaceAroundStep(range2.start - (joinBefore ? 2 : 0), range2.end, range2.start, range2.end, new prosemirrorModel.Slice(content, 0, 0), wrappers.length, true));
      var found = 0;
      for (var _i = 0; _i < wrappers.length; _i++) if (wrappers[_i].type == listType) found = _i + 1;
      var splitDepth = wrappers.length - found;
      var splitPos = range2.start + wrappers.length - (joinBefore ? 2 : 0), parent = range2.parent;
      for (var _i2 = range2.startIndex, e = range2.endIndex, first = true; _i2 < e; _i2++, first = false) {
        if (!first && prosemirrorTransform.canSplit(tr.doc, splitPos, splitDepth)) {
          tr.split(splitPos, splitDepth);
          splitPos += 2 * splitDepth;
        }
        splitPos += parent.child(_i2).nodeSize;
      }
      return tr;
    }
    function splitListItem(itemType, itemAttrs) {
      return function(state2, dispatch) {
        var _state$selection2 = state2.selection, $from = _state$selection2.$from, $to = _state$selection2.$to, node = _state$selection2.node;
        if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) return false;
        var grandParent = $from.node(-1);
        if (grandParent.type != itemType) return false;
        if ($from.parent.content.size == 0 && $from.node(-1).childCount == $from.indexAfter(-1)) {
          if ($from.depth == 3 || $from.node(-3).type != itemType || $from.index(-2) != $from.node(-2).childCount - 1) return false;
          if (dispatch) {
            var wrap = prosemirrorModel.Fragment.empty;
            var depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;
            for (var d = $from.depth - depthBefore; d >= $from.depth - 3; d--) wrap = prosemirrorModel.Fragment.from($from.node(d).copy(wrap));
            var depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;
            wrap = wrap.append(prosemirrorModel.Fragment.from(itemType.createAndFill()));
            var start = $from.before($from.depth - (depthBefore - 1));
            var _tr = state2.tr.replace(start, $from.after(-depthAfter), new prosemirrorModel.Slice(wrap, 4 - depthBefore, 0));
            var sel = -1;
            _tr.doc.nodesBetween(start, _tr.doc.content.size, function(node2, pos) {
              if (sel > -1) return false;
              if (node2.isTextblock && node2.content.size == 0) sel = pos + 1;
            });
            if (sel > -1) _tr.setSelection(prosemirrorState.Selection.near(_tr.doc.resolve(sel)));
            dispatch(_tr.scrollIntoView());
          }
          return true;
        }
        var nextType = $to.pos == $from.end() ? grandParent.contentMatchAt(0).defaultType : null;
        var tr = state2.tr["delete"]($from.pos, $to.pos);
        var types2 = nextType ? [itemAttrs ? {
          type: itemType,
          attrs: itemAttrs
        } : null, {
          type: nextType
        }] : void 0;
        if (!prosemirrorTransform.canSplit(tr.doc, $from.pos, 2, types2)) return false;
        if (dispatch) dispatch(tr.split($from.pos, 2, types2).scrollIntoView());
        return true;
      };
    }
    function splitListItemKeepMarks(itemType, itemAttrs) {
      var split = splitListItem(itemType, itemAttrs);
      return function(state2, dispatch) {
        return split(state2, dispatch && function(tr) {
          var marks = state2.storedMarks || state2.selection.$to.parentOffset && state2.selection.$from.marks();
          if (marks) tr.ensureMarks(marks);
          dispatch(tr);
        });
      };
    }
    function liftListItem(itemType) {
      return function(state2, dispatch) {
        var _state$selection3 = state2.selection, $from = _state$selection3.$from, $to = _state$selection3.$to;
        var range2 = $from.blockRange($to, function(node) {
          return node.childCount > 0 && node.firstChild.type == itemType;
        });
        if (!range2) return false;
        if (!dispatch) return true;
        if ($from.node(range2.depth - 1).type == itemType) return liftToOuterList(state2, dispatch, itemType, range2);
        else return liftOutOfList(state2, dispatch, range2);
      };
    }
    function liftToOuterList(state2, dispatch, itemType, range2) {
      var tr = state2.tr, end = range2.end, endOfList = range2.$to.end(range2.depth);
      if (end < endOfList) {
        tr.step(new prosemirrorTransform.ReplaceAroundStep(end - 1, endOfList, end, endOfList, new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(itemType.create(null, range2.parent.copy())), 1, 0), 1, true));
        range2 = new prosemirrorModel.NodeRange(tr.doc.resolve(range2.$from.pos), tr.doc.resolve(endOfList), range2.depth);
      }
      var target = prosemirrorTransform.liftTarget(range2);
      if (target == null) return false;
      tr.lift(range2, target);
      var $after = tr.doc.resolve(tr.mapping.map(end, -1) - 1);
      if (prosemirrorTransform.canJoin(tr.doc, $after.pos) && $after.nodeBefore.type == $after.nodeAfter.type) tr.join($after.pos);
      dispatch(tr.scrollIntoView());
      return true;
    }
    function liftOutOfList(state2, dispatch, range2) {
      var tr = state2.tr, list = range2.parent;
      for (var pos = range2.end, i = range2.endIndex - 1, e = range2.startIndex; i > e; i--) {
        pos -= list.child(i).nodeSize;
        tr["delete"](pos - 1, pos + 1);
      }
      var $start = tr.doc.resolve(range2.start), item = $start.nodeAfter;
      if (tr.mapping.map(range2.end) != range2.start + $start.nodeAfter.nodeSize) return false;
      var atStart = range2.startIndex == 0, atEnd = range2.endIndex == list.childCount;
      var parent = $start.node(-1), indexBefore = $start.index(-1);
      if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, item.content.append(atEnd ? prosemirrorModel.Fragment.empty : prosemirrorModel.Fragment.from(list)))) return false;
      var start = $start.pos, end = start + item.nodeSize;
      tr.step(new prosemirrorTransform.ReplaceAroundStep(start - (atStart ? 1 : 0), end + (atEnd ? 1 : 0), start + 1, end - 1, new prosemirrorModel.Slice((atStart ? prosemirrorModel.Fragment.empty : prosemirrorModel.Fragment.from(list.copy(prosemirrorModel.Fragment.empty))).append(atEnd ? prosemirrorModel.Fragment.empty : prosemirrorModel.Fragment.from(list.copy(prosemirrorModel.Fragment.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));
      dispatch(tr.scrollIntoView());
      return true;
    }
    function sinkListItem(itemType) {
      return function(state2, dispatch) {
        var _state$selection4 = state2.selection, $from = _state$selection4.$from, $to = _state$selection4.$to;
        var range2 = $from.blockRange($to, function(node) {
          return node.childCount > 0 && node.firstChild.type == itemType;
        });
        if (!range2) return false;
        var startIndex = range2.startIndex;
        if (startIndex == 0) return false;
        var parent = range2.parent, nodeBefore = parent.child(startIndex - 1);
        if (nodeBefore.type != itemType) return false;
        if (dispatch) {
          var nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;
          var inner = prosemirrorModel.Fragment.from(nestedBefore ? itemType.create() : null);
          var slice = new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(itemType.create(null, prosemirrorModel.Fragment.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);
          var before = range2.start, after = range2.end;
          dispatch(state2.tr.step(new prosemirrorTransform.ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice, 1, true)).scrollIntoView());
        }
        return true;
      };
    }
    exports2.addListNodes = addListNodes;
    exports2.bulletList = bulletList;
    exports2.liftListItem = liftListItem;
    exports2.listItem = listItem;
    exports2.orderedList = orderedList;
    exports2.sinkListItem = sinkListItem;
    exports2.splitListItem = splitListItem;
    exports2.splitListItemKeepMarks = splitListItemKeepMarks;
    exports2.wrapInList = wrapInList;
    exports2.wrapRangeInList = wrapRangeInList;
  }
});

// node_modules/.pnpm/@tiptap+pm@3.11.0/node_modules/@tiptap/pm/dist/schema-list/index.cjs
var require_schema_list = __commonJS({
  "node_modules/.pnpm/@tiptap+pm@3.11.0/node_modules/@tiptap/pm/dist/schema-list/index.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function _createStarExport(obj) {
      Object.keys(obj).filter((key) => key !== "default" && key !== "__esModule").forEach((key) => {
        if (exports2.hasOwnProperty(key)) {
          return;
        }
        Object.defineProperty(exports2, key, { enumerable: true, configurable: true, get: () => obj[key] });
      });
    }
    var _prosemirrorschemalist = require_dist6();
    _createStarExport(_prosemirrorschemalist);
  }
});

// node_modules/.pnpm/prosemirror-view@1.41.3/node_modules/prosemirror-view/dist/index.cjs
var require_dist7 = __commonJS({
  "node_modules/.pnpm/prosemirror-view@1.41.3/node_modules/prosemirror-view/dist/index.cjs"(exports2) {
    "use strict";
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArrayLimit(r, l) {
      var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (null != t) {
        var e, n, i, u, a = [], f = true, o = false;
        try {
          if (i = (t = t.call(r)).next, 0 === l) {
            if (Object(t) !== t) return;
            f = false;
          } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
        } catch (r2) {
          o = true, n = r2;
        } finally {
          try {
            if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
          } finally {
            if (o) throw n;
          }
        }
        return a;
      }
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it) o = it;
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n() {
            if (i >= o.length) return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e) {
            throw _e;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = it.call(o);
      }, n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e2) {
        didErr = true;
        err = _e2;
      }, f: function f() {
        try {
          if (!normalCompletion && it["return"] != null) it["return"]();
        } finally {
          if (didErr) throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
      return arr2;
    }
    function _get() {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get.bind();
      } else {
        _get = function _get2(target, property, receiver) {
          var base = _superPropBase(target, property);
          if (!base) return;
          var desc = Object.getOwnPropertyDescriptor(base, property);
          if (desc.get) {
            return desc.get.call(arguments.length < 3 ? target : receiver);
          }
          return desc.value;
        };
      }
      return _get.apply(this, arguments);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null) break;
      }
      return object;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      Object.defineProperty(subClass, "prototype", { writable: false });
      if (superClass) _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return _typeof(key) === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (_typeof(input) !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (_typeof(res) !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var prosemirrorState = require_dist4();
    var prosemirrorModel = require_dist2();
    var prosemirrorTransform = require_dist3();
    var domIndex = function domIndex2(node) {
      for (var index = 0; ; index++) {
        node = node.previousSibling;
        if (!node) return index;
      }
    };
    var parentNode = function parentNode2(node) {
      var parent = node.assignedSlot || node.parentNode;
      return parent && parent.nodeType == 11 ? parent.host : parent;
    };
    var reusedRange = null;
    var textRange = function textRange2(node, from, to) {
      var range2 = reusedRange || (reusedRange = document.createRange());
      range2.setEnd(node, to == null ? node.nodeValue.length : to);
      range2.setStart(node, from || 0);
      return range2;
    };
    var clearReusedRange = function clearReusedRange2() {
      reusedRange = null;
    };
    var isEquivalentPosition = function isEquivalentPosition2(node, off, targetNode, targetOff) {
      return targetNode && (scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1));
    };
    var atomElements = /^(img|br|input|textarea|hr)$/i;
    function scanFor(node, off, targetNode, targetOff, dir) {
      var _a;
      for (; ; ) {
        if (node == targetNode && off == targetOff) return true;
        if (off == (dir < 0 ? 0 : nodeSize(node))) {
          var parent = node.parentNode;
          if (!parent || parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) || node.contentEditable == "false") return false;
          off = domIndex(node) + (dir < 0 ? 0 : 1);
          node = parent;
        } else if (node.nodeType == 1) {
          var child = node.childNodes[off + (dir < 0 ? -1 : 0)];
          if (child.nodeType == 1 && child.contentEditable == "false") {
            if ((_a = child.pmViewDesc) === null || _a === void 0 ? void 0 : _a.ignoreForSelection) off += dir;
            else return false;
          } else {
            node = child;
            off = dir < 0 ? nodeSize(node) : 0;
          }
        } else {
          return false;
        }
      }
    }
    function nodeSize(node) {
      return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
    }
    function textNodeBefore$1(node, offset) {
      for (; ; ) {
        if (node.nodeType == 3 && offset) return node;
        if (node.nodeType == 1 && offset > 0) {
          if (node.contentEditable == "false") return null;
          node = node.childNodes[offset - 1];
          offset = nodeSize(node);
        } else if (node.parentNode && !hasBlockDesc(node)) {
          offset = domIndex(node);
          node = node.parentNode;
        } else {
          return null;
        }
      }
    }
    function textNodeAfter$1(node, offset) {
      for (; ; ) {
        if (node.nodeType == 3 && offset < node.nodeValue.length) return node;
        if (node.nodeType == 1 && offset < node.childNodes.length) {
          if (node.contentEditable == "false") return null;
          node = node.childNodes[offset];
          offset = 0;
        } else if (node.parentNode && !hasBlockDesc(node)) {
          offset = domIndex(node) + 1;
          node = node.parentNode;
        } else {
          return null;
        }
      }
    }
    function isOnEdge(node, offset, parent) {
      for (var atStart = offset == 0, atEnd = offset == nodeSize(node); atStart || atEnd; ) {
        if (node == parent) return true;
        var index = domIndex(node);
        node = node.parentNode;
        if (!node) return false;
        atStart = atStart && index == 0;
        atEnd = atEnd && index == nodeSize(node);
      }
    }
    function hasBlockDesc(dom) {
      var desc;
      for (var cur = dom; cur; cur = cur.parentNode) if (desc = cur.pmViewDesc) break;
      return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);
    }
    var selectionCollapsed = function selectionCollapsed2(domSel) {
      return domSel.focusNode && isEquivalentPosition(domSel.focusNode, domSel.focusOffset, domSel.anchorNode, domSel.anchorOffset);
    };
    function keyEvent(keyCode, key) {
      var event = document.createEvent("Event");
      event.initEvent("keydown", true, true);
      event.keyCode = keyCode;
      event.key = event.code = key;
      return event;
    }
    function deepActiveElement(doc2) {
      var elt = doc2.activeElement;
      while (elt && elt.shadowRoot) elt = elt.shadowRoot.activeElement;
      return elt;
    }
    function caretFromPoint(doc2, x, y) {
      if (doc2.caretPositionFromPoint) {
        try {
          var pos = doc2.caretPositionFromPoint(x, y);
          if (pos) return {
            node: pos.offsetNode,
            offset: Math.min(nodeSize(pos.offsetNode), pos.offset)
          };
        } catch (_) {
        }
      }
      if (doc2.caretRangeFromPoint) {
        var range2 = doc2.caretRangeFromPoint(x, y);
        if (range2) return {
          node: range2.startContainer,
          offset: Math.min(nodeSize(range2.startContainer), range2.startOffset)
        };
      }
    }
    var nav = typeof navigator != "undefined" ? navigator : null;
    var doc = typeof document != "undefined" ? document : null;
    var agent = nav && nav.userAgent || "";
    var ie_edge = /Edge\/(\d+)/.exec(agent);
    var ie_upto10 = /MSIE \d/.exec(agent);
    var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(agent);
    var ie = !!(ie_upto10 || ie_11up || ie_edge);
    var ie_version = ie_upto10 ? document.documentMode : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0;
    var gecko = !ie && /gecko\/(\d+)/i.test(agent);
    gecko && +(/Firefox\/(\d+)/.exec(agent) || [0, 0])[1];
    var _chrome = !ie && /Chrome\/(\d+)/.exec(agent);
    var chrome = !!_chrome;
    var chrome_version = _chrome ? +_chrome[1] : 0;
    var safari = !ie && !!nav && /Apple Computer/.test(nav.vendor);
    var ios = safari && (/Mobile\/\w+/.test(agent) || !!nav && nav.maxTouchPoints > 2);
    var mac = ios || (nav ? /Mac/.test(nav.platform) : false);
    var windows = nav ? /Win/.test(nav.platform) : false;
    var android = /Android \d/.test(agent);
    var webkit = !!doc && "webkitFontSmoothing" in doc.documentElement.style;
    var webkit_version = webkit ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
    function windowRect(doc2) {
      var vp = doc2.defaultView && doc2.defaultView.visualViewport;
      if (vp) return {
        left: 0,
        right: vp.width,
        top: 0,
        bottom: vp.height
      };
      return {
        left: 0,
        right: doc2.documentElement.clientWidth,
        top: 0,
        bottom: doc2.documentElement.clientHeight
      };
    }
    function getSide(value, side) {
      return typeof value == "number" ? value : value[side];
    }
    function clientRect(node) {
      var rect = node.getBoundingClientRect();
      var scaleX = rect.width / node.offsetWidth || 1;
      var scaleY = rect.height / node.offsetHeight || 1;
      return {
        left: rect.left,
        right: rect.left + node.clientWidth * scaleX,
        top: rect.top,
        bottom: rect.top + node.clientHeight * scaleY
      };
    }
    function scrollRectIntoView(view, rect, startDOM) {
      var scrollThreshold = view.someProp("scrollThreshold") || 0, scrollMargin = view.someProp("scrollMargin") || 5;
      var doc2 = view.dom.ownerDocument;
      for (var parent = startDOM || view.dom; ; ) {
        if (!parent) break;
        if (parent.nodeType != 1) {
          parent = parentNode(parent);
          continue;
        }
        var elt = parent;
        var atTop = elt == doc2.body;
        var bounding = atTop ? windowRect(doc2) : clientRect(elt);
        var moveX = 0, moveY = 0;
        if (rect.top < bounding.top + getSide(scrollThreshold, "top")) moveY = -(bounding.top - rect.top + getSide(scrollMargin, "top"));
        else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, "bottom")) moveY = rect.bottom - rect.top > bounding.bottom - bounding.top ? rect.top + getSide(scrollMargin, "top") - bounding.top : rect.bottom - bounding.bottom + getSide(scrollMargin, "bottom");
        if (rect.left < bounding.left + getSide(scrollThreshold, "left")) moveX = -(bounding.left - rect.left + getSide(scrollMargin, "left"));
        else if (rect.right > bounding.right - getSide(scrollThreshold, "right")) moveX = rect.right - bounding.right + getSide(scrollMargin, "right");
        if (moveX || moveY) {
          if (atTop) {
            doc2.defaultView.scrollBy(moveX, moveY);
          } else {
            var startX = elt.scrollLeft, startY = elt.scrollTop;
            if (moveY) elt.scrollTop += moveY;
            if (moveX) elt.scrollLeft += moveX;
            var dX = elt.scrollLeft - startX, dY = elt.scrollTop - startY;
            rect = {
              left: rect.left - dX,
              top: rect.top - dY,
              right: rect.right - dX,
              bottom: rect.bottom - dY
            };
          }
        }
        var pos = atTop ? "fixed" : getComputedStyle(parent).position;
        if (/^(fixed|sticky)$/.test(pos)) break;
        parent = pos == "absolute" ? parent.offsetParent : parentNode(parent);
      }
    }
    function storeScrollPos(view) {
      var rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);
      var refDOM, refTop;
      for (var x = (rect.left + rect.right) / 2, y = startY + 1; y < Math.min(innerHeight, rect.bottom); y += 5) {
        var dom = view.root.elementFromPoint(x, y);
        if (!dom || dom == view.dom || !view.dom.contains(dom)) continue;
        var localRect = dom.getBoundingClientRect();
        if (localRect.top >= startY - 20) {
          refDOM = dom;
          refTop = localRect.top;
          break;
        }
      }
      return {
        refDOM,
        refTop,
        stack: scrollStack(view.dom)
      };
    }
    function scrollStack(dom) {
      var stack = [], doc2 = dom.ownerDocument;
      for (var cur = dom; cur; cur = parentNode(cur)) {
        stack.push({
          dom: cur,
          top: cur.scrollTop,
          left: cur.scrollLeft
        });
        if (dom == doc2) break;
      }
      return stack;
    }
    function resetScrollPos(_ref) {
      var refDOM = _ref.refDOM, refTop = _ref.refTop, stack = _ref.stack;
      var newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;
      restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop);
    }
    function restoreScrollStack(stack, dTop) {
      for (var i = 0; i < stack.length; i++) {
        var _stack$i = stack[i], dom = _stack$i.dom, top = _stack$i.top, left = _stack$i.left;
        if (dom.scrollTop != top + dTop) dom.scrollTop = top + dTop;
        if (dom.scrollLeft != left) dom.scrollLeft = left;
      }
    }
    var preventScrollSupported = null;
    function focusPreventScroll(dom) {
      if (dom.setActive) return dom.setActive();
      if (preventScrollSupported) return dom.focus(preventScrollSupported);
      var stored = scrollStack(dom);
      dom.focus(preventScrollSupported == null ? {
        get preventScroll() {
          preventScrollSupported = {
            preventScroll: true
          };
          return true;
        }
      } : void 0);
      if (!preventScrollSupported) {
        preventScrollSupported = false;
        restoreScrollStack(stored, 0);
      }
    }
    function findOffsetInNode(node, coords) {
      var closest, dxClosest = 2e8, coordsClosest, offset = 0;
      var rowBot = coords.top, rowTop = coords.top;
      var firstBelow, coordsBelow;
      for (var child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {
        var rects = void 0;
        if (child.nodeType == 1) rects = child.getClientRects();
        else if (child.nodeType == 3) rects = textRange(child).getClientRects();
        else continue;
        for (var i = 0; i < rects.length; i++) {
          var rect = rects[i];
          if (rect.top <= rowBot && rect.bottom >= rowTop) {
            rowBot = Math.max(rect.bottom, rowBot);
            rowTop = Math.min(rect.top, rowTop);
            var dx = rect.left > coords.left ? rect.left - coords.left : rect.right < coords.left ? coords.left - rect.right : 0;
            if (dx < dxClosest) {
              closest = child;
              dxClosest = dx;
              coordsClosest = dx && closest.nodeType == 3 ? {
                left: rect.right < coords.left ? rect.right : rect.left,
                top: coords.top
              } : coords;
              if (child.nodeType == 1 && dx) offset = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);
              continue;
            }
          } else if (rect.top > coords.top && !firstBelow && rect.left <= coords.left && rect.right >= coords.left) {
            firstBelow = child;
            coordsBelow = {
              left: Math.max(rect.left, Math.min(rect.right, coords.left)),
              top: rect.top
            };
          }
          if (!closest && (coords.left >= rect.right && coords.top >= rect.top || coords.left >= rect.left && coords.top >= rect.bottom)) offset = childIndex + 1;
        }
      }
      if (!closest && firstBelow) {
        closest = firstBelow;
        coordsClosest = coordsBelow;
        dxClosest = 0;
      }
      if (closest && closest.nodeType == 3) return findOffsetInText(closest, coordsClosest);
      if (!closest || dxClosest && closest.nodeType == 1) return {
        node,
        offset
      };
      return findOffsetInNode(closest, coordsClosest);
    }
    function findOffsetInText(node, coords) {
      var len = node.nodeValue.length;
      var range2 = document.createRange();
      for (var i = 0; i < len; i++) {
        range2.setEnd(node, i + 1);
        range2.setStart(node, i);
        var rect = singleRect(range2, 1);
        if (rect.top == rect.bottom) continue;
        if (inRect(coords, rect)) return {
          node,
          offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0)
        };
      }
      return {
        node,
        offset: 0
      };
    }
    function inRect(coords, rect) {
      return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 && coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;
    }
    function targetKludge(dom, coords) {
      var parent = dom.parentNode;
      if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left) return parent;
      return dom;
    }
    function posFromElement(view, elt, coords) {
      var _findOffsetInNode = findOffsetInNode(elt, coords), node = _findOffsetInNode.node, offset = _findOffsetInNode.offset, bias = -1;
      if (node.nodeType == 1 && !node.firstChild) {
        var rect = node.getBoundingClientRect();
        bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;
      }
      return view.docView.posFromDOM(node, offset, bias);
    }
    function posFromCaret(view, node, offset, coords) {
      var outsideBlock = -1;
      for (var cur = node, sawBlock = false; ; ) {
        if (cur == view.dom) break;
        var desc = view.docView.nearestDesc(cur, true), rect = void 0;
        if (!desc) return null;
        if (desc.dom.nodeType == 1 && (desc.node.isBlock && desc.parent || !desc.contentDOM) && ((rect = desc.dom.getBoundingClientRect()).width || rect.height)) {
          if (desc.node.isBlock && desc.parent && !/^T(R|BODY|HEAD|FOOT)$/.test(desc.dom.nodeName)) {
            if (!sawBlock && rect.left > coords.left || rect.top > coords.top) outsideBlock = desc.posBefore;
            else if (!sawBlock && rect.right < coords.left || rect.bottom < coords.top) outsideBlock = desc.posAfter;
            sawBlock = true;
          }
          if (!desc.contentDOM && outsideBlock < 0 && !desc.node.isText) {
            var before = desc.node.isBlock ? coords.top < (rect.top + rect.bottom) / 2 : coords.left < (rect.left + rect.right) / 2;
            return before ? desc.posBefore : desc.posAfter;
          }
        }
        cur = desc.dom.parentNode;
      }
      return outsideBlock > -1 ? outsideBlock : view.docView.posFromDOM(node, offset, -1);
    }
    function elementFromPoint(element, coords, box) {
      var len = element.childNodes.length;
      if (len && box.top < box.bottom) {
        for (var startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i = startI; ; ) {
          var child = element.childNodes[i];
          if (child.nodeType == 1) {
            var rects = child.getClientRects();
            for (var j = 0; j < rects.length; j++) {
              var rect = rects[j];
              if (inRect(coords, rect)) return elementFromPoint(child, coords, rect);
            }
          }
          if ((i = (i + 1) % len) == startI) break;
        }
      }
      return element;
    }
    function _posAtCoords(view, coords) {
      var doc2 = view.dom.ownerDocument, node, offset = 0;
      var caret = caretFromPoint(doc2, coords.left, coords.top);
      if (caret) {
        node = caret.node;
        offset = caret.offset;
      }
      var elt = (view.root.elementFromPoint ? view.root : doc2).elementFromPoint(coords.left, coords.top);
      var pos;
      if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {
        var box = view.dom.getBoundingClientRect();
        if (!inRect(coords, box)) return null;
        elt = elementFromPoint(view.dom, coords, box);
        if (!elt) return null;
      }
      if (safari) {
        for (var p = elt; node && p; p = parentNode(p)) if (p.draggable) node = void 0;
      }
      elt = targetKludge(elt, coords);
      if (node) {
        if (gecko && node.nodeType == 1) {
          offset = Math.min(offset, node.childNodes.length);
          if (offset < node.childNodes.length) {
            var next = node.childNodes[offset], _box;
            if (next.nodeName == "IMG" && (_box = next.getBoundingClientRect()).right <= coords.left && _box.bottom > coords.top) offset++;
          }
        }
        var prev;
        if (webkit && offset && node.nodeType == 1 && (prev = node.childNodes[offset - 1]).nodeType == 1 && prev.contentEditable == "false" && prev.getBoundingClientRect().top >= coords.top) offset--;
        if (node == view.dom && offset == node.childNodes.length - 1 && node.lastChild.nodeType == 1 && coords.top > node.lastChild.getBoundingClientRect().bottom) pos = view.state.doc.content.size;
        else if (offset == 0 || node.nodeType != 1 || node.childNodes[offset - 1].nodeName != "BR") pos = posFromCaret(view, node, offset, coords);
      }
      if (pos == null) pos = posFromElement(view, elt, coords);
      var desc = view.docView.nearestDesc(elt, true);
      return {
        pos,
        inside: desc ? desc.posAtStart - desc.border : -1
      };
    }
    function nonZero(rect) {
      return rect.top < rect.bottom || rect.left < rect.right;
    }
    function singleRect(target, bias) {
      var rects = target.getClientRects();
      if (rects.length) {
        var first = rects[bias < 0 ? 0 : rects.length - 1];
        if (nonZero(first)) return first;
      }
      return Array.prototype.find.call(rects, nonZero) || target.getBoundingClientRect();
    }
    var BIDI = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
    function _coordsAtPos(view, pos, side) {
      var _view$docView$domFrom = view.docView.domFromPos(pos, side < 0 ? -1 : 1), node = _view$docView$domFrom.node, offset = _view$docView$domFrom.offset, atom = _view$docView$domFrom.atom;
      var supportEmptyRange = webkit || gecko;
      if (node.nodeType == 3) {
        if (supportEmptyRange && (BIDI.test(node.nodeValue) || (side < 0 ? !offset : offset == node.nodeValue.length))) {
          var rect = singleRect(textRange(node, offset, offset), side);
          if (gecko && offset && /\s/.test(node.nodeValue[offset - 1]) && offset < node.nodeValue.length) {
            var rectBefore = singleRect(textRange(node, offset - 1, offset - 1), -1);
            if (rectBefore.top == rect.top) {
              var rectAfter = singleRect(textRange(node, offset, offset + 1), -1);
              if (rectAfter.top != rect.top) return flattenV(rectAfter, rectAfter.left < rectBefore.left);
            }
          }
          return rect;
        } else {
          var from = offset, to = offset, takeSide = side < 0 ? 1 : -1;
          if (side < 0 && !offset) {
            to++;
            takeSide = -1;
          } else if (side >= 0 && offset == node.nodeValue.length) {
            from--;
            takeSide = 1;
          } else if (side < 0) {
            from--;
          } else {
            to++;
          }
          return flattenV(singleRect(textRange(node, from, to), takeSide), takeSide < 0);
        }
      }
      var $dom = view.state.doc.resolve(pos - (atom || 0));
      if (!$dom.parent.inlineContent) {
        if (atom == null && offset && (side < 0 || offset == nodeSize(node))) {
          var before = node.childNodes[offset - 1];
          if (before.nodeType == 1) return flattenH(before.getBoundingClientRect(), false);
        }
        if (atom == null && offset < nodeSize(node)) {
          var after = node.childNodes[offset];
          if (after.nodeType == 1) return flattenH(after.getBoundingClientRect(), true);
        }
        return flattenH(node.getBoundingClientRect(), side >= 0);
      }
      if (atom == null && offset && (side < 0 || offset == nodeSize(node))) {
        var _before = node.childNodes[offset - 1];
        var target = _before.nodeType == 3 ? textRange(_before, nodeSize(_before) - (supportEmptyRange ? 0 : 1)) : _before.nodeType == 1 && (_before.nodeName != "BR" || !_before.nextSibling) ? _before : null;
        if (target) return flattenV(singleRect(target, 1), false);
      }
      if (atom == null && offset < nodeSize(node)) {
        var _after = node.childNodes[offset];
        while (_after.pmViewDesc && _after.pmViewDesc.ignoreForCoords) _after = _after.nextSibling;
        var _target = !_after ? null : _after.nodeType == 3 ? textRange(_after, 0, supportEmptyRange ? 0 : 1) : _after.nodeType == 1 ? _after : null;
        if (_target) return flattenV(singleRect(_target, -1), true);
      }
      return flattenV(singleRect(node.nodeType == 3 ? textRange(node) : node, -side), side >= 0);
    }
    function flattenV(rect, left) {
      if (rect.width == 0) return rect;
      var x = left ? rect.left : rect.right;
      return {
        top: rect.top,
        bottom: rect.bottom,
        left: x,
        right: x
      };
    }
    function flattenH(rect, top) {
      if (rect.height == 0) return rect;
      var y = top ? rect.top : rect.bottom;
      return {
        top: y,
        bottom: y,
        left: rect.left,
        right: rect.right
      };
    }
    function withFlushedState(view, state2, f) {
      var viewState = view.state, active = view.root.activeElement;
      if (viewState != state2) view.updateState(state2);
      if (active != view.dom) view.focus();
      try {
        return f();
      } finally {
        if (viewState != state2) view.updateState(viewState);
        if (active != view.dom && active) active.focus();
      }
    }
    function endOfTextblockVertical(view, state2, dir) {
      var sel = state2.selection;
      var $pos = dir == "up" ? sel.$from : sel.$to;
      return withFlushedState(view, state2, function() {
        var _view$docView$domFrom2 = view.docView.domFromPos($pos.pos, dir == "up" ? -1 : 1), dom = _view$docView$domFrom2.node;
        for (; ; ) {
          var nearest = view.docView.nearestDesc(dom, true);
          if (!nearest) break;
          if (nearest.node.isBlock) {
            dom = nearest.contentDOM || nearest.dom;
            break;
          }
          dom = nearest.dom.parentNode;
        }
        var coords = _coordsAtPos(view, $pos.pos, 1);
        for (var child = dom.firstChild; child; child = child.nextSibling) {
          var boxes = void 0;
          if (child.nodeType == 1) boxes = child.getClientRects();
          else if (child.nodeType == 3) boxes = textRange(child, 0, child.nodeValue.length).getClientRects();
          else continue;
          for (var i = 0; i < boxes.length; i++) {
            var box = boxes[i];
            if (box.bottom > box.top + 1 && (dir == "up" ? coords.top - box.top > (box.bottom - coords.top) * 2 : box.bottom - coords.bottom > (coords.bottom - box.top) * 2)) return false;
          }
        }
        return true;
      });
    }
    var maybeRTL = /[\u0590-\u08ac]/;
    function endOfTextblockHorizontal(view, state2, dir) {
      var $head = state2.selection.$head;
      if (!$head.parent.isTextblock) return false;
      var offset = $head.parentOffset, atStart = !offset, atEnd = offset == $head.parent.content.size;
      var sel = view.domSelection();
      if (!sel) return $head.pos == $head.start() || $head.pos == $head.end();
      if (!maybeRTL.test($head.parent.textContent) || !sel.modify) return dir == "left" || dir == "backward" ? atStart : atEnd;
      return withFlushedState(view, state2, function() {
        var _view$domSelectionRan = view.domSelectionRange(), oldNode = _view$domSelectionRan.focusNode, oldOff = _view$domSelectionRan.focusOffset, anchorNode = _view$domSelectionRan.anchorNode, anchorOffset = _view$domSelectionRan.anchorOffset;
        var oldBidiLevel = sel.caretBidiLevel;
        sel.modify("move", dir, "character");
        var parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;
        var _view$domSelectionRan2 = view.domSelectionRange(), newNode = _view$domSelectionRan2.focusNode, newOff = _view$domSelectionRan2.focusOffset;
        var result = newNode && !parentDOM.contains(newNode.nodeType == 1 ? newNode : newNode.parentNode) || oldNode == newNode && oldOff == newOff;
        try {
          sel.collapse(anchorNode, anchorOffset);
          if (oldNode && (oldNode != anchorNode || oldOff != anchorOffset) && sel.extend) sel.extend(oldNode, oldOff);
        } catch (_) {
        }
        if (oldBidiLevel != null) sel.caretBidiLevel = oldBidiLevel;
        return result;
      });
    }
    var cachedState = null;
    var cachedDir = null;
    var cachedResult = false;
    function _endOfTextblock(view, state2, dir) {
      if (cachedState == state2 && cachedDir == dir) return cachedResult;
      cachedState = state2;
      cachedDir = dir;
      return cachedResult = dir == "up" || dir == "down" ? endOfTextblockVertical(view, state2, dir) : endOfTextblockHorizontal(view, state2, dir);
    }
    var NOT_DIRTY = 0;
    var CHILD_DIRTY = 1;
    var CONTENT_DIRTY = 2;
    var NODE_DIRTY = 3;
    var ViewDesc = (function() {
      function ViewDesc2(parent, children, dom, contentDOM) {
        _classCallCheck(this, ViewDesc2);
        this.parent = parent;
        this.children = children;
        this.dom = dom;
        this.contentDOM = contentDOM;
        this.dirty = NOT_DIRTY;
        dom.pmViewDesc = this;
      }
      _createClass(ViewDesc2, [{
        key: "matchesWidget",
        value: function matchesWidget(widget) {
          return false;
        }
      }, {
        key: "matchesMark",
        value: function matchesMark(mark) {
          return false;
        }
      }, {
        key: "matchesNode",
        value: function matchesNode(node, outerDeco, innerDeco) {
          return false;
        }
      }, {
        key: "matchesHack",
        value: function matchesHack(nodeName) {
          return false;
        }
      }, {
        key: "parseRule",
        value: function parseRule() {
          return null;
        }
      }, {
        key: "stopEvent",
        value: function stopEvent(event) {
          return false;
        }
      }, {
        key: "size",
        get: function get2() {
          var size = 0;
          for (var i = 0; i < this.children.length; i++) size += this.children[i].size;
          return size;
        }
      }, {
        key: "border",
        get: function get2() {
          return 0;
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.parent = void 0;
          if (this.dom.pmViewDesc == this) this.dom.pmViewDesc = void 0;
          for (var i = 0; i < this.children.length; i++) this.children[i].destroy();
        }
      }, {
        key: "posBeforeChild",
        value: function posBeforeChild(child) {
          for (var i = 0, pos = this.posAtStart; ; i++) {
            var cur = this.children[i];
            if (cur == child) return pos;
            pos += cur.size;
          }
        }
      }, {
        key: "posBefore",
        get: function get2() {
          return this.parent.posBeforeChild(this);
        }
      }, {
        key: "posAtStart",
        get: function get2() {
          return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
        }
      }, {
        key: "posAfter",
        get: function get2() {
          return this.posBefore + this.size;
        }
      }, {
        key: "posAtEnd",
        get: function get2() {
          return this.posAtStart + this.size - 2 * this.border;
        }
      }, {
        key: "localPosFromDOM",
        value: function localPosFromDOM(dom, offset, bias) {
          if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {
            if (bias < 0) {
              var domBefore, desc;
              if (dom == this.contentDOM) {
                domBefore = dom.childNodes[offset - 1];
              } else {
                while (dom.parentNode != this.contentDOM) dom = dom.parentNode;
                domBefore = dom.previousSibling;
              }
              while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this)) domBefore = domBefore.previousSibling;
              return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;
            } else {
              var domAfter, _desc;
              if (dom == this.contentDOM) {
                domAfter = dom.childNodes[offset];
              } else {
                while (dom.parentNode != this.contentDOM) dom = dom.parentNode;
                domAfter = dom.nextSibling;
              }
              while (domAfter && !((_desc = domAfter.pmViewDesc) && _desc.parent == this)) domAfter = domAfter.nextSibling;
              return domAfter ? this.posBeforeChild(_desc) : this.posAtEnd;
            }
          }
          var atEnd;
          if (dom == this.dom && this.contentDOM) {
            atEnd = offset > domIndex(this.contentDOM);
          } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {
            atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;
          } else if (this.dom.firstChild) {
            if (offset == 0) for (var search = dom; ; search = search.parentNode) {
              if (search == this.dom) {
                atEnd = false;
                break;
              }
              if (search.previousSibling) break;
            }
            if (atEnd == null && offset == dom.childNodes.length) for (var _search = dom; ; _search = _search.parentNode) {
              if (_search == this.dom) {
                atEnd = true;
                break;
              }
              if (_search.nextSibling) break;
            }
          }
          return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart;
        }
      }, {
        key: "nearestDesc",
        value: function nearestDesc(dom) {
          var onlyNodes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          for (var first = true, cur = dom; cur; cur = cur.parentNode) {
            var desc = this.getDesc(cur), nodeDOM = void 0;
            if (desc && (!onlyNodes || desc.node)) {
              if (first && (nodeDOM = desc.nodeDOM) && !(nodeDOM.nodeType == 1 ? nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : nodeDOM == dom)) first = false;
              else return desc;
            }
          }
        }
      }, {
        key: "getDesc",
        value: function getDesc(dom) {
          var desc = dom.pmViewDesc;
          for (var cur = desc; cur; cur = cur.parent) if (cur == this) return desc;
        }
      }, {
        key: "posFromDOM",
        value: function posFromDOM(dom, offset, bias) {
          for (var scan = dom; scan; scan = scan.parentNode) {
            var desc = this.getDesc(scan);
            if (desc) return desc.localPosFromDOM(dom, offset, bias);
          }
          return -1;
        }
      }, {
        key: "descAt",
        value: function descAt(pos) {
          for (var i = 0, offset = 0; i < this.children.length; i++) {
            var child = this.children[i], end = offset + child.size;
            if (offset == pos && end != offset) {
              while (!child.border && child.children.length) {
                for (var _i = 0; _i < child.children.length; _i++) {
                  var inner = child.children[_i];
                  if (inner.size) {
                    child = inner;
                    break;
                  }
                }
              }
              return child;
            }
            if (pos < end) return child.descAt(pos - offset - child.border);
            offset = end;
          }
        }
      }, {
        key: "domFromPos",
        value: function domFromPos(pos, side) {
          if (!this.contentDOM) return {
            node: this.dom,
            offset: 0,
            atom: pos + 1
          };
          var i = 0, offset = 0;
          for (var curPos = 0; i < this.children.length; i++) {
            var child = this.children[i], end = curPos + child.size;
            if (end > pos || child instanceof TrailingHackViewDesc) {
              offset = pos - curPos;
              break;
            }
            curPos = end;
          }
          if (offset) return this.children[i].domFromPos(offset - this.children[i].border, side);
          for (var prev; i && !(prev = this.children[i - 1]).size && prev instanceof WidgetViewDesc && prev.side >= 0; i--) {
          }
          if (side <= 0) {
            var _prev, enter = true;
            for (; ; i--, enter = false) {
              _prev = i ? this.children[i - 1] : null;
              if (!_prev || _prev.dom.parentNode == this.contentDOM) break;
            }
            if (_prev && side && enter && !_prev.border && !_prev.domAtom) return _prev.domFromPos(_prev.size, side);
            return {
              node: this.contentDOM,
              offset: _prev ? domIndex(_prev.dom) + 1 : 0
            };
          } else {
            var next, _enter = true;
            for (; ; i++, _enter = false) {
              next = i < this.children.length ? this.children[i] : null;
              if (!next || next.dom.parentNode == this.contentDOM) break;
            }
            if (next && _enter && !next.border && !next.domAtom) return next.domFromPos(0, side);
            return {
              node: this.contentDOM,
              offset: next ? domIndex(next.dom) : this.contentDOM.childNodes.length
            };
          }
        }
      }, {
        key: "parseRange",
        value: function parseRange(from, to) {
          var base = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
          if (this.children.length == 0) return {
            node: this.contentDOM,
            from,
            to,
            fromOffset: 0,
            toOffset: this.contentDOM.childNodes.length
          };
          var fromOffset = -1, toOffset = -1;
          for (var offset = base, i = 0; ; i++) {
            var child = this.children[i], end = offset + child.size;
            if (fromOffset == -1 && from <= end) {
              var childBase = offset + child.border;
              if (from >= childBase && to <= end - child.border && child.node && child.contentDOM && this.contentDOM.contains(child.contentDOM)) return child.parseRange(from, to, childBase);
              from = offset;
              for (var j = i; j > 0; j--) {
                var prev = this.children[j - 1];
                if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {
                  fromOffset = domIndex(prev.dom) + 1;
                  break;
                }
                from -= prev.size;
              }
              if (fromOffset == -1) fromOffset = 0;
            }
            if (fromOffset > -1 && (end > to || i == this.children.length - 1)) {
              to = end;
              for (var _j = i + 1; _j < this.children.length; _j++) {
                var next = this.children[_j];
                if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {
                  toOffset = domIndex(next.dom);
                  break;
                }
                to += next.size;
              }
              if (toOffset == -1) toOffset = this.contentDOM.childNodes.length;
              break;
            }
            offset = end;
          }
          return {
            node: this.contentDOM,
            from,
            to,
            fromOffset,
            toOffset
          };
        }
      }, {
        key: "emptyChildAt",
        value: function emptyChildAt(side) {
          if (this.border || !this.contentDOM || !this.children.length) return false;
          var child = this.children[side < 0 ? 0 : this.children.length - 1];
          return child.size == 0 || child.emptyChildAt(side);
        }
      }, {
        key: "domAfterPos",
        value: function domAfterPos(pos) {
          var _this$domFromPos = this.domFromPos(pos, 0), node = _this$domFromPos.node, offset = _this$domFromPos.offset;
          if (node.nodeType != 1 || offset == node.childNodes.length) throw new RangeError("No node after pos " + pos);
          return node.childNodes[offset];
        }
      }, {
        key: "setSelection",
        value: function setSelection(anchor, head, view) {
          var force = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
          var from = Math.min(anchor, head), to = Math.max(anchor, head);
          for (var i = 0, offset = 0; i < this.children.length; i++) {
            var child = this.children[i], end = offset + child.size;
            if (from > offset && to < end) return child.setSelection(anchor - offset - child.border, head - offset - child.border, view, force);
            offset = end;
          }
          var anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);
          var headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);
          var domSel = view.root.getSelection();
          var selRange = view.domSelectionRange();
          var brKludge = false;
          if ((gecko || safari) && anchor == head) {
            var _anchorDOM = anchorDOM, node = _anchorDOM.node, _offset = _anchorDOM.offset;
            if (node.nodeType == 3) {
              brKludge = !!(_offset && node.nodeValue[_offset - 1] == "\n");
              if (brKludge && _offset == node.nodeValue.length) {
                for (var scan = node, after; scan; scan = scan.parentNode) {
                  if (after = scan.nextSibling) {
                    if (after.nodeName == "BR") anchorDOM = headDOM = {
                      node: after.parentNode,
                      offset: domIndex(after) + 1
                    };
                    break;
                  }
                  var desc = scan.pmViewDesc;
                  if (desc && desc.node && desc.node.isBlock) break;
                }
              }
            } else {
              var prev = node.childNodes[_offset - 1];
              brKludge = prev && (prev.nodeName == "BR" || prev.contentEditable == "false");
            }
          }
          if (gecko && selRange.focusNode && selRange.focusNode != headDOM.node && selRange.focusNode.nodeType == 1) {
            var _after2 = selRange.focusNode.childNodes[selRange.focusOffset];
            if (_after2 && _after2.contentEditable == "false") force = true;
          }
          if (!(force || brKludge && safari) && isEquivalentPosition(anchorDOM.node, anchorDOM.offset, selRange.anchorNode, selRange.anchorOffset) && isEquivalentPosition(headDOM.node, headDOM.offset, selRange.focusNode, selRange.focusOffset)) return;
          var domSelExtended = false;
          if ((domSel.extend || anchor == head) && !(brKludge && gecko)) {
            domSel.collapse(anchorDOM.node, anchorDOM.offset);
            try {
              if (anchor != head) domSel.extend(headDOM.node, headDOM.offset);
              domSelExtended = true;
            } catch (_) {
            }
          }
          if (!domSelExtended) {
            if (anchor > head) {
              var tmp = anchorDOM;
              anchorDOM = headDOM;
              headDOM = tmp;
            }
            var range2 = document.createRange();
            range2.setEnd(headDOM.node, headDOM.offset);
            range2.setStart(anchorDOM.node, anchorDOM.offset);
            domSel.removeAllRanges();
            domSel.addRange(range2);
          }
        }
      }, {
        key: "ignoreMutation",
        value: function ignoreMutation(mutation) {
          return !this.contentDOM && mutation.type != "selection";
        }
      }, {
        key: "contentLost",
        get: function get2() {
          return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
        }
      }, {
        key: "markDirty",
        value: function markDirty(from, to) {
          for (var offset = 0, i = 0; i < this.children.length; i++) {
            var child = this.children[i], end = offset + child.size;
            if (offset == end ? from <= end && to >= offset : from < end && to > offset) {
              var startInside = offset + child.border, endInside = end - child.border;
              if (from >= startInside && to <= endInside) {
                this.dirty = from == offset || to == end ? CONTENT_DIRTY : CHILD_DIRTY;
                if (from == startInside && to == endInside && (child.contentLost || child.dom.parentNode != this.contentDOM)) child.dirty = NODE_DIRTY;
                else child.markDirty(from - startInside, to - startInside);
                return;
              } else {
                child.dirty = child.dom == child.contentDOM && child.dom.parentNode == this.contentDOM && !child.children.length ? CONTENT_DIRTY : NODE_DIRTY;
              }
            }
            offset = end;
          }
          this.dirty = CONTENT_DIRTY;
        }
      }, {
        key: "markParentsDirty",
        value: function markParentsDirty() {
          var level = 1;
          for (var node = this.parent; node; node = node.parent, level++) {
            var dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;
            if (node.dirty < dirty) node.dirty = dirty;
          }
        }
      }, {
        key: "domAtom",
        get: function get2() {
          return false;
        }
      }, {
        key: "ignoreForCoords",
        get: function get2() {
          return false;
        }
      }, {
        key: "ignoreForSelection",
        get: function get2() {
          return false;
        }
      }, {
        key: "isText",
        value: function isText(text) {
          return false;
        }
      }]);
      return ViewDesc2;
    })();
    var WidgetViewDesc = (function(_ViewDesc) {
      _inherits(WidgetViewDesc2, _ViewDesc);
      var _super = _createSuper(WidgetViewDesc2);
      function WidgetViewDesc2(parent, widget, view, pos) {
        var _this;
        _classCallCheck(this, WidgetViewDesc2);
        var self2, dom = widget.type.toDOM;
        if (typeof dom == "function") dom = dom(view, function() {
          if (!self2) return pos;
          if (self2.parent) return self2.parent.posBeforeChild(self2);
        });
        if (!widget.type.spec.raw) {
          if (dom.nodeType != 1) {
            var wrap = document.createElement("span");
            wrap.appendChild(dom);
            dom = wrap;
          }
          dom.contentEditable = "false";
          dom.classList.add("ProseMirror-widget");
        }
        _this = _super.call(this, parent, [], dom, null);
        _this.widget = widget;
        _this.widget = widget;
        self2 = _assertThisInitialized(_this);
        return _this;
      }
      _createClass(WidgetViewDesc2, [{
        key: "matchesWidget",
        value: function matchesWidget(widget) {
          return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type);
        }
      }, {
        key: "parseRule",
        value: function parseRule() {
          return {
            ignore: true
          };
        }
      }, {
        key: "stopEvent",
        value: function stopEvent(event) {
          var stop = this.widget.spec.stopEvent;
          return stop ? stop(event) : false;
        }
      }, {
        key: "ignoreMutation",
        value: function ignoreMutation(mutation) {
          return mutation.type != "selection" || this.widget.spec.ignoreSelection;
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.widget.type.destroy(this.dom);
          _get(_getPrototypeOf(WidgetViewDesc2.prototype), "destroy", this).call(this);
        }
      }, {
        key: "domAtom",
        get: function get2() {
          return true;
        }
      }, {
        key: "ignoreForSelection",
        get: function get2() {
          return !!this.widget.type.spec.relaxedSide;
        }
      }, {
        key: "side",
        get: function get2() {
          return this.widget.type.side;
        }
      }]);
      return WidgetViewDesc2;
    })(ViewDesc);
    var CompositionViewDesc = (function(_ViewDesc2) {
      _inherits(CompositionViewDesc2, _ViewDesc2);
      var _super2 = _createSuper(CompositionViewDesc2);
      function CompositionViewDesc2(parent, dom, textDOM, text) {
        var _this2;
        _classCallCheck(this, CompositionViewDesc2);
        _this2 = _super2.call(this, parent, [], dom, null);
        _this2.textDOM = textDOM;
        _this2.text = text;
        return _this2;
      }
      _createClass(CompositionViewDesc2, [{
        key: "size",
        get: function get2() {
          return this.text.length;
        }
      }, {
        key: "localPosFromDOM",
        value: function localPosFromDOM(dom, offset) {
          if (dom != this.textDOM) return this.posAtStart + (offset ? this.size : 0);
          return this.posAtStart + offset;
        }
      }, {
        key: "domFromPos",
        value: function domFromPos(pos) {
          return {
            node: this.textDOM,
            offset: pos
          };
        }
      }, {
        key: "ignoreMutation",
        value: function ignoreMutation(mut) {
          return mut.type === "characterData" && mut.target.nodeValue == mut.oldValue;
        }
      }]);
      return CompositionViewDesc2;
    })(ViewDesc);
    var MarkViewDesc = (function(_ViewDesc3) {
      _inherits(MarkViewDesc2, _ViewDesc3);
      var _super3 = _createSuper(MarkViewDesc2);
      function MarkViewDesc2(parent, mark, dom, contentDOM, spec) {
        var _this3;
        _classCallCheck(this, MarkViewDesc2);
        _this3 = _super3.call(this, parent, [], dom, contentDOM);
        _this3.mark = mark;
        _this3.spec = spec;
        return _this3;
      }
      _createClass(MarkViewDesc2, [{
        key: "parseRule",
        value: function parseRule() {
          if (this.dirty & NODE_DIRTY || this.mark.type.spec.reparseInView) return null;
          return {
            mark: this.mark.type.name,
            attrs: this.mark.attrs,
            contentElement: this.contentDOM
          };
        }
      }, {
        key: "matchesMark",
        value: function matchesMark(mark) {
          return this.dirty != NODE_DIRTY && this.mark.eq(mark);
        }
      }, {
        key: "markDirty",
        value: function markDirty(from, to) {
          _get(_getPrototypeOf(MarkViewDesc2.prototype), "markDirty", this).call(this, from, to);
          if (this.dirty != NOT_DIRTY) {
            var parent = this.parent;
            while (!parent.node) parent = parent.parent;
            if (parent.dirty < this.dirty) parent.dirty = this.dirty;
            this.dirty = NOT_DIRTY;
          }
        }
      }, {
        key: "slice",
        value: function slice(from, to, view) {
          var copy = MarkViewDesc2.create(this.parent, this.mark, true, view);
          var nodes = this.children, size = this.size;
          if (to < size) nodes = replaceNodes(nodes, to, size, view);
          if (from > 0) nodes = replaceNodes(nodes, 0, from, view);
          for (var i = 0; i < nodes.length; i++) nodes[i].parent = copy;
          copy.children = nodes;
          return copy;
        }
      }, {
        key: "ignoreMutation",
        value: function ignoreMutation(mutation) {
          return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : _get(_getPrototypeOf(MarkViewDesc2.prototype), "ignoreMutation", this).call(this, mutation);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          if (this.spec.destroy) this.spec.destroy();
          _get(_getPrototypeOf(MarkViewDesc2.prototype), "destroy", this).call(this);
        }
      }], [{
        key: "create",
        value: function create(parent, mark, inline, view) {
          var custom = view.nodeViews[mark.type.name];
          var spec = custom && custom(mark, view, inline);
          if (!spec || !spec.dom) spec = prosemirrorModel.DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline), null, mark.attrs);
          return new MarkViewDesc2(parent, mark, spec.dom, spec.contentDOM || spec.dom, spec);
        }
      }]);
      return MarkViewDesc2;
    })(ViewDesc);
    var NodeViewDesc = (function(_ViewDesc4) {
      _inherits(NodeViewDesc2, _ViewDesc4);
      var _super4 = _createSuper(NodeViewDesc2);
      function NodeViewDesc2(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos) {
        var _this4;
        _classCallCheck(this, NodeViewDesc2);
        _this4 = _super4.call(this, parent, [], dom, contentDOM);
        _this4.node = node;
        _this4.outerDeco = outerDeco;
        _this4.innerDeco = innerDeco;
        _this4.nodeDOM = nodeDOM;
        return _this4;
      }
      _createClass(NodeViewDesc2, [{
        key: "parseRule",
        value: function parseRule() {
          var _this5 = this;
          if (this.node.type.spec.reparseInView) return null;
          var rule = {
            node: this.node.type.name,
            attrs: this.node.attrs
          };
          if (this.node.type.whitespace == "pre") rule.preserveWhitespace = "full";
          if (!this.contentDOM) {
            rule.getContent = function() {
              return _this5.node.content;
            };
          } else if (!this.contentLost) {
            rule.contentElement = this.contentDOM;
          } else {
            for (var i = this.children.length - 1; i >= 0; i--) {
              var child = this.children[i];
              if (this.dom.contains(child.dom.parentNode)) {
                rule.contentElement = child.dom.parentNode;
                break;
              }
            }
            if (!rule.contentElement) rule.getContent = function() {
              return prosemirrorModel.Fragment.empty;
            };
          }
          return rule;
        }
      }, {
        key: "matchesNode",
        value: function matchesNode(node, outerDeco, innerDeco) {
          return this.dirty == NOT_DIRTY && node.eq(this.node) && sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);
        }
      }, {
        key: "size",
        get: function get2() {
          return this.node.nodeSize;
        }
      }, {
        key: "border",
        get: function get2() {
          return this.node.isLeaf ? 0 : 1;
        }
      }, {
        key: "updateChildren",
        value: function updateChildren(view, pos) {
          var _this6 = this;
          var inline = this.node.inlineContent, off = pos;
          var composition = view.composing ? this.localCompositionInfo(view, pos) : null;
          var localComposition = composition && composition.pos > -1 ? composition : null;
          var compositionInChild = composition && composition.pos < 0;
          var updater = new ViewTreeUpdater(this, localComposition && localComposition.node, view);
          iterDeco(this.node, this.innerDeco, function(widget, i, insideNode) {
            if (widget.spec.marks) updater.syncToMarks(widget.spec.marks, inline, view);
            else if (widget.type.side >= 0 && !insideNode) updater.syncToMarks(i == _this6.node.childCount ? prosemirrorModel.Mark.none : _this6.node.child(i).marks, inline, view);
            updater.placeWidget(widget, view, off);
          }, function(child, outerDeco, innerDeco, i) {
            updater.syncToMarks(child.marks, inline, view);
            var compIndex;
            if (updater.findNodeMatch(child, outerDeco, innerDeco, i)) ;
            else if (compositionInChild && view.state.selection.from > off && view.state.selection.to < off + child.nodeSize && (compIndex = updater.findIndexWithChild(composition.node)) > -1 && updater.updateNodeAt(child, outerDeco, innerDeco, compIndex, view)) ;
            else if (updater.updateNextNode(child, outerDeco, innerDeco, view, i, off)) ;
            else {
              updater.addNode(child, outerDeco, innerDeco, view, off);
            }
            off += child.nodeSize;
          });
          updater.syncToMarks([], inline, view);
          if (this.node.isTextblock) updater.addTextblockHacks();
          updater.destroyRest();
          if (updater.changed || this.dirty == CONTENT_DIRTY) {
            if (localComposition) this.protectLocalComposition(view, localComposition);
            renderDescs(this.contentDOM, this.children, view);
            if (ios) iosHacks(this.dom);
          }
        }
      }, {
        key: "localCompositionInfo",
        value: function localCompositionInfo(view, pos) {
          var _view$state$selection = view.state.selection, from = _view$state$selection.from, to = _view$state$selection.to;
          if (!(view.state.selection instanceof prosemirrorState.TextSelection) || from < pos || to > pos + this.node.content.size) return null;
          var textNode = view.input.compositionNode;
          if (!textNode || !this.dom.contains(textNode.parentNode)) return null;
          if (this.node.inlineContent) {
            var text = textNode.nodeValue;
            var textPos = findTextInFragment(this.node.content, text, from - pos, to - pos);
            return textPos < 0 ? null : {
              node: textNode,
              pos: textPos,
              text
            };
          } else {
            return {
              node: textNode,
              pos: -1,
              text: ""
            };
          }
        }
      }, {
        key: "protectLocalComposition",
        value: function protectLocalComposition(view, _ref2) {
          var node = _ref2.node, pos = _ref2.pos, text = _ref2.text;
          if (this.getDesc(node)) return;
          var topNode = node;
          for (; ; topNode = topNode.parentNode) {
            if (topNode.parentNode == this.contentDOM) break;
            while (topNode.previousSibling) topNode.parentNode.removeChild(topNode.previousSibling);
            while (topNode.nextSibling) topNode.parentNode.removeChild(topNode.nextSibling);
            if (topNode.pmViewDesc) topNode.pmViewDesc = void 0;
          }
          var desc = new CompositionViewDesc(this, topNode, node, text);
          view.input.compositionNodes.push(desc);
          this.children = replaceNodes(this.children, pos, pos + text.length, view, desc);
        }
      }, {
        key: "update",
        value: function update(node, outerDeco, innerDeco, view) {
          if (this.dirty == NODE_DIRTY || !node.sameMarkup(this.node)) return false;
          this.updateInner(node, outerDeco, innerDeco, view);
          return true;
        }
      }, {
        key: "updateInner",
        value: function updateInner(node, outerDeco, innerDeco, view) {
          this.updateOuterDeco(outerDeco);
          this.node = node;
          this.innerDeco = innerDeco;
          if (this.contentDOM) this.updateChildren(view, this.posAtStart);
          this.dirty = NOT_DIRTY;
        }
      }, {
        key: "updateOuterDeco",
        value: function updateOuterDeco(outerDeco) {
          if (sameOuterDeco(outerDeco, this.outerDeco)) return;
          var needsWrap = this.nodeDOM.nodeType != 1;
          var oldDOM = this.dom;
          this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, needsWrap), computeOuterDeco(outerDeco, this.node, needsWrap));
          if (this.dom != oldDOM) {
            oldDOM.pmViewDesc = void 0;
            this.dom.pmViewDesc = this;
          }
          this.outerDeco = outerDeco;
        }
      }, {
        key: "selectNode",
        value: function selectNode() {
          if (this.nodeDOM.nodeType == 1) {
            this.nodeDOM.classList.add("ProseMirror-selectednode");
            if (this.contentDOM || !this.node.type.spec.draggable) this.nodeDOM.draggable = true;
          }
        }
      }, {
        key: "deselectNode",
        value: function deselectNode() {
          if (this.nodeDOM.nodeType == 1) {
            this.nodeDOM.classList.remove("ProseMirror-selectednode");
            if (this.contentDOM || !this.node.type.spec.draggable) this.nodeDOM.removeAttribute("draggable");
          }
        }
      }, {
        key: "domAtom",
        get: function get2() {
          return this.node.isAtom;
        }
      }], [{
        key: "create",
        value: function create(parent, node, outerDeco, innerDeco, view, pos) {
          var custom = view.nodeViews[node.type.name], descObj;
          var spec = custom && custom(node, view, function() {
            if (!descObj) return pos;
            if (descObj.parent) return descObj.parent.posBeforeChild(descObj);
          }, outerDeco, innerDeco);
          var dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;
          if (node.isText) {
            if (!dom) dom = document.createTextNode(node.text);
            else if (dom.nodeType != 3) throw new RangeError("Text must be rendered as a DOM text node");
          } else if (!dom) {
            var _spec = prosemirrorModel.DOMSerializer.renderSpec(document, node.type.spec.toDOM(node), null, node.attrs);
            dom = _spec.dom;
            contentDOM = _spec.contentDOM;
          }
          if (!contentDOM && !node.isText && dom.nodeName != "BR") {
            if (!dom.hasAttribute("contenteditable")) dom.contentEditable = "false";
            if (node.type.spec.draggable) dom.draggable = true;
          }
          var nodeDOM = dom;
          dom = applyOuterDeco(dom, outerDeco, node);
          if (spec) return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, spec, view, pos + 1);
          else if (node.isText) return new TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view);
          else return new NodeViewDesc2(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, view, pos + 1);
        }
      }]);
      return NodeViewDesc2;
    })(ViewDesc);
    function docViewDesc(doc2, outerDeco, innerDeco, dom, view) {
      applyOuterDeco(dom, outerDeco, doc2);
      var docView = new NodeViewDesc(void 0, doc2, outerDeco, innerDeco, dom, dom, dom, view, 0);
      if (docView.contentDOM) docView.updateChildren(view, 0);
      return docView;
    }
    var TextViewDesc = (function(_NodeViewDesc) {
      _inherits(TextViewDesc2, _NodeViewDesc);
      var _super5 = _createSuper(TextViewDesc2);
      function TextViewDesc2(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) {
        _classCallCheck(this, TextViewDesc2);
        return _super5.call(this, parent, node, outerDeco, innerDeco, dom, null, nodeDOM, view, 0);
      }
      _createClass(TextViewDesc2, [{
        key: "parseRule",
        value: function parseRule() {
          var skip = this.nodeDOM.parentNode;
          while (skip && skip != this.dom && !skip.pmIsDeco) skip = skip.parentNode;
          return {
            skip: skip || true
          };
        }
      }, {
        key: "update",
        value: function update(node, outerDeco, innerDeco, view) {
          if (this.dirty == NODE_DIRTY || this.dirty != NOT_DIRTY && !this.inParent() || !node.sameMarkup(this.node)) return false;
          this.updateOuterDeco(outerDeco);
          if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue) {
            this.nodeDOM.nodeValue = node.text;
            if (view.trackWrites == this.nodeDOM) view.trackWrites = null;
          }
          this.node = node;
          this.dirty = NOT_DIRTY;
          return true;
        }
      }, {
        key: "inParent",
        value: function inParent() {
          var parentDOM = this.parent.contentDOM;
          for (var n = this.nodeDOM; n; n = n.parentNode) if (n == parentDOM) return true;
          return false;
        }
      }, {
        key: "domFromPos",
        value: function domFromPos(pos) {
          return {
            node: this.nodeDOM,
            offset: pos
          };
        }
      }, {
        key: "localPosFromDOM",
        value: function localPosFromDOM(dom, offset, bias) {
          if (dom == this.nodeDOM) return this.posAtStart + Math.min(offset, this.node.text.length);
          return _get(_getPrototypeOf(TextViewDesc2.prototype), "localPosFromDOM", this).call(this, dom, offset, bias);
        }
      }, {
        key: "ignoreMutation",
        value: function ignoreMutation(mutation) {
          return mutation.type != "characterData" && mutation.type != "selection";
        }
      }, {
        key: "slice",
        value: function slice(from, to, view) {
          var node = this.node.cut(from, to), dom = document.createTextNode(node.text);
          return new TextViewDesc2(this.parent, node, this.outerDeco, this.innerDeco, dom, dom, view);
        }
      }, {
        key: "markDirty",
        value: function markDirty(from, to) {
          _get(_getPrototypeOf(TextViewDesc2.prototype), "markDirty", this).call(this, from, to);
          if (this.dom != this.nodeDOM && (from == 0 || to == this.nodeDOM.nodeValue.length)) this.dirty = NODE_DIRTY;
        }
      }, {
        key: "domAtom",
        get: function get2() {
          return false;
        }
      }, {
        key: "isText",
        value: function isText(text) {
          return this.node.text == text;
        }
      }]);
      return TextViewDesc2;
    })(NodeViewDesc);
    var TrailingHackViewDesc = (function(_ViewDesc5) {
      _inherits(TrailingHackViewDesc2, _ViewDesc5);
      var _super6 = _createSuper(TrailingHackViewDesc2);
      function TrailingHackViewDesc2() {
        _classCallCheck(this, TrailingHackViewDesc2);
        return _super6.apply(this, arguments);
      }
      _createClass(TrailingHackViewDesc2, [{
        key: "parseRule",
        value: function parseRule() {
          return {
            ignore: true
          };
        }
      }, {
        key: "matchesHack",
        value: function matchesHack(nodeName) {
          return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName;
        }
      }, {
        key: "domAtom",
        get: function get2() {
          return true;
        }
      }, {
        key: "ignoreForCoords",
        get: function get2() {
          return this.dom.nodeName == "IMG";
        }
      }]);
      return TrailingHackViewDesc2;
    })(ViewDesc);
    var CustomNodeViewDesc = (function(_NodeViewDesc2) {
      _inherits(CustomNodeViewDesc2, _NodeViewDesc2);
      var _super7 = _createSuper(CustomNodeViewDesc2);
      function CustomNodeViewDesc2(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos) {
        var _this7;
        _classCallCheck(this, CustomNodeViewDesc2);
        _this7 = _super7.call(this, parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos);
        _this7.spec = spec;
        return _this7;
      }
      _createClass(CustomNodeViewDesc2, [{
        key: "update",
        value: function update(node, outerDeco, innerDeco, view) {
          if (this.dirty == NODE_DIRTY) return false;
          if (this.spec.update && (this.node.type == node.type || this.spec.multiType)) {
            var result = this.spec.update(node, outerDeco, innerDeco);
            if (result) this.updateInner(node, outerDeco, innerDeco, view);
            return result;
          } else if (!this.contentDOM && !node.isLeaf) {
            return false;
          } else {
            return _get(_getPrototypeOf(CustomNodeViewDesc2.prototype), "update", this).call(this, node, outerDeco, innerDeco, view);
          }
        }
      }, {
        key: "selectNode",
        value: function selectNode() {
          this.spec.selectNode ? this.spec.selectNode() : _get(_getPrototypeOf(CustomNodeViewDesc2.prototype), "selectNode", this).call(this);
        }
      }, {
        key: "deselectNode",
        value: function deselectNode() {
          this.spec.deselectNode ? this.spec.deselectNode() : _get(_getPrototypeOf(CustomNodeViewDesc2.prototype), "deselectNode", this).call(this);
        }
      }, {
        key: "setSelection",
        value: function setSelection(anchor, head, view, force) {
          this.spec.setSelection ? this.spec.setSelection(anchor, head, view.root) : _get(_getPrototypeOf(CustomNodeViewDesc2.prototype), "setSelection", this).call(this, anchor, head, view, force);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          if (this.spec.destroy) this.spec.destroy();
          _get(_getPrototypeOf(CustomNodeViewDesc2.prototype), "destroy", this).call(this);
        }
      }, {
        key: "stopEvent",
        value: function stopEvent(event) {
          return this.spec.stopEvent ? this.spec.stopEvent(event) : false;
        }
      }, {
        key: "ignoreMutation",
        value: function ignoreMutation(mutation) {
          return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : _get(_getPrototypeOf(CustomNodeViewDesc2.prototype), "ignoreMutation", this).call(this, mutation);
        }
      }]);
      return CustomNodeViewDesc2;
    })(NodeViewDesc);
    function renderDescs(parentDOM, descs, view) {
      var dom = parentDOM.firstChild, written = false;
      for (var i = 0; i < descs.length; i++) {
        var desc = descs[i], childDOM = desc.dom;
        if (childDOM.parentNode == parentDOM) {
          while (childDOM != dom) {
            dom = rm(dom);
            written = true;
          }
          dom = dom.nextSibling;
        } else {
          written = true;
          parentDOM.insertBefore(childDOM, dom);
        }
        if (desc instanceof MarkViewDesc) {
          var pos = dom ? dom.previousSibling : parentDOM.lastChild;
          renderDescs(desc.contentDOM, desc.children, view);
          dom = pos ? pos.nextSibling : parentDOM.firstChild;
        }
      }
      while (dom) {
        dom = rm(dom);
        written = true;
      }
      if (written && view.trackWrites == parentDOM) view.trackWrites = null;
    }
    var OuterDecoLevel = function OuterDecoLevel2(nodeName) {
      if (nodeName) this.nodeName = nodeName;
    };
    OuterDecoLevel.prototype = /* @__PURE__ */ Object.create(null);
    var noDeco = [new OuterDecoLevel()];
    function computeOuterDeco(outerDeco, node, needsWrap) {
      if (outerDeco.length == 0) return noDeco;
      var top = needsWrap ? noDeco[0] : new OuterDecoLevel(), result = [top];
      for (var i = 0; i < outerDeco.length; i++) {
        var attrs = outerDeco[i].type.attrs;
        if (!attrs) continue;
        if (attrs.nodeName) result.push(top = new OuterDecoLevel(attrs.nodeName));
        for (var name in attrs) {
          var val = attrs[name];
          if (val == null) continue;
          if (needsWrap && result.length == 1) result.push(top = new OuterDecoLevel(node.isInline ? "span" : "div"));
          if (name == "class") top["class"] = (top["class"] ? top["class"] + " " : "") + val;
          else if (name == "style") top.style = (top.style ? top.style + ";" : "") + val;
          else if (name != "nodeName") top[name] = val;
        }
      }
      return result;
    }
    function patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {
      if (prevComputed == noDeco && curComputed == noDeco) return nodeDOM;
      var curDOM = nodeDOM;
      for (var i = 0; i < curComputed.length; i++) {
        var deco = curComputed[i], prev = prevComputed[i];
        if (i) {
          var parent = void 0;
          if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM && (parent = curDOM.parentNode) && parent.nodeName.toLowerCase() == deco.nodeName) {
            curDOM = parent;
          } else {
            parent = document.createElement(deco.nodeName);
            parent.pmIsDeco = true;
            parent.appendChild(curDOM);
            prev = noDeco[0];
            curDOM = parent;
          }
        }
        patchAttributes(curDOM, prev || noDeco[0], deco);
      }
      return curDOM;
    }
    function patchAttributes(dom, prev, cur) {
      for (var name in prev) if (name != "class" && name != "style" && name != "nodeName" && !(name in cur)) dom.removeAttribute(name);
      for (var _name in cur) if (_name != "class" && _name != "style" && _name != "nodeName" && cur[_name] != prev[_name]) dom.setAttribute(_name, cur[_name]);
      if (prev["class"] != cur["class"]) {
        var prevList = prev["class"] ? prev["class"].split(" ").filter(Boolean) : [];
        var curList = cur["class"] ? cur["class"].split(" ").filter(Boolean) : [];
        for (var i = 0; i < prevList.length; i++) if (curList.indexOf(prevList[i]) == -1) dom.classList.remove(prevList[i]);
        for (var _i2 = 0; _i2 < curList.length; _i2++) if (prevList.indexOf(curList[_i2]) == -1) dom.classList.add(curList[_i2]);
        if (dom.classList.length == 0) dom.removeAttribute("class");
      }
      if (prev.style != cur.style) {
        if (prev.style) {
          var prop2 = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, m;
          while (m = prop2.exec(prev.style)) dom.style.removeProperty(m[1]);
        }
        if (cur.style) dom.style.cssText += cur.style;
      }
    }
    function applyOuterDeco(dom, deco, node) {
      return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node, dom.nodeType != 1));
    }
    function sameOuterDeco(a, b) {
      if (a.length != b.length) return false;
      for (var i = 0; i < a.length; i++) if (!a[i].type.eq(b[i].type)) return false;
      return true;
    }
    function rm(dom) {
      var next = dom.nextSibling;
      dom.parentNode.removeChild(dom);
      return next;
    }
    var ViewTreeUpdater = (function() {
      function ViewTreeUpdater2(top, lock, view) {
        _classCallCheck(this, ViewTreeUpdater2);
        this.lock = lock;
        this.view = view;
        this.index = 0;
        this.stack = [];
        this.changed = false;
        this.top = top;
        this.preMatch = preMatch(top.node.content, top);
      }
      _createClass(ViewTreeUpdater2, [{
        key: "destroyBetween",
        value: function destroyBetween(start, end) {
          if (start == end) return;
          for (var i = start; i < end; i++) this.top.children[i].destroy();
          this.top.children.splice(start, end - start);
          this.changed = true;
        }
      }, {
        key: "destroyRest",
        value: function destroyRest() {
          this.destroyBetween(this.index, this.top.children.length);
        }
      }, {
        key: "syncToMarks",
        value: function syncToMarks(marks, inline, view) {
          var keep = 0, depth = this.stack.length >> 1;
          var maxKeep = Math.min(depth, marks.length);
          while (keep < maxKeep && (keep == depth - 1 ? this.top : this.stack[keep + 1 << 1]).matchesMark(marks[keep]) && marks[keep].type.spec.spanning !== false) keep++;
          while (keep < depth) {
            this.destroyRest();
            this.top.dirty = NOT_DIRTY;
            this.index = this.stack.pop();
            this.top = this.stack.pop();
            depth--;
          }
          while (depth < marks.length) {
            this.stack.push(this.top, this.index + 1);
            var found = -1;
            for (var i = this.index; i < Math.min(this.index + 3, this.top.children.length); i++) {
              var next = this.top.children[i];
              if (next.matchesMark(marks[depth]) && !this.isLocked(next.dom)) {
                found = i;
                break;
              }
            }
            if (found > -1) {
              if (found > this.index) {
                this.changed = true;
                this.destroyBetween(this.index, found);
              }
              this.top = this.top.children[this.index];
            } else {
              var markDesc = MarkViewDesc.create(this.top, marks[depth], inline, view);
              this.top.children.splice(this.index, 0, markDesc);
              this.top = markDesc;
              this.changed = true;
            }
            this.index = 0;
            depth++;
          }
        }
      }, {
        key: "findNodeMatch",
        value: function findNodeMatch(node, outerDeco, innerDeco, index) {
          var found = -1, targetDesc;
          if (index >= this.preMatch.index && (targetDesc = this.preMatch.matches[index - this.preMatch.index]).parent == this.top && targetDesc.matchesNode(node, outerDeco, innerDeco)) {
            found = this.top.children.indexOf(targetDesc, this.index);
          } else {
            for (var i = this.index, e = Math.min(this.top.children.length, i + 5); i < e; i++) {
              var child = this.top.children[i];
              if (child.matchesNode(node, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {
                found = i;
                break;
              }
            }
          }
          if (found < 0) return false;
          this.destroyBetween(this.index, found);
          this.index++;
          return true;
        }
      }, {
        key: "updateNodeAt",
        value: function updateNodeAt(node, outerDeco, innerDeco, index, view) {
          var child = this.top.children[index];
          if (child.dirty == NODE_DIRTY && child.dom == child.contentDOM) child.dirty = CONTENT_DIRTY;
          if (!child.update(node, outerDeco, innerDeco, view)) return false;
          this.destroyBetween(this.index, index);
          this.index++;
          return true;
        }
      }, {
        key: "findIndexWithChild",
        value: function findIndexWithChild(domNode) {
          for (; ; ) {
            var parent = domNode.parentNode;
            if (!parent) return -1;
            if (parent == this.top.contentDOM) {
              var desc = domNode.pmViewDesc;
              if (desc) for (var i = this.index; i < this.top.children.length; i++) {
                if (this.top.children[i] == desc) return i;
              }
              return -1;
            }
            domNode = parent;
          }
        }
      }, {
        key: "updateNextNode",
        value: function updateNextNode(node, outerDeco, innerDeco, view, index, pos) {
          for (var i = this.index; i < this.top.children.length; i++) {
            var next = this.top.children[i];
            if (next instanceof NodeViewDesc) {
              var _preMatch = this.preMatch.matched.get(next);
              if (_preMatch != null && _preMatch != index) return false;
              var nextDOM = next.dom, updated = void 0;
              var locked = this.isLocked(nextDOM) && !(node.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node.text && next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));
              if (!locked && next.update(node, outerDeco, innerDeco, view)) {
                this.destroyBetween(this.index, i);
                if (next.dom != nextDOM) this.changed = true;
                this.index++;
                return true;
              } else if (!locked && (updated = this.recreateWrapper(next, node, outerDeco, innerDeco, view, pos))) {
                this.destroyBetween(this.index, i);
                this.top.children[this.index] = updated;
                if (updated.contentDOM) {
                  updated.dirty = CONTENT_DIRTY;
                  updated.updateChildren(view, pos + 1);
                  updated.dirty = NOT_DIRTY;
                }
                this.changed = true;
                this.index++;
                return true;
              }
              break;
            }
          }
          return false;
        }
      }, {
        key: "recreateWrapper",
        value: function recreateWrapper(next, node, outerDeco, innerDeco, view, pos) {
          if (next.dirty || node.isAtom || !next.children.length || !next.node.content.eq(node.content) || !sameOuterDeco(outerDeco, next.outerDeco) || !innerDeco.eq(next.innerDeco)) return null;
          var wrapper = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);
          if (wrapper.contentDOM) {
            wrapper.children = next.children;
            next.children = [];
            var _iterator = _createForOfIteratorHelper(wrapper.children), _step;
            try {
              for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                var ch = _step.value;
                ch.parent = wrapper;
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }
          }
          next.destroy();
          return wrapper;
        }
      }, {
        key: "addNode",
        value: function addNode(node, outerDeco, innerDeco, view, pos) {
          var desc = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);
          if (desc.contentDOM) desc.updateChildren(view, pos + 1);
          this.top.children.splice(this.index++, 0, desc);
          this.changed = true;
        }
      }, {
        key: "placeWidget",
        value: function placeWidget(widget, view, pos) {
          var next = this.index < this.top.children.length ? this.top.children[this.index] : null;
          if (next && next.matchesWidget(widget) && (widget == next.widget || !next.widget.type.toDOM.parentNode)) {
            this.index++;
          } else {
            var desc = new WidgetViewDesc(this.top, widget, view, pos);
            this.top.children.splice(this.index++, 0, desc);
            this.changed = true;
          }
        }
      }, {
        key: "addTextblockHacks",
        value: function addTextblockHacks() {
          var lastChild = this.top.children[this.index - 1], parent = this.top;
          while (lastChild instanceof MarkViewDesc) {
            parent = lastChild;
            lastChild = parent.children[parent.children.length - 1];
          }
          if (!lastChild || !(lastChild instanceof TextViewDesc) || /\n$/.test(lastChild.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(lastChild.node.text)) {
            if ((safari || chrome) && lastChild && lastChild.dom.contentEditable == "false") this.addHackNode("IMG", parent);
            this.addHackNode("BR", this.top);
          }
        }
      }, {
        key: "addHackNode",
        value: function addHackNode(nodeName, parent) {
          if (parent == this.top && this.index < parent.children.length && parent.children[this.index].matchesHack(nodeName)) {
            this.index++;
          } else {
            var dom = document.createElement(nodeName);
            if (nodeName == "IMG") {
              dom.className = "ProseMirror-separator";
              dom.alt = "";
            }
            if (nodeName == "BR") dom.className = "ProseMirror-trailingBreak";
            var hack = new TrailingHackViewDesc(this.top, [], dom, null);
            if (parent != this.top) parent.children.push(hack);
            else parent.children.splice(this.index++, 0, hack);
            this.changed = true;
          }
        }
      }, {
        key: "isLocked",
        value: function isLocked(node) {
          return this.lock && (node == this.lock || node.nodeType == 1 && node.contains(this.lock.parentNode));
        }
      }]);
      return ViewTreeUpdater2;
    })();
    function preMatch(frag, parentDesc) {
      var curDesc = parentDesc, descI = curDesc.children.length;
      var fI = frag.childCount, matched = /* @__PURE__ */ new Map(), matches = [];
      outer: while (fI > 0) {
        var desc = void 0;
        for (; ; ) {
          if (descI) {
            var next = curDesc.children[descI - 1];
            if (next instanceof MarkViewDesc) {
              curDesc = next;
              descI = next.children.length;
            } else {
              desc = next;
              descI--;
              break;
            }
          } else if (curDesc == parentDesc) {
            break outer;
          } else {
            descI = curDesc.parent.children.indexOf(curDesc);
            curDesc = curDesc.parent;
          }
        }
        var node = desc.node;
        if (!node) continue;
        if (node != frag.child(fI - 1)) break;
        --fI;
        matched.set(desc, fI);
        matches.push(desc);
      }
      return {
        index: fI,
        matched,
        matches: matches.reverse()
      };
    }
    function compareSide(a, b) {
      return a.type.side - b.type.side;
    }
    function iterDeco(parent, deco, onWidget, onNode) {
      var locals = deco.locals(parent), offset = 0;
      if (locals.length == 0) {
        for (var i = 0; i < parent.childCount; i++) {
          var child = parent.child(i);
          onNode(child, locals, deco.forChild(offset, child), i);
          offset += child.nodeSize;
        }
        return;
      }
      var decoIndex = 0, active = [], restNode = null;
      for (var parentIndex = 0; ; ) {
        var widget = void 0, widgets = void 0;
        while (decoIndex < locals.length && locals[decoIndex].to == offset) {
          var next = locals[decoIndex++];
          if (next.widget) {
            if (!widget) widget = next;
            else (widgets || (widgets = [widget])).push(next);
          }
        }
        if (widget) {
          if (widgets) {
            widgets.sort(compareSide);
            for (var _i3 = 0; _i3 < widgets.length; _i3++) onWidget(widgets[_i3], parentIndex, !!restNode);
          } else {
            onWidget(widget, parentIndex, !!restNode);
          }
        }
        var _child = void 0, index = void 0;
        if (restNode) {
          index = -1;
          _child = restNode;
          restNode = null;
        } else if (parentIndex < parent.childCount) {
          index = parentIndex;
          _child = parent.child(parentIndex++);
        } else {
          break;
        }
        for (var _i4 = 0; _i4 < active.length; _i4++) if (active[_i4].to <= offset) active.splice(_i4--, 1);
        while (decoIndex < locals.length && locals[decoIndex].from <= offset && locals[decoIndex].to > offset) active.push(locals[decoIndex++]);
        var end = offset + _child.nodeSize;
        if (_child.isText) {
          var cutAt = end;
          if (decoIndex < locals.length && locals[decoIndex].from < cutAt) cutAt = locals[decoIndex].from;
          for (var _i5 = 0; _i5 < active.length; _i5++) if (active[_i5].to < cutAt) cutAt = active[_i5].to;
          if (cutAt < end) {
            restNode = _child.cut(cutAt - offset);
            _child = _child.cut(0, cutAt - offset);
            end = cutAt;
            index = -1;
          }
        } else {
          while (decoIndex < locals.length && locals[decoIndex].to < end) decoIndex++;
        }
        var outerDeco = _child.isInline && !_child.isLeaf ? active.filter(function(d) {
          return !d.inline;
        }) : active.slice();
        onNode(_child, outerDeco, deco.forChild(offset, _child), index);
        offset = end;
      }
    }
    function iosHacks(dom) {
      if (dom.nodeName == "UL" || dom.nodeName == "OL") {
        var oldCSS = dom.style.cssText;
        dom.style.cssText = oldCSS + "; list-style: square !important";
        window.getComputedStyle(dom).listStyle;
        dom.style.cssText = oldCSS;
      }
    }
    function findTextInFragment(frag, text, from, to) {
      for (var i = 0, pos = 0; i < frag.childCount && pos <= to; ) {
        var child = frag.child(i++), childStart = pos;
        pos += child.nodeSize;
        if (!child.isText) continue;
        var str = child.text;
        while (i < frag.childCount) {
          var next = frag.child(i++);
          pos += next.nodeSize;
          if (!next.isText) break;
          str += next.text;
        }
        if (pos >= from) {
          if (pos >= to && str.slice(to - text.length - childStart, to - childStart) == text) return to - text.length;
          var found = childStart < to ? str.lastIndexOf(text, to - childStart - 1) : -1;
          if (found >= 0 && found + text.length + childStart >= from) return childStart + found;
          if (from == to && str.length >= to + text.length - childStart && str.slice(to - childStart, to - childStart + text.length) == text) return to;
        }
      }
      return -1;
    }
    function replaceNodes(nodes, from, to, view, replacement) {
      var result = [];
      for (var i = 0, off = 0; i < nodes.length; i++) {
        var child = nodes[i], start = off, end = off += child.size;
        if (start >= to || end <= from) {
          result.push(child);
        } else {
          if (start < from) result.push(child.slice(0, from - start, view));
          if (replacement) {
            result.push(replacement);
            replacement = void 0;
          }
          if (end > to) result.push(child.slice(to - start, child.size, view));
        }
      }
      return result;
    }
    function selectionFromDOM(view) {
      var origin = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      var domSel = view.domSelectionRange(), doc2 = view.state.doc;
      if (!domSel.focusNode) return null;
      var nearestDesc = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc && nearestDesc.size == 0;
      var head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset, 1);
      if (head < 0) return null;
      var $head = doc2.resolve(head), anchor, selection;
      if (selectionCollapsed(domSel)) {
        anchor = head;
        while (nearestDesc && !nearestDesc.node) nearestDesc = nearestDesc.parent;
        var nearestDescNode = nearestDesc.node;
        if (nearestDesc && nearestDescNode.isAtom && prosemirrorState.NodeSelection.isSelectable(nearestDescNode) && nearestDesc.parent && !(nearestDescNode.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {
          var pos = nearestDesc.posBefore;
          selection = new prosemirrorState.NodeSelection(head == pos ? $head : doc2.resolve(pos));
        }
      } else {
        if (domSel instanceof view.dom.ownerDocument.defaultView.Selection && domSel.rangeCount > 1) {
          var min2 = head, max2 = head;
          for (var i = 0; i < domSel.rangeCount; i++) {
            var range2 = domSel.getRangeAt(i);
            min2 = Math.min(min2, view.docView.posFromDOM(range2.startContainer, range2.startOffset, 1));
            max2 = Math.max(max2, view.docView.posFromDOM(range2.endContainer, range2.endOffset, -1));
          }
          if (min2 < 0) return null;
          var _ref3 = max2 == view.state.selection.anchor ? [max2, min2] : [min2, max2];
          var _ref4 = _slicedToArray(_ref3, 2);
          anchor = _ref4[0];
          head = _ref4[1];
          $head = doc2.resolve(head);
        } else {
          anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset, 1);
        }
        if (anchor < 0) return null;
      }
      var $anchor = doc2.resolve(anchor);
      if (!selection) {
        var bias = origin == "pointer" || view.state.selection.head < $head.pos && !inWidget ? 1 : -1;
        selection = selectionBetween(view, $anchor, $head, bias);
      }
      return selection;
    }
    function editorOwnsSelection(view) {
      return view.editable ? view.hasFocus() : hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);
    }
    function selectionToDOM(view) {
      var force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var sel = view.state.selection;
      syncNodeSelection(view, sel);
      if (!editorOwnsSelection(view)) return;
      if (!force && view.input.mouseDown && view.input.mouseDown.allowDefault && chrome) {
        var domSel = view.domSelectionRange(), curSel = view.domObserver.currentSelection;
        if (domSel.anchorNode && curSel.anchorNode && isEquivalentPosition(domSel.anchorNode, domSel.anchorOffset, curSel.anchorNode, curSel.anchorOffset)) {
          view.input.mouseDown.delayedSelectionSync = true;
          view.domObserver.setCurSelection();
          return;
        }
      }
      view.domObserver.disconnectSelection();
      if (view.cursorWrapper) {
        selectCursorWrapper(view);
      } else {
        var anchor = sel.anchor, head = sel.head, resetEditableFrom, resetEditableTo;
        if (brokenSelectBetweenUneditable && !(sel instanceof prosemirrorState.TextSelection)) {
          if (!sel.$from.parent.inlineContent) resetEditableFrom = temporarilyEditableNear(view, sel.from);
          if (!sel.empty && !sel.$from.parent.inlineContent) resetEditableTo = temporarilyEditableNear(view, sel.to);
        }
        view.docView.setSelection(anchor, head, view, force);
        if (brokenSelectBetweenUneditable) {
          if (resetEditableFrom) resetEditable(resetEditableFrom);
          if (resetEditableTo) resetEditable(resetEditableTo);
        }
        if (sel.visible) {
          view.dom.classList.remove("ProseMirror-hideselection");
        } else {
          view.dom.classList.add("ProseMirror-hideselection");
          if ("onselectionchange" in document) removeClassOnSelectionChange(view);
        }
      }
      view.domObserver.setCurSelection();
      view.domObserver.connectSelection();
    }
    var brokenSelectBetweenUneditable = safari || chrome && chrome_version < 63;
    function temporarilyEditableNear(view, pos) {
      var _view$docView$domFrom3 = view.docView.domFromPos(pos, 0), node = _view$docView$domFrom3.node, offset = _view$docView$domFrom3.offset;
      var after = offset < node.childNodes.length ? node.childNodes[offset] : null;
      var before = offset ? node.childNodes[offset - 1] : null;
      if (safari && after && after.contentEditable == "false") return setEditable(after);
      if ((!after || after.contentEditable == "false") && (!before || before.contentEditable == "false")) {
        if (after) return setEditable(after);
        else if (before) return setEditable(before);
      }
    }
    function setEditable(element) {
      element.contentEditable = "true";
      if (safari && element.draggable) {
        element.draggable = false;
        element.wasDraggable = true;
      }
      return element;
    }
    function resetEditable(element) {
      element.contentEditable = "false";
      if (element.wasDraggable) {
        element.draggable = true;
        element.wasDraggable = null;
      }
    }
    function removeClassOnSelectionChange(view) {
      var doc2 = view.dom.ownerDocument;
      doc2.removeEventListener("selectionchange", view.input.hideSelectionGuard);
      var domSel = view.domSelectionRange();
      var node = domSel.anchorNode, offset = domSel.anchorOffset;
      doc2.addEventListener("selectionchange", view.input.hideSelectionGuard = function() {
        if (domSel.anchorNode != node || domSel.anchorOffset != offset) {
          doc2.removeEventListener("selectionchange", view.input.hideSelectionGuard);
          setTimeout(function() {
            if (!editorOwnsSelection(view) || view.state.selection.visible) view.dom.classList.remove("ProseMirror-hideselection");
          }, 20);
        }
      });
    }
    function selectCursorWrapper(view) {
      var domSel = view.domSelection();
      if (!domSel) return;
      var node = view.cursorWrapper.dom, img = node.nodeName == "IMG";
      if (img) domSel.collapse(node.parentNode, domIndex(node) + 1);
      else domSel.collapse(node, 0);
      if (!img && !view.state.selection.visible && ie && ie_version <= 11) {
        node.disabled = true;
        node.disabled = false;
      }
    }
    function syncNodeSelection(view, sel) {
      if (sel instanceof prosemirrorState.NodeSelection) {
        var desc = view.docView.descAt(sel.from);
        if (desc != view.lastSelectedViewDesc) {
          clearNodeSelection(view);
          if (desc) desc.selectNode();
          view.lastSelectedViewDesc = desc;
        }
      } else {
        clearNodeSelection(view);
      }
    }
    function clearNodeSelection(view) {
      if (view.lastSelectedViewDesc) {
        if (view.lastSelectedViewDesc.parent) view.lastSelectedViewDesc.deselectNode();
        view.lastSelectedViewDesc = void 0;
      }
    }
    function selectionBetween(view, $anchor, $head, bias) {
      return view.someProp("createSelectionBetween", function(f) {
        return f(view, $anchor, $head);
      }) || prosemirrorState.TextSelection.between($anchor, $head, bias);
    }
    function hasFocusAndSelection(view) {
      if (view.editable && !view.hasFocus()) return false;
      return hasSelection(view);
    }
    function hasSelection(view) {
      var sel = view.domSelectionRange();
      if (!sel.anchorNode) return false;
      try {
        return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) && (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));
      } catch (_) {
        return false;
      }
    }
    function anchorInRightPlace(view) {
      var anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);
      var domSel = view.domSelectionRange();
      return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);
    }
    function moveSelectionBlock(state2, dir) {
      var _state$selection = state2.selection, $anchor = _state$selection.$anchor, $head = _state$selection.$head;
      var $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);
      var $start = !$side.parent.inlineContent ? $side : $side.depth ? state2.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;
      return $start && prosemirrorState.Selection.findFrom($start, dir);
    }
    function apply(view, sel) {
      view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());
      return true;
    }
    function selectHorizontally(view, dir, mods) {
      var sel = view.state.selection;
      if (sel instanceof prosemirrorState.TextSelection) {
        if (mods.indexOf("s") > -1) {
          var $head = sel.$head, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter;
          if (!node || node.isText || !node.isLeaf) return false;
          var $newHead = view.state.doc.resolve($head.pos + node.nodeSize * (dir < 0 ? -1 : 1));
          return apply(view, new prosemirrorState.TextSelection(sel.$anchor, $newHead));
        } else if (!sel.empty) {
          return false;
        } else if (view.endOfTextblock(dir > 0 ? "forward" : "backward")) {
          var next = moveSelectionBlock(view.state, dir);
          if (next && next instanceof prosemirrorState.NodeSelection) return apply(view, next);
          return false;
        } else if (!(mac && mods.indexOf("m") > -1)) {
          var _$head = sel.$head, _node = _$head.textOffset ? null : dir < 0 ? _$head.nodeBefore : _$head.nodeAfter, desc;
          if (!_node || _node.isText) return false;
          var nodePos = dir < 0 ? _$head.pos - _node.nodeSize : _$head.pos;
          if (!(_node.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM)) return false;
          if (prosemirrorState.NodeSelection.isSelectable(_node)) {
            return apply(view, new prosemirrorState.NodeSelection(dir < 0 ? view.state.doc.resolve(_$head.pos - _node.nodeSize) : _$head));
          } else if (webkit) {
            return apply(view, new prosemirrorState.TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + _node.nodeSize)));
          } else {
            return false;
          }
        }
      } else if (sel instanceof prosemirrorState.NodeSelection && sel.node.isInline) {
        return apply(view, new prosemirrorState.TextSelection(dir > 0 ? sel.$to : sel.$from));
      } else {
        var _next = moveSelectionBlock(view.state, dir);
        if (_next) return apply(view, _next);
        return false;
      }
    }
    function nodeLen(node) {
      return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
    }
    function isIgnorable(dom, dir) {
      var desc = dom.pmViewDesc;
      return desc && desc.size == 0 && (dir < 0 || dom.nextSibling || dom.nodeName != "BR");
    }
    function skipIgnoredNodes(view, dir) {
      return dir < 0 ? skipIgnoredNodesBefore(view) : skipIgnoredNodesAfter(view);
    }
    function skipIgnoredNodesBefore(view) {
      var sel = view.domSelectionRange();
      var node = sel.focusNode, offset = sel.focusOffset;
      if (!node) return;
      var moveNode, moveOffset, force = false;
      if (gecko && node.nodeType == 1 && offset < nodeLen(node) && isIgnorable(node.childNodes[offset], -1)) force = true;
      for (; ; ) {
        if (offset > 0) {
          if (node.nodeType != 1) {
            break;
          } else {
            var before = node.childNodes[offset - 1];
            if (isIgnorable(before, -1)) {
              moveNode = node;
              moveOffset = --offset;
            } else if (before.nodeType == 3) {
              node = before;
              offset = node.nodeValue.length;
            } else break;
          }
        } else if (isBlockNode(node)) {
          break;
        } else {
          var prev = node.previousSibling;
          while (prev && isIgnorable(prev, -1)) {
            moveNode = node.parentNode;
            moveOffset = domIndex(prev);
            prev = prev.previousSibling;
          }
          if (!prev) {
            node = node.parentNode;
            if (node == view.dom) break;
            offset = 0;
          } else {
            node = prev;
            offset = nodeLen(node);
          }
        }
      }
      if (force) setSelFocus(view, node, offset);
      else if (moveNode) setSelFocus(view, moveNode, moveOffset);
    }
    function skipIgnoredNodesAfter(view) {
      var sel = view.domSelectionRange();
      var node = sel.focusNode, offset = sel.focusOffset;
      if (!node) return;
      var len = nodeLen(node);
      var moveNode, moveOffset;
      for (; ; ) {
        if (offset < len) {
          if (node.nodeType != 1) break;
          var after = node.childNodes[offset];
          if (isIgnorable(after, 1)) {
            moveNode = node;
            moveOffset = ++offset;
          } else break;
        } else if (isBlockNode(node)) {
          break;
        } else {
          var next = node.nextSibling;
          while (next && isIgnorable(next, 1)) {
            moveNode = next.parentNode;
            moveOffset = domIndex(next) + 1;
            next = next.nextSibling;
          }
          if (!next) {
            node = node.parentNode;
            if (node == view.dom) break;
            offset = len = 0;
          } else {
            node = next;
            offset = 0;
            len = nodeLen(node);
          }
        }
      }
      if (moveNode) setSelFocus(view, moveNode, moveOffset);
    }
    function isBlockNode(dom) {
      var desc = dom.pmViewDesc;
      return desc && desc.node && desc.node.isBlock;
    }
    function textNodeAfter(node, offset) {
      while (node && offset == node.childNodes.length && !hasBlockDesc(node)) {
        offset = domIndex(node) + 1;
        node = node.parentNode;
      }
      while (node && offset < node.childNodes.length) {
        var next = node.childNodes[offset];
        if (next.nodeType == 3) return next;
        if (next.nodeType == 1 && next.contentEditable == "false") break;
        node = next;
        offset = 0;
      }
    }
    function textNodeBefore(node, offset) {
      while (node && !offset && !hasBlockDesc(node)) {
        offset = domIndex(node);
        node = node.parentNode;
      }
      while (node && offset) {
        var next = node.childNodes[offset - 1];
        if (next.nodeType == 3) return next;
        if (next.nodeType == 1 && next.contentEditable == "false") break;
        node = next;
        offset = node.childNodes.length;
      }
    }
    function setSelFocus(view, node, offset) {
      if (node.nodeType != 3) {
        var before, after;
        if (after = textNodeAfter(node, offset)) {
          node = after;
          offset = 0;
        } else if (before = textNodeBefore(node, offset)) {
          node = before;
          offset = before.nodeValue.length;
        }
      }
      var sel = view.domSelection();
      if (!sel) return;
      if (selectionCollapsed(sel)) {
        var range2 = document.createRange();
        range2.setEnd(node, offset);
        range2.setStart(node, offset);
        sel.removeAllRanges();
        sel.addRange(range2);
      } else if (sel.extend) {
        sel.extend(node, offset);
      }
      view.domObserver.setCurSelection();
      var state2 = view.state;
      setTimeout(function() {
        if (view.state == state2) selectionToDOM(view);
      }, 50);
    }
    function findDirection(view, pos) {
      var $pos = view.state.doc.resolve(pos);
      if (!(chrome || windows) && $pos.parent.inlineContent) {
        var coords = view.coordsAtPos(pos);
        if (pos > $pos.start()) {
          var before = view.coordsAtPos(pos - 1);
          var mid = (before.top + before.bottom) / 2;
          if (mid > coords.top && mid < coords.bottom && Math.abs(before.left - coords.left) > 1) return before.left < coords.left ? "ltr" : "rtl";
        }
        if (pos < $pos.end()) {
          var after = view.coordsAtPos(pos + 1);
          var _mid = (after.top + after.bottom) / 2;
          if (_mid > coords.top && _mid < coords.bottom && Math.abs(after.left - coords.left) > 1) return after.left > coords.left ? "ltr" : "rtl";
        }
      }
      var computed = getComputedStyle(view.dom).direction;
      return computed == "rtl" ? "rtl" : "ltr";
    }
    function selectVertically(view, dir, mods) {
      var sel = view.state.selection;
      if (sel instanceof prosemirrorState.TextSelection && !sel.empty || mods.indexOf("s") > -1) return false;
      if (mac && mods.indexOf("m") > -1) return false;
      var $from = sel.$from, $to = sel.$to;
      if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? "up" : "down")) {
        var next = moveSelectionBlock(view.state, dir);
        if (next && next instanceof prosemirrorState.NodeSelection) return apply(view, next);
      }
      if (!$from.parent.inlineContent) {
        var side = dir < 0 ? $from : $to;
        var beyond = sel instanceof prosemirrorState.AllSelection ? prosemirrorState.Selection.near(side, dir) : prosemirrorState.Selection.findFrom(side, dir);
        return beyond ? apply(view, beyond) : false;
      }
      return false;
    }
    function stopNativeHorizontalDelete(view, dir) {
      if (!(view.state.selection instanceof prosemirrorState.TextSelection)) return true;
      var _view$state$selection2 = view.state.selection, $head = _view$state$selection2.$head, $anchor = _view$state$selection2.$anchor, empty2 = _view$state$selection2.empty;
      if (!$head.sameParent($anchor)) return true;
      if (!empty2) return false;
      if (view.endOfTextblock(dir > 0 ? "forward" : "backward")) return true;
      var nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);
      if (nextNode && !nextNode.isText) {
        var tr = view.state.tr;
        if (dir < 0) tr["delete"]($head.pos - nextNode.nodeSize, $head.pos);
        else tr["delete"]($head.pos, $head.pos + nextNode.nodeSize);
        view.dispatch(tr);
        return true;
      }
      return false;
    }
    function switchEditable(view, node, state2) {
      view.domObserver.stop();
      node.contentEditable = state2;
      view.domObserver.start();
    }
    function safariDownArrowBug(view) {
      if (!safari || view.state.selection.$head.parentOffset > 0) return false;
      var _view$domSelectionRan3 = view.domSelectionRange(), focusNode = _view$domSelectionRan3.focusNode, focusOffset = _view$domSelectionRan3.focusOffset;
      if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 && focusNode.firstChild && focusNode.firstChild.contentEditable == "false") {
        var child = focusNode.firstChild;
        switchEditable(view, child, "true");
        setTimeout(function() {
          return switchEditable(view, child, "false");
        }, 20);
      }
      return false;
    }
    function getMods(event) {
      var result = "";
      if (event.ctrlKey) result += "c";
      if (event.metaKey) result += "m";
      if (event.altKey) result += "a";
      if (event.shiftKey) result += "s";
      return result;
    }
    function captureKeyDown(view, event) {
      var code = event.keyCode, mods = getMods(event);
      if (code == 8 || mac && code == 72 && mods == "c") {
        return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodes(view, -1);
      } else if (code == 46 && !event.shiftKey || mac && code == 68 && mods == "c") {
        return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodes(view, 1);
      } else if (code == 13 || code == 27) {
        return true;
      } else if (code == 37 || mac && code == 66 && mods == "c") {
        var dir = code == 37 ? findDirection(view, view.state.selection.from) == "ltr" ? -1 : 1 : -1;
        return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
      } else if (code == 39 || mac && code == 70 && mods == "c") {
        var _dir = code == 39 ? findDirection(view, view.state.selection.from) == "ltr" ? 1 : -1 : 1;
        return selectHorizontally(view, _dir, mods) || skipIgnoredNodes(view, _dir);
      } else if (code == 38 || mac && code == 80 && mods == "c") {
        return selectVertically(view, -1, mods) || skipIgnoredNodes(view, -1);
      } else if (code == 40 || mac && code == 78 && mods == "c") {
        return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodes(view, 1);
      } else if (mods == (mac ? "m" : "c") && (code == 66 || code == 73 || code == 89 || code == 90)) {
        return true;
      }
      return false;
    }
    function _serializeForClipboard(view, slice) {
      view.someProp("transformCopied", function(f) {
        slice = f(slice, view);
      });
      var context = [], _slice = slice, content = _slice.content, openStart = _slice.openStart, openEnd = _slice.openEnd;
      while (openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1) {
        openStart--;
        openEnd--;
        var node = content.firstChild;
        context.push(node.type.name, node.attrs != node.type.defaultAttrs ? node.attrs : null);
        content = node.content;
      }
      var serializer = view.someProp("clipboardSerializer") || prosemirrorModel.DOMSerializer.fromSchema(view.state.schema);
      var doc2 = detachedDoc(), wrap = doc2.createElement("div");
      wrap.appendChild(serializer.serializeFragment(content, {
        document: doc2
      }));
      var firstChild = wrap.firstChild, needsWrap, wrappers = 0;
      while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {
        for (var i = needsWrap.length - 1; i >= 0; i--) {
          var wrapper = doc2.createElement(needsWrap[i]);
          while (wrap.firstChild) wrapper.appendChild(wrap.firstChild);
          wrap.appendChild(wrapper);
          wrappers++;
        }
        firstChild = wrap.firstChild;
      }
      if (firstChild && firstChild.nodeType == 1) firstChild.setAttribute("data-pm-slice", "".concat(openStart, " ").concat(openEnd).concat(wrappers ? " -".concat(wrappers) : "", " ").concat(JSON.stringify(context)));
      var text = view.someProp("clipboardTextSerializer", function(f) {
        return f(slice, view);
      }) || slice.content.textBetween(0, slice.content.size, "\n\n");
      return {
        dom: wrap,
        text,
        slice
      };
    }
    function parseFromClipboard(view, text, html, plainText, $context) {
      var inCode = $context.parent.type.spec.code;
      var dom, slice;
      if (!html && !text) return null;
      var asText = !!text && (plainText || inCode || !html);
      if (asText) {
        view.someProp("transformPastedText", function(f) {
          text = f(text, inCode || plainText, view);
        });
        if (inCode) {
          slice = new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(view.state.schema.text(text.replace(/\r\n?/g, "\n"))), 0, 0);
          view.someProp("transformPasted", function(f) {
            slice = f(slice, view, true);
          });
          return slice;
        }
        var parsed = view.someProp("clipboardTextParser", function(f) {
          return f(text, $context, plainText, view);
        });
        if (parsed) {
          slice = parsed;
        } else {
          var marks = $context.marks();
          var schema = view.state.schema, serializer = prosemirrorModel.DOMSerializer.fromSchema(schema);
          dom = document.createElement("div");
          text.split(/(?:\r\n?|\n)+/).forEach(function(block) {
            var p = dom.appendChild(document.createElement("p"));
            if (block) p.appendChild(serializer.serializeNode(schema.text(block, marks)));
          });
        }
      } else {
        view.someProp("transformPastedHTML", function(f) {
          html = f(html, view);
        });
        dom = readHTML(html);
        if (webkit) restoreReplacedSpaces(dom);
      }
      var contextNode = dom && dom.querySelector("[data-pm-slice]");
      var sliceData = contextNode && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(contextNode.getAttribute("data-pm-slice") || "");
      if (sliceData && sliceData[3]) for (var i = +sliceData[3]; i > 0; i--) {
        var child = dom.firstChild;
        while (child && child.nodeType != 1) child = child.nextSibling;
        if (!child) break;
        dom = child;
      }
      if (!slice) {
        var parser = view.someProp("clipboardParser") || view.someProp("domParser") || prosemirrorModel.DOMParser.fromSchema(view.state.schema);
        slice = parser.parseSlice(dom, {
          preserveWhitespace: !!(asText || sliceData),
          context: $context,
          ruleFromNode: function ruleFromNode2(dom2) {
            if (dom2.nodeName == "BR" && !dom2.nextSibling && dom2.parentNode && !inlineParents.test(dom2.parentNode.nodeName)) return {
              ignore: true
            };
            return null;
          }
        });
      }
      if (sliceData) {
        slice = addContext(closeSlice(slice, +sliceData[1], +sliceData[2]), sliceData[4]);
      } else {
        slice = prosemirrorModel.Slice.maxOpen(normalizeSiblings(slice.content, $context), true);
        if (slice.openStart || slice.openEnd) {
          var openStart = 0, openEnd = 0;
          for (var node = slice.content.firstChild; openStart < slice.openStart && !node.type.spec.isolating; openStart++, node = node.firstChild) {
          }
          for (var _node2 = slice.content.lastChild; openEnd < slice.openEnd && !_node2.type.spec.isolating; openEnd++, _node2 = _node2.lastChild) {
          }
          slice = closeSlice(slice, openStart, openEnd);
        }
      }
      view.someProp("transformPasted", function(f) {
        slice = f(slice, view, asText);
      });
      return slice;
    }
    var inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
    function normalizeSiblings(fragment, $context) {
      if (fragment.childCount < 2) return fragment;
      var _loop = function _loop2() {
        var parent = $context.node(d);
        var match = parent.contentMatchAt($context.index(d));
        var lastWrap, result = [];
        fragment.forEach(function(node) {
          if (!result) return;
          var wrap = match.findWrapping(node.type), inLast;
          if (!wrap) return result = null;
          if (inLast = result.length && lastWrap.length && addToSibling(wrap, lastWrap, node, result[result.length - 1], 0)) {
            result[result.length - 1] = inLast;
          } else {
            if (result.length) result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length);
            var wrapped = withWrappers(node, wrap);
            result.push(wrapped);
            match = match.matchType(wrapped.type);
            lastWrap = wrap;
          }
        });
        if (result) return {
          v: prosemirrorModel.Fragment.from(result)
        };
      }, _ret;
      for (var d = $context.depth; d >= 0; d--) {
        _ret = _loop();
        if (_ret) return _ret.v;
      }
      return fragment;
    }
    function withWrappers(node, wrap) {
      var from = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      for (var i = wrap.length - 1; i >= from; i--) node = wrap[i].create(null, prosemirrorModel.Fragment.from(node));
      return node;
    }
    function addToSibling(wrap, lastWrap, node, sibling, depth) {
      if (depth < wrap.length && depth < lastWrap.length && wrap[depth] == lastWrap[depth]) {
        var inner = addToSibling(wrap, lastWrap, node, sibling.lastChild, depth + 1);
        if (inner) return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));
        var match = sibling.contentMatchAt(sibling.childCount);
        if (match.matchType(depth == wrap.length - 1 ? node.type : wrap[depth + 1])) return sibling.copy(sibling.content.append(prosemirrorModel.Fragment.from(withWrappers(node, wrap, depth + 1))));
      }
    }
    function closeRight(node, depth) {
      if (depth == 0) return node;
      var fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1));
      var fill = node.contentMatchAt(node.childCount).fillBefore(prosemirrorModel.Fragment.empty, true);
      return node.copy(fragment.append(fill));
    }
    function closeRange(fragment, side, from, to, depth, openEnd) {
      var node = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node.content;
      if (fragment.childCount > 1) openEnd = 0;
      if (depth < to - 1) inner = closeRange(inner, side, from, to, depth + 1, openEnd);
      if (depth >= from) inner = side < 0 ? node.contentMatchAt(0).fillBefore(inner, openEnd <= depth).append(inner) : inner.append(node.contentMatchAt(node.childCount).fillBefore(prosemirrorModel.Fragment.empty, true));
      return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node.copy(inner));
    }
    function closeSlice(slice, openStart, openEnd) {
      if (openStart < slice.openStart) slice = new prosemirrorModel.Slice(closeRange(slice.content, -1, openStart, slice.openStart, 0, slice.openEnd), openStart, slice.openEnd);
      if (openEnd < slice.openEnd) slice = new prosemirrorModel.Slice(closeRange(slice.content, 1, openEnd, slice.openEnd, 0, 0), slice.openStart, openEnd);
      return slice;
    }
    var wrapMap = {
      thead: ["table"],
      tbody: ["table"],
      tfoot: ["table"],
      caption: ["table"],
      colgroup: ["table"],
      col: ["table", "colgroup"],
      tr: ["table", "tbody"],
      td: ["table", "tbody", "tr"],
      th: ["table", "tbody", "tr"]
    };
    var _detachedDoc = null;
    function detachedDoc() {
      return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument("title"));
    }
    var _policy = null;
    function maybeWrapTrusted(html) {
      var trustedTypes = window.trustedTypes;
      if (!trustedTypes) return html;
      if (!_policy) _policy = trustedTypes.defaultPolicy || trustedTypes.createPolicy("ProseMirrorClipboard", {
        createHTML: function createHTML(s) {
          return s;
        }
      });
      return _policy.createHTML(html);
    }
    function readHTML(html) {
      var metas = /^(\s*<meta [^>]*>)*/.exec(html);
      if (metas) html = html.slice(metas[0].length);
      var elt = detachedDoc().createElement("div");
      var firstTag = /<([a-z][^>\s]+)/i.exec(html), wrap;
      if (wrap = firstTag && wrapMap[firstTag[1].toLowerCase()]) html = wrap.map(function(n) {
        return "<" + n + ">";
      }).join("") + html + wrap.map(function(n) {
        return "</" + n + ">";
      }).reverse().join("");
      elt.innerHTML = maybeWrapTrusted(html);
      if (wrap) for (var i = 0; i < wrap.length; i++) elt = elt.querySelector(wrap[i]) || elt;
      return elt;
    }
    function restoreReplacedSpaces(dom) {
      var nodes = dom.querySelectorAll(chrome ? "span:not([class]):not([style])" : "span.Apple-converted-space");
      for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        if (node.childNodes.length == 1 && node.textContent == "\xA0" && node.parentNode) node.parentNode.replaceChild(dom.ownerDocument.createTextNode(" "), node);
      }
    }
    function addContext(slice, context) {
      if (!slice.size) return slice;
      var schema = slice.content.firstChild.type.schema, array;
      try {
        array = JSON.parse(context);
      } catch (e) {
        return slice;
      }
      var content = slice.content, openStart = slice.openStart, openEnd = slice.openEnd;
      for (var i = array.length - 2; i >= 0; i -= 2) {
        var type2 = schema.nodes[array[i]];
        if (!type2 || type2.hasRequiredAttrs()) break;
        content = prosemirrorModel.Fragment.from(type2.create(array[i + 1], content));
        openStart++;
        openEnd++;
      }
      return new prosemirrorModel.Slice(content, openStart, openEnd);
    }
    var handlers = {};
    var editHandlers = {};
    var passiveHandlers = {
      touchstart: true,
      touchmove: true
    };
    var InputState = _createClass(function InputState2() {
      _classCallCheck(this, InputState2);
      this.shiftKey = false;
      this.mouseDown = null;
      this.lastKeyCode = null;
      this.lastKeyCodeTime = 0;
      this.lastClick = {
        time: 0,
        x: 0,
        y: 0,
        type: "",
        button: 0
      };
      this.lastSelectionOrigin = null;
      this.lastSelectionTime = 0;
      this.lastIOSEnter = 0;
      this.lastIOSEnterFallbackTimeout = -1;
      this.lastFocus = 0;
      this.lastTouch = 0;
      this.lastChromeDelete = 0;
      this.composing = false;
      this.compositionNode = null;
      this.composingTimeout = -1;
      this.compositionNodes = [];
      this.compositionEndedAt = -2e8;
      this.compositionID = 1;
      this.compositionPendingChanges = 0;
      this.domChangeCount = 0;
      this.eventHandlers = /* @__PURE__ */ Object.create(null);
      this.hideSelectionGuard = null;
    });
    function initInput(view) {
      var _loop2 = function _loop22() {
        var handler = handlers[event];
        view.dom.addEventListener(event, view.input.eventHandlers[event] = function(event2) {
          if (eventBelongsToView(view, event2) && !runCustomHandler(view, event2) && (view.editable || !(event2.type in editHandlers))) handler(view, event2);
        }, passiveHandlers[event] ? {
          passive: true
        } : void 0);
      };
      for (var event in handlers) {
        _loop2();
      }
      if (safari) view.dom.addEventListener("input", function() {
        return null;
      });
      ensureListeners(view);
    }
    function setSelectionOrigin(view, origin) {
      view.input.lastSelectionOrigin = origin;
      view.input.lastSelectionTime = Date.now();
    }
    function destroyInput(view) {
      view.domObserver.stop();
      for (var type2 in view.input.eventHandlers) view.dom.removeEventListener(type2, view.input.eventHandlers[type2]);
      clearTimeout(view.input.composingTimeout);
      clearTimeout(view.input.lastIOSEnterFallbackTimeout);
    }
    function ensureListeners(view) {
      view.someProp("handleDOMEvents", function(currentHandlers) {
        for (var type2 in currentHandlers) if (!view.input.eventHandlers[type2]) view.dom.addEventListener(type2, view.input.eventHandlers[type2] = function(event) {
          return runCustomHandler(view, event);
        });
      });
    }
    function runCustomHandler(view, event) {
      return view.someProp("handleDOMEvents", function(handlers2) {
        var handler = handlers2[event.type];
        return handler ? handler(view, event) || event.defaultPrevented : false;
      });
    }
    function eventBelongsToView(view, event) {
      if (!event.bubbles) return true;
      if (event.defaultPrevented) return false;
      for (var node = event.target; node != view.dom; node = node.parentNode) if (!node || node.nodeType == 11 || node.pmViewDesc && node.pmViewDesc.stopEvent(event)) return false;
      return true;
    }
    function _dispatchEvent(view, event) {
      if (!runCustomHandler(view, event) && handlers[event.type] && (view.editable || !(event.type in editHandlers))) handlers[event.type](view, event);
    }
    editHandlers.keydown = function(view, _event) {
      var event = _event;
      view.input.shiftKey = event.keyCode == 16 || event.shiftKey;
      if (inOrNearComposition(view, event)) return;
      view.input.lastKeyCode = event.keyCode;
      view.input.lastKeyCodeTime = Date.now();
      if (android && chrome && event.keyCode == 13) return;
      if (event.keyCode != 229) view.domObserver.forceFlush();
      if (ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {
        var now = Date.now();
        view.input.lastIOSEnter = now;
        view.input.lastIOSEnterFallbackTimeout = setTimeout(function() {
          if (view.input.lastIOSEnter == now) {
            view.someProp("handleKeyDown", function(f) {
              return f(view, keyEvent(13, "Enter"));
            });
            view.input.lastIOSEnter = 0;
          }
        }, 200);
      } else if (view.someProp("handleKeyDown", function(f) {
        return f(view, event);
      }) || captureKeyDown(view, event)) {
        event.preventDefault();
      } else {
        setSelectionOrigin(view, "key");
      }
    };
    editHandlers.keyup = function(view, event) {
      if (event.keyCode == 16) view.input.shiftKey = false;
    };
    editHandlers.keypress = function(view, _event) {
      var event = _event;
      if (inOrNearComposition(view, event) || !event.charCode || event.ctrlKey && !event.altKey || mac && event.metaKey) return;
      if (view.someProp("handleKeyPress", function(f) {
        return f(view, event);
      })) {
        event.preventDefault();
        return;
      }
      var sel = view.state.selection;
      if (!(sel instanceof prosemirrorState.TextSelection) || !sel.$from.sameParent(sel.$to)) {
        var text = String.fromCharCode(event.charCode);
        var deflt = function deflt2() {
          return view.state.tr.insertText(text).scrollIntoView();
        };
        if (!/[\r\n]/.test(text) && !view.someProp("handleTextInput", function(f) {
          return f(view, sel.$from.pos, sel.$to.pos, text, deflt);
        })) view.dispatch(deflt());
        event.preventDefault();
      }
    };
    function eventCoords(event) {
      return {
        left: event.clientX,
        top: event.clientY
      };
    }
    function isNear(event, click) {
      var dx = click.x - event.clientX, dy = click.y - event.clientY;
      return dx * dx + dy * dy < 100;
    }
    function runHandlerOnContext(view, propName, pos, inside, event) {
      if (inside == -1) return false;
      var $pos = view.state.doc.resolve(inside);
      var _loop3 = function _loop32(i2) {
        if (view.someProp(propName, function(f) {
          return i2 > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i2), event, true) : f(view, pos, $pos.node(i2), $pos.before(i2), event, false);
        })) return {
          v: true
        };
      }, _ret2;
      for (var i = $pos.depth + 1; i > 0; i--) {
        _ret2 = _loop3(i);
        if (_ret2) return _ret2.v;
      }
      return false;
    }
    function updateSelection(view, selection, origin) {
      if (!view.focused) view.focus();
      if (view.state.selection.eq(selection)) return;
      var tr = view.state.tr.setSelection(selection);
      if (origin == "pointer") tr.setMeta("pointer", true);
      view.dispatch(tr);
    }
    function selectClickedLeaf(view, inside) {
      if (inside == -1) return false;
      var $pos = view.state.doc.resolve(inside), node = $pos.nodeAfter;
      if (node && node.isAtom && prosemirrorState.NodeSelection.isSelectable(node)) {
        updateSelection(view, new prosemirrorState.NodeSelection($pos), "pointer");
        return true;
      }
      return false;
    }
    function selectClickedNode(view, inside) {
      if (inside == -1) return false;
      var sel = view.state.selection, selectedNode, selectAt;
      if (sel instanceof prosemirrorState.NodeSelection) selectedNode = sel.node;
      var $pos = view.state.doc.resolve(inside);
      for (var i = $pos.depth + 1; i > 0; i--) {
        var node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
        if (prosemirrorState.NodeSelection.isSelectable(node)) {
          if (selectedNode && sel.$from.depth > 0 && i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos) selectAt = $pos.before(sel.$from.depth);
          else selectAt = $pos.before(i);
          break;
        }
      }
      if (selectAt != null) {
        updateSelection(view, prosemirrorState.NodeSelection.create(view.state.doc, selectAt), "pointer");
        return true;
      } else {
        return false;
      }
    }
    function handleSingleClick(view, pos, inside, event, selectNode) {
      return runHandlerOnContext(view, "handleClickOn", pos, inside, event) || view.someProp("handleClick", function(f) {
        return f(view, pos, event);
      }) || (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));
    }
    function handleDoubleClick(view, pos, inside, event) {
      return runHandlerOnContext(view, "handleDoubleClickOn", pos, inside, event) || view.someProp("handleDoubleClick", function(f) {
        return f(view, pos, event);
      });
    }
    function handleTripleClick(view, pos, inside, event) {
      return runHandlerOnContext(view, "handleTripleClickOn", pos, inside, event) || view.someProp("handleTripleClick", function(f) {
        return f(view, pos, event);
      }) || defaultTripleClick(view, inside, event);
    }
    function defaultTripleClick(view, inside, event) {
      if (event.button != 0) return false;
      var doc2 = view.state.doc;
      if (inside == -1) {
        if (doc2.inlineContent) {
          updateSelection(view, prosemirrorState.TextSelection.create(doc2, 0, doc2.content.size), "pointer");
          return true;
        }
        return false;
      }
      var $pos = doc2.resolve(inside);
      for (var i = $pos.depth + 1; i > 0; i--) {
        var node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
        var nodePos = $pos.before(i);
        if (node.inlineContent) updateSelection(view, prosemirrorState.TextSelection.create(doc2, nodePos + 1, nodePos + 1 + node.content.size), "pointer");
        else if (prosemirrorState.NodeSelection.isSelectable(node)) updateSelection(view, prosemirrorState.NodeSelection.create(doc2, nodePos), "pointer");
        else continue;
        return true;
      }
    }
    function forceDOMFlush(view) {
      return endComposition(view);
    }
    var selectNodeModifier = mac ? "metaKey" : "ctrlKey";
    handlers.mousedown = function(view, _event) {
      var event = _event;
      view.input.shiftKey = event.shiftKey;
      var flushed = forceDOMFlush(view);
      var now = Date.now(), type2 = "singleClick";
      if (now - view.input.lastClick.time < 500 && isNear(event, view.input.lastClick) && !event[selectNodeModifier] && view.input.lastClick.button == event.button) {
        if (view.input.lastClick.type == "singleClick") type2 = "doubleClick";
        else if (view.input.lastClick.type == "doubleClick") type2 = "tripleClick";
      }
      view.input.lastClick = {
        time: now,
        x: event.clientX,
        y: event.clientY,
        type: type2,
        button: event.button
      };
      var pos = view.posAtCoords(eventCoords(event));
      if (!pos) return;
      if (type2 == "singleClick") {
        if (view.input.mouseDown) view.input.mouseDown.done();
        view.input.mouseDown = new MouseDown(view, pos, event, !!flushed);
      } else if ((type2 == "doubleClick" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event)) {
        event.preventDefault();
      } else {
        setSelectionOrigin(view, "pointer");
      }
    };
    var MouseDown = (function() {
      function MouseDown2(view, pos, event, flushed) {
        var _this8 = this;
        _classCallCheck(this, MouseDown2);
        this.view = view;
        this.pos = pos;
        this.event = event;
        this.flushed = flushed;
        this.delayedSelectionSync = false;
        this.mightDrag = null;
        this.startDoc = view.state.doc;
        this.selectNode = !!event[selectNodeModifier];
        this.allowDefault = event.shiftKey;
        var targetNode, targetPos;
        if (pos.inside > -1) {
          targetNode = view.state.doc.nodeAt(pos.inside);
          targetPos = pos.inside;
        } else {
          var $pos = view.state.doc.resolve(pos.pos);
          targetNode = $pos.parent;
          targetPos = $pos.depth ? $pos.before() : 0;
        }
        var target = flushed ? null : event.target;
        var targetDesc = target ? view.docView.nearestDesc(target, true) : null;
        this.target = targetDesc && targetDesc.nodeDOM.nodeType == 1 ? targetDesc.nodeDOM : null;
        var selection = view.state.selection;
        if (event.button == 0 && targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || selection instanceof prosemirrorState.NodeSelection && selection.from <= targetPos && selection.to > targetPos) this.mightDrag = {
          node: targetNode,
          pos: targetPos,
          addAttr: !!(this.target && !this.target.draggable),
          setUneditable: !!(this.target && gecko && !this.target.hasAttribute("contentEditable"))
        };
        if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {
          this.view.domObserver.stop();
          if (this.mightDrag.addAttr) this.target.draggable = true;
          if (this.mightDrag.setUneditable) setTimeout(function() {
            if (_this8.view.input.mouseDown == _this8) _this8.target.setAttribute("contentEditable", "false");
          }, 20);
          this.view.domObserver.start();
        }
        view.root.addEventListener("mouseup", this.up = this.up.bind(this));
        view.root.addEventListener("mousemove", this.move = this.move.bind(this));
        setSelectionOrigin(view, "pointer");
      }
      _createClass(MouseDown2, [{
        key: "done",
        value: function done() {
          var _this9 = this;
          this.view.root.removeEventListener("mouseup", this.up);
          this.view.root.removeEventListener("mousemove", this.move);
          if (this.mightDrag && this.target) {
            this.view.domObserver.stop();
            if (this.mightDrag.addAttr) this.target.removeAttribute("draggable");
            if (this.mightDrag.setUneditable) this.target.removeAttribute("contentEditable");
            this.view.domObserver.start();
          }
          if (this.delayedSelectionSync) setTimeout(function() {
            return selectionToDOM(_this9.view);
          });
          this.view.input.mouseDown = null;
        }
      }, {
        key: "up",
        value: function up(event) {
          this.done();
          if (!this.view.dom.contains(event.target)) return;
          var pos = this.pos;
          if (this.view.state.doc != this.startDoc) pos = this.view.posAtCoords(eventCoords(event));
          this.updateAllowDefault(event);
          if (this.allowDefault || !pos) {
            setSelectionOrigin(this.view, "pointer");
          } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {
            event.preventDefault();
          } else if (event.button == 0 && (this.flushed || safari && this.mightDrag && !this.mightDrag.node.isAtom || chrome && !this.view.state.selection.visible && Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2)) {
            updateSelection(this.view, prosemirrorState.Selection.near(this.view.state.doc.resolve(pos.pos)), "pointer");
            event.preventDefault();
          } else {
            setSelectionOrigin(this.view, "pointer");
          }
        }
      }, {
        key: "move",
        value: function move(event) {
          this.updateAllowDefault(event);
          setSelectionOrigin(this.view, "pointer");
          if (event.buttons == 0) this.done();
        }
      }, {
        key: "updateAllowDefault",
        value: function updateAllowDefault(event) {
          if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4)) this.allowDefault = true;
        }
      }]);
      return MouseDown2;
    })();
    handlers.touchstart = function(view) {
      view.input.lastTouch = Date.now();
      forceDOMFlush(view);
      setSelectionOrigin(view, "pointer");
    };
    handlers.touchmove = function(view) {
      view.input.lastTouch = Date.now();
      setSelectionOrigin(view, "pointer");
    };
    handlers.contextmenu = function(view) {
      return forceDOMFlush(view);
    };
    function inOrNearComposition(view, event) {
      if (view.composing) return true;
      if (safari && Math.abs(event.timeStamp - view.input.compositionEndedAt) < 500) {
        view.input.compositionEndedAt = -2e8;
        return true;
      }
      return false;
    }
    var timeoutComposition = android ? 5e3 : -1;
    editHandlers.compositionstart = editHandlers.compositionupdate = function(view) {
      if (!view.composing) {
        view.domObserver.flush();
        var state2 = view.state, $pos = state2.selection.$to;
        if (state2.selection instanceof prosemirrorState.TextSelection && (state2.storedMarks || !$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some(function(m) {
          return m.type.spec.inclusive === false;
        }))) {
          view.markCursor = view.state.storedMarks || $pos.marks();
          endComposition(view, true);
          view.markCursor = null;
        } else {
          endComposition(view, !state2.selection.empty);
          if (gecko && state2.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {
            var sel = view.domSelectionRange();
            for (var node = sel.focusNode, offset = sel.focusOffset; node && node.nodeType == 1 && offset != 0; ) {
              var before = offset < 0 ? node.lastChild : node.childNodes[offset - 1];
              if (!before) break;
              if (before.nodeType == 3) {
                var _sel = view.domSelection();
                if (_sel) _sel.collapse(before, before.nodeValue.length);
                break;
              } else {
                node = before;
                offset = -1;
              }
            }
          }
        }
        view.input.composing = true;
      }
      scheduleComposeEnd(view, timeoutComposition);
    };
    editHandlers.compositionend = function(view, event) {
      if (view.composing) {
        view.input.composing = false;
        view.input.compositionEndedAt = event.timeStamp;
        view.input.compositionPendingChanges = view.domObserver.pendingRecords().length ? view.input.compositionID : 0;
        view.input.compositionNode = null;
        if (view.input.compositionPendingChanges) Promise.resolve().then(function() {
          return view.domObserver.flush();
        });
        view.input.compositionID++;
        scheduleComposeEnd(view, 20);
      }
    };
    function scheduleComposeEnd(view, delay) {
      clearTimeout(view.input.composingTimeout);
      if (delay > -1) view.input.composingTimeout = setTimeout(function() {
        return endComposition(view);
      }, delay);
    }
    function clearComposition(view) {
      if (view.composing) {
        view.input.composing = false;
        view.input.compositionEndedAt = timestampFromCustomEvent();
      }
      while (view.input.compositionNodes.length > 0) view.input.compositionNodes.pop().markParentsDirty();
    }
    function findCompositionNode(view) {
      var sel = view.domSelectionRange();
      if (!sel.focusNode) return null;
      var textBefore = textNodeBefore$1(sel.focusNode, sel.focusOffset);
      var textAfter = textNodeAfter$1(sel.focusNode, sel.focusOffset);
      if (textBefore && textAfter && textBefore != textAfter) {
        var descAfter = textAfter.pmViewDesc, lastChanged = view.domObserver.lastChangedTextNode;
        if (textBefore == lastChanged || textAfter == lastChanged) return lastChanged;
        if (!descAfter || !descAfter.isText(textAfter.nodeValue)) {
          return textAfter;
        } else if (view.input.compositionNode == textAfter) {
          var descBefore = textBefore.pmViewDesc;
          if (!(!descBefore || !descBefore.isText(textBefore.nodeValue))) return textAfter;
        }
      }
      return textBefore || textAfter;
    }
    function timestampFromCustomEvent() {
      var event = document.createEvent("Event");
      event.initEvent("event", true, true);
      return event.timeStamp;
    }
    function endComposition(view) {
      var restarting = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (android && view.domObserver.flushingSoon >= 0) return;
      view.domObserver.forceFlush();
      clearComposition(view);
      if (restarting || view.docView && view.docView.dirty) {
        var sel = selectionFromDOM(view), cur = view.state.selection;
        if (sel && !sel.eq(cur)) view.dispatch(view.state.tr.setSelection(sel));
        else if ((view.markCursor || restarting) && !cur.$from.node(cur.$from.sharedDepth(cur.to)).inlineContent) view.dispatch(view.state.tr.deleteSelection());
        else view.updateState(view.state);
        return true;
      }
      return false;
    }
    function captureCopy(view, dom) {
      if (!view.dom.parentNode) return;
      var wrap = view.dom.parentNode.appendChild(document.createElement("div"));
      wrap.appendChild(dom);
      wrap.style.cssText = "position: fixed; left: -10000px; top: 10px";
      var sel = getSelection(), range2 = document.createRange();
      range2.selectNodeContents(dom);
      view.dom.blur();
      sel.removeAllRanges();
      sel.addRange(range2);
      setTimeout(function() {
        if (wrap.parentNode) wrap.parentNode.removeChild(wrap);
        view.focus();
      }, 50);
    }
    var brokenClipboardAPI = ie && ie_version < 15 || ios && webkit_version < 604;
    handlers.copy = editHandlers.cut = function(view, _event) {
      var event = _event;
      var sel = view.state.selection, cut = event.type == "cut";
      if (sel.empty) return;
      var data = brokenClipboardAPI ? null : event.clipboardData;
      var slice = sel.content(), _serializeForClipboar = _serializeForClipboard(view, slice), dom = _serializeForClipboar.dom, text = _serializeForClipboar.text;
      if (data) {
        event.preventDefault();
        data.clearData();
        data.setData("text/html", dom.innerHTML);
        data.setData("text/plain", text);
      } else {
        captureCopy(view, dom);
      }
      if (cut) view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
    };
    function sliceSingleNode(slice) {
      return slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1 ? slice.content.firstChild : null;
    }
    function capturePaste(view, event) {
      if (!view.dom.parentNode) return;
      var plainText = view.input.shiftKey || view.state.selection.$from.parent.type.spec.code;
      var target = view.dom.parentNode.appendChild(document.createElement(plainText ? "textarea" : "div"));
      if (!plainText) target.contentEditable = "true";
      target.style.cssText = "position: fixed; left: -10000px; top: 10px";
      target.focus();
      var plain = view.input.shiftKey && view.input.lastKeyCode != 45;
      setTimeout(function() {
        view.focus();
        if (target.parentNode) target.parentNode.removeChild(target);
        if (plainText) doPaste(view, target.value, null, plain, event);
        else doPaste(view, target.textContent, target.innerHTML, plain, event);
      }, 50);
    }
    function doPaste(view, text, html, preferPlain, event) {
      var slice = parseFromClipboard(view, text, html, preferPlain, view.state.selection.$from);
      if (view.someProp("handlePaste", function(f) {
        return f(view, event, slice || prosemirrorModel.Slice.empty);
      })) return true;
      if (!slice) return false;
      var singleNode = sliceSingleNode(slice);
      var tr = singleNode ? view.state.tr.replaceSelectionWith(singleNode, preferPlain) : view.state.tr.replaceSelection(slice);
      view.dispatch(tr.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste"));
      return true;
    }
    function getText(clipboardData) {
      var text = clipboardData.getData("text/plain") || clipboardData.getData("Text");
      if (text) return text;
      var uris = clipboardData.getData("text/uri-list");
      return uris ? uris.replace(/\r?\n/g, " ") : "";
    }
    editHandlers.paste = function(view, _event) {
      var event = _event;
      if (view.composing && !android) return;
      var data = brokenClipboardAPI ? null : event.clipboardData;
      var plain = view.input.shiftKey && view.input.lastKeyCode != 45;
      if (data && doPaste(view, getText(data), data.getData("text/html"), plain, event)) event.preventDefault();
      else capturePaste(view, event);
    };
    var Dragging = _createClass(function Dragging2(slice, move, node) {
      _classCallCheck(this, Dragging2);
      this.slice = slice;
      this.move = move;
      this.node = node;
    });
    var dragCopyModifier = mac ? "altKey" : "ctrlKey";
    function dragMoves(view, event) {
      var moves = view.someProp("dragCopies", function(test) {
        return !test(event);
      });
      return moves != null ? moves : !event[dragCopyModifier];
    }
    handlers.dragstart = function(view, _event) {
      var event = _event;
      var mouseDown = view.input.mouseDown;
      if (mouseDown) mouseDown.done();
      if (!event.dataTransfer) return;
      var sel = view.state.selection;
      var pos = sel.empty ? null : view.posAtCoords(eventCoords(event));
      var node;
      if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof prosemirrorState.NodeSelection ? sel.to - 1 : sel.to)) ;
      else if (mouseDown && mouseDown.mightDrag) {
        node = prosemirrorState.NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos);
      } else if (event.target && event.target.nodeType == 1) {
        var desc = view.docView.nearestDesc(event.target, true);
        if (desc && desc.node.type.spec.draggable && desc != view.docView) node = prosemirrorState.NodeSelection.create(view.state.doc, desc.posBefore);
      }
      var draggedSlice = (node || view.state.selection).content();
      var _serializeForClipboar2 = _serializeForClipboard(view, draggedSlice), dom = _serializeForClipboar2.dom, text = _serializeForClipboar2.text, slice = _serializeForClipboar2.slice;
      if (!event.dataTransfer.files.length || !chrome || chrome_version > 120) event.dataTransfer.clearData();
      event.dataTransfer.setData(brokenClipboardAPI ? "Text" : "text/html", dom.innerHTML);
      event.dataTransfer.effectAllowed = "copyMove";
      if (!brokenClipboardAPI) event.dataTransfer.setData("text/plain", text);
      view.dragging = new Dragging(slice, dragMoves(view, event), node);
    };
    handlers.dragend = function(view) {
      var dragging = view.dragging;
      window.setTimeout(function() {
        if (view.dragging == dragging) view.dragging = null;
      }, 50);
    };
    editHandlers.dragover = editHandlers.dragenter = function(_, e) {
      return e.preventDefault();
    };
    editHandlers.drop = function(view, _event) {
      var event = _event;
      var dragging = view.dragging;
      view.dragging = null;
      if (!event.dataTransfer) return;
      var eventPos = view.posAtCoords(eventCoords(event));
      if (!eventPos) return;
      var $mouse = view.state.doc.resolve(eventPos.pos);
      var slice = dragging && dragging.slice;
      if (slice) {
        view.someProp("transformPasted", function(f) {
          slice = f(slice, view, false);
        });
      } else {
        slice = parseFromClipboard(view, getText(event.dataTransfer), brokenClipboardAPI ? null : event.dataTransfer.getData("text/html"), false, $mouse);
      }
      var move = !!(dragging && dragMoves(view, event));
      if (view.someProp("handleDrop", function(f) {
        return f(view, event, slice || prosemirrorModel.Slice.empty, move);
      })) {
        event.preventDefault();
        return;
      }
      if (!slice) return;
      event.preventDefault();
      var insertPos = slice ? prosemirrorTransform.dropPoint(view.state.doc, $mouse.pos, slice) : $mouse.pos;
      if (insertPos == null) insertPos = $mouse.pos;
      var tr = view.state.tr;
      if (move) {
        var node = dragging.node;
        if (node) node.replace(tr);
        else tr.deleteSelection();
      }
      var pos = tr.mapping.map(insertPos);
      var isNode = slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1;
      var beforeInsert = tr.doc;
      if (isNode) tr.replaceRangeWith(pos, pos, slice.content.firstChild);
      else tr.replaceRange(pos, pos, slice);
      if (tr.doc.eq(beforeInsert)) return;
      var $pos = tr.doc.resolve(pos);
      if (isNode && prosemirrorState.NodeSelection.isSelectable(slice.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice.content.firstChild)) {
        tr.setSelection(new prosemirrorState.NodeSelection($pos));
      } else {
        var end = tr.mapping.map(insertPos);
        tr.mapping.maps[tr.mapping.maps.length - 1].forEach(function(_from, _to, _newFrom, newTo) {
          return end = newTo;
        });
        tr.setSelection(selectionBetween(view, $pos, tr.doc.resolve(end)));
      }
      view.focus();
      view.dispatch(tr.setMeta("uiEvent", "drop"));
    };
    handlers.focus = function(view) {
      view.input.lastFocus = Date.now();
      if (!view.focused) {
        view.domObserver.stop();
        view.dom.classList.add("ProseMirror-focused");
        view.domObserver.start();
        view.focused = true;
        setTimeout(function() {
          if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.domSelectionRange())) selectionToDOM(view);
        }, 20);
      }
    };
    handlers.blur = function(view, _event) {
      var event = _event;
      if (view.focused) {
        view.domObserver.stop();
        view.dom.classList.remove("ProseMirror-focused");
        view.domObserver.start();
        if (event.relatedTarget && view.dom.contains(event.relatedTarget)) view.domObserver.currentSelection.clear();
        view.focused = false;
      }
    };
    handlers.beforeinput = function(view, _event) {
      var event = _event;
      if (chrome && android && event.inputType == "deleteContentBackward") {
        view.domObserver.flushSoon();
        var domChangeCount = view.input.domChangeCount;
        setTimeout(function() {
          if (view.input.domChangeCount != domChangeCount) return;
          view.dom.blur();
          view.focus();
          if (view.someProp("handleKeyDown", function(f) {
            return f(view, keyEvent(8, "Backspace"));
          })) return;
          var $cursor = view.state.selection.$cursor;
          if ($cursor && $cursor.pos > 0) view.dispatch(view.state.tr["delete"]($cursor.pos - 1, $cursor.pos).scrollIntoView());
        }, 50);
      }
    };
    for (prop in editHandlers) handlers[prop] = editHandlers[prop];
    var prop;
    function compareObjs(a, b) {
      if (a == b) return true;
      for (var p in a) if (a[p] !== b[p]) return false;
      for (var _p in b) if (!(_p in a)) return false;
      return true;
    }
    var WidgetType = (function() {
      function WidgetType2(toDOM, spec) {
        _classCallCheck(this, WidgetType2);
        this.toDOM = toDOM;
        this.spec = spec || noSpec;
        this.side = this.spec.side || 0;
      }
      _createClass(WidgetType2, [{
        key: "map",
        value: function map(mapping, span, offset, oldOffset) {
          var _mapping$mapResult = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1), pos = _mapping$mapResult.pos, deleted = _mapping$mapResult.deleted;
          return deleted ? null : new Decoration(pos - offset, pos - offset, this);
        }
      }, {
        key: "valid",
        value: function valid() {
          return true;
        }
      }, {
        key: "eq",
        value: function eq(other) {
          return this == other || other instanceof WidgetType2 && (this.spec.key && this.spec.key == other.spec.key || this.toDOM == other.toDOM && compareObjs(this.spec, other.spec));
        }
      }, {
        key: "destroy",
        value: function destroy(node) {
          if (this.spec.destroy) this.spec.destroy(node);
        }
      }]);
      return WidgetType2;
    })();
    var InlineType = (function() {
      function InlineType2(attrs, spec) {
        _classCallCheck(this, InlineType2);
        this.attrs = attrs;
        this.spec = spec || noSpec;
      }
      _createClass(InlineType2, [{
        key: "map",
        value: function map(mapping, span, offset, oldOffset) {
          var from = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset;
          var to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset;
          return from >= to ? null : new Decoration(from, to, this);
        }
      }, {
        key: "valid",
        value: function valid(_, span) {
          return span.from < span.to;
        }
      }, {
        key: "eq",
        value: function eq(other) {
          return this == other || other instanceof InlineType2 && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
        }
      }, {
        key: "destroy",
        value: function destroy() {
        }
      }], [{
        key: "is",
        value: function is(span) {
          return span.type instanceof InlineType2;
        }
      }]);
      return InlineType2;
    })();
    var NodeType = (function() {
      function NodeType2(attrs, spec) {
        _classCallCheck(this, NodeType2);
        this.attrs = attrs;
        this.spec = spec || noSpec;
      }
      _createClass(NodeType2, [{
        key: "map",
        value: function map(mapping, span, offset, oldOffset) {
          var from = mapping.mapResult(span.from + oldOffset, 1);
          if (from.deleted) return null;
          var to = mapping.mapResult(span.to + oldOffset, -1);
          if (to.deleted || to.pos <= from.pos) return null;
          return new Decoration(from.pos - offset, to.pos - offset, this);
        }
      }, {
        key: "valid",
        value: function valid(node, span) {
          var _node$content$findInd = node.content.findIndex(span.from), index = _node$content$findInd.index, offset = _node$content$findInd.offset, child;
          return offset == span.from && !(child = node.child(index)).isText && offset + child.nodeSize == span.to;
        }
      }, {
        key: "eq",
        value: function eq(other) {
          return this == other || other instanceof NodeType2 && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
        }
      }, {
        key: "destroy",
        value: function destroy() {
        }
      }]);
      return NodeType2;
    })();
    var Decoration = (function() {
      function Decoration2(from, to, type2) {
        _classCallCheck(this, Decoration2);
        this.from = from;
        this.to = to;
        this.type = type2;
      }
      _createClass(Decoration2, [{
        key: "copy",
        value: function copy(from, to) {
          return new Decoration2(from, to, this.type);
        }
      }, {
        key: "eq",
        value: function eq(other) {
          var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
          return this.type.eq(other.type) && this.from + offset == other.from && this.to + offset == other.to;
        }
      }, {
        key: "map",
        value: function map(mapping, offset, oldOffset) {
          return this.type.map(mapping, this, offset, oldOffset);
        }
      }, {
        key: "spec",
        get: function get2() {
          return this.type.spec;
        }
      }, {
        key: "inline",
        get: function get2() {
          return this.type instanceof InlineType;
        }
      }, {
        key: "widget",
        get: function get2() {
          return this.type instanceof WidgetType;
        }
      }], [{
        key: "widget",
        value: function widget(pos, toDOM, spec) {
          return new Decoration2(pos, pos, new WidgetType(toDOM, spec));
        }
      }, {
        key: "inline",
        value: function inline(from, to, attrs, spec) {
          return new Decoration2(from, to, new InlineType(attrs, spec));
        }
      }, {
        key: "node",
        value: function node(from, to, attrs, spec) {
          return new Decoration2(from, to, new NodeType(attrs, spec));
        }
      }]);
      return Decoration2;
    })();
    var none = [];
    var noSpec = {};
    var DecorationSet = (function() {
      function DecorationSet2(local, children) {
        _classCallCheck(this, DecorationSet2);
        this.local = local.length ? local : none;
        this.children = children.length ? children : none;
      }
      _createClass(DecorationSet2, [{
        key: "find",
        value: function find(start, end, predicate) {
          var result = [];
          this.findInner(start == null ? 0 : start, end == null ? 1e9 : end, result, 0, predicate);
          return result;
        }
      }, {
        key: "findInner",
        value: function findInner(start, end, result, offset, predicate) {
          for (var i = 0; i < this.local.length; i++) {
            var span = this.local[i];
            if (span.from <= end && span.to >= start && (!predicate || predicate(span.spec))) result.push(span.copy(span.from + offset, span.to + offset));
          }
          for (var _i6 = 0; _i6 < this.children.length; _i6 += 3) {
            if (this.children[_i6] < end && this.children[_i6 + 1] > start) {
              var childOff = this.children[_i6] + 1;
              this.children[_i6 + 2].findInner(start - childOff, end - childOff, result, offset + childOff, predicate);
            }
          }
        }
      }, {
        key: "map",
        value: function map(mapping, doc2, options) {
          if (this == empty || mapping.maps.length == 0) return this;
          return this.mapInner(mapping, doc2, 0, 0, options || noSpec);
        }
      }, {
        key: "mapInner",
        value: function mapInner(mapping, node, offset, oldOffset, options) {
          var newLocal;
          for (var i = 0; i < this.local.length; i++) {
            var mapped = this.local[i].map(mapping, offset, oldOffset);
            if (mapped && mapped.type.valid(node, mapped)) (newLocal || (newLocal = [])).push(mapped);
            else if (options.onRemove) options.onRemove(this.local[i].spec);
          }
          if (this.children.length) return mapChildren(this.children, newLocal || [], mapping, node, offset, oldOffset, options);
          else return newLocal ? new DecorationSet2(newLocal.sort(byPos), none) : empty;
        }
      }, {
        key: "add",
        value: function add(doc2, decorations) {
          if (!decorations.length) return this;
          if (this == empty) return DecorationSet2.create(doc2, decorations);
          return this.addInner(doc2, decorations, 0);
        }
      }, {
        key: "addInner",
        value: function addInner(doc2, decorations, offset) {
          var _this10 = this;
          var children, childIndex = 0;
          doc2.forEach(function(childNode, childOffset) {
            var baseOffset = childOffset + offset, found;
            if (!(found = takeSpansForNode(decorations, childNode, baseOffset))) return;
            if (!children) children = _this10.children.slice();
            while (childIndex < children.length && children[childIndex] < childOffset) childIndex += 3;
            if (children[childIndex] == childOffset) children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found, baseOffset + 1);
            else children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found, childNode, baseOffset + 1, noSpec));
            childIndex += 3;
          });
          var local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset);
          for (var i = 0; i < local.length; i++) if (!local[i].type.valid(doc2, local[i])) local.splice(i--, 1);
          return new DecorationSet2(local.length ? this.local.concat(local).sort(byPos) : this.local, children || this.children);
        }
      }, {
        key: "remove",
        value: function remove(decorations) {
          if (decorations.length == 0 || this == empty) return this;
          return this.removeInner(decorations, 0);
        }
      }, {
        key: "removeInner",
        value: function removeInner(decorations, offset) {
          var children = this.children, local = this.local;
          for (var i = 0; i < children.length; i += 3) {
            var found = void 0;
            var from = children[i] + offset, to = children[i + 1] + offset;
            for (var j = 0, span; j < decorations.length; j++) if (span = decorations[j]) {
              if (span.from > from && span.to < to) {
                decorations[j] = null;
                (found || (found = [])).push(span);
              }
            }
            if (!found) continue;
            if (children == this.children) children = this.children.slice();
            var removed = children[i + 2].removeInner(found, from + 1);
            if (removed != empty) {
              children[i + 2] = removed;
            } else {
              children.splice(i, 3);
              i -= 3;
            }
          }
          if (local.length) {
            for (var _i7 = 0, _span; _i7 < decorations.length; _i7++) if (_span = decorations[_i7]) {
              for (var _j2 = 0; _j2 < local.length; _j2++) if (local[_j2].eq(_span, offset)) {
                if (local == this.local) local = this.local.slice();
                local.splice(_j2--, 1);
              }
            }
          }
          if (children == this.children && local == this.local) return this;
          return local.length || children.length ? new DecorationSet2(local, children) : empty;
        }
      }, {
        key: "forChild",
        value: function forChild(offset, node) {
          if (this == empty) return this;
          if (node.isLeaf) return DecorationSet2.empty;
          var child, local;
          for (var i = 0; i < this.children.length; i += 3) if (this.children[i] >= offset) {
            if (this.children[i] == offset) child = this.children[i + 2];
            break;
          }
          var start = offset + 1, end = start + node.content.size;
          for (var _i8 = 0; _i8 < this.local.length; _i8++) {
            var dec = this.local[_i8];
            if (dec.from < end && dec.to > start && dec.type instanceof InlineType) {
              var from = Math.max(start, dec.from) - start, to = Math.min(end, dec.to) - start;
              if (from < to) (local || (local = [])).push(dec.copy(from, to));
            }
          }
          if (local) {
            var localSet = new DecorationSet2(local.sort(byPos), none);
            return child ? new DecorationGroup([localSet, child]) : localSet;
          }
          return child || empty;
        }
      }, {
        key: "eq",
        value: function eq(other) {
          if (this == other) return true;
          if (!(other instanceof DecorationSet2) || this.local.length != other.local.length || this.children.length != other.children.length) return false;
          for (var i = 0; i < this.local.length; i++) if (!this.local[i].eq(other.local[i])) return false;
          for (var _i9 = 0; _i9 < this.children.length; _i9 += 3) if (this.children[_i9] != other.children[_i9] || this.children[_i9 + 1] != other.children[_i9 + 1] || !this.children[_i9 + 2].eq(other.children[_i9 + 2])) return false;
          return true;
        }
      }, {
        key: "locals",
        value: function locals(node) {
          return removeOverlap(this.localsInner(node));
        }
      }, {
        key: "localsInner",
        value: function localsInner(node) {
          if (this == empty) return none;
          if (node.inlineContent || !this.local.some(InlineType.is)) return this.local;
          var result = [];
          for (var i = 0; i < this.local.length; i++) {
            if (!(this.local[i].type instanceof InlineType)) result.push(this.local[i]);
          }
          return result;
        }
      }, {
        key: "forEachSet",
        value: function forEachSet(f) {
          f(this);
        }
      }], [{
        key: "create",
        value: function create(doc2, decorations) {
          return decorations.length ? buildTree(decorations, doc2, 0, noSpec) : empty;
        }
      }]);
      return DecorationSet2;
    })();
    DecorationSet.empty = new DecorationSet([], []);
    DecorationSet.removeOverlap = removeOverlap;
    var empty = DecorationSet.empty;
    var DecorationGroup = (function() {
      function DecorationGroup2(members) {
        _classCallCheck(this, DecorationGroup2);
        this.members = members;
      }
      _createClass(DecorationGroup2, [{
        key: "map",
        value: function map(mapping, doc2) {
          var mappedDecos = this.members.map(function(member) {
            return member.map(mapping, doc2, noSpec);
          });
          return DecorationGroup2.from(mappedDecos);
        }
      }, {
        key: "forChild",
        value: function forChild(offset, child) {
          if (child.isLeaf) return DecorationSet.empty;
          var found = [];
          for (var i = 0; i < this.members.length; i++) {
            var result = this.members[i].forChild(offset, child);
            if (result == empty) continue;
            if (result instanceof DecorationGroup2) found = found.concat(result.members);
            else found.push(result);
          }
          return DecorationGroup2.from(found);
        }
      }, {
        key: "eq",
        value: function eq(other) {
          if (!(other instanceof DecorationGroup2) || other.members.length != this.members.length) return false;
          for (var i = 0; i < this.members.length; i++) if (!this.members[i].eq(other.members[i])) return false;
          return true;
        }
      }, {
        key: "locals",
        value: function locals(node) {
          var result, sorted = true;
          for (var i = 0; i < this.members.length; i++) {
            var locals2 = this.members[i].localsInner(node);
            if (!locals2.length) continue;
            if (!result) {
              result = locals2;
            } else {
              if (sorted) {
                result = result.slice();
                sorted = false;
              }
              for (var j = 0; j < locals2.length; j++) result.push(locals2[j]);
            }
          }
          return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none;
        }
      }, {
        key: "forEachSet",
        value: function forEachSet(f) {
          for (var i = 0; i < this.members.length; i++) this.members[i].forEachSet(f);
        }
      }], [{
        key: "from",
        value: function from(members) {
          switch (members.length) {
            case 0:
              return empty;
            case 1:
              return members[0];
            default:
              return new DecorationGroup2(members.every(function(m) {
                return m instanceof DecorationSet;
              }) ? members : members.reduce(function(r, m) {
                return r.concat(m instanceof DecorationSet ? m : m.members);
              }, []));
          }
        }
      }]);
      return DecorationGroup2;
    })();
    function mapChildren(oldChildren, newLocal, mapping, node, offset, oldOffset, options) {
      var children = oldChildren.slice();
      var _loop4 = function _loop42(_baseOffset) {
        var moved = 0;
        mapping.maps[i].forEach(function(oldStart, oldEnd, newStart, newEnd) {
          var dSize = newEnd - newStart - (oldEnd - oldStart);
          for (var _i13 = 0; _i13 < children.length; _i13 += 3) {
            var end = children[_i13 + 1];
            if (end < 0 || oldStart > end + _baseOffset - moved) continue;
            var start = children[_i13] + _baseOffset - moved;
            if (oldEnd >= start) {
              children[_i13 + 1] = oldStart <= start ? -2 : -1;
            } else if (oldStart >= _baseOffset && dSize) {
              children[_i13] += dSize;
              children[_i13 + 1] += dSize;
            }
          }
          moved += dSize;
        });
        _baseOffset = mapping.maps[i].map(_baseOffset, -1);
        baseOffset = _baseOffset;
      };
      for (var i = 0, baseOffset = oldOffset; i < mapping.maps.length; i++) {
        _loop4(baseOffset);
      }
      var mustRebuild = false;
      for (var _i10 = 0; _i10 < children.length; _i10 += 3) if (children[_i10 + 1] < 0) {
        if (children[_i10 + 1] == -2) {
          mustRebuild = true;
          children[_i10 + 1] = -1;
          continue;
        }
        var from = mapping.map(oldChildren[_i10] + oldOffset), fromLocal = from - offset;
        if (fromLocal < 0 || fromLocal >= node.content.size) {
          mustRebuild = true;
          continue;
        }
        var to = mapping.map(oldChildren[_i10 + 1] + oldOffset, -1), toLocal = to - offset;
        var _node$content$findInd2 = node.content.findIndex(fromLocal), index = _node$content$findInd2.index, childOffset = _node$content$findInd2.offset;
        var childNode = node.maybeChild(index);
        if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {
          var mapped = children[_i10 + 2].mapInner(mapping, childNode, from + 1, oldChildren[_i10] + oldOffset + 1, options);
          if (mapped != empty) {
            children[_i10] = fromLocal;
            children[_i10 + 1] = toLocal;
            children[_i10 + 2] = mapped;
          } else {
            children[_i10 + 1] = -2;
            mustRebuild = true;
          }
        } else {
          mustRebuild = true;
        }
      }
      if (mustRebuild) {
        var decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal, mapping, offset, oldOffset, options);
        var built = buildTree(decorations, node, 0, options);
        newLocal = built.local;
        for (var _i11 = 0; _i11 < children.length; _i11 += 3) if (children[_i11 + 1] < 0) {
          children.splice(_i11, 3);
          _i11 -= 3;
        }
        for (var _i12 = 0, j = 0; _i12 < built.children.length; _i12 += 3) {
          var _from2 = built.children[_i12];
          while (j < children.length && children[j] < _from2) j += 3;
          children.splice(j, 0, built.children[_i12], built.children[_i12 + 1], built.children[_i12 + 2]);
        }
      }
      return new DecorationSet(newLocal.sort(byPos), children);
    }
    function moveSpans(spans, offset) {
      if (!offset || !spans.length) return spans;
      var result = [];
      for (var i = 0; i < spans.length; i++) {
        var span = spans[i];
        result.push(new Decoration(span.from + offset, span.to + offset, span.type));
      }
      return result;
    }
    function mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset, oldOffset, options) {
      function gather(set, oldOffset2) {
        for (var i2 = 0; i2 < set.local.length; i2++) {
          var mapped = set.local[i2].map(mapping, offset, oldOffset2);
          if (mapped) decorations.push(mapped);
          else if (options.onRemove) options.onRemove(set.local[i2].spec);
        }
        for (var _i14 = 0; _i14 < set.children.length; _i14 += 3) gather(set.children[_i14 + 2], set.children[_i14] + oldOffset2 + 1);
      }
      for (var i = 0; i < children.length; i += 3) if (children[i + 1] == -1) gather(children[i + 2], oldChildren[i] + oldOffset + 1);
      return decorations;
    }
    function takeSpansForNode(spans, node, offset) {
      if (node.isLeaf) return null;
      var end = offset + node.nodeSize, found = null;
      for (var i = 0, span; i < spans.length; i++) {
        if ((span = spans[i]) && span.from > offset && span.to < end) {
          (found || (found = [])).push(span);
          spans[i] = null;
        }
      }
      return found;
    }
    function withoutNulls(array) {
      var result = [];
      for (var i = 0; i < array.length; i++) if (array[i] != null) result.push(array[i]);
      return result;
    }
    function buildTree(spans, node, offset, options) {
      var children = [], hasNulls = false;
      node.forEach(function(childNode, localStart) {
        var found = takeSpansForNode(spans, childNode, localStart + offset);
        if (found) {
          hasNulls = true;
          var subtree = buildTree(found, childNode, offset + localStart + 1, options);
          if (subtree != empty) children.push(localStart, localStart + childNode.nodeSize, subtree);
        }
      });
      var locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset).sort(byPos);
      for (var i = 0; i < locals.length; i++) if (!locals[i].type.valid(node, locals[i])) {
        if (options.onRemove) options.onRemove(locals[i].spec);
        locals.splice(i--, 1);
      }
      return locals.length || children.length ? new DecorationSet(locals, children) : empty;
    }
    function byPos(a, b) {
      return a.from - b.from || a.to - b.to;
    }
    function removeOverlap(spans) {
      var working = spans;
      for (var i = 0; i < working.length - 1; i++) {
        var span = working[i];
        if (span.from != span.to) for (var j = i + 1; j < working.length; j++) {
          var next = working[j];
          if (next.from == span.from) {
            if (next.to != span.to) {
              if (working == spans) working = spans.slice();
              working[j] = next.copy(next.from, span.to);
              insertAhead(working, j + 1, next.copy(span.to, next.to));
            }
            continue;
          } else {
            if (next.from < span.to) {
              if (working == spans) working = spans.slice();
              working[i] = span.copy(span.from, next.from);
              insertAhead(working, j, span.copy(next.from, span.to));
            }
            break;
          }
        }
      }
      return working;
    }
    function insertAhead(array, i, deco) {
      while (i < array.length && byPos(deco, array[i]) > 0) i++;
      array.splice(i, 0, deco);
    }
    function viewDecorations(view) {
      var found = [];
      view.someProp("decorations", function(f) {
        var result = f(view.state);
        if (result && result != empty) found.push(result);
      });
      if (view.cursorWrapper) found.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco]));
      return DecorationGroup.from(found);
    }
    var observeOptions = {
      childList: true,
      characterData: true,
      characterDataOldValue: true,
      attributes: true,
      attributeOldValue: true,
      subtree: true
    };
    var useCharData = ie && ie_version <= 11;
    var SelectionState = (function() {
      function SelectionState2() {
        _classCallCheck(this, SelectionState2);
        this.anchorNode = null;
        this.anchorOffset = 0;
        this.focusNode = null;
        this.focusOffset = 0;
      }
      _createClass(SelectionState2, [{
        key: "set",
        value: function set(sel) {
          this.anchorNode = sel.anchorNode;
          this.anchorOffset = sel.anchorOffset;
          this.focusNode = sel.focusNode;
          this.focusOffset = sel.focusOffset;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.anchorNode = this.focusNode = null;
        }
      }, {
        key: "eq",
        value: function eq(sel) {
          return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset && sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;
        }
      }]);
      return SelectionState2;
    })();
    var DOMObserver = (function() {
      function DOMObserver2(view, handleDOMChange) {
        var _this11 = this;
        _classCallCheck(this, DOMObserver2);
        this.view = view;
        this.handleDOMChange = handleDOMChange;
        this.queue = [];
        this.flushingSoon = -1;
        this.observer = null;
        this.currentSelection = new SelectionState();
        this.onCharData = null;
        this.suppressingSelectionUpdates = false;
        this.lastChangedTextNode = null;
        this.observer = window.MutationObserver && new window.MutationObserver(function(mutations) {
          for (var i = 0; i < mutations.length; i++) _this11.queue.push(mutations[i]);
          if (ie && ie_version <= 11 && mutations.some(function(m) {
            return m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length;
          })) _this11.flushSoon();
          else _this11.flush();
        });
        if (useCharData) {
          this.onCharData = function(e) {
            _this11.queue.push({
              target: e.target,
              type: "characterData",
              oldValue: e.prevValue
            });
            _this11.flushSoon();
          };
        }
        this.onSelectionChange = this.onSelectionChange.bind(this);
      }
      _createClass(DOMObserver2, [{
        key: "flushSoon",
        value: function flushSoon() {
          var _this12 = this;
          if (this.flushingSoon < 0) this.flushingSoon = window.setTimeout(function() {
            _this12.flushingSoon = -1;
            _this12.flush();
          }, 20);
        }
      }, {
        key: "forceFlush",
        value: function forceFlush() {
          if (this.flushingSoon > -1) {
            window.clearTimeout(this.flushingSoon);
            this.flushingSoon = -1;
            this.flush();
          }
        }
      }, {
        key: "start",
        value: function start() {
          if (this.observer) {
            this.observer.takeRecords();
            this.observer.observe(this.view.dom, observeOptions);
          }
          if (this.onCharData) this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
          this.connectSelection();
        }
      }, {
        key: "stop",
        value: function stop() {
          var _this13 = this;
          if (this.observer) {
            var take = this.observer.takeRecords();
            if (take.length) {
              for (var i = 0; i < take.length; i++) this.queue.push(take[i]);
              window.setTimeout(function() {
                return _this13.flush();
              }, 20);
            }
            this.observer.disconnect();
          }
          if (this.onCharData) this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
          this.disconnectSelection();
        }
      }, {
        key: "connectSelection",
        value: function connectSelection() {
          this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
        }
      }, {
        key: "disconnectSelection",
        value: function disconnectSelection() {
          this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
        }
      }, {
        key: "suppressSelectionUpdates",
        value: function suppressSelectionUpdates() {
          var _this14 = this;
          this.suppressingSelectionUpdates = true;
          setTimeout(function() {
            return _this14.suppressingSelectionUpdates = false;
          }, 50);
        }
      }, {
        key: "onSelectionChange",
        value: function onSelectionChange() {
          if (!hasFocusAndSelection(this.view)) return;
          if (this.suppressingSelectionUpdates) return selectionToDOM(this.view);
          if (ie && ie_version <= 11 && !this.view.state.selection.empty) {
            var sel = this.view.domSelectionRange();
            if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset)) return this.flushSoon();
          }
          this.flush();
        }
      }, {
        key: "setCurSelection",
        value: function setCurSelection() {
          this.currentSelection.set(this.view.domSelectionRange());
        }
      }, {
        key: "ignoreSelectionChange",
        value: function ignoreSelectionChange(sel) {
          if (!sel.focusNode) return true;
          var ancestors = /* @__PURE__ */ new Set(), container;
          for (var scan = sel.focusNode; scan; scan = parentNode(scan)) ancestors.add(scan);
          for (var _scan = sel.anchorNode; _scan; _scan = parentNode(_scan)) if (ancestors.has(_scan)) {
            container = _scan;
            break;
          }
          var desc = container && this.view.docView.nearestDesc(container);
          if (desc && desc.ignoreMutation({
            type: "selection",
            target: container.nodeType == 3 ? container.parentNode : container
          })) {
            this.setCurSelection();
            return true;
          }
        }
      }, {
        key: "pendingRecords",
        value: function pendingRecords() {
          if (this.observer) {
            var _iterator2 = _createForOfIteratorHelper(this.observer.takeRecords()), _step2;
            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                var mut = _step2.value;
                this.queue.push(mut);
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
          }
          return this.queue;
        }
      }, {
        key: "flush",
        value: function flush() {
          var view = this.view;
          if (!view.docView || this.flushingSoon > -1) return;
          var mutations = this.pendingRecords();
          if (mutations.length) this.queue = [];
          var sel = view.domSelectionRange();
          var newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasFocusAndSelection(view) && !this.ignoreSelectionChange(sel);
          var from = -1, to = -1, typeOver = false, added = [];
          if (view.editable) {
            for (var i = 0; i < mutations.length; i++) {
              var result = this.registerMutation(mutations[i], added);
              if (result) {
                from = from < 0 ? result.from : Math.min(result.from, from);
                to = to < 0 ? result.to : Math.max(result.to, to);
                if (result.typeOver) typeOver = true;
              }
            }
          }
          if (gecko && added.length) {
            var brs = added.filter(function(n) {
              return n.nodeName == "BR";
            });
            if (brs.length == 2) {
              var _brs = _slicedToArray(brs, 2), a = _brs[0], b = _brs[1];
              if (a.parentNode && a.parentNode.parentNode == b.parentNode) b.remove();
              else a.remove();
            } else {
              var focusNode = this.currentSelection.focusNode;
              var _iterator3 = _createForOfIteratorHelper(brs), _step3;
              try {
                for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
                  var br = _step3.value;
                  var parent = br.parentNode;
                  if (parent && parent.nodeName == "LI" && (!focusNode || blockParent(view, focusNode) != parent)) br.remove();
                }
              } catch (err) {
                _iterator3.e(err);
              } finally {
                _iterator3.f();
              }
            }
          }
          var readSel = null;
          if (from < 0 && newSel && view.input.lastFocus > Date.now() - 200 && Math.max(view.input.lastTouch, view.input.lastClick.time) < Date.now() - 300 && selectionCollapsed(sel) && (readSel = selectionFromDOM(view)) && readSel.eq(prosemirrorState.Selection.near(view.state.doc.resolve(0), 1))) {
            view.input.lastFocus = 0;
            selectionToDOM(view);
            this.currentSelection.set(sel);
            view.scrollToSelection();
          } else if (from > -1 || newSel) {
            if (from > -1) {
              view.docView.markDirty(from, to);
              checkCSS(view);
            }
            this.handleDOMChange(from, to, typeOver, added);
            if (view.docView && view.docView.dirty) view.updateState(view.state);
            else if (!this.currentSelection.eq(sel)) selectionToDOM(view);
            this.currentSelection.set(sel);
          }
        }
      }, {
        key: "registerMutation",
        value: function registerMutation(mut, added) {
          if (added.indexOf(mut.target) > -1) return null;
          var desc = this.view.docView.nearestDesc(mut.target);
          if (mut.type == "attributes" && (desc == this.view.docView || mut.attributeName == "contenteditable" || mut.attributeName == "style" && !mut.oldValue && !mut.target.getAttribute("style"))) return null;
          if (!desc || desc.ignoreMutation(mut)) return null;
          if (mut.type == "childList") {
            for (var i = 0; i < mut.addedNodes.length; i++) {
              var node = mut.addedNodes[i];
              added.push(node);
              if (node.nodeType == 3) this.lastChangedTextNode = node;
            }
            if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target)) return {
              from: desc.posBefore,
              to: desc.posAfter
            };
            var prev = mut.previousSibling, next = mut.nextSibling;
            if (ie && ie_version <= 11 && mut.addedNodes.length) {
              for (var _i15 = 0; _i15 < mut.addedNodes.length; _i15++) {
                var _mut$addedNodes$_i = mut.addedNodes[_i15], previousSibling = _mut$addedNodes$_i.previousSibling, nextSibling = _mut$addedNodes$_i.nextSibling;
                if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0) prev = previousSibling;
                if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0) next = nextSibling;
              }
            }
            var fromOffset = prev && prev.parentNode == mut.target ? domIndex(prev) + 1 : 0;
            var from = desc.localPosFromDOM(mut.target, fromOffset, -1);
            var toOffset = next && next.parentNode == mut.target ? domIndex(next) : mut.target.childNodes.length;
            var to = desc.localPosFromDOM(mut.target, toOffset, 1);
            return {
              from,
              to
            };
          } else if (mut.type == "attributes") {
            return {
              from: desc.posAtStart - desc.border,
              to: desc.posAtEnd + desc.border
            };
          } else {
            this.lastChangedTextNode = mut.target;
            return {
              from: desc.posAtStart,
              to: desc.posAtEnd,
              typeOver: mut.target.nodeValue == mut.oldValue
            };
          }
        }
      }]);
      return DOMObserver2;
    })();
    var cssChecked = /* @__PURE__ */ new WeakMap();
    var cssCheckWarned = false;
    function checkCSS(view) {
      if (cssChecked.has(view)) return;
      cssChecked.set(view, null);
      if (["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(view.dom).whiteSpace) !== -1) {
        view.requiresGeckoHackNode = gecko;
        if (cssCheckWarned) return;
        console["warn"]("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.");
        cssCheckWarned = true;
      }
    }
    function rangeToSelectionRange(view, range2) {
      var anchorNode = range2.startContainer, anchorOffset = range2.startOffset;
      var focusNode = range2.endContainer, focusOffset = range2.endOffset;
      var currentAnchor = view.domAtPos(view.state.selection.anchor);
      if (isEquivalentPosition(currentAnchor.node, currentAnchor.offset, focusNode, focusOffset)) {
        var _ref5 = [focusNode, focusOffset, anchorNode, anchorOffset];
        anchorNode = _ref5[0];
        anchorOffset = _ref5[1];
        focusNode = _ref5[2];
        focusOffset = _ref5[3];
      }
      return {
        anchorNode,
        anchorOffset,
        focusNode,
        focusOffset
      };
    }
    function safariShadowSelectionRange(view, selection) {
      if (selection.getComposedRanges) {
        var range2 = selection.getComposedRanges(view.root)[0];
        if (range2) return rangeToSelectionRange(view, range2);
      }
      var found;
      function read(event) {
        event.preventDefault();
        event.stopImmediatePropagation();
        found = event.getTargetRanges()[0];
      }
      view.dom.addEventListener("beforeinput", read, true);
      document.execCommand("indent");
      view.dom.removeEventListener("beforeinput", read, true);
      return found ? rangeToSelectionRange(view, found) : null;
    }
    function blockParent(view, node) {
      for (var p = node.parentNode; p && p != view.dom; p = p.parentNode) {
        var desc = view.docView.nearestDesc(p, true);
        if (desc && desc.node.isBlock) return p;
      }
      return null;
    }
    function parseBetween(view, from_, to_) {
      var _view$docView$parseRa = view.docView.parseRange(from_, to_), parent = _view$docView$parseRa.node, fromOffset = _view$docView$parseRa.fromOffset, toOffset = _view$docView$parseRa.toOffset, from = _view$docView$parseRa.from, to = _view$docView$parseRa.to;
      var domSel = view.domSelectionRange();
      var find;
      var anchor = domSel.anchorNode;
      if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {
        find = [{
          node: anchor,
          offset: domSel.anchorOffset
        }];
        if (!selectionCollapsed(domSel)) find.push({
          node: domSel.focusNode,
          offset: domSel.focusOffset
        });
      }
      if (chrome && view.input.lastKeyCode === 8) {
        for (var off = toOffset; off > fromOffset; off--) {
          var node = parent.childNodes[off - 1], desc = node.pmViewDesc;
          if (node.nodeName == "BR" && !desc) {
            toOffset = off;
            break;
          }
          if (!desc || desc.size) break;
        }
      }
      var startDoc = view.state.doc;
      var parser = view.someProp("domParser") || prosemirrorModel.DOMParser.fromSchema(view.state.schema);
      var $from = startDoc.resolve(from);
      var sel = null, doc2 = parser.parse(parent, {
        topNode: $from.parent,
        topMatch: $from.parent.contentMatchAt($from.index()),
        topOpen: true,
        from: fromOffset,
        to: toOffset,
        preserveWhitespace: $from.parent.type.whitespace == "pre" ? "full" : true,
        findPositions: find,
        ruleFromNode,
        context: $from
      });
      if (find && find[0].pos != null) {
        var _anchor = find[0].pos, head = find[1] && find[1].pos;
        if (head == null) head = _anchor;
        sel = {
          anchor: _anchor + from,
          head: head + from
        };
      }
      return {
        doc: doc2,
        sel,
        from,
        to
      };
    }
    function ruleFromNode(dom) {
      var desc = dom.pmViewDesc;
      if (desc) {
        return desc.parseRule();
      } else if (dom.nodeName == "BR" && dom.parentNode) {
        if (safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {
          var skip = document.createElement("div");
          skip.appendChild(document.createElement("li"));
          return {
            skip
          };
        } else if (dom.parentNode.lastChild == dom || safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {
          return {
            ignore: true
          };
        }
      } else if (dom.nodeName == "IMG" && dom.getAttribute("mark-placeholder")) {
        return {
          ignore: true
        };
      }
      return null;
    }
    var isInline = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|img|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
    function readDOMChange(view, from, to, typeOver, addedNodes) {
      var compositionID = view.input.compositionPendingChanges || (view.composing ? view.input.compositionID : 0);
      view.input.compositionPendingChanges = 0;
      if (from < 0) {
        var origin = view.input.lastSelectionTime > Date.now() - 50 ? view.input.lastSelectionOrigin : null;
        var newSel = selectionFromDOM(view, origin);
        if (newSel && !view.state.selection.eq(newSel)) {
          if (chrome && android && view.input.lastKeyCode === 13 && Date.now() - 100 < view.input.lastKeyCodeTime && view.someProp("handleKeyDown", function(f) {
            return f(view, keyEvent(13, "Enter"));
          })) return;
          var tr = view.state.tr.setSelection(newSel);
          if (origin == "pointer") tr.setMeta("pointer", true);
          else if (origin == "key") tr.scrollIntoView();
          if (compositionID) tr.setMeta("composition", compositionID);
          view.dispatch(tr);
        }
        return;
      }
      var $before = view.state.doc.resolve(from);
      var shared = $before.sharedDepth(to);
      from = $before.before(shared + 1);
      to = view.state.doc.resolve(to).after(shared + 1);
      var sel = view.state.selection;
      var parse = parseBetween(view, from, to);
      var doc2 = view.state.doc, compare = doc2.slice(parse.from, parse.to);
      var preferredPos, preferredSide;
      if (view.input.lastKeyCode === 8 && Date.now() - 100 < view.input.lastKeyCodeTime) {
        preferredPos = view.state.selection.to;
        preferredSide = "end";
      } else {
        preferredPos = view.state.selection.from;
        preferredSide = "start";
      }
      view.input.lastKeyCode = null;
      var change = findDiff(compare.content, parse.doc.content, parse.from, preferredPos, preferredSide);
      if (change) view.input.domChangeCount++;
      if ((ios && view.input.lastIOSEnter > Date.now() - 225 || android) && addedNodes.some(function(n) {
        return n.nodeType == 1 && !isInline.test(n.nodeName);
      }) && (!change || change.endA >= change.endB) && view.someProp("handleKeyDown", function(f) {
        return f(view, keyEvent(13, "Enter"));
      })) {
        view.input.lastIOSEnter = 0;
        return;
      }
      if (!change) {
        if (typeOver && sel instanceof prosemirrorState.TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) && !view.composing && !(parse.sel && parse.sel.anchor != parse.sel.head)) {
          change = {
            start: sel.from,
            endA: sel.to,
            endB: sel.to
          };
        } else {
          if (parse.sel) {
            var _sel2 = resolveSelection(view, view.state.doc, parse.sel);
            if (_sel2 && !_sel2.eq(view.state.selection)) {
              var _tr = view.state.tr.setSelection(_sel2);
              if (compositionID) _tr.setMeta("composition", compositionID);
              view.dispatch(_tr);
            }
          }
          return;
        }
      }
      if (view.state.selection.from < view.state.selection.to && change.start == change.endB && view.state.selection instanceof prosemirrorState.TextSelection) {
        if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2 && view.state.selection.from >= parse.from) {
          change.start = view.state.selection.from;
        } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2 && view.state.selection.to <= parse.to) {
          change.endB += view.state.selection.to - change.endA;
          change.endA = view.state.selection.to;
        }
      }
      if (ie && ie_version <= 11 && change.endB == change.start + 1 && change.endA == change.start && change.start > parse.from && parse.doc.textBetween(change.start - parse.from - 1, change.start - parse.from + 1) == " \xA0") {
        change.start--;
        change.endA--;
        change.endB--;
      }
      var $from = parse.doc.resolveNoCache(change.start - parse.from);
      var $to = parse.doc.resolveNoCache(change.endB - parse.from);
      var $fromA = doc2.resolve(change.start);
      var inlineChange = $from.sameParent($to) && $from.parent.inlineContent && $fromA.end() >= change.endA;
      if ((ios && view.input.lastIOSEnter > Date.now() - 225 && (!inlineChange || addedNodes.some(function(n) {
        return n.nodeName == "DIV" || n.nodeName == "P";
      })) || !inlineChange && $from.pos < parse.doc.content.size && (!$from.sameParent($to) || !$from.parent.inlineContent) && $from.pos < $to.pos && !/\S/.test(parse.doc.textBetween($from.pos, $to.pos, "", ""))) && view.someProp("handleKeyDown", function(f) {
        return f(view, keyEvent(13, "Enter"));
      })) {
        view.input.lastIOSEnter = 0;
        return;
      }
      if (view.state.selection.anchor > change.start && looksLikeBackspace(doc2, change.start, change.endA, $from, $to) && view.someProp("handleKeyDown", function(f) {
        return f(view, keyEvent(8, "Backspace"));
      })) {
        if (android && chrome) view.domObserver.suppressSelectionUpdates();
        return;
      }
      if (chrome && change.endB == change.start) view.input.lastChromeDelete = Date.now();
      if (android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth && parse.sel && parse.sel.anchor == parse.sel.head && parse.sel.head == change.endA) {
        change.endB -= 2;
        $to = parse.doc.resolveNoCache(change.endB - parse.from);
        setTimeout(function() {
          view.someProp("handleKeyDown", function(f) {
            return f(view, keyEvent(13, "Enter"));
          });
        }, 20);
      }
      var chFrom = change.start, chTo = change.endA;
      var mkTr = function mkTr2(base) {
        var tr2 = base || view.state.tr.replace(chFrom, chTo, parse.doc.slice(change.start - parse.from, change.endB - parse.from));
        if (parse.sel) {
          var _sel3 = resolveSelection(view, tr2.doc, parse.sel);
          if (_sel3 && !(chrome && view.composing && _sel3.empty && (change.start != change.endB || view.input.lastChromeDelete < Date.now() - 100) && (_sel3.head == chFrom || _sel3.head == tr2.mapping.map(chTo) - 1) || ie && _sel3.empty && _sel3.head == chFrom)) tr2.setSelection(_sel3);
        }
        if (compositionID) tr2.setMeta("composition", compositionID);
        return tr2.scrollIntoView();
      };
      var markChange;
      if (inlineChange) {
        if ($from.pos == $to.pos) {
          if (ie && ie_version <= 11 && $from.parentOffset == 0) {
            view.domObserver.suppressSelectionUpdates();
            setTimeout(function() {
              return selectionToDOM(view);
            }, 20);
          }
          var _tr2 = mkTr(view.state.tr["delete"](chFrom, chTo));
          var marks = doc2.resolve(change.start).marksAcross(doc2.resolve(change.endA));
          if (marks) _tr2.ensureMarks(marks);
          view.dispatch(_tr2);
        } else if (change.endA == change.endB && (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset), $fromA.parent.content.cut($fromA.parentOffset, change.endA - $fromA.start())))) {
          var _tr3 = mkTr(view.state.tr);
          if (markChange.type == "add") _tr3.addMark(chFrom, chTo, markChange.mark);
          else _tr3.removeMark(chFrom, chTo, markChange.mark);
          view.dispatch(_tr3);
        } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {
          var text = $from.parent.textBetween($from.parentOffset, $to.parentOffset);
          var deflt = function deflt2() {
            return mkTr(view.state.tr.insertText(text, chFrom, chTo));
          };
          if (!view.someProp("handleTextInput", function(f) {
            return f(view, chFrom, chTo, text, deflt);
          })) view.dispatch(deflt());
        } else {
          view.dispatch(mkTr());
        }
      } else {
        view.dispatch(mkTr());
      }
    }
    function resolveSelection(view, doc2, parsedSel) {
      if (Math.max(parsedSel.anchor, parsedSel.head) > doc2.content.size) return null;
      return selectionBetween(view, doc2.resolve(parsedSel.anchor), doc2.resolve(parsedSel.head));
    }
    function isMarkChange(cur, prev) {
      var curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;
      var added = curMarks, removed = prevMarks, type2, mark, update;
      for (var i = 0; i < prevMarks.length; i++) added = prevMarks[i].removeFromSet(added);
      for (var _i16 = 0; _i16 < curMarks.length; _i16++) removed = curMarks[_i16].removeFromSet(removed);
      if (added.length == 1 && removed.length == 0) {
        mark = added[0];
        type2 = "add";
        update = function update2(node) {
          return node.mark(mark.addToSet(node.marks));
        };
      } else if (added.length == 0 && removed.length == 1) {
        mark = removed[0];
        type2 = "remove";
        update = function update2(node) {
          return node.mark(mark.removeFromSet(node.marks));
        };
      } else {
        return null;
      }
      var updated = [];
      for (var _i17 = 0; _i17 < prev.childCount; _i17++) updated.push(update(prev.child(_i17)));
      if (prosemirrorModel.Fragment.from(updated).eq(cur)) return {
        mark,
        type: type2
      };
    }
    function looksLikeBackspace(old, start, end, $newStart, $newEnd) {
      if (end - start <= $newEnd.pos - $newStart.pos || skipClosingAndOpening($newStart, true, false) < $newEnd.pos) return false;
      var $start = old.resolve(start);
      if (!$newStart.parent.isTextblock) {
        var after = $start.nodeAfter;
        return after != null && end == start + after.nodeSize;
      }
      if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock) return false;
      var $next = old.resolve(skipClosingAndOpening($start, true, true));
      if (!$next.parent.isTextblock || $next.pos > end || skipClosingAndOpening($next, true, false) < end) return false;
      return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);
    }
    function skipClosingAndOpening($pos, fromEnd, mayOpen) {
      var depth = $pos.depth, end = fromEnd ? $pos.end() : $pos.pos;
      while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {
        depth--;
        end++;
        fromEnd = false;
      }
      if (mayOpen) {
        var next = $pos.node(depth).maybeChild($pos.indexAfter(depth));
        while (next && !next.isLeaf) {
          next = next.firstChild;
          end++;
        }
      }
      return end;
    }
    function findDiff(a, b, pos, preferredPos, preferredSide) {
      var start = a.findDiffStart(b, pos);
      if (start == null) return null;
      var _a$findDiffEnd = a.findDiffEnd(b, pos + a.size, pos + b.size), endA = _a$findDiffEnd.a, endB = _a$findDiffEnd.b;
      if (preferredSide == "end") {
        var adjust = Math.max(0, start - Math.min(endA, endB));
        preferredPos -= endA + adjust - start;
      }
      if (endA < start && a.size < b.size) {
        var move = preferredPos <= start && preferredPos >= endA ? start - preferredPos : 0;
        start -= move;
        if (start && start < b.size && isSurrogatePair(b.textBetween(start - 1, start + 1))) start += move ? 1 : -1;
        endB = start + (endB - endA);
        endA = start;
      } else if (endB < start) {
        var _move = preferredPos <= start && preferredPos >= endB ? start - preferredPos : 0;
        start -= _move;
        if (start && start < a.size && isSurrogatePair(a.textBetween(start - 1, start + 1))) start += _move ? 1 : -1;
        endA = start + (endA - endB);
        endB = start;
      }
      return {
        start,
        endA,
        endB
      };
    }
    function isSurrogatePair(str) {
      if (str.length != 2) return false;
      var a = str.charCodeAt(0), b = str.charCodeAt(1);
      return a >= 56320 && a <= 57343 && b >= 55296 && b <= 56319;
    }
    var __parseFromClipboard = parseFromClipboard;
    var __endComposition = endComposition;
    var EditorView = (function() {
      function EditorView2(place, props) {
        var _this15 = this;
        _classCallCheck(this, EditorView2);
        this._root = null;
        this.focused = false;
        this.trackWrites = null;
        this.mounted = false;
        this.markCursor = null;
        this.cursorWrapper = null;
        this.lastSelectedViewDesc = void 0;
        this.input = new InputState();
        this.prevDirectPlugins = [];
        this.pluginViews = [];
        this.requiresGeckoHackNode = false;
        this.dragging = null;
        this._props = props;
        this.state = props.state;
        this.directPlugins = props.plugins || [];
        this.directPlugins.forEach(checkStateComponent);
        this.dispatch = this.dispatch.bind(this);
        this.dom = place && place.mount || document.createElement("div");
        if (place) {
          if (place.appendChild) place.appendChild(this.dom);
          else if (typeof place == "function") place(this.dom);
          else if (place.mount) this.mounted = true;
        }
        this.editable = getEditable(this);
        updateCursorWrapper(this);
        this.nodeViews = buildNodeViews(this);
        this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);
        this.domObserver = new DOMObserver(this, function(from, to, typeOver, added) {
          return readDOMChange(_this15, from, to, typeOver, added);
        });
        this.domObserver.start();
        initInput(this);
        this.updatePluginViews();
      }
      _createClass(EditorView2, [{
        key: "composing",
        get: function get2() {
          return this.input.composing;
        }
      }, {
        key: "props",
        get: function get2() {
          if (this._props.state != this.state) {
            var prev = this._props;
            this._props = {};
            for (var name in prev) this._props[name] = prev[name];
            this._props.state = this.state;
          }
          return this._props;
        }
      }, {
        key: "update",
        value: function update(props) {
          if (props.handleDOMEvents != this._props.handleDOMEvents) ensureListeners(this);
          var prevProps = this._props;
          this._props = props;
          if (props.plugins) {
            props.plugins.forEach(checkStateComponent);
            this.directPlugins = props.plugins;
          }
          this.updateStateInner(props.state, prevProps);
        }
      }, {
        key: "setProps",
        value: function setProps(props) {
          var updated = {};
          for (var name in this._props) updated[name] = this._props[name];
          updated.state = this.state;
          for (var _name2 in props) updated[_name2] = props[_name2];
          this.update(updated);
        }
      }, {
        key: "updateState",
        value: function updateState(state2) {
          this.updateStateInner(state2, this._props);
        }
      }, {
        key: "updateStateInner",
        value: function updateStateInner(state2, prevProps) {
          var _a;
          var prev = this.state, redraw = false, updateSel = false;
          if (state2.storedMarks && this.composing) {
            clearComposition(this);
            updateSel = true;
          }
          this.state = state2;
          var pluginsChanged = prev.plugins != state2.plugins || this._props.plugins != prevProps.plugins;
          if (pluginsChanged || this._props.plugins != prevProps.plugins || this._props.nodeViews != prevProps.nodeViews) {
            var nodeViews = buildNodeViews(this);
            if (changedNodeViews(nodeViews, this.nodeViews)) {
              this.nodeViews = nodeViews;
              redraw = true;
            }
          }
          if (pluginsChanged || prevProps.handleDOMEvents != this._props.handleDOMEvents) {
            ensureListeners(this);
          }
          this.editable = getEditable(this);
          updateCursorWrapper(this);
          var innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);
          var scroll = prev.plugins != state2.plugins && !prev.doc.eq(state2.doc) ? "reset" : state2.scrollToSelection > prev.scrollToSelection ? "to selection" : "preserve";
          var updateDoc = redraw || !this.docView.matchesNode(state2.doc, outerDeco, innerDeco);
          if (updateDoc || !state2.selection.eq(prev.selection)) updateSel = true;
          var oldScrollPos = scroll == "preserve" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);
          if (updateSel) {
            this.domObserver.stop();
            var forceSelUpdate = updateDoc && (ie || chrome) && !this.composing && !prev.selection.empty && !state2.selection.empty && selectionContextChanged(prev.selection, state2.selection);
            if (updateDoc) {
              var chromeKludge = chrome ? this.trackWrites = this.domSelectionRange().focusNode : null;
              if (this.composing) this.input.compositionNode = findCompositionNode(this);
              if (redraw || !this.docView.update(state2.doc, outerDeco, innerDeco, this)) {
                this.docView.updateOuterDeco(outerDeco);
                this.docView.destroy();
                this.docView = docViewDesc(state2.doc, outerDeco, innerDeco, this.dom, this);
              }
              if (chromeKludge && !this.trackWrites) forceSelUpdate = true;
            }
            if (forceSelUpdate || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && anchorInRightPlace(this))) {
              selectionToDOM(this, forceSelUpdate);
            } else {
              syncNodeSelection(this, state2.selection);
              this.domObserver.setCurSelection();
            }
            this.domObserver.start();
          }
          this.updatePluginViews(prev);
          if (((_a = this.dragging) === null || _a === void 0 ? void 0 : _a.node) && !prev.doc.eq(state2.doc)) this.updateDraggedNode(this.dragging, prev);
          if (scroll == "reset") {
            this.dom.scrollTop = 0;
          } else if (scroll == "to selection") {
            this.scrollToSelection();
          } else if (oldScrollPos) {
            resetScrollPos(oldScrollPos);
          }
        }
      }, {
        key: "scrollToSelection",
        value: function scrollToSelection() {
          var _this16 = this;
          var startDOM = this.domSelectionRange().focusNode;
          if (!startDOM || !this.dom.contains(startDOM.nodeType == 1 ? startDOM : startDOM.parentNode)) ;
          else if (this.someProp("handleScrollToSelection", function(f) {
            return f(_this16);
          })) ;
          else if (this.state.selection instanceof prosemirrorState.NodeSelection) {
            var target = this.docView.domAfterPos(this.state.selection.from);
            if (target.nodeType == 1) scrollRectIntoView(this, target.getBoundingClientRect(), startDOM);
          } else {
            scrollRectIntoView(this, this.coordsAtPos(this.state.selection.head, 1), startDOM);
          }
        }
      }, {
        key: "destroyPluginViews",
        value: function destroyPluginViews() {
          var view;
          while (view = this.pluginViews.pop()) if (view.destroy) view.destroy();
        }
      }, {
        key: "updatePluginViews",
        value: function updatePluginViews(prevState) {
          if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
            this.prevDirectPlugins = this.directPlugins;
            this.destroyPluginViews();
            for (var i = 0; i < this.directPlugins.length; i++) {
              var plugin = this.directPlugins[i];
              if (plugin.spec.view) this.pluginViews.push(plugin.spec.view(this));
            }
            for (var _i18 = 0; _i18 < this.state.plugins.length; _i18++) {
              var _plugin = this.state.plugins[_i18];
              if (_plugin.spec.view) this.pluginViews.push(_plugin.spec.view(this));
            }
          } else {
            for (var _i19 = 0; _i19 < this.pluginViews.length; _i19++) {
              var pluginView = this.pluginViews[_i19];
              if (pluginView.update) pluginView.update(this, prevState);
            }
          }
        }
      }, {
        key: "updateDraggedNode",
        value: function updateDraggedNode(dragging, prev) {
          var sel = dragging.node, found = -1;
          if (this.state.doc.nodeAt(sel.from) == sel.node) {
            found = sel.from;
          } else {
            var movedPos = sel.from + (this.state.doc.content.size - prev.doc.content.size);
            var moved = movedPos > 0 && this.state.doc.nodeAt(movedPos);
            if (moved == sel.node) found = movedPos;
          }
          this.dragging = new Dragging(dragging.slice, dragging.move, found < 0 ? void 0 : prosemirrorState.NodeSelection.create(this.state.doc, found));
        }
      }, {
        key: "someProp",
        value: function someProp(propName, f) {
          var prop2 = this._props && this._props[propName], value;
          if (prop2 != null && (value = f ? f(prop2) : prop2)) return value;
          for (var i = 0; i < this.directPlugins.length; i++) {
            var _prop = this.directPlugins[i].props[propName];
            if (_prop != null && (value = f ? f(_prop) : _prop)) return value;
          }
          var plugins = this.state.plugins;
          if (plugins) for (var _i20 = 0; _i20 < plugins.length; _i20++) {
            var _prop2 = plugins[_i20].props[propName];
            if (_prop2 != null && (value = f ? f(_prop2) : _prop2)) return value;
          }
        }
      }, {
        key: "hasFocus",
        value: function hasFocus() {
          if (ie) {
            var node = this.root.activeElement;
            if (node == this.dom) return true;
            if (!node || !this.dom.contains(node)) return false;
            while (node && this.dom != node && this.dom.contains(node)) {
              if (node.contentEditable == "false") return false;
              node = node.parentElement;
            }
            return true;
          }
          return this.root.activeElement == this.dom;
        }
      }, {
        key: "focus",
        value: function focus() {
          this.domObserver.stop();
          if (this.editable) focusPreventScroll(this.dom);
          selectionToDOM(this);
          this.domObserver.start();
        }
      }, {
        key: "root",
        get: function get2() {
          var _this17 = this;
          var cached = this._root;
          if (cached == null) {
            var _loop5 = function _loop52(search2) {
              if (search2.nodeType == 9 || search2.nodeType == 11 && search2.host) {
                if (!search2.getSelection) Object.getPrototypeOf(search2).getSelection = function() {
                  return search2.ownerDocument.getSelection();
                };
                return {
                  v: _this17._root = search2
                };
              }
            }, _ret3;
            for (var search = this.dom.parentNode; search; search = search.parentNode) {
              _ret3 = _loop5(search);
              if (_ret3) return _ret3.v;
            }
          }
          return cached || document;
        }
      }, {
        key: "updateRoot",
        value: function updateRoot() {
          this._root = null;
        }
      }, {
        key: "posAtCoords",
        value: function posAtCoords(coords) {
          return _posAtCoords(this, coords);
        }
      }, {
        key: "coordsAtPos",
        value: function coordsAtPos(pos) {
          var side = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
          return _coordsAtPos(this, pos, side);
        }
      }, {
        key: "domAtPos",
        value: function domAtPos(pos) {
          var side = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
          return this.docView.domFromPos(pos, side);
        }
      }, {
        key: "nodeDOM",
        value: function nodeDOM(pos) {
          var desc = this.docView.descAt(pos);
          return desc ? desc.nodeDOM : null;
        }
      }, {
        key: "posAtDOM",
        value: function posAtDOM(node, offset) {
          var bias = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -1;
          var pos = this.docView.posFromDOM(node, offset, bias);
          if (pos == null) throw new RangeError("DOM position not inside the editor");
          return pos;
        }
      }, {
        key: "endOfTextblock",
        value: function endOfTextblock(dir, state2) {
          return _endOfTextblock(this, state2 || this.state, dir);
        }
      }, {
        key: "pasteHTML",
        value: function pasteHTML(html, event) {
          return doPaste(this, "", html, false, event || new ClipboardEvent("paste"));
        }
      }, {
        key: "pasteText",
        value: function pasteText(text, event) {
          return doPaste(this, text, null, true, event || new ClipboardEvent("paste"));
        }
      }, {
        key: "serializeForClipboard",
        value: function serializeForClipboard(slice) {
          return _serializeForClipboard(this, slice);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          if (!this.docView) return;
          destroyInput(this);
          this.destroyPluginViews();
          if (this.mounted) {
            this.docView.update(this.state.doc, [], viewDecorations(this), this);
            this.dom.textContent = "";
          } else if (this.dom.parentNode) {
            this.dom.parentNode.removeChild(this.dom);
          }
          this.docView.destroy();
          this.docView = null;
          clearReusedRange();
        }
      }, {
        key: "isDestroyed",
        get: function get2() {
          return this.docView == null;
        }
      }, {
        key: "dispatchEvent",
        value: function dispatchEvent(event) {
          return _dispatchEvent(this, event);
        }
      }, {
        key: "domSelectionRange",
        value: function domSelectionRange() {
          var sel = this.domSelection();
          if (!sel) return {
            focusNode: null,
            focusOffset: 0,
            anchorNode: null,
            anchorOffset: 0
          };
          return safari && this.root.nodeType === 11 && deepActiveElement(this.dom.ownerDocument) == this.dom && safariShadowSelectionRange(this, sel) || sel;
        }
      }, {
        key: "domSelection",
        value: function domSelection() {
          return this.root.getSelection();
        }
      }]);
      return EditorView2;
    })();
    EditorView.prototype.dispatch = function(tr) {
      var dispatchTransaction = this._props.dispatchTransaction;
      if (dispatchTransaction) dispatchTransaction.call(this, tr);
      else this.updateState(this.state.apply(tr));
    };
    function computeDocDeco(view) {
      var attrs = /* @__PURE__ */ Object.create(null);
      attrs["class"] = "ProseMirror";
      attrs.contenteditable = String(view.editable);
      view.someProp("attributes", function(value) {
        if (typeof value == "function") value = value(view.state);
        if (value) for (var attr in value) {
          if (attr == "class") attrs["class"] += " " + value[attr];
          else if (attr == "style") attrs.style = (attrs.style ? attrs.style + ";" : "") + value[attr];
          else if (!attrs[attr] && attr != "contenteditable" && attr != "nodeName") attrs[attr] = String(value[attr]);
        }
      });
      if (!attrs.translate) attrs.translate = "no";
      return [Decoration.node(0, view.state.doc.content.size, attrs)];
    }
    function updateCursorWrapper(view) {
      if (view.markCursor) {
        var dom = document.createElement("img");
        dom.className = "ProseMirror-separator";
        dom.setAttribute("mark-placeholder", "true");
        dom.setAttribute("alt", "");
        view.cursorWrapper = {
          dom,
          deco: Decoration.widget(view.state.selection.from, dom, {
            raw: true,
            marks: view.markCursor
          })
        };
      } else {
        view.cursorWrapper = null;
      }
    }
    function getEditable(view) {
      return !view.someProp("editable", function(value) {
        return value(view.state) === false;
      });
    }
    function selectionContextChanged(sel1, sel2) {
      var depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));
      return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);
    }
    function buildNodeViews(view) {
      var result = /* @__PURE__ */ Object.create(null);
      function add(obj) {
        for (var _prop3 in obj) if (!Object.prototype.hasOwnProperty.call(result, _prop3)) result[_prop3] = obj[_prop3];
      }
      view.someProp("nodeViews", add);
      view.someProp("markViews", add);
      return result;
    }
    function changedNodeViews(a, b) {
      var nA = 0, nB = 0;
      for (var _prop4 in a) {
        if (a[_prop4] != b[_prop4]) return true;
        nA++;
      }
      for (var _ in b) nB++;
      return nA != nB;
    }
    function checkStateComponent(plugin) {
      if (plugin.spec.state || plugin.spec.filterTransaction || plugin.spec.appendTransaction) throw new RangeError("Plugins passed directly to the view must not have a state component");
    }
    exports2.Decoration = Decoration;
    exports2.DecorationSet = DecorationSet;
    exports2.EditorView = EditorView;
    exports2.__endComposition = __endComposition;
    exports2.__parseFromClipboard = __parseFromClipboard;
  }
});

// node_modules/.pnpm/@tiptap+pm@3.11.0/node_modules/@tiptap/pm/dist/view/index.cjs
var require_view = __commonJS({
  "node_modules/.pnpm/@tiptap+pm@3.11.0/node_modules/@tiptap/pm/dist/view/index.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function _createStarExport(obj) {
      Object.keys(obj).filter((key) => key !== "default" && key !== "__esModule").forEach((key) => {
        if (exports2.hasOwnProperty(key)) {
          return;
        }
        Object.defineProperty(exports2, key, { enumerable: true, configurable: true, get: () => obj[key] });
      });
    }
    var _prosemirrorview = require_dist7();
    _createStarExport(_prosemirrorview);
  }
});

// node_modules/.pnpm/w3c-keyname@2.2.8/node_modules/w3c-keyname/index.cjs
var require_w3c_keyname = __commonJS({
  "node_modules/.pnpm/w3c-keyname@2.2.8/node_modules/w3c-keyname/index.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var base = {
      8: "Backspace",
      9: "Tab",
      10: "Enter",
      12: "NumLock",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      44: "PrintScreen",
      45: "Insert",
      46: "Delete",
      59: ";",
      61: "=",
      91: "Meta",
      92: "Meta",
      106: "*",
      107: "+",
      108: ",",
      109: "-",
      110: ".",
      111: "/",
      144: "NumLock",
      145: "ScrollLock",
      160: "Shift",
      161: "Shift",
      162: "Control",
      163: "Control",
      164: "Alt",
      165: "Alt",
      173: "-",
      186: ";",
      187: "=",
      188: ",",
      189: "-",
      190: ".",
      191: "/",
      192: "`",
      219: "[",
      220: "\\",
      221: "]",
      222: "'"
    };
    var shift = {
      48: ")",
      49: "!",
      50: "@",
      51: "#",
      52: "$",
      53: "%",
      54: "^",
      55: "&",
      56: "*",
      57: "(",
      59: ":",
      61: "+",
      173: "_",
      186: ":",
      187: "+",
      188: "<",
      189: "_",
      190: ">",
      191: "?",
      192: "~",
      219: "{",
      220: "|",
      221: "}",
      222: '"'
    };
    var mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
    var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
    for (i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i);
    var i;
    for (i = 1; i <= 24; i++) base[i + 111] = "F" + i;
    var i;
    for (i = 65; i <= 90; i++) {
      base[i] = String.fromCharCode(i + 32);
      shift[i] = String.fromCharCode(i);
    }
    var i;
    for (code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code];
    var code;
    function keyName(event) {
      var ignoreKey = mac && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey || ie && event.shiftKey && event.key && event.key.length == 1 || event.key == "Unidentified";
      var name = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || "Unidentified";
      if (name == "Esc") name = "Escape";
      if (name == "Del") name = "Delete";
      if (name == "Left") name = "ArrowLeft";
      if (name == "Up") name = "ArrowUp";
      if (name == "Right") name = "ArrowRight";
      if (name == "Down") name = "ArrowDown";
      return name;
    }
    exports2.base = base;
    exports2.keyName = keyName;
    exports2.shift = shift;
  }
});

// node_modules/.pnpm/prosemirror-keymap@1.2.3/node_modules/prosemirror-keymap/dist/index.cjs
var require_dist8 = __commonJS({
  "node_modules/.pnpm/prosemirror-keymap@1.2.3/node_modules/prosemirror-keymap/dist/index.cjs"(exports2) {
    "use strict";
    var w3cKeyname = require_w3c_keyname();
    var prosemirrorState = require_dist4();
    var mac = typeof navigator != "undefined" && /Mac|iP(hone|[oa]d)/.test(navigator.platform);
    var windows = typeof navigator != "undefined" && /Win/.test(navigator.platform);
    function normalizeKeyName(name) {
      var parts = name.split(/-(?!$)/), result = parts[parts.length - 1];
      if (result == "Space") result = " ";
      var alt, ctrl, shift, meta;
      for (var i = 0; i < parts.length - 1; i++) {
        var mod = parts[i];
        if (/^(cmd|meta|m)$/i.test(mod)) meta = true;
        else if (/^a(lt)?$/i.test(mod)) alt = true;
        else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true;
        else if (/^s(hift)?$/i.test(mod)) shift = true;
        else if (/^mod$/i.test(mod)) {
          if (mac) meta = true;
          else ctrl = true;
        } else throw new Error("Unrecognized modifier name: " + mod);
      }
      if (alt) result = "Alt-" + result;
      if (ctrl) result = "Ctrl-" + result;
      if (meta) result = "Meta-" + result;
      if (shift) result = "Shift-" + result;
      return result;
    }
    function normalize(map) {
      var copy = /* @__PURE__ */ Object.create(null);
      for (var prop in map) copy[normalizeKeyName(prop)] = map[prop];
      return copy;
    }
    function modifiers(name, event) {
      var shift = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      if (event.altKey) name = "Alt-" + name;
      if (event.ctrlKey) name = "Ctrl-" + name;
      if (event.metaKey) name = "Meta-" + name;
      if (shift && event.shiftKey) name = "Shift-" + name;
      return name;
    }
    function keymap(bindings) {
      return new prosemirrorState.Plugin({
        props: {
          handleKeyDown: keydownHandler(bindings)
        }
      });
    }
    function keydownHandler(bindings) {
      var map = normalize(bindings);
      return function(view, event) {
        var name = w3cKeyname.keyName(event), baseName, direct = map[modifiers(name, event)];
        if (direct && direct(view.state, view.dispatch, view)) return true;
        if (name.length == 1 && name != " ") {
          if (event.shiftKey) {
            var noShift = map[modifiers(name, event, false)];
            if (noShift && noShift(view.state, view.dispatch, view)) return true;
          }
          if ((event.altKey || event.metaKey || event.ctrlKey) && !(windows && event.ctrlKey && event.altKey) && (baseName = w3cKeyname.base[event.keyCode]) && baseName != name) {
            var fromCode = map[modifiers(baseName, event)];
            if (fromCode && fromCode(view.state, view.dispatch, view)) return true;
          }
        }
        return false;
      };
    }
    exports2.keydownHandler = keydownHandler;
    exports2.keymap = keymap;
  }
});

// node_modules/.pnpm/@tiptap+pm@3.11.0/node_modules/@tiptap/pm/dist/keymap/index.cjs
var require_keymap = __commonJS({
  "node_modules/.pnpm/@tiptap+pm@3.11.0/node_modules/@tiptap/pm/dist/keymap/index.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function _createStarExport(obj) {
      Object.keys(obj).filter((key) => key !== "default" && key !== "__esModule").forEach((key) => {
        if (exports2.hasOwnProperty(key)) {
          return;
        }
        Object.defineProperty(exports2, key, { enumerable: true, configurable: true, get: () => obj[key] });
      });
    }
    var _prosemirrorkeymap = require_dist8();
    _createStarExport(_prosemirrorkeymap);
  }
});

// node_modules/.pnpm/@tiptap+core@3.11.0_@tiptap+pm@3.11.0/node_modules/@tiptap/core/dist/index.cjs
var require_dist9 = __commonJS({
  "node_modules/.pnpm/@tiptap+core@3.11.0_@tiptap+pm@3.11.0/node_modules/@tiptap/core/dist/index.cjs"(exports2, module2) {
    "use strict";
    var __defProp3 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp3 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp3(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp3.call(to, key) && key !== except)
            __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp3({}, "__esModule", { value: true }), mod);
    var index_exports = {};
    __export2(index_exports, {
      CommandManager: () => CommandManager,
      Editor: () => Editor,
      Extendable: () => Extendable,
      Extension: () => Extension,
      Fragment: () => Fragment6,
      InputRule: () => InputRule,
      Mark: () => Mark,
      MarkView: () => MarkView,
      Node: () => Node3,
      NodePos: () => NodePos,
      NodeView: () => NodeView,
      PasteRule: () => PasteRule,
      ResizableNodeView: () => ResizableNodeView,
      ResizableNodeview: () => ResizableNodeview,
      Tracker: () => Tracker,
      callOrReturn: () => callOrReturn,
      canInsertNode: () => canInsertNode,
      combineTransactionSteps: () => combineTransactionSteps,
      commands: () => commands_exports,
      createAtomBlockMarkdownSpec: () => createAtomBlockMarkdownSpec,
      createBlockMarkdownSpec: () => createBlockMarkdownSpec,
      createChainableState: () => createChainableState,
      createDocument: () => createDocument,
      createElement: () => h,
      createInlineMarkdownSpec: () => createInlineMarkdownSpec,
      createNodeFromContent: () => createNodeFromContent,
      createStyleTag: () => createStyleTag,
      defaultBlockAt: () => defaultBlockAt,
      deleteProps: () => deleteProps,
      elementFromString: () => elementFromString,
      escapeForRegEx: () => escapeForRegEx,
      extensions: () => extensions_exports,
      findChildren: () => findChildren,
      findChildrenInRange: () => findChildrenInRange,
      findDuplicates: () => findDuplicates,
      findParentNode: () => findParentNode,
      findParentNodeClosestToPos: () => findParentNodeClosestToPos,
      flattenExtensions: () => flattenExtensions,
      fromString: () => fromString,
      generateHTML: () => generateHTML,
      generateJSON: () => generateJSON,
      generateText: () => generateText,
      getAttributes: () => getAttributes,
      getAttributesFromExtensions: () => getAttributesFromExtensions,
      getChangedRanges: () => getChangedRanges,
      getDebugJSON: () => getDebugJSON,
      getExtensionField: () => getExtensionField,
      getHTMLFromFragment: () => getHTMLFromFragment,
      getMarkAttributes: () => getMarkAttributes,
      getMarkRange: () => getMarkRange,
      getMarkType: () => getMarkType,
      getMarksBetween: () => getMarksBetween,
      getNodeAtPosition: () => getNodeAtPosition,
      getNodeAttributes: () => getNodeAttributes,
      getNodeType: () => getNodeType,
      getRenderedAttributes: () => getRenderedAttributes,
      getSchema: () => getSchema,
      getSchemaByResolvedExtensions: () => getSchemaByResolvedExtensions,
      getSchemaTypeByName: () => getSchemaTypeByName,
      getSchemaTypeNameByName: () => getSchemaTypeNameByName,
      getSplittedAttributes: () => getSplittedAttributes,
      getText: () => getText,
      getTextBetween: () => getTextBetween,
      getTextContentFromNodes: () => getTextContentFromNodes,
      getTextSerializersFromSchema: () => getTextSerializersFromSchema,
      h: () => h,
      injectExtensionAttributesToParseRule: () => injectExtensionAttributesToParseRule,
      inputRulesPlugin: () => inputRulesPlugin,
      isActive: () => isActive,
      isAndroid: () => isAndroid,
      isAtEndOfNode: () => isAtEndOfNode,
      isAtStartOfNode: () => isAtStartOfNode,
      isEmptyObject: () => isEmptyObject,
      isExtensionRulesEnabled: () => isExtensionRulesEnabled,
      isFunction: () => isFunction,
      isList: () => isList,
      isMacOS: () => isMacOS,
      isMarkActive: () => isMarkActive,
      isNodeActive: () => isNodeActive,
      isNodeEmpty: () => isNodeEmpty,
      isNodeSelection: () => isNodeSelection,
      isNumber: () => isNumber,
      isPlainObject: () => isPlainObject,
      isRegExp: () => isRegExp,
      isString: () => isString,
      isTextSelection: () => isTextSelection,
      isiOS: () => isiOS,
      markInputRule: () => markInputRule,
      markPasteRule: () => markPasteRule,
      markdown: () => markdown_exports,
      mergeAttributes: () => mergeAttributes,
      mergeDeep: () => mergeDeep,
      minMax: () => minMax,
      nodeInputRule: () => nodeInputRule,
      nodePasteRule: () => nodePasteRule,
      objectIncludes: () => objectIncludes,
      parseAttributes: () => parseAttributes,
      parseIndentedBlocks: () => parseIndentedBlocks,
      pasteRulesPlugin: () => pasteRulesPlugin,
      posToDOMRect: () => posToDOMRect,
      removeDuplicates: () => removeDuplicates,
      renderNestedMarkdownContent: () => renderNestedMarkdownContent,
      resolveExtensions: () => resolveExtensions,
      resolveFocusPosition: () => resolveFocusPosition,
      rewriteUnknownContent: () => rewriteUnknownContent,
      selectionToInsertionEnd: () => selectionToInsertionEnd,
      serializeAttributes: () => serializeAttributes,
      sortExtensions: () => sortExtensions,
      splitExtensions: () => splitExtensions,
      textInputRule: () => textInputRule,
      textPasteRule: () => textPasteRule,
      textblockTypeInputRule: () => textblockTypeInputRule,
      updateMarkViewAttributes: () => updateMarkViewAttributes,
      wrappingInputRule: () => wrappingInputRule
    });
    module2.exports = __toCommonJS2(index_exports);
    function createChainableState(config) {
      const { state: state2, transaction } = config;
      let { selection } = transaction;
      let { doc } = transaction;
      let { storedMarks } = transaction;
      return {
        ...state2,
        apply: state2.apply.bind(state2),
        applyTransaction: state2.applyTransaction.bind(state2),
        plugins: state2.plugins,
        schema: state2.schema,
        reconfigure: state2.reconfigure.bind(state2),
        toJSON: state2.toJSON.bind(state2),
        get storedMarks() {
          return storedMarks;
        },
        get selection() {
          return selection;
        },
        get doc() {
          return doc;
        },
        get tr() {
          selection = transaction.selection;
          doc = transaction.doc;
          storedMarks = transaction.storedMarks;
          return transaction;
        }
      };
    }
    var CommandManager = class {
      constructor(props) {
        this.editor = props.editor;
        this.rawCommands = this.editor.extensionManager.commands;
        this.customState = props.state;
      }
      get hasCustomState() {
        return !!this.customState;
      }
      get state() {
        return this.customState || this.editor.state;
      }
      get commands() {
        const { rawCommands, editor, state: state2 } = this;
        const { view } = editor;
        const { tr } = state2;
        const props = this.buildProps(tr);
        return Object.fromEntries(
          Object.entries(rawCommands).map(([name, command2]) => {
            const method = (...args) => {
              const callback = command2(...args)(props);
              if (!tr.getMeta("preventDispatch") && !this.hasCustomState) {
                view.dispatch(tr);
              }
              return callback;
            };
            return [name, method];
          })
        );
      }
      get chain() {
        return () => this.createChain();
      }
      get can() {
        return () => this.createCan();
      }
      createChain(startTr, shouldDispatch = true) {
        const { rawCommands, editor, state: state2 } = this;
        const { view } = editor;
        const callbacks = [];
        const hasStartTransaction = !!startTr;
        const tr = startTr || state2.tr;
        const run3 = () => {
          if (!hasStartTransaction && shouldDispatch && !tr.getMeta("preventDispatch") && !this.hasCustomState) {
            view.dispatch(tr);
          }
          return callbacks.every((callback) => callback === true);
        };
        const chain = {
          ...Object.fromEntries(
            Object.entries(rawCommands).map(([name, command2]) => {
              const chainedCommand = (...args) => {
                const props = this.buildProps(tr, shouldDispatch);
                const callback = command2(...args)(props);
                callbacks.push(callback);
                return chain;
              };
              return [name, chainedCommand];
            })
          ),
          run: run3
        };
        return chain;
      }
      createCan(startTr) {
        const { rawCommands, state: state2 } = this;
        const dispatch = false;
        const tr = startTr || state2.tr;
        const props = this.buildProps(tr, dispatch);
        const formattedCommands = Object.fromEntries(
          Object.entries(rawCommands).map(([name, command2]) => {
            return [name, (...args) => command2(...args)({ ...props, dispatch: void 0 })];
          })
        );
        return {
          ...formattedCommands,
          chain: () => this.createChain(tr, dispatch)
        };
      }
      buildProps(tr, shouldDispatch = true) {
        const { rawCommands, editor, state: state2 } = this;
        const { view } = editor;
        const props = {
          tr,
          editor,
          view,
          state: createChainableState({
            state: state2,
            transaction: tr
          }),
          dispatch: shouldDispatch ? () => void 0 : void 0,
          chain: () => this.createChain(tr, shouldDispatch),
          can: () => this.createCan(tr),
          get commands() {
            return Object.fromEntries(
              Object.entries(rawCommands).map(([name, command2]) => {
                return [name, (...args) => command2(...args)(props)];
              })
            );
          }
        };
        return props;
      }
    };
    var commands_exports = {};
    __export2(commands_exports, {
      blur: () => blur,
      clearContent: () => clearContent,
      clearNodes: () => clearNodes,
      command: () => command,
      createParagraphNear: () => createParagraphNear,
      cut: () => cut,
      deleteCurrentNode: () => deleteCurrentNode,
      deleteNode: () => deleteNode,
      deleteRange: () => deleteRange,
      deleteSelection: () => deleteSelection,
      enter: () => enter,
      exitCode: () => exitCode,
      extendMarkRange: () => extendMarkRange,
      first: () => first,
      focus: () => focus,
      forEach: () => forEach,
      insertContent: () => insertContent,
      insertContentAt: () => insertContentAt,
      joinBackward: () => joinBackward,
      joinDown: () => joinDown,
      joinForward: () => joinForward,
      joinItemBackward: () => joinItemBackward,
      joinItemForward: () => joinItemForward,
      joinTextblockBackward: () => joinTextblockBackward,
      joinTextblockForward: () => joinTextblockForward,
      joinUp: () => joinUp,
      keyboardShortcut: () => keyboardShortcut,
      lift: () => lift,
      liftEmptyBlock: () => liftEmptyBlock,
      liftListItem: () => liftListItem,
      newlineInCode: () => newlineInCode,
      resetAttributes: () => resetAttributes,
      scrollIntoView: () => scrollIntoView,
      selectAll: () => selectAll,
      selectNodeBackward: () => selectNodeBackward,
      selectNodeForward: () => selectNodeForward,
      selectParentNode: () => selectParentNode,
      selectTextblockEnd: () => selectTextblockEnd,
      selectTextblockStart: () => selectTextblockStart,
      setContent: () => setContent,
      setMark: () => setMark,
      setMeta: () => setMeta,
      setNode: () => setNode,
      setNodeSelection: () => setNodeSelection,
      setTextDirection: () => setTextDirection,
      setTextSelection: () => setTextSelection,
      sinkListItem: () => sinkListItem,
      splitBlock: () => splitBlock,
      splitListItem: () => splitListItem,
      toggleList: () => toggleList,
      toggleMark: () => toggleMark,
      toggleNode: () => toggleNode,
      toggleWrap: () => toggleWrap,
      undoInputRule: () => undoInputRule,
      unsetAllMarks: () => unsetAllMarks,
      unsetMark: () => unsetMark,
      unsetTextDirection: () => unsetTextDirection,
      updateAttributes: () => updateAttributes,
      wrapIn: () => wrapIn,
      wrapInList: () => wrapInList
    });
    var blur = () => ({ editor, view }) => {
      requestAnimationFrame(() => {
        var _a;
        if (!editor.isDestroyed) {
          ;
          view.dom.blur();
          (_a = window == null ? void 0 : window.getSelection()) == null ? void 0 : _a.removeAllRanges();
        }
      });
      return true;
    };
    var clearContent = (emitUpdate = true) => ({ commands: commands2 }) => {
      return commands2.setContent("", { emitUpdate });
    };
    var import_transform = require_transform();
    var clearNodes = () => ({ state: state2, tr, dispatch }) => {
      const { selection } = tr;
      const { ranges } = selection;
      if (!dispatch) {
        return true;
      }
      ranges.forEach(({ $from, $to }) => {
        state2.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {
          if (node.type.isText) {
            return;
          }
          const { doc, mapping } = tr;
          const $mappedFrom = doc.resolve(mapping.map(pos));
          const $mappedTo = doc.resolve(mapping.map(pos + node.nodeSize));
          const nodeRange = $mappedFrom.blockRange($mappedTo);
          if (!nodeRange) {
            return;
          }
          const targetLiftDepth = (0, import_transform.liftTarget)(nodeRange);
          if (node.type.isTextblock) {
            const { defaultType } = $mappedFrom.parent.contentMatchAt($mappedFrom.index());
            tr.setNodeMarkup(nodeRange.start, defaultType);
          }
          if (targetLiftDepth || targetLiftDepth === 0) {
            tr.lift(nodeRange, targetLiftDepth);
          }
        });
      });
      return true;
    };
    var command = (fn) => (props) => {
      return fn(props);
    };
    var import_commands = require_commands();
    var createParagraphNear = () => ({ state: state2, dispatch }) => {
      return (0, import_commands.createParagraphNear)(state2, dispatch);
    };
    var import_state = require_state();
    var cut = (originRange, targetPos) => ({ editor, tr }) => {
      const { state: state2 } = editor;
      const contentSlice = state2.doc.slice(originRange.from, originRange.to);
      tr.deleteRange(originRange.from, originRange.to);
      const newPos = tr.mapping.map(targetPos);
      tr.insert(newPos, contentSlice.content);
      tr.setSelection(new import_state.TextSelection(tr.doc.resolve(Math.max(newPos - 1, 0))));
      return true;
    };
    var deleteCurrentNode = () => ({ tr, dispatch }) => {
      const { selection } = tr;
      const currentNode = selection.$anchor.node();
      if (currentNode.content.size > 0) {
        return false;
      }
      const $pos = tr.selection.$anchor;
      for (let depth = $pos.depth; depth > 0; depth -= 1) {
        const node = $pos.node(depth);
        if (node.type === currentNode.type) {
          if (dispatch) {
            const from = $pos.before(depth);
            const to = $pos.after(depth);
            tr.delete(from, to).scrollIntoView();
          }
          return true;
        }
      }
      return false;
    };
    function getNodeType(nameOrType, schema) {
      if (typeof nameOrType === "string") {
        if (!schema.nodes[nameOrType]) {
          throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`);
        }
        return schema.nodes[nameOrType];
      }
      return nameOrType;
    }
    var deleteNode = (typeOrName) => ({ tr, state: state2, dispatch }) => {
      const type2 = getNodeType(typeOrName, state2.schema);
      const $pos = tr.selection.$anchor;
      for (let depth = $pos.depth; depth > 0; depth -= 1) {
        const node = $pos.node(depth);
        if (node.type === type2) {
          if (dispatch) {
            const from = $pos.before(depth);
            const to = $pos.after(depth);
            tr.delete(from, to).scrollIntoView();
          }
          return true;
        }
      }
      return false;
    };
    var deleteRange = (range2) => ({ tr, dispatch }) => {
      const { from, to } = range2;
      if (dispatch) {
        tr.delete(from, to);
      }
      return true;
    };
    var import_commands2 = require_commands();
    var deleteSelection = () => ({ state: state2, dispatch }) => {
      return (0, import_commands2.deleteSelection)(state2, dispatch);
    };
    var enter = () => ({ commands: commands2 }) => {
      return commands2.keyboardShortcut("Enter");
    };
    var import_commands3 = require_commands();
    var exitCode = () => ({ state: state2, dispatch }) => {
      return (0, import_commands3.exitCode)(state2, dispatch);
    };
    var import_state2 = require_state();
    function isRegExp(value) {
      return Object.prototype.toString.call(value) === "[object RegExp]";
    }
    function objectIncludes(object1, object2, options = { strict: true }) {
      const keys = Object.keys(object2);
      if (!keys.length) {
        return true;
      }
      return keys.every((key) => {
        if (options.strict) {
          return object2[key] === object1[key];
        }
        if (isRegExp(object2[key])) {
          return object2[key].test(object1[key]);
        }
        return object2[key] === object1[key];
      });
    }
    function findMarkInSet(marks, type2, attributes = {}) {
      return marks.find((item) => {
        return item.type === type2 && objectIncludes(
          // Only check equality for the attributes that are provided
          Object.fromEntries(Object.keys(attributes).map((k) => [k, item.attrs[k]])),
          attributes
        );
      });
    }
    function isMarkInSet(marks, type2, attributes = {}) {
      return !!findMarkInSet(marks, type2, attributes);
    }
    function getMarkRange($pos, type2, attributes) {
      var _a;
      if (!$pos || !type2) {
        return;
      }
      let start = $pos.parent.childAfter($pos.parentOffset);
      if (!start.node || !start.node.marks.some((mark2) => mark2.type === type2)) {
        start = $pos.parent.childBefore($pos.parentOffset);
      }
      if (!start.node || !start.node.marks.some((mark2) => mark2.type === type2)) {
        return;
      }
      attributes = attributes || ((_a = start.node.marks[0]) == null ? void 0 : _a.attrs);
      const mark = findMarkInSet([...start.node.marks], type2, attributes);
      if (!mark) {
        return;
      }
      let startIndex = start.index;
      let startPos = $pos.start() + start.offset;
      let endIndex = startIndex + 1;
      let endPos = startPos + start.node.nodeSize;
      while (startIndex > 0 && isMarkInSet([...$pos.parent.child(startIndex - 1).marks], type2, attributes)) {
        startIndex -= 1;
        startPos -= $pos.parent.child(startIndex).nodeSize;
      }
      while (endIndex < $pos.parent.childCount && isMarkInSet([...$pos.parent.child(endIndex).marks], type2, attributes)) {
        endPos += $pos.parent.child(endIndex).nodeSize;
        endIndex += 1;
      }
      return {
        from: startPos,
        to: endPos
      };
    }
    function getMarkType(nameOrType, schema) {
      if (typeof nameOrType === "string") {
        if (!schema.marks[nameOrType]) {
          throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`);
        }
        return schema.marks[nameOrType];
      }
      return nameOrType;
    }
    var extendMarkRange = (typeOrName, attributes = {}) => ({ tr, state: state2, dispatch }) => {
      const type2 = getMarkType(typeOrName, state2.schema);
      const { doc, selection } = tr;
      const { $from, from, to } = selection;
      if (dispatch) {
        const range2 = getMarkRange($from, type2, attributes);
        if (range2 && range2.from <= from && range2.to >= to) {
          const newSelection = import_state2.TextSelection.create(doc, range2.from, range2.to);
          tr.setSelection(newSelection);
        }
      }
      return true;
    };
    var first = (commands2) => (props) => {
      const items = typeof commands2 === "function" ? commands2(props) : commands2;
      for (let i = 0; i < items.length; i += 1) {
        if (items[i](props)) {
          return true;
        }
      }
      return false;
    };
    var import_state3 = require_state();
    function isTextSelection(value) {
      return value instanceof import_state3.TextSelection;
    }
    var import_state4 = require_state();
    function minMax(value = 0, min2 = 0, max2 = 0) {
      return Math.min(Math.max(value, min2), max2);
    }
    function resolveFocusPosition(doc, position = null) {
      if (!position) {
        return null;
      }
      const selectionAtStart = import_state4.Selection.atStart(doc);
      const selectionAtEnd = import_state4.Selection.atEnd(doc);
      if (position === "start" || position === true) {
        return selectionAtStart;
      }
      if (position === "end") {
        return selectionAtEnd;
      }
      const minPos = selectionAtStart.from;
      const maxPos = selectionAtEnd.to;
      if (position === "all") {
        return import_state4.TextSelection.create(doc, minMax(0, minPos, maxPos), minMax(doc.content.size, minPos, maxPos));
      }
      return import_state4.TextSelection.create(doc, minMax(position, minPos, maxPos), minMax(position, minPos, maxPos));
    }
    function isAndroid() {
      return navigator.platform === "Android" || /android/i.test(navigator.userAgent);
    }
    function isiOS() {
      return ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(navigator.platform) || // iPad on iOS 13 detection
      navigator.userAgent.includes("Mac") && "ontouchend" in document;
    }
    var focus = (position = null, options = {}) => ({ editor, view, tr, dispatch }) => {
      options = {
        scrollIntoView: true,
        ...options
      };
      const delayedFocus = () => {
        if (isiOS() || isAndroid()) {
          ;
          view.dom.focus();
        }
        requestAnimationFrame(() => {
          if (!editor.isDestroyed) {
            view.focus();
            if (options == null ? void 0 : options.scrollIntoView) {
              editor.commands.scrollIntoView();
            }
          }
        });
      };
      if (view.hasFocus() && position === null || position === false) {
        return true;
      }
      if (dispatch && position === null && !isTextSelection(editor.state.selection)) {
        delayedFocus();
        return true;
      }
      const selection = resolveFocusPosition(tr.doc, position) || editor.state.selection;
      const isSameSelection = editor.state.selection.eq(selection);
      if (dispatch) {
        if (!isSameSelection) {
          tr.setSelection(selection);
        }
        if (isSameSelection && tr.storedMarks) {
          tr.setStoredMarks(tr.storedMarks);
        }
        delayedFocus();
      }
      return true;
    };
    var forEach = (items, fn) => (props) => {
      return items.every((item, index) => fn(item, { ...props, index }));
    };
    var insertContent = (value, options) => ({ tr, commands: commands2 }) => {
      return commands2.insertContentAt({ from: tr.selection.from, to: tr.selection.to }, value, options);
    };
    var import_model2 = require_model();
    var import_model = require_model();
    var removeWhitespaces = (node) => {
      const children = node.childNodes;
      for (let i = children.length - 1; i >= 0; i -= 1) {
        const child = children[i];
        if (child.nodeType === 3 && child.nodeValue && /^(\n\s\s|\n)$/.test(child.nodeValue)) {
          node.removeChild(child);
        } else if (child.nodeType === 1) {
          removeWhitespaces(child);
        }
      }
      return node;
    };
    function elementFromString(value) {
      if (typeof window === "undefined") {
        throw new Error("[tiptap error]: there is no window object available, so this function cannot be used");
      }
      const wrappedValue = `<body>${value}</body>`;
      const html = new window.DOMParser().parseFromString(wrappedValue, "text/html").body;
      return removeWhitespaces(html);
    }
    function createNodeFromContent(content, schema, options) {
      if (content instanceof import_model.Node || content instanceof import_model.Fragment) {
        return content;
      }
      options = {
        slice: true,
        parseOptions: {},
        ...options
      };
      const isJSONContent = typeof content === "object" && content !== null;
      const isTextContent = typeof content === "string";
      if (isJSONContent) {
        try {
          const isArrayContent = Array.isArray(content) && content.length > 0;
          if (isArrayContent) {
            return import_model.Fragment.fromArray(content.map((item) => schema.nodeFromJSON(item)));
          }
          const node = schema.nodeFromJSON(content);
          if (options.errorOnInvalidContent) {
            node.check();
          }
          return node;
        } catch (error) {
          if (options.errorOnInvalidContent) {
            throw new Error("[tiptap error]: Invalid JSON content", { cause: error });
          }
          console.warn("[tiptap warn]: Invalid content.", "Passed value:", content, "Error:", error);
          return createNodeFromContent("", schema, options);
        }
      }
      if (isTextContent) {
        if (options.errorOnInvalidContent) {
          let hasInvalidContent = false;
          let invalidContent = "";
          const contentCheckSchema = new import_model.Schema({
            topNode: schema.spec.topNode,
            marks: schema.spec.marks,
            // Prosemirror's schemas are executed such that: the last to execute, matches last
            // This means that we can add a catch-all node at the end of the schema to catch any content that we don't know how to handle
            nodes: schema.spec.nodes.append({
              __tiptap__private__unknown__catch__all__node: {
                content: "inline*",
                group: "block",
                parseDOM: [
                  {
                    tag: "*",
                    getAttrs: (e) => {
                      hasInvalidContent = true;
                      invalidContent = typeof e === "string" ? e : e.outerHTML;
                      return null;
                    }
                  }
                ]
              }
            })
          });
          if (options.slice) {
            import_model.DOMParser.fromSchema(contentCheckSchema).parseSlice(elementFromString(content), options.parseOptions);
          } else {
            import_model.DOMParser.fromSchema(contentCheckSchema).parse(elementFromString(content), options.parseOptions);
          }
          if (options.errorOnInvalidContent && hasInvalidContent) {
            throw new Error("[tiptap error]: Invalid HTML content", {
              cause: new Error(`Invalid element found: ${invalidContent}`)
            });
          }
        }
        const parser = import_model.DOMParser.fromSchema(schema);
        if (options.slice) {
          return parser.parseSlice(elementFromString(content), options.parseOptions).content;
        }
        return parser.parse(elementFromString(content), options.parseOptions);
      }
      return createNodeFromContent("", schema, options);
    }
    var import_state5 = require_state();
    var import_transform2 = require_transform();
    function selectionToInsertionEnd(tr, startLen, bias) {
      const last = tr.steps.length - 1;
      if (last < startLen) {
        return;
      }
      const step = tr.steps[last];
      if (!(step instanceof import_transform2.ReplaceStep || step instanceof import_transform2.ReplaceAroundStep)) {
        return;
      }
      const map = tr.mapping.maps[last];
      let end = 0;
      map.forEach((_from, _to, _newFrom, newTo) => {
        if (end === 0) {
          end = newTo;
        }
      });
      tr.setSelection(import_state5.Selection.near(tr.doc.resolve(end), bias));
    }
    var isFragment = (nodeOrFragment) => {
      return !("type" in nodeOrFragment);
    };
    var insertContentAt = (position, value, options) => ({ tr, dispatch, editor }) => {
      var _a;
      if (dispatch) {
        options = {
          parseOptions: editor.options.parseOptions,
          updateSelection: true,
          applyInputRules: false,
          applyPasteRules: false,
          ...options
        };
        let content;
        const emitContentError = (error) => {
          editor.emit("contentError", {
            editor,
            error,
            disableCollaboration: () => {
              if ("collaboration" in editor.storage && typeof editor.storage.collaboration === "object" && editor.storage.collaboration) {
                ;
                editor.storage.collaboration.isDisabled = true;
              }
            }
          });
        };
        const parseOptions = {
          preserveWhitespace: "full",
          ...options.parseOptions
        };
        if (!options.errorOnInvalidContent && !editor.options.enableContentCheck && editor.options.emitContentError) {
          try {
            createNodeFromContent(value, editor.schema, {
              parseOptions,
              errorOnInvalidContent: true
            });
          } catch (e) {
            emitContentError(e);
          }
        }
        try {
          content = createNodeFromContent(value, editor.schema, {
            parseOptions,
            errorOnInvalidContent: (_a = options.errorOnInvalidContent) != null ? _a : editor.options.enableContentCheck
          });
        } catch (e) {
          emitContentError(e);
          return false;
        }
        let { from, to } = typeof position === "number" ? { from: position, to: position } : { from: position.from, to: position.to };
        let isOnlyTextContent = true;
        let isOnlyBlockContent = true;
        const nodes = isFragment(content) ? content : [content];
        nodes.forEach((node) => {
          node.check();
          isOnlyTextContent = isOnlyTextContent ? node.isText && node.marks.length === 0 : false;
          isOnlyBlockContent = isOnlyBlockContent ? node.isBlock : false;
        });
        if (from === to && isOnlyBlockContent) {
          const { parent } = tr.doc.resolve(from);
          const isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount;
          if (isEmptyTextBlock) {
            from -= 1;
            to += 1;
          }
        }
        let newContent;
        if (isOnlyTextContent) {
          if (Array.isArray(value)) {
            newContent = value.map((v) => v.text || "").join("");
          } else if (value instanceof import_model2.Fragment) {
            let text = "";
            value.forEach((node) => {
              if (node.text) {
                text += node.text;
              }
            });
            newContent = text;
          } else if (typeof value === "object" && !!value && !!value.text) {
            newContent = value.text;
          } else {
            newContent = value;
          }
          tr.insertText(newContent, from, to);
        } else {
          newContent = content;
          const $from = tr.doc.resolve(from);
          const $fromNode = $from.node();
          const fromSelectionAtStart = $from.parentOffset === 0;
          const isTextSelection2 = $fromNode.isText || $fromNode.isTextblock;
          const hasContent = $fromNode.content.size > 0;
          if (fromSelectionAtStart && isTextSelection2 && hasContent) {
            from = Math.max(0, from - 1);
          }
          tr.replaceWith(from, to, newContent);
        }
        if (options.updateSelection) {
          selectionToInsertionEnd(tr, tr.steps.length - 1, -1);
        }
        if (options.applyInputRules) {
          tr.setMeta("applyInputRules", { from, text: newContent });
        }
        if (options.applyPasteRules) {
          tr.setMeta("applyPasteRules", { from, text: newContent });
        }
      }
      return true;
    };
    var import_commands4 = require_commands();
    var joinUp = () => ({ state: state2, dispatch }) => {
      return (0, import_commands4.joinUp)(state2, dispatch);
    };
    var joinDown = () => ({ state: state2, dispatch }) => {
      return (0, import_commands4.joinDown)(state2, dispatch);
    };
    var joinBackward = () => ({ state: state2, dispatch }) => {
      return (0, import_commands4.joinBackward)(state2, dispatch);
    };
    var joinForward = () => ({ state: state2, dispatch }) => {
      return (0, import_commands4.joinForward)(state2, dispatch);
    };
    var import_transform3 = require_transform();
    var joinItemBackward = () => ({ state: state2, dispatch, tr }) => {
      try {
        const point = (0, import_transform3.joinPoint)(state2.doc, state2.selection.$from.pos, -1);
        if (point === null || point === void 0) {
          return false;
        }
        tr.join(point, 2);
        if (dispatch) {
          dispatch(tr);
        }
        return true;
      } catch {
        return false;
      }
    };
    var import_transform4 = require_transform();
    var joinItemForward = () => ({ state: state2, dispatch, tr }) => {
      try {
        const point = (0, import_transform4.joinPoint)(state2.doc, state2.selection.$from.pos, 1);
        if (point === null || point === void 0) {
          return false;
        }
        tr.join(point, 2);
        if (dispatch) {
          dispatch(tr);
        }
        return true;
      } catch {
        return false;
      }
    };
    var import_commands5 = require_commands();
    var joinTextblockBackward = () => ({ state: state2, dispatch }) => {
      return (0, import_commands5.joinTextblockBackward)(state2, dispatch);
    };
    var import_commands6 = require_commands();
    var joinTextblockForward = () => ({ state: state2, dispatch }) => {
      return (0, import_commands6.joinTextblockForward)(state2, dispatch);
    };
    function isMacOS() {
      return typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
    }
    function normalizeKeyName(name) {
      const parts = name.split(/-(?!$)/);
      let result = parts[parts.length - 1];
      if (result === "Space") {
        result = " ";
      }
      let alt;
      let ctrl;
      let shift;
      let meta;
      for (let i = 0; i < parts.length - 1; i += 1) {
        const mod = parts[i];
        if (/^(cmd|meta|m)$/i.test(mod)) {
          meta = true;
        } else if (/^a(lt)?$/i.test(mod)) {
          alt = true;
        } else if (/^(c|ctrl|control)$/i.test(mod)) {
          ctrl = true;
        } else if (/^s(hift)?$/i.test(mod)) {
          shift = true;
        } else if (/^mod$/i.test(mod)) {
          if (isiOS() || isMacOS()) {
            meta = true;
          } else {
            ctrl = true;
          }
        } else {
          throw new Error(`Unrecognized modifier name: ${mod}`);
        }
      }
      if (alt) {
        result = `Alt-${result}`;
      }
      if (ctrl) {
        result = `Ctrl-${result}`;
      }
      if (meta) {
        result = `Meta-${result}`;
      }
      if (shift) {
        result = `Shift-${result}`;
      }
      return result;
    }
    var keyboardShortcut = (name) => ({ editor, view, tr, dispatch }) => {
      const keys = normalizeKeyName(name).split(/-(?!$)/);
      const key = keys.find((item) => !["Alt", "Ctrl", "Meta", "Shift"].includes(item));
      const event = new KeyboardEvent("keydown", {
        key: key === "Space" ? " " : key,
        altKey: keys.includes("Alt"),
        ctrlKey: keys.includes("Ctrl"),
        metaKey: keys.includes("Meta"),
        shiftKey: keys.includes("Shift"),
        bubbles: true,
        cancelable: true
      });
      const capturedTransaction = editor.captureTransaction(() => {
        view.someProp("handleKeyDown", (f) => f(view, event));
      });
      capturedTransaction == null ? void 0 : capturedTransaction.steps.forEach((step) => {
        const newStep = step.map(tr.mapping);
        if (newStep && dispatch) {
          tr.maybeStep(newStep);
        }
      });
      return true;
    };
    var import_commands7 = require_commands();
    function isNodeActive(state2, typeOrName, attributes = {}) {
      const { from, to, empty } = state2.selection;
      const type2 = typeOrName ? getNodeType(typeOrName, state2.schema) : null;
      const nodeRanges = [];
      state2.doc.nodesBetween(from, to, (node, pos) => {
        if (node.isText) {
          return;
        }
        const relativeFrom = Math.max(from, pos);
        const relativeTo = Math.min(to, pos + node.nodeSize);
        nodeRanges.push({
          node,
          from: relativeFrom,
          to: relativeTo
        });
      });
      const selectionRange = to - from;
      const matchedNodeRanges = nodeRanges.filter((nodeRange) => {
        if (!type2) {
          return true;
        }
        return type2.name === nodeRange.node.type.name;
      }).filter((nodeRange) => objectIncludes(nodeRange.node.attrs, attributes, { strict: false }));
      if (empty) {
        return !!matchedNodeRanges.length;
      }
      const range2 = matchedNodeRanges.reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0);
      return range2 >= selectionRange;
    }
    var lift = (typeOrName, attributes = {}) => ({ state: state2, dispatch }) => {
      const type2 = getNodeType(typeOrName, state2.schema);
      const isActive2 = isNodeActive(state2, type2, attributes);
      if (!isActive2) {
        return false;
      }
      return (0, import_commands7.lift)(state2, dispatch);
    };
    var import_commands8 = require_commands();
    var liftEmptyBlock = () => ({ state: state2, dispatch }) => {
      return (0, import_commands8.liftEmptyBlock)(state2, dispatch);
    };
    var import_schema_list = require_schema_list();
    var liftListItem = (typeOrName) => ({ state: state2, dispatch }) => {
      const type2 = getNodeType(typeOrName, state2.schema);
      return (0, import_schema_list.liftListItem)(type2)(state2, dispatch);
    };
    var import_commands9 = require_commands();
    var newlineInCode = () => ({ state: state2, dispatch }) => {
      return (0, import_commands9.newlineInCode)(state2, dispatch);
    };
    function getSchemaTypeNameByName(name, schema) {
      if (schema.nodes[name]) {
        return "node";
      }
      if (schema.marks[name]) {
        return "mark";
      }
      return null;
    }
    function deleteProps(obj, propOrProps) {
      const props = typeof propOrProps === "string" ? [propOrProps] : propOrProps;
      return Object.keys(obj).reduce((newObj, prop) => {
        if (!props.includes(prop)) {
          newObj[prop] = obj[prop];
        }
        return newObj;
      }, {});
    }
    var resetAttributes = (typeOrName, attributes) => ({ tr, state: state2, dispatch }) => {
      let nodeType = null;
      let markType = null;
      const schemaType = getSchemaTypeNameByName(
        typeof typeOrName === "string" ? typeOrName : typeOrName.name,
        state2.schema
      );
      if (!schemaType) {
        return false;
      }
      if (schemaType === "node") {
        nodeType = getNodeType(typeOrName, state2.schema);
      }
      if (schemaType === "mark") {
        markType = getMarkType(typeOrName, state2.schema);
      }
      let canReset = false;
      tr.selection.ranges.forEach((range2) => {
        state2.doc.nodesBetween(range2.$from.pos, range2.$to.pos, (node, pos) => {
          if (nodeType && nodeType === node.type) {
            canReset = true;
            if (dispatch) {
              tr.setNodeMarkup(pos, void 0, deleteProps(node.attrs, attributes));
            }
          }
          if (markType && node.marks.length) {
            node.marks.forEach((mark) => {
              if (markType === mark.type) {
                canReset = true;
                if (dispatch) {
                  tr.addMark(pos, pos + node.nodeSize, markType.create(deleteProps(mark.attrs, attributes)));
                }
              }
            });
          }
        });
      });
      return canReset;
    };
    var scrollIntoView = () => ({ tr, dispatch }) => {
      if (dispatch) {
        tr.scrollIntoView();
      }
      return true;
    };
    var import_state6 = require_state();
    var selectAll = () => ({ tr, dispatch }) => {
      if (dispatch) {
        const selection = new import_state6.AllSelection(tr.doc);
        tr.setSelection(selection);
      }
      return true;
    };
    var import_commands10 = require_commands();
    var selectNodeBackward = () => ({ state: state2, dispatch }) => {
      return (0, import_commands10.selectNodeBackward)(state2, dispatch);
    };
    var import_commands11 = require_commands();
    var selectNodeForward = () => ({ state: state2, dispatch }) => {
      return (0, import_commands11.selectNodeForward)(state2, dispatch);
    };
    var import_commands12 = require_commands();
    var selectParentNode = () => ({ state: state2, dispatch }) => {
      return (0, import_commands12.selectParentNode)(state2, dispatch);
    };
    var import_commands13 = require_commands();
    var selectTextblockEnd = () => ({ state: state2, dispatch }) => {
      return (0, import_commands13.selectTextblockEnd)(state2, dispatch);
    };
    var import_commands14 = require_commands();
    var selectTextblockStart = () => ({ state: state2, dispatch }) => {
      return (0, import_commands14.selectTextblockStart)(state2, dispatch);
    };
    function createDocument(content, schema, parseOptions = {}, options = {}) {
      return createNodeFromContent(content, schema, {
        slice: false,
        parseOptions,
        errorOnInvalidContent: options.errorOnInvalidContent
      });
    }
    var setContent = (content, { errorOnInvalidContent, emitUpdate = true, parseOptions = {} } = {}) => ({ editor, tr, dispatch, commands: commands2 }) => {
      const { doc } = tr;
      if (parseOptions.preserveWhitespace !== "full") {
        const document2 = createDocument(content, editor.schema, parseOptions, {
          errorOnInvalidContent: errorOnInvalidContent != null ? errorOnInvalidContent : editor.options.enableContentCheck
        });
        if (dispatch) {
          tr.replaceWith(0, doc.content.size, document2).setMeta("preventUpdate", !emitUpdate);
        }
        return true;
      }
      if (dispatch) {
        tr.setMeta("preventUpdate", !emitUpdate);
      }
      return commands2.insertContentAt({ from: 0, to: doc.content.size }, content, {
        parseOptions,
        errorOnInvalidContent: errorOnInvalidContent != null ? errorOnInvalidContent : editor.options.enableContentCheck
      });
    };
    function getMarkAttributes(state2, typeOrName) {
      const type2 = getMarkType(typeOrName, state2.schema);
      const { from, to, empty } = state2.selection;
      const marks = [];
      if (empty) {
        if (state2.storedMarks) {
          marks.push(...state2.storedMarks);
        }
        marks.push(...state2.selection.$head.marks());
      } else {
        state2.doc.nodesBetween(from, to, (node) => {
          marks.push(...node.marks);
        });
      }
      const mark = marks.find((markItem) => markItem.type.name === type2.name);
      if (!mark) {
        return {};
      }
      return { ...mark.attrs };
    }
    var import_transform5 = require_transform();
    function combineTransactionSteps(oldDoc, transactions) {
      const transform = new import_transform5.Transform(oldDoc);
      transactions.forEach((transaction) => {
        transaction.steps.forEach((step) => {
          transform.step(step);
        });
      });
      return transform;
    }
    function defaultBlockAt(match) {
      for (let i = 0; i < match.edgeCount; i += 1) {
        const { type: type2 } = match.edge(i);
        if (type2.isTextblock && !type2.hasRequiredAttrs()) {
          return type2;
        }
      }
      return null;
    }
    function findChildren(node, predicate) {
      const nodesWithPos = [];
      node.descendants((child, pos) => {
        if (predicate(child)) {
          nodesWithPos.push({
            node: child,
            pos
          });
        }
      });
      return nodesWithPos;
    }
    function findChildrenInRange(node, range2, predicate) {
      const nodesWithPos = [];
      node.nodesBetween(range2.from, range2.to, (child, pos) => {
        if (predicate(child)) {
          nodesWithPos.push({
            node: child,
            pos
          });
        }
      });
      return nodesWithPos;
    }
    function findParentNodeClosestToPos($pos, predicate) {
      for (let i = $pos.depth; i > 0; i -= 1) {
        const node = $pos.node(i);
        if (predicate(node)) {
          return {
            pos: i > 0 ? $pos.before(i) : 0,
            start: $pos.start(i),
            depth: i,
            node
          };
        }
      }
    }
    function findParentNode(predicate) {
      return (selection) => findParentNodeClosestToPos(selection.$from, predicate);
    }
    function getExtensionField(extension, field, context) {
      if (extension.config[field] === void 0 && extension.parent) {
        return getExtensionField(extension.parent, field, context);
      }
      if (typeof extension.config[field] === "function") {
        const value = extension.config[field].bind({
          ...context,
          parent: extension.parent ? getExtensionField(extension.parent, field, context) : null
        });
        return value;
      }
      return extension.config[field];
    }
    function flattenExtensions(extensions2) {
      return extensions2.map((extension) => {
        const context = {
          name: extension.name,
          options: extension.options,
          storage: extension.storage
        };
        const addExtensions = getExtensionField(extension, "addExtensions", context);
        if (addExtensions) {
          return [extension, ...flattenExtensions(addExtensions())];
        }
        return extension;
      }).flat(10);
    }
    var import_model5 = require_model();
    var import_model3 = require_model();
    function getHTMLFromFragment(fragment, schema) {
      const documentFragment = import_model3.DOMSerializer.fromSchema(schema).serializeFragment(fragment);
      const temporaryDocument = document.implementation.createHTMLDocument();
      const container = temporaryDocument.createElement("div");
      container.appendChild(documentFragment);
      return container.innerHTML;
    }
    var import_model4 = require_model();
    function isFunction(value) {
      return typeof value === "function";
    }
    function callOrReturn(value, context = void 0, ...props) {
      if (isFunction(value)) {
        if (context) {
          return value.bind(context)(...props);
        }
        return value(...props);
      }
      return value;
    }
    function isEmptyObject(value = {}) {
      return Object.keys(value).length === 0 && value.constructor === Object;
    }
    function splitExtensions(extensions2) {
      const baseExtensions = extensions2.filter((extension) => extension.type === "extension");
      const nodeExtensions = extensions2.filter((extension) => extension.type === "node");
      const markExtensions = extensions2.filter((extension) => extension.type === "mark");
      return {
        baseExtensions,
        nodeExtensions,
        markExtensions
      };
    }
    function getAttributesFromExtensions(extensions2) {
      const extensionAttributes = [];
      const { nodeExtensions, markExtensions } = splitExtensions(extensions2);
      const nodeAndMarkExtensions = [...nodeExtensions, ...markExtensions];
      const defaultAttribute = {
        default: null,
        validate: void 0,
        rendered: true,
        renderHTML: null,
        parseHTML: null,
        keepOnSplit: true,
        isRequired: false
      };
      extensions2.forEach((extension) => {
        const context = {
          name: extension.name,
          options: extension.options,
          storage: extension.storage,
          extensions: nodeAndMarkExtensions
        };
        const addGlobalAttributes = getExtensionField(
          extension,
          "addGlobalAttributes",
          context
        );
        if (!addGlobalAttributes) {
          return;
        }
        const globalAttributes = addGlobalAttributes();
        globalAttributes.forEach((globalAttribute) => {
          globalAttribute.types.forEach((type2) => {
            Object.entries(globalAttribute.attributes).forEach(([name, attribute]) => {
              extensionAttributes.push({
                type: type2,
                name,
                attribute: {
                  ...defaultAttribute,
                  ...attribute
                }
              });
            });
          });
        });
      });
      nodeAndMarkExtensions.forEach((extension) => {
        const context = {
          name: extension.name,
          options: extension.options,
          storage: extension.storage
        };
        const addAttributes = getExtensionField(
          extension,
          "addAttributes",
          context
        );
        if (!addAttributes) {
          return;
        }
        const attributes = addAttributes();
        Object.entries(attributes).forEach(([name, attribute]) => {
          const mergedAttr = {
            ...defaultAttribute,
            ...attribute
          };
          if (typeof (mergedAttr == null ? void 0 : mergedAttr.default) === "function") {
            mergedAttr.default = mergedAttr.default();
          }
          if ((mergedAttr == null ? void 0 : mergedAttr.isRequired) && (mergedAttr == null ? void 0 : mergedAttr.default) === void 0) {
            delete mergedAttr.default;
          }
          extensionAttributes.push({
            type: extension.name,
            name,
            attribute: mergedAttr
          });
        });
      });
      return extensionAttributes;
    }
    function mergeAttributes(...objects) {
      return objects.filter((item) => !!item).reduce((items, item) => {
        const mergedAttributes = { ...items };
        Object.entries(item).forEach(([key, value]) => {
          const exists = mergedAttributes[key];
          if (!exists) {
            mergedAttributes[key] = value;
            return;
          }
          if (key === "class") {
            const valueClasses = value ? String(value).split(" ") : [];
            const existingClasses = mergedAttributes[key] ? mergedAttributes[key].split(" ") : [];
            const insertClasses = valueClasses.filter((valueClass) => !existingClasses.includes(valueClass));
            mergedAttributes[key] = [...existingClasses, ...insertClasses].join(" ");
          } else if (key === "style") {
            const newStyles = value ? value.split(";").map((style2) => style2.trim()).filter(Boolean) : [];
            const existingStyles = mergedAttributes[key] ? mergedAttributes[key].split(";").map((style2) => style2.trim()).filter(Boolean) : [];
            const styleMap = /* @__PURE__ */ new Map();
            existingStyles.forEach((style2) => {
              const [property, val] = style2.split(":").map((part) => part.trim());
              styleMap.set(property, val);
            });
            newStyles.forEach((style2) => {
              const [property, val] = style2.split(":").map((part) => part.trim());
              styleMap.set(property, val);
            });
            mergedAttributes[key] = Array.from(styleMap.entries()).map(([property, val]) => `${property}: ${val}`).join("; ");
          } else {
            mergedAttributes[key] = value;
          }
        });
        return mergedAttributes;
      }, {});
    }
    function getRenderedAttributes(nodeOrMark, extensionAttributes) {
      return extensionAttributes.filter((attribute) => attribute.type === nodeOrMark.type.name).filter((item) => item.attribute.rendered).map((item) => {
        if (!item.attribute.renderHTML) {
          return {
            [item.name]: nodeOrMark.attrs[item.name]
          };
        }
        return item.attribute.renderHTML(nodeOrMark.attrs) || {};
      }).reduce((attributes, attribute) => mergeAttributes(attributes, attribute), {});
    }
    function fromString(value) {
      if (typeof value !== "string") {
        return value;
      }
      if (value.match(/^[+-]?(?:\d*\.)?\d+$/)) {
        return Number(value);
      }
      if (value === "true") {
        return true;
      }
      if (value === "false") {
        return false;
      }
      return value;
    }
    function injectExtensionAttributesToParseRule(parseRule, extensionAttributes) {
      if ("style" in parseRule) {
        return parseRule;
      }
      return {
        ...parseRule,
        getAttrs: (node) => {
          const oldAttributes = parseRule.getAttrs ? parseRule.getAttrs(node) : parseRule.attrs;
          if (oldAttributes === false) {
            return false;
          }
          const newAttributes = extensionAttributes.reduce((items, item) => {
            const value = item.attribute.parseHTML ? item.attribute.parseHTML(node) : fromString(node.getAttribute(item.name));
            if (value === null || value === void 0) {
              return items;
            }
            return {
              ...items,
              [item.name]: value
            };
          }, {});
          return { ...oldAttributes, ...newAttributes };
        }
      };
    }
    function cleanUpSchemaItem(data) {
      return Object.fromEntries(
        // @ts-ignore
        Object.entries(data).filter(([key, value]) => {
          if (key === "attrs" && isEmptyObject(value)) {
            return false;
          }
          return value !== null && value !== void 0;
        })
      );
    }
    function buildAttributeSpec(extensionAttribute) {
      var _a, _b;
      const spec = {};
      if (!((_a = extensionAttribute == null ? void 0 : extensionAttribute.attribute) == null ? void 0 : _a.isRequired) && "default" in ((extensionAttribute == null ? void 0 : extensionAttribute.attribute) || {})) {
        spec.default = extensionAttribute.attribute.default;
      }
      if (((_b = extensionAttribute == null ? void 0 : extensionAttribute.attribute) == null ? void 0 : _b.validate) !== void 0) {
        spec.validate = extensionAttribute.attribute.validate;
      }
      return [extensionAttribute.name, spec];
    }
    function getSchemaByResolvedExtensions(extensions2, editor) {
      var _a;
      const allAttributes = getAttributesFromExtensions(extensions2);
      const { nodeExtensions, markExtensions } = splitExtensions(extensions2);
      const topNode = (_a = nodeExtensions.find((extension) => getExtensionField(extension, "topNode"))) == null ? void 0 : _a.name;
      const nodes = Object.fromEntries(
        nodeExtensions.map((extension) => {
          const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);
          const context = {
            name: extension.name,
            options: extension.options,
            storage: extension.storage,
            editor
          };
          const extraNodeFields = extensions2.reduce((fields, e) => {
            const extendNodeSchema = getExtensionField(e, "extendNodeSchema", context);
            return {
              ...fields,
              ...extendNodeSchema ? extendNodeSchema(extension) : {}
            };
          }, {});
          const schema = cleanUpSchemaItem({
            ...extraNodeFields,
            content: callOrReturn(getExtensionField(extension, "content", context)),
            marks: callOrReturn(getExtensionField(extension, "marks", context)),
            group: callOrReturn(getExtensionField(extension, "group", context)),
            inline: callOrReturn(getExtensionField(extension, "inline", context)),
            atom: callOrReturn(getExtensionField(extension, "atom", context)),
            selectable: callOrReturn(getExtensionField(extension, "selectable", context)),
            draggable: callOrReturn(getExtensionField(extension, "draggable", context)),
            code: callOrReturn(getExtensionField(extension, "code", context)),
            whitespace: callOrReturn(getExtensionField(extension, "whitespace", context)),
            linebreakReplacement: callOrReturn(
              getExtensionField(extension, "linebreakReplacement", context)
            ),
            defining: callOrReturn(getExtensionField(extension, "defining", context)),
            isolating: callOrReturn(getExtensionField(extension, "isolating", context)),
            attrs: Object.fromEntries(extensionAttributes.map(buildAttributeSpec))
          });
          const parseHTML = callOrReturn(getExtensionField(extension, "parseHTML", context));
          if (parseHTML) {
            schema.parseDOM = parseHTML.map(
              (parseRule) => injectExtensionAttributesToParseRule(parseRule, extensionAttributes)
            );
          }
          const renderHTML = getExtensionField(extension, "renderHTML", context);
          if (renderHTML) {
            schema.toDOM = (node) => renderHTML({
              node,
              HTMLAttributes: getRenderedAttributes(node, extensionAttributes)
            });
          }
          const renderText = getExtensionField(extension, "renderText", context);
          if (renderText) {
            schema.toText = renderText;
          }
          return [extension.name, schema];
        })
      );
      const marks = Object.fromEntries(
        markExtensions.map((extension) => {
          const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);
          const context = {
            name: extension.name,
            options: extension.options,
            storage: extension.storage,
            editor
          };
          const extraMarkFields = extensions2.reduce((fields, e) => {
            const extendMarkSchema = getExtensionField(e, "extendMarkSchema", context);
            return {
              ...fields,
              ...extendMarkSchema ? extendMarkSchema(extension) : {}
            };
          }, {});
          const schema = cleanUpSchemaItem({
            ...extraMarkFields,
            inclusive: callOrReturn(getExtensionField(extension, "inclusive", context)),
            excludes: callOrReturn(getExtensionField(extension, "excludes", context)),
            group: callOrReturn(getExtensionField(extension, "group", context)),
            spanning: callOrReturn(getExtensionField(extension, "spanning", context)),
            code: callOrReturn(getExtensionField(extension, "code", context)),
            attrs: Object.fromEntries(extensionAttributes.map(buildAttributeSpec))
          });
          const parseHTML = callOrReturn(getExtensionField(extension, "parseHTML", context));
          if (parseHTML) {
            schema.parseDOM = parseHTML.map(
              (parseRule) => injectExtensionAttributesToParseRule(parseRule, extensionAttributes)
            );
          }
          const renderHTML = getExtensionField(extension, "renderHTML", context);
          if (renderHTML) {
            schema.toDOM = (mark) => renderHTML({
              mark,
              HTMLAttributes: getRenderedAttributes(mark, extensionAttributes)
            });
          }
          return [extension.name, schema];
        })
      );
      return new import_model4.Schema({
        topNode,
        nodes,
        marks
      });
    }
    function findDuplicates(items) {
      const filtered = items.filter((el, index) => items.indexOf(el) !== index);
      return Array.from(new Set(filtered));
    }
    function sortExtensions(extensions2) {
      const defaultPriority = 100;
      return extensions2.sort((a, b) => {
        const priorityA = getExtensionField(a, "priority") || defaultPriority;
        const priorityB = getExtensionField(b, "priority") || defaultPriority;
        if (priorityA > priorityB) {
          return -1;
        }
        if (priorityA < priorityB) {
          return 1;
        }
        return 0;
      });
    }
    function resolveExtensions(extensions2) {
      const resolvedExtensions = sortExtensions(flattenExtensions(extensions2));
      const duplicatedNames = findDuplicates(resolvedExtensions.map((extension) => extension.name));
      if (duplicatedNames.length) {
        console.warn(
          `[tiptap warn]: Duplicate extension names found: [${duplicatedNames.map((item) => `'${item}'`).join(", ")}]. This can lead to issues.`
        );
      }
      return resolvedExtensions;
    }
    function getSchema(extensions2, editor) {
      const resolvedExtensions = resolveExtensions(extensions2);
      return getSchemaByResolvedExtensions(resolvedExtensions, editor);
    }
    function generateHTML(doc, extensions2) {
      const schema = getSchema(extensions2);
      const contentNode = import_model5.Node.fromJSON(schema, doc);
      return getHTMLFromFragment(contentNode.content, schema);
    }
    var import_model6 = require_model();
    function generateJSON(html, extensions2) {
      const schema = getSchema(extensions2);
      const dom = elementFromString(html);
      return import_model6.DOMParser.fromSchema(schema).parse(dom).toJSON();
    }
    var import_model7 = require_model();
    function getTextBetween(startNode, range2, options) {
      const { from, to } = range2;
      const { blockSeparator = "\n\n", textSerializers = {} } = options || {};
      let text = "";
      startNode.nodesBetween(from, to, (node, pos, parent, index) => {
        var _a;
        if (node.isBlock && pos > from) {
          text += blockSeparator;
        }
        const textSerializer = textSerializers == null ? void 0 : textSerializers[node.type.name];
        if (textSerializer) {
          if (parent) {
            text += textSerializer({
              node,
              pos,
              parent,
              index,
              range: range2
            });
          }
          return false;
        }
        if (node.isText) {
          text += (_a = node == null ? void 0 : node.text) == null ? void 0 : _a.slice(Math.max(from, pos) - pos, to - pos);
        }
      });
      return text;
    }
    function getText(node, options) {
      const range2 = {
        from: 0,
        to: node.content.size
      };
      return getTextBetween(node, range2, options);
    }
    function getTextSerializersFromSchema(schema) {
      return Object.fromEntries(
        Object.entries(schema.nodes).filter(([, node]) => node.spec.toText).map(([name, node]) => [name, node.spec.toText])
      );
    }
    function generateText(doc, extensions2, options) {
      const { blockSeparator = "\n\n", textSerializers = {} } = options || {};
      const schema = getSchema(extensions2);
      const contentNode = import_model7.Node.fromJSON(schema, doc);
      return getText(contentNode, {
        blockSeparator,
        textSerializers: {
          ...getTextSerializersFromSchema(schema),
          ...textSerializers
        }
      });
    }
    function getNodeAttributes(state2, typeOrName) {
      const type2 = getNodeType(typeOrName, state2.schema);
      const { from, to } = state2.selection;
      const nodes = [];
      state2.doc.nodesBetween(from, to, (node2) => {
        nodes.push(node2);
      });
      const node = nodes.reverse().find((nodeItem) => nodeItem.type.name === type2.name);
      if (!node) {
        return {};
      }
      return { ...node.attrs };
    }
    function getAttributes(state2, typeOrName) {
      const schemaType = getSchemaTypeNameByName(
        typeof typeOrName === "string" ? typeOrName : typeOrName.name,
        state2.schema
      );
      if (schemaType === "node") {
        return getNodeAttributes(state2, typeOrName);
      }
      if (schemaType === "mark") {
        return getMarkAttributes(state2, typeOrName);
      }
      return {};
    }
    function removeDuplicates(array, by = JSON.stringify) {
      const seen = {};
      return array.filter((item) => {
        const key = by(item);
        return Object.prototype.hasOwnProperty.call(seen, key) ? false : seen[key] = true;
      });
    }
    function simplifyChangedRanges(changes) {
      const uniqueChanges = removeDuplicates(changes);
      return uniqueChanges.length === 1 ? uniqueChanges : uniqueChanges.filter((change, index) => {
        const rest = uniqueChanges.filter((_, i) => i !== index);
        return !rest.some((otherChange) => {
          return change.oldRange.from >= otherChange.oldRange.from && change.oldRange.to <= otherChange.oldRange.to && change.newRange.from >= otherChange.newRange.from && change.newRange.to <= otherChange.newRange.to;
        });
      });
    }
    function getChangedRanges(transform) {
      const { mapping, steps } = transform;
      const changes = [];
      mapping.maps.forEach((stepMap, index) => {
        const ranges = [];
        if (!stepMap.ranges.length) {
          const { from, to } = steps[index];
          if (from === void 0 || to === void 0) {
            return;
          }
          ranges.push({ from, to });
        } else {
          stepMap.forEach((from, to) => {
            ranges.push({ from, to });
          });
        }
        ranges.forEach(({ from, to }) => {
          const newStart = mapping.slice(index).map(from, -1);
          const newEnd = mapping.slice(index).map(to);
          const oldStart = mapping.invert().map(newStart, -1);
          const oldEnd = mapping.invert().map(newEnd);
          changes.push({
            oldRange: {
              from: oldStart,
              to: oldEnd
            },
            newRange: {
              from: newStart,
              to: newEnd
            }
          });
        });
      });
      return simplifyChangedRanges(changes);
    }
    function getDebugJSON(node, startOffset = 0) {
      const isTopNode = node.type === node.type.schema.topNodeType;
      const increment = isTopNode ? 0 : 1;
      const from = startOffset;
      const to = from + node.nodeSize;
      const marks = node.marks.map((mark) => {
        const output2 = {
          type: mark.type.name
        };
        if (Object.keys(mark.attrs).length) {
          output2.attrs = { ...mark.attrs };
        }
        return output2;
      });
      const attrs = { ...node.attrs };
      const output = {
        type: node.type.name,
        from,
        to
      };
      if (Object.keys(attrs).length) {
        output.attrs = attrs;
      }
      if (marks.length) {
        output.marks = marks;
      }
      if (node.content.childCount) {
        output.content = [];
        node.forEach((child, offset) => {
          var _a;
          (_a = output.content) == null ? void 0 : _a.push(getDebugJSON(child, startOffset + offset + increment));
        });
      }
      if (node.text) {
        output.text = node.text;
      }
      return output;
    }
    function getMarksBetween(from, to, doc) {
      const marks = [];
      if (from === to) {
        doc.resolve(from).marks().forEach((mark) => {
          const $pos = doc.resolve(from);
          const range2 = getMarkRange($pos, mark.type);
          if (!range2) {
            return;
          }
          marks.push({
            mark,
            ...range2
          });
        });
      } else {
        doc.nodesBetween(from, to, (node, pos) => {
          if (!node || (node == null ? void 0 : node.nodeSize) === void 0) {
            return;
          }
          marks.push(
            ...node.marks.map((mark) => ({
              from: pos,
              to: pos + node.nodeSize,
              mark
            }))
          );
        });
      }
      return marks;
    }
    var getNodeAtPosition = (state2, typeOrName, pos, maxDepth = 20) => {
      const $pos = state2.doc.resolve(pos);
      let currentDepth = maxDepth;
      let node = null;
      while (currentDepth > 0 && node === null) {
        const currentNode = $pos.node(currentDepth);
        if ((currentNode == null ? void 0 : currentNode.type.name) === typeOrName) {
          node = currentNode;
        } else {
          currentDepth -= 1;
        }
      }
      return [node, currentDepth];
    };
    function getSchemaTypeByName(name, schema) {
      return schema.nodes[name] || schema.marks[name] || null;
    }
    function getSplittedAttributes(extensionAttributes, typeName, attributes) {
      return Object.fromEntries(
        Object.entries(attributes).filter(([name]) => {
          const extensionAttribute = extensionAttributes.find((item) => {
            return item.type === typeName && item.name === name;
          });
          if (!extensionAttribute) {
            return false;
          }
          return extensionAttribute.attribute.keepOnSplit;
        })
      );
    }
    var getTextContentFromNodes = ($from, maxMatch = 500) => {
      let textBefore = "";
      const sliceEndPos = $from.parentOffset;
      $from.parent.nodesBetween(Math.max(0, sliceEndPos - maxMatch), sliceEndPos, (node, pos, parent, index) => {
        var _a, _b;
        const chunk = ((_b = (_a = node.type.spec).toText) == null ? void 0 : _b.call(_a, {
          node,
          pos,
          parent,
          index
        })) || node.textContent || "%leaf%";
        textBefore += node.isAtom && !node.isText ? chunk : chunk.slice(0, Math.max(0, sliceEndPos - pos));
      });
      return textBefore;
    };
    function isMarkActive(state2, typeOrName, attributes = {}) {
      const { empty, ranges } = state2.selection;
      const type2 = typeOrName ? getMarkType(typeOrName, state2.schema) : null;
      if (empty) {
        return !!(state2.storedMarks || state2.selection.$from.marks()).filter((mark) => {
          if (!type2) {
            return true;
          }
          return type2.name === mark.type.name;
        }).find((mark) => objectIncludes(mark.attrs, attributes, { strict: false }));
      }
      let selectionRange = 0;
      const markRanges = [];
      ranges.forEach(({ $from, $to }) => {
        const from = $from.pos;
        const to = $to.pos;
        state2.doc.nodesBetween(from, to, (node, pos) => {
          if (!node.isText && !node.marks.length) {
            return;
          }
          const relativeFrom = Math.max(from, pos);
          const relativeTo = Math.min(to, pos + node.nodeSize);
          const range22 = relativeTo - relativeFrom;
          selectionRange += range22;
          markRanges.push(
            ...node.marks.map((mark) => ({
              mark,
              from: relativeFrom,
              to: relativeTo
            }))
          );
        });
      });
      if (selectionRange === 0) {
        return false;
      }
      const matchedRange = markRanges.filter((markRange) => {
        if (!type2) {
          return true;
        }
        return type2.name === markRange.mark.type.name;
      }).filter((markRange) => objectIncludes(markRange.mark.attrs, attributes, { strict: false })).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
      const excludedRange = markRanges.filter((markRange) => {
        if (!type2) {
          return true;
        }
        return markRange.mark.type !== type2 && markRange.mark.type.excludes(type2);
      }).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
      const range2 = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;
      return range2 >= selectionRange;
    }
    function isActive(state2, name, attributes = {}) {
      if (!name) {
        return isNodeActive(state2, null, attributes) || isMarkActive(state2, null, attributes);
      }
      const schemaType = getSchemaTypeNameByName(name, state2.schema);
      if (schemaType === "node") {
        return isNodeActive(state2, name, attributes);
      }
      if (schemaType === "mark") {
        return isMarkActive(state2, name, attributes);
      }
      return false;
    }
    var isAtEndOfNode = (state2, nodeType) => {
      const { $from, $to, $anchor } = state2.selection;
      if (nodeType) {
        const parentNode = findParentNode((node) => node.type.name === nodeType)(state2.selection);
        if (!parentNode) {
          return false;
        }
        const $parentPos = state2.doc.resolve(parentNode.pos + 1);
        if ($anchor.pos + 1 === $parentPos.end()) {
          return true;
        }
        return false;
      }
      if ($to.parentOffset < $to.parent.nodeSize - 2 || $from.pos !== $to.pos) {
        return false;
      }
      return true;
    };
    var isAtStartOfNode = (state2) => {
      const { $from, $to } = state2.selection;
      if ($from.parentOffset > 0 || $from.pos !== $to.pos) {
        return false;
      }
      return true;
    };
    function isExtensionRulesEnabled(extension, enabled) {
      if (Array.isArray(enabled)) {
        return enabled.some((enabledExtension) => {
          const name = typeof enabledExtension === "string" ? enabledExtension : enabledExtension.name;
          return name === extension.name;
        });
      }
      return enabled;
    }
    function isList(name, extensions2) {
      const { nodeExtensions } = splitExtensions(extensions2);
      const extension = nodeExtensions.find((item) => item.name === name);
      if (!extension) {
        return false;
      }
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage
      };
      const group = callOrReturn(getExtensionField(extension, "group", context));
      if (typeof group !== "string") {
        return false;
      }
      return group.split(" ").includes("list");
    }
    function isNodeEmpty(node, {
      checkChildren = true,
      ignoreWhitespace = false
    } = {}) {
      var _a;
      if (ignoreWhitespace) {
        if (node.type.name === "hardBreak") {
          return true;
        }
        if (node.isText) {
          return /^\s*$/m.test((_a = node.text) != null ? _a : "");
        }
      }
      if (node.isText) {
        return !node.text;
      }
      if (node.isAtom || node.isLeaf) {
        return false;
      }
      if (node.content.childCount === 0) {
        return true;
      }
      if (checkChildren) {
        let isContentEmpty = true;
        node.content.forEach((childNode) => {
          if (isContentEmpty === false) {
            return;
          }
          if (!isNodeEmpty(childNode, { ignoreWhitespace, checkChildren })) {
            isContentEmpty = false;
          }
        });
        return isContentEmpty;
      }
      return false;
    }
    var import_state7 = require_state();
    function isNodeSelection(value) {
      return value instanceof import_state7.NodeSelection;
    }
    function posToDOMRect(view, from, to) {
      const minPos = 0;
      const maxPos = view.state.doc.content.size;
      const resolvedFrom = minMax(from, minPos, maxPos);
      const resolvedEnd = minMax(to, minPos, maxPos);
      const start = view.coordsAtPos(resolvedFrom);
      const end = view.coordsAtPos(resolvedEnd, -1);
      const top = Math.min(start.top, end.top);
      const bottom = Math.max(start.bottom, end.bottom);
      const left = Math.min(start.left, end.left);
      const right = Math.max(start.right, end.right);
      const width = right - left;
      const height = bottom - top;
      const x = left;
      const y = top;
      const data = {
        top,
        bottom,
        left,
        right,
        width,
        height,
        x,
        y
      };
      return {
        ...data,
        toJSON: () => data
      };
    }
    function rewriteUnknownContentInner({
      json,
      validMarks,
      validNodes,
      options,
      rewrittenContent = []
    }) {
      if (json.marks && Array.isArray(json.marks)) {
        json.marks = json.marks.filter((mark) => {
          const name = typeof mark === "string" ? mark : mark.type;
          if (validMarks.has(name)) {
            return true;
          }
          rewrittenContent.push({
            original: JSON.parse(JSON.stringify(mark)),
            unsupported: name
          });
          return false;
        });
      }
      if (json.content && Array.isArray(json.content)) {
        json.content = json.content.map(
          (value) => rewriteUnknownContentInner({
            json: value,
            validMarks,
            validNodes,
            options,
            rewrittenContent
          }).json
        ).filter((a) => a !== null && a !== void 0);
      }
      if (json.type && !validNodes.has(json.type)) {
        rewrittenContent.push({
          original: JSON.parse(JSON.stringify(json)),
          unsupported: json.type
        });
        if (json.content && Array.isArray(json.content) && (options == null ? void 0 : options.fallbackToParagraph) !== false) {
          json.type = "paragraph";
          return {
            json,
            rewrittenContent
          };
        }
        return {
          json: null,
          rewrittenContent
        };
      }
      return { json, rewrittenContent };
    }
    function rewriteUnknownContent(json, schema, options) {
      return rewriteUnknownContentInner({
        json,
        validNodes: new Set(Object.keys(schema.nodes)),
        validMarks: new Set(Object.keys(schema.marks)),
        options
      });
    }
    function canSetMark(state2, tr, newMarkType) {
      var _a;
      const { selection } = tr;
      let cursor = null;
      if (isTextSelection(selection)) {
        cursor = selection.$cursor;
      }
      if (cursor) {
        const currentMarks = (_a = state2.storedMarks) != null ? _a : cursor.marks();
        const parentAllowsMarkType = cursor.parent.type.allowsMarkType(newMarkType);
        return parentAllowsMarkType && (!!newMarkType.isInSet(currentMarks) || !currentMarks.some((mark) => mark.type.excludes(newMarkType)));
      }
      const { ranges } = selection;
      return ranges.some(({ $from, $to }) => {
        let someNodeSupportsMark = $from.depth === 0 ? state2.doc.inlineContent && state2.doc.type.allowsMarkType(newMarkType) : false;
        state2.doc.nodesBetween($from.pos, $to.pos, (node, _pos, parent) => {
          if (someNodeSupportsMark) {
            return false;
          }
          if (node.isInline) {
            const parentAllowsMarkType = !parent || parent.type.allowsMarkType(newMarkType);
            const currentMarksAllowMarkType = !!newMarkType.isInSet(node.marks) || !node.marks.some((otherMark) => otherMark.type.excludes(newMarkType));
            someNodeSupportsMark = parentAllowsMarkType && currentMarksAllowMarkType;
          }
          return !someNodeSupportsMark;
        });
        return someNodeSupportsMark;
      });
    }
    var setMark = (typeOrName, attributes = {}) => ({ tr, state: state2, dispatch }) => {
      const { selection } = tr;
      const { empty, ranges } = selection;
      const type2 = getMarkType(typeOrName, state2.schema);
      if (dispatch) {
        if (empty) {
          const oldAttributes = getMarkAttributes(state2, type2);
          tr.addStoredMark(
            type2.create({
              ...oldAttributes,
              ...attributes
            })
          );
        } else {
          ranges.forEach((range2) => {
            const from = range2.$from.pos;
            const to = range2.$to.pos;
            state2.doc.nodesBetween(from, to, (node, pos) => {
              const trimmedFrom = Math.max(pos, from);
              const trimmedTo = Math.min(pos + node.nodeSize, to);
              const someHasMark = node.marks.find((mark) => mark.type === type2);
              if (someHasMark) {
                node.marks.forEach((mark) => {
                  if (type2 === mark.type) {
                    tr.addMark(
                      trimmedFrom,
                      trimmedTo,
                      type2.create({
                        ...mark.attrs,
                        ...attributes
                      })
                    );
                  }
                });
              } else {
                tr.addMark(trimmedFrom, trimmedTo, type2.create(attributes));
              }
            });
          });
        }
      }
      return canSetMark(state2, tr, type2);
    };
    var setMeta = (key, value) => ({ tr }) => {
      tr.setMeta(key, value);
      return true;
    };
    var import_commands15 = require_commands();
    var setNode = (typeOrName, attributes = {}) => ({ state: state2, dispatch, chain }) => {
      const type2 = getNodeType(typeOrName, state2.schema);
      let attributesToCopy;
      if (state2.selection.$anchor.sameParent(state2.selection.$head)) {
        attributesToCopy = state2.selection.$anchor.parent.attrs;
      }
      if (!type2.isTextblock) {
        console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.');
        return false;
      }
      return chain().command(({ commands: commands2 }) => {
        const canSetBlock = (0, import_commands15.setBlockType)(type2, { ...attributesToCopy, ...attributes })(state2);
        if (canSetBlock) {
          return true;
        }
        return commands2.clearNodes();
      }).command(({ state: updatedState }) => {
        return (0, import_commands15.setBlockType)(type2, { ...attributesToCopy, ...attributes })(updatedState, dispatch);
      }).run();
    };
    var import_state8 = require_state();
    var setNodeSelection = (position) => ({ tr, dispatch }) => {
      if (dispatch) {
        const { doc } = tr;
        const from = minMax(position, 0, doc.content.size);
        const selection = import_state8.NodeSelection.create(doc, from);
        tr.setSelection(selection);
      }
      return true;
    };
    var setTextDirection = (direction, position) => ({ tr, state: state2, dispatch }) => {
      const { selection } = state2;
      let from;
      let to;
      if (typeof position === "number") {
        from = position;
        to = position;
      } else if (position && "from" in position && "to" in position) {
        from = position.from;
        to = position.to;
      } else {
        from = selection.from;
        to = selection.to;
      }
      if (dispatch) {
        tr.doc.nodesBetween(from, to, (node, pos) => {
          if (node.isText) {
            return;
          }
          tr.setNodeMarkup(pos, void 0, {
            ...node.attrs,
            dir: direction
          });
        });
      }
      return true;
    };
    var import_state9 = require_state();
    var setTextSelection = (position) => ({ tr, dispatch }) => {
      if (dispatch) {
        const { doc } = tr;
        const { from, to } = typeof position === "number" ? { from: position, to: position } : position;
        const minPos = import_state9.TextSelection.atStart(doc).from;
        const maxPos = import_state9.TextSelection.atEnd(doc).to;
        const resolvedFrom = minMax(from, minPos, maxPos);
        const resolvedEnd = minMax(to, minPos, maxPos);
        const selection = import_state9.TextSelection.create(doc, resolvedFrom, resolvedEnd);
        tr.setSelection(selection);
      }
      return true;
    };
    var import_schema_list2 = require_schema_list();
    var sinkListItem = (typeOrName) => ({ state: state2, dispatch }) => {
      const type2 = getNodeType(typeOrName, state2.schema);
      return (0, import_schema_list2.sinkListItem)(type2)(state2, dispatch);
    };
    var import_state10 = require_state();
    var import_transform6 = require_transform();
    function ensureMarks(state2, splittableMarks) {
      const marks = state2.storedMarks || state2.selection.$to.parentOffset && state2.selection.$from.marks();
      if (marks) {
        const filteredMarks = marks.filter((mark) => splittableMarks == null ? void 0 : splittableMarks.includes(mark.type.name));
        state2.tr.ensureMarks(filteredMarks);
      }
    }
    var splitBlock = ({ keepMarks = true } = {}) => ({ tr, state: state2, dispatch, editor }) => {
      const { selection, doc } = tr;
      const { $from, $to } = selection;
      const extensionAttributes = editor.extensionManager.attributes;
      const newAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
      if (selection instanceof import_state10.NodeSelection && selection.node.isBlock) {
        if (!$from.parentOffset || !(0, import_transform6.canSplit)(doc, $from.pos)) {
          return false;
        }
        if (dispatch) {
          if (keepMarks) {
            ensureMarks(state2, editor.extensionManager.splittableMarks);
          }
          tr.split($from.pos).scrollIntoView();
        }
        return true;
      }
      if (!$from.parent.isBlock) {
        return false;
      }
      const atEnd = $to.parentOffset === $to.parent.content.size;
      const deflt = $from.depth === 0 ? void 0 : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));
      let types2 = atEnd && deflt ? [
        {
          type: deflt,
          attrs: newAttributes
        }
      ] : void 0;
      let can = (0, import_transform6.canSplit)(tr.doc, tr.mapping.map($from.pos), 1, types2);
      if (!types2 && !can && (0, import_transform6.canSplit)(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : void 0)) {
        can = true;
        types2 = deflt ? [
          {
            type: deflt,
            attrs: newAttributes
          }
        ] : void 0;
      }
      if (dispatch) {
        if (can) {
          if (selection instanceof import_state10.TextSelection) {
            tr.deleteSelection();
          }
          tr.split(tr.mapping.map($from.pos), 1, types2);
          if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {
            const first2 = tr.mapping.map($from.before());
            const $first = tr.doc.resolve(first2);
            if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {
              tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);
            }
          }
        }
        if (keepMarks) {
          ensureMarks(state2, editor.extensionManager.splittableMarks);
        }
        tr.scrollIntoView();
      }
      return can;
    };
    var import_model8 = require_model();
    var import_state11 = require_state();
    var import_transform7 = require_transform();
    var splitListItem = (typeOrName, overrideAttrs = {}) => ({ tr, state: state2, dispatch, editor }) => {
      var _a;
      const type2 = getNodeType(typeOrName, state2.schema);
      const { $from, $to } = state2.selection;
      const node = state2.selection.node;
      if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) {
        return false;
      }
      const grandParent = $from.node(-1);
      if (grandParent.type !== type2) {
        return false;
      }
      const extensionAttributes = editor.extensionManager.attributes;
      if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {
        if ($from.depth === 2 || $from.node(-3).type !== type2 || $from.index(-2) !== $from.node(-2).childCount - 1) {
          return false;
        }
        if (dispatch) {
          let wrap = import_model8.Fragment.empty;
          const depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;
          for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d -= 1) {
            wrap = import_model8.Fragment.from($from.node(d).copy(wrap));
          }
          const depthAfter = (
            // eslint-disable-next-line no-nested-ternary
            $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3
          );
          const newNextTypeAttributes2 = {
            ...getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs),
            ...overrideAttrs
          };
          const nextType2 = ((_a = type2.contentMatch.defaultType) == null ? void 0 : _a.createAndFill(newNextTypeAttributes2)) || void 0;
          wrap = wrap.append(import_model8.Fragment.from(type2.createAndFill(null, nextType2) || void 0));
          const start = $from.before($from.depth - (depthBefore - 1));
          tr.replace(start, $from.after(-depthAfter), new import_model8.Slice(wrap, 4 - depthBefore, 0));
          let sel = -1;
          tr.doc.nodesBetween(start, tr.doc.content.size, (n, pos) => {
            if (sel > -1) {
              return false;
            }
            if (n.isTextblock && n.content.size === 0) {
              sel = pos + 1;
            }
          });
          if (sel > -1) {
            tr.setSelection(import_state11.TextSelection.near(tr.doc.resolve(sel)));
          }
          tr.scrollIntoView();
        }
        return true;
      }
      const nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;
      const newTypeAttributes = {
        ...getSplittedAttributes(extensionAttributes, grandParent.type.name, grandParent.attrs),
        ...overrideAttrs
      };
      const newNextTypeAttributes = {
        ...getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs),
        ...overrideAttrs
      };
      tr.delete($from.pos, $to.pos);
      const types2 = nextType ? [
        { type: type2, attrs: newTypeAttributes },
        { type: nextType, attrs: newNextTypeAttributes }
      ] : [{ type: type2, attrs: newTypeAttributes }];
      if (!(0, import_transform7.canSplit)(tr.doc, $from.pos, 2)) {
        return false;
      }
      if (dispatch) {
        const { selection, storedMarks } = state2;
        const { splittableMarks } = editor.extensionManager;
        const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
        tr.split($from.pos, 2, types2).scrollIntoView();
        if (!marks || !dispatch) {
          return true;
        }
        const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
        tr.ensureMarks(filteredMarks);
      }
      return true;
    };
    var import_transform8 = require_transform();
    var joinListBackwards = (tr, listType) => {
      const list = findParentNode((node) => node.type === listType)(tr.selection);
      if (!list) {
        return true;
      }
      const before = tr.doc.resolve(Math.max(0, list.pos - 1)).before(list.depth);
      if (before === void 0) {
        return true;
      }
      const nodeBefore = tr.doc.nodeAt(before);
      const canJoinBackwards = list.node.type === (nodeBefore == null ? void 0 : nodeBefore.type) && (0, import_transform8.canJoin)(tr.doc, list.pos);
      if (!canJoinBackwards) {
        return true;
      }
      tr.join(list.pos);
      return true;
    };
    var joinListForwards = (tr, listType) => {
      const list = findParentNode((node) => node.type === listType)(tr.selection);
      if (!list) {
        return true;
      }
      const after = tr.doc.resolve(list.start).after(list.depth);
      if (after === void 0) {
        return true;
      }
      const nodeAfter = tr.doc.nodeAt(after);
      const canJoinForwards = list.node.type === (nodeAfter == null ? void 0 : nodeAfter.type) && (0, import_transform8.canJoin)(tr.doc, after);
      if (!canJoinForwards) {
        return true;
      }
      tr.join(after);
      return true;
    };
    var toggleList = (listTypeOrName, itemTypeOrName, keepMarks, attributes = {}) => ({ editor, tr, state: state2, dispatch, chain, commands: commands2, can }) => {
      const { extensions: extensions2, splittableMarks } = editor.extensionManager;
      const listType = getNodeType(listTypeOrName, state2.schema);
      const itemType = getNodeType(itemTypeOrName, state2.schema);
      const { selection, storedMarks } = state2;
      const { $from, $to } = selection;
      const range2 = $from.blockRange($to);
      const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
      if (!range2) {
        return false;
      }
      const parentList = findParentNode((node) => isList(node.type.name, extensions2))(selection);
      if (range2.depth >= 1 && parentList && range2.depth - parentList.depth <= 1) {
        if (parentList.node.type === listType) {
          return commands2.liftListItem(itemType);
        }
        if (isList(parentList.node.type.name, extensions2) && listType.validContent(parentList.node.content) && dispatch) {
          return chain().command(() => {
            tr.setNodeMarkup(parentList.pos, listType);
            return true;
          }).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();
        }
      }
      if (!keepMarks || !marks || !dispatch) {
        return chain().command(() => {
          const canWrapInList = can().wrapInList(listType, attributes);
          if (canWrapInList) {
            return true;
          }
          return commands2.clearNodes();
        }).wrapInList(listType, attributes).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();
      }
      return chain().command(() => {
        const canWrapInList = can().wrapInList(listType, attributes);
        const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
        tr.ensureMarks(filteredMarks);
        if (canWrapInList) {
          return true;
        }
        return commands2.clearNodes();
      }).wrapInList(listType, attributes).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();
    };
    var toggleMark = (typeOrName, attributes = {}, options = {}) => ({ state: state2, commands: commands2 }) => {
      const { extendEmptyMarkRange = false } = options;
      const type2 = getMarkType(typeOrName, state2.schema);
      const isActive2 = isMarkActive(state2, type2, attributes);
      if (isActive2) {
        return commands2.unsetMark(type2, { extendEmptyMarkRange });
      }
      return commands2.setMark(type2, attributes);
    };
    var toggleNode = (typeOrName, toggleTypeOrName, attributes = {}) => ({ state: state2, commands: commands2 }) => {
      const type2 = getNodeType(typeOrName, state2.schema);
      const toggleType = getNodeType(toggleTypeOrName, state2.schema);
      const isActive2 = isNodeActive(state2, type2, attributes);
      let attributesToCopy;
      if (state2.selection.$anchor.sameParent(state2.selection.$head)) {
        attributesToCopy = state2.selection.$anchor.parent.attrs;
      }
      if (isActive2) {
        return commands2.setNode(toggleType, attributesToCopy);
      }
      return commands2.setNode(type2, { ...attributesToCopy, ...attributes });
    };
    var toggleWrap = (typeOrName, attributes = {}) => ({ state: state2, commands: commands2 }) => {
      const type2 = getNodeType(typeOrName, state2.schema);
      const isActive2 = isNodeActive(state2, type2, attributes);
      if (isActive2) {
        return commands2.lift(type2);
      }
      return commands2.wrapIn(type2, attributes);
    };
    var undoInputRule = () => ({ state: state2, dispatch }) => {
      const plugins = state2.plugins;
      for (let i = 0; i < plugins.length; i += 1) {
        const plugin = plugins[i];
        let undoable;
        if (plugin.spec.isInputRules && (undoable = plugin.getState(state2))) {
          if (dispatch) {
            const tr = state2.tr;
            const toUndo = undoable.transform;
            for (let j = toUndo.steps.length - 1; j >= 0; j -= 1) {
              tr.step(toUndo.steps[j].invert(toUndo.docs[j]));
            }
            if (undoable.text) {
              const marks = tr.doc.resolve(undoable.from).marks();
              tr.replaceWith(undoable.from, undoable.to, state2.schema.text(undoable.text, marks));
            } else {
              tr.delete(undoable.from, undoable.to);
            }
          }
          return true;
        }
      }
      return false;
    };
    var unsetAllMarks = () => ({ tr, dispatch }) => {
      const { selection } = tr;
      const { empty, ranges } = selection;
      if (empty) {
        return true;
      }
      if (dispatch) {
        ranges.forEach((range2) => {
          tr.removeMark(range2.$from.pos, range2.$to.pos);
        });
      }
      return true;
    };
    var unsetMark = (typeOrName, options = {}) => ({ tr, state: state2, dispatch }) => {
      var _a;
      const { extendEmptyMarkRange = false } = options;
      const { selection } = tr;
      const type2 = getMarkType(typeOrName, state2.schema);
      const { $from, empty, ranges } = selection;
      if (!dispatch) {
        return true;
      }
      if (empty && extendEmptyMarkRange) {
        let { from, to } = selection;
        const attrs = (_a = $from.marks().find((mark) => mark.type === type2)) == null ? void 0 : _a.attrs;
        const range2 = getMarkRange($from, type2, attrs);
        if (range2) {
          from = range2.from;
          to = range2.to;
        }
        tr.removeMark(from, to, type2);
      } else {
        ranges.forEach((range2) => {
          tr.removeMark(range2.$from.pos, range2.$to.pos, type2);
        });
      }
      tr.removeStoredMark(type2);
      return true;
    };
    var unsetTextDirection = (position) => ({ tr, state: state2, dispatch }) => {
      const { selection } = state2;
      let from;
      let to;
      if (typeof position === "number") {
        from = position;
        to = position;
      } else if (position && "from" in position && "to" in position) {
        from = position.from;
        to = position.to;
      } else {
        from = selection.from;
        to = selection.to;
      }
      if (dispatch) {
        tr.doc.nodesBetween(from, to, (node, pos) => {
          if (node.isText) {
            return;
          }
          const newAttrs = { ...node.attrs };
          delete newAttrs.dir;
          tr.setNodeMarkup(pos, void 0, newAttrs);
        });
      }
      return true;
    };
    var updateAttributes = (typeOrName, attributes = {}) => ({ tr, state: state2, dispatch }) => {
      let nodeType = null;
      let markType = null;
      const schemaType = getSchemaTypeNameByName(
        typeof typeOrName === "string" ? typeOrName : typeOrName.name,
        state2.schema
      );
      if (!schemaType) {
        return false;
      }
      if (schemaType === "node") {
        nodeType = getNodeType(typeOrName, state2.schema);
      }
      if (schemaType === "mark") {
        markType = getMarkType(typeOrName, state2.schema);
      }
      let canUpdate = false;
      tr.selection.ranges.forEach((range2) => {
        const from = range2.$from.pos;
        const to = range2.$to.pos;
        let lastPos;
        let lastNode;
        let trimmedFrom;
        let trimmedTo;
        if (tr.selection.empty) {
          state2.doc.nodesBetween(from, to, (node, pos) => {
            if (nodeType && nodeType === node.type) {
              canUpdate = true;
              trimmedFrom = Math.max(pos, from);
              trimmedTo = Math.min(pos + node.nodeSize, to);
              lastPos = pos;
              lastNode = node;
            }
          });
        } else {
          state2.doc.nodesBetween(from, to, (node, pos) => {
            if (pos < from && nodeType && nodeType === node.type) {
              canUpdate = true;
              trimmedFrom = Math.max(pos, from);
              trimmedTo = Math.min(pos + node.nodeSize, to);
              lastPos = pos;
              lastNode = node;
            }
            if (pos >= from && pos <= to) {
              if (nodeType && nodeType === node.type) {
                canUpdate = true;
                if (dispatch) {
                  tr.setNodeMarkup(pos, void 0, {
                    ...node.attrs,
                    ...attributes
                  });
                }
              }
              if (markType && node.marks.length) {
                node.marks.forEach((mark) => {
                  if (markType === mark.type) {
                    canUpdate = true;
                    if (dispatch) {
                      const trimmedFrom2 = Math.max(pos, from);
                      const trimmedTo2 = Math.min(pos + node.nodeSize, to);
                      tr.addMark(
                        trimmedFrom2,
                        trimmedTo2,
                        markType.create({
                          ...mark.attrs,
                          ...attributes
                        })
                      );
                    }
                  }
                });
              }
            }
          });
        }
        if (lastNode) {
          if (lastPos !== void 0 && dispatch) {
            tr.setNodeMarkup(lastPos, void 0, {
              ...lastNode.attrs,
              ...attributes
            });
          }
          if (markType && lastNode.marks.length) {
            lastNode.marks.forEach((mark) => {
              if (markType === mark.type && dispatch) {
                tr.addMark(
                  trimmedFrom,
                  trimmedTo,
                  markType.create({
                    ...mark.attrs,
                    ...attributes
                  })
                );
              }
            });
          }
        }
      });
      return canUpdate;
    };
    var import_commands16 = require_commands();
    var wrapIn = (typeOrName, attributes = {}) => ({ state: state2, dispatch }) => {
      const type2 = getNodeType(typeOrName, state2.schema);
      return (0, import_commands16.wrapIn)(type2, attributes)(state2, dispatch);
    };
    var import_schema_list3 = require_schema_list();
    var wrapInList = (typeOrName, attributes = {}) => ({ state: state2, dispatch }) => {
      const type2 = getNodeType(typeOrName, state2.schema);
      return (0, import_schema_list3.wrapInList)(type2, attributes)(state2, dispatch);
    };
    var import_state22 = require_state();
    var import_view = require_view();
    var EventEmitter = class {
      constructor() {
        this.callbacks = {};
      }
      on(event, fn) {
        if (!this.callbacks[event]) {
          this.callbacks[event] = [];
        }
        this.callbacks[event].push(fn);
        return this;
      }
      emit(event, ...args) {
        const callbacks = this.callbacks[event];
        if (callbacks) {
          callbacks.forEach((callback) => callback.apply(this, args));
        }
        return this;
      }
      off(event, fn) {
        const callbacks = this.callbacks[event];
        if (callbacks) {
          if (fn) {
            this.callbacks[event] = callbacks.filter((callback) => callback !== fn);
          } else {
            delete this.callbacks[event];
          }
        }
        return this;
      }
      once(event, fn) {
        const onceFn = (...args) => {
          this.off(event, onceFn);
          fn.apply(this, args);
        };
        return this.on(event, onceFn);
      }
      removeAllListeners() {
        this.callbacks = {};
      }
    };
    var import_keymap = require_keymap();
    var import_model9 = require_model();
    var import_state12 = require_state();
    var InputRule = class {
      constructor(config) {
        var _a;
        this.find = config.find;
        this.handler = config.handler;
        this.undoable = (_a = config.undoable) != null ? _a : true;
      }
    };
    var inputRuleMatcherHandler = (text, find) => {
      if (isRegExp(find)) {
        return find.exec(text);
      }
      const inputRuleMatch = find(text);
      if (!inputRuleMatch) {
        return null;
      }
      const result = [inputRuleMatch.text];
      result.index = inputRuleMatch.index;
      result.input = text;
      result.data = inputRuleMatch.data;
      if (inputRuleMatch.replaceWith) {
        if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {
          console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".');
        }
        result.push(inputRuleMatch.replaceWith);
      }
      return result;
    };
    function run(config) {
      var _a;
      const { editor, from, to, text, rules, plugin } = config;
      const { view } = editor;
      if (view.composing) {
        return false;
      }
      const $from = view.state.doc.resolve(from);
      if (
        // check for code node
        $from.parent.type.spec.code || // check for code mark
        !!((_a = $from.nodeBefore || $from.nodeAfter) == null ? void 0 : _a.marks.find((mark) => mark.type.spec.code))
      ) {
        return false;
      }
      let matched = false;
      const textBefore = getTextContentFromNodes($from) + text;
      rules.forEach((rule) => {
        if (matched) {
          return;
        }
        const match = inputRuleMatcherHandler(textBefore, rule.find);
        if (!match) {
          return;
        }
        const tr = view.state.tr;
        const state2 = createChainableState({
          state: view.state,
          transaction: tr
        });
        const range2 = {
          from: from - (match[0].length - text.length),
          to
        };
        const { commands: commands2, chain, can } = new CommandManager({
          editor,
          state: state2
        });
        const handler = rule.handler({
          state: state2,
          range: range2,
          match,
          commands: commands2,
          chain,
          can
        });
        if (handler === null || !tr.steps.length) {
          return;
        }
        if (rule.undoable) {
          tr.setMeta(plugin, {
            transform: tr,
            from,
            to,
            text
          });
        }
        view.dispatch(tr);
        matched = true;
      });
      return matched;
    }
    function inputRulesPlugin(props) {
      const { editor, rules } = props;
      const plugin = new import_state12.Plugin({
        state: {
          init() {
            return null;
          },
          apply(tr, prev, state2) {
            const stored = tr.getMeta(plugin);
            if (stored) {
              return stored;
            }
            const simulatedInputMeta = tr.getMeta("applyInputRules");
            const isSimulatedInput = !!simulatedInputMeta;
            if (isSimulatedInput) {
              setTimeout(() => {
                let { text } = simulatedInputMeta;
                if (typeof text === "string") {
                  text = text;
                } else {
                  text = getHTMLFromFragment(import_model9.Fragment.from(text), state2.schema);
                }
                const { from } = simulatedInputMeta;
                const to = from + text.length;
                run({
                  editor,
                  from,
                  to,
                  text,
                  rules,
                  plugin
                });
              });
            }
            return tr.selectionSet || tr.docChanged ? null : prev;
          }
        },
        props: {
          handleTextInput(view, from, to, text) {
            return run({
              editor,
              from,
              to,
              text,
              rules,
              plugin
            });
          },
          handleDOMEvents: {
            compositionend: (view) => {
              setTimeout(() => {
                const { $cursor } = view.state.selection;
                if ($cursor) {
                  run({
                    editor,
                    from: $cursor.pos,
                    to: $cursor.pos,
                    text: "",
                    rules,
                    plugin
                  });
                }
              });
              return false;
            }
          },
          // add support for input rules to trigger on enter
          // this is useful for example for code blocks
          handleKeyDown(view, event) {
            if (event.key !== "Enter") {
              return false;
            }
            const { $cursor } = view.state.selection;
            if ($cursor) {
              return run({
                editor,
                from: $cursor.pos,
                to: $cursor.pos,
                text: "\n",
                rules,
                plugin
              });
            }
            return false;
          }
        },
        // @ts-ignore
        isInputRules: true
      });
      return plugin;
    }
    function getType(value) {
      return Object.prototype.toString.call(value).slice(8, -1);
    }
    function isPlainObject(value) {
      if (getType(value) !== "Object") {
        return false;
      }
      return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype;
    }
    function mergeDeep(target, source) {
      const output = { ...target };
      if (isPlainObject(target) && isPlainObject(source)) {
        Object.keys(source).forEach((key) => {
          if (isPlainObject(source[key]) && isPlainObject(target[key])) {
            output[key] = mergeDeep(target[key], source[key]);
          } else {
            output[key] = source[key];
          }
        });
      }
      return output;
    }
    var Extendable = class {
      constructor(config = {}) {
        this.type = "extendable";
        this.parent = null;
        this.child = null;
        this.name = "";
        this.config = {
          name: this.name
        };
        this.config = {
          ...this.config,
          ...config
        };
        this.name = this.config.name;
      }
      get options() {
        return {
          ...callOrReturn(
            getExtensionField(this, "addOptions", {
              name: this.name
            })
          ) || {}
        };
      }
      get storage() {
        return {
          ...callOrReturn(
            getExtensionField(this, "addStorage", {
              name: this.name,
              options: this.options
            })
          ) || {}
        };
      }
      configure(options = {}) {
        const extension = this.extend({
          ...this.config,
          addOptions: () => {
            return mergeDeep(this.options, options);
          }
        });
        extension.name = this.name;
        extension.parent = this.parent;
        return extension;
      }
      extend(extendedConfig = {}) {
        const extension = new this.constructor({ ...this.config, ...extendedConfig });
        extension.parent = this;
        this.child = extension;
        extension.name = "name" in extendedConfig ? extendedConfig.name : extension.parent.name;
        return extension;
      }
    };
    var Mark = class _Mark extends Extendable {
      constructor() {
        super(...arguments);
        this.type = "mark";
      }
      /**
       * Create a new Mark instance
       * @param config - Mark configuration object or a function that returns a configuration object
       */
      static create(config = {}) {
        const resolvedConfig = typeof config === "function" ? config() : config;
        return new _Mark(resolvedConfig);
      }
      static handleExit({ editor, mark }) {
        const { tr } = editor.state;
        const currentPos = editor.state.selection.$from;
        const isAtEnd = currentPos.pos === currentPos.end();
        if (isAtEnd) {
          const currentMarks = currentPos.marks();
          const isInMark = !!currentMarks.find((m) => (m == null ? void 0 : m.type.name) === mark.name);
          if (!isInMark) {
            return false;
          }
          const removeMark = currentMarks.find((m) => (m == null ? void 0 : m.type.name) === mark.name);
          if (removeMark) {
            tr.removeStoredMark(removeMark);
          }
          tr.insertText(" ", currentPos.pos);
          editor.view.dispatch(tr);
          return true;
        }
        return false;
      }
      configure(options) {
        return super.configure(options);
      }
      extend(extendedConfig) {
        const resolvedConfig = typeof extendedConfig === "function" ? extendedConfig() : extendedConfig;
        return super.extend(resolvedConfig);
      }
    };
    var import_model10 = require_model();
    var import_state13 = require_state();
    function isNumber(value) {
      return typeof value === "number";
    }
    var PasteRule = class {
      constructor(config) {
        this.find = config.find;
        this.handler = config.handler;
      }
    };
    var pasteRuleMatcherHandler = (text, find, event) => {
      if (isRegExp(find)) {
        return [...text.matchAll(find)];
      }
      const matches = find(text, event);
      if (!matches) {
        return [];
      }
      return matches.map((pasteRuleMatch) => {
        const result = [pasteRuleMatch.text];
        result.index = pasteRuleMatch.index;
        result.input = text;
        result.data = pasteRuleMatch.data;
        if (pasteRuleMatch.replaceWith) {
          if (!pasteRuleMatch.text.includes(pasteRuleMatch.replaceWith)) {
            console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".');
          }
          result.push(pasteRuleMatch.replaceWith);
        }
        return result;
      });
    };
    function run2(config) {
      const { editor, state: state2, from, to, rule, pasteEvent, dropEvent } = config;
      const { commands: commands2, chain, can } = new CommandManager({
        editor,
        state: state2
      });
      const handlers = [];
      state2.doc.nodesBetween(from, to, (node, pos) => {
        var _a, _b, _c, _d, _e;
        if (((_b = (_a = node.type) == null ? void 0 : _a.spec) == null ? void 0 : _b.code) || !(node.isText || node.isTextblock || node.isInline)) {
          return;
        }
        const contentSize = (_e = (_d = (_c = node.content) == null ? void 0 : _c.size) != null ? _d : node.nodeSize) != null ? _e : 0;
        const resolvedFrom = Math.max(from, pos);
        const resolvedTo = Math.min(to, pos + contentSize);
        if (resolvedFrom >= resolvedTo) {
          return;
        }
        const textToMatch = node.isText ? node.text || "" : node.textBetween(resolvedFrom - pos, resolvedTo - pos, void 0, "\uFFFC");
        const matches = pasteRuleMatcherHandler(textToMatch, rule.find, pasteEvent);
        matches.forEach((match) => {
          if (match.index === void 0) {
            return;
          }
          const start = resolvedFrom + match.index + 1;
          const end = start + match[0].length;
          const range2 = {
            from: state2.tr.mapping.map(start),
            to: state2.tr.mapping.map(end)
          };
          const handler = rule.handler({
            state: state2,
            range: range2,
            match,
            commands: commands2,
            chain,
            can,
            pasteEvent,
            dropEvent
          });
          handlers.push(handler);
        });
      });
      const success = handlers.every((handler) => handler !== null);
      return success;
    }
    var tiptapDragFromOtherEditor = null;
    var createClipboardPasteEvent = (text) => {
      var _a;
      const event = new ClipboardEvent("paste", {
        clipboardData: new DataTransfer()
      });
      (_a = event.clipboardData) == null ? void 0 : _a.setData("text/html", text);
      return event;
    };
    function pasteRulesPlugin(props) {
      const { editor, rules } = props;
      let dragSourceElement = null;
      let isPastedFromProseMirror = false;
      let isDroppedFromProseMirror = false;
      let pasteEvent = typeof ClipboardEvent !== "undefined" ? new ClipboardEvent("paste") : null;
      let dropEvent;
      try {
        dropEvent = typeof DragEvent !== "undefined" ? new DragEvent("drop") : null;
      } catch {
        dropEvent = null;
      }
      const processEvent = ({
        state: state2,
        from,
        to,
        rule,
        pasteEvt
      }) => {
        const tr = state2.tr;
        const chainableState = createChainableState({
          state: state2,
          transaction: tr
        });
        const handler = run2({
          editor,
          state: chainableState,
          from: Math.max(from - 1, 0),
          to: to.b - 1,
          rule,
          pasteEvent: pasteEvt,
          dropEvent
        });
        if (!handler || !tr.steps.length) {
          return;
        }
        try {
          dropEvent = typeof DragEvent !== "undefined" ? new DragEvent("drop") : null;
        } catch {
          dropEvent = null;
        }
        pasteEvent = typeof ClipboardEvent !== "undefined" ? new ClipboardEvent("paste") : null;
        return tr;
      };
      const plugins = rules.map((rule) => {
        return new import_state13.Plugin({
          // we register a global drag handler to track the current drag source element
          view(view) {
            const handleDragstart = (event) => {
              var _a;
              dragSourceElement = ((_a = view.dom.parentElement) == null ? void 0 : _a.contains(event.target)) ? view.dom.parentElement : null;
              if (dragSourceElement) {
                tiptapDragFromOtherEditor = editor;
              }
            };
            const handleDragend = () => {
              if (tiptapDragFromOtherEditor) {
                tiptapDragFromOtherEditor = null;
              }
            };
            window.addEventListener("dragstart", handleDragstart);
            window.addEventListener("dragend", handleDragend);
            return {
              destroy() {
                window.removeEventListener("dragstart", handleDragstart);
                window.removeEventListener("dragend", handleDragend);
              }
            };
          },
          props: {
            handleDOMEvents: {
              drop: (view, event) => {
                isDroppedFromProseMirror = dragSourceElement === view.dom.parentElement;
                dropEvent = event;
                if (!isDroppedFromProseMirror) {
                  const dragFromOtherEditor = tiptapDragFromOtherEditor;
                  if (dragFromOtherEditor == null ? void 0 : dragFromOtherEditor.isEditable) {
                    setTimeout(() => {
                      const selection = dragFromOtherEditor.state.selection;
                      if (selection) {
                        dragFromOtherEditor.commands.deleteRange({ from: selection.from, to: selection.to });
                      }
                    }, 10);
                  }
                }
                return false;
              },
              paste: (_view, event) => {
                var _a;
                const html = (_a = event.clipboardData) == null ? void 0 : _a.getData("text/html");
                pasteEvent = event;
                isPastedFromProseMirror = !!(html == null ? void 0 : html.includes("data-pm-slice"));
                return false;
              }
            }
          },
          appendTransaction: (transactions, oldState, state2) => {
            const transaction = transactions[0];
            const isPaste = transaction.getMeta("uiEvent") === "paste" && !isPastedFromProseMirror;
            const isDrop = transaction.getMeta("uiEvent") === "drop" && !isDroppedFromProseMirror;
            const simulatedPasteMeta = transaction.getMeta("applyPasteRules");
            const isSimulatedPaste = !!simulatedPasteMeta;
            if (!isPaste && !isDrop && !isSimulatedPaste) {
              return;
            }
            if (isSimulatedPaste) {
              let { text } = simulatedPasteMeta;
              if (typeof text === "string") {
                text = text;
              } else {
                text = getHTMLFromFragment(import_model10.Fragment.from(text), state2.schema);
              }
              const { from: from2 } = simulatedPasteMeta;
              const to2 = from2 + text.length;
              const pasteEvt = createClipboardPasteEvent(text);
              return processEvent({
                rule,
                state: state2,
                from: from2,
                to: { b: to2 },
                pasteEvt
              });
            }
            const from = oldState.doc.content.findDiffStart(state2.doc.content);
            const to = oldState.doc.content.findDiffEnd(state2.doc.content);
            if (!isNumber(from) || !to || from === to.b) {
              return;
            }
            return processEvent({
              rule,
              state: state2,
              from,
              to,
              pasteEvt: pasteEvent
            });
          }
        });
      });
      return plugins;
    }
    var ExtensionManager = class {
      constructor(extensions2, editor) {
        this.splittableMarks = [];
        this.editor = editor;
        this.baseExtensions = extensions2;
        this.extensions = resolveExtensions(extensions2);
        this.schema = getSchemaByResolvedExtensions(this.extensions, editor);
        this.setupExtensions();
      }
      /**
       * Get all commands from the extensions.
       * @returns An object with all commands where the key is the command name and the value is the command function
       */
      get commands() {
        return this.extensions.reduce((commands2, extension) => {
          const context = {
            name: extension.name,
            options: extension.options,
            storage: this.editor.extensionStorage[extension.name],
            editor: this.editor,
            type: getSchemaTypeByName(extension.name, this.schema)
          };
          const addCommands = getExtensionField(extension, "addCommands", context);
          if (!addCommands) {
            return commands2;
          }
          return {
            ...commands2,
            ...addCommands()
          };
        }, {});
      }
      /**
       * Get all registered Prosemirror plugins from the extensions.
       * @returns An array of Prosemirror plugins
       */
      get plugins() {
        const { editor } = this;
        const extensions2 = sortExtensions([...this.extensions].reverse());
        const allPlugins = extensions2.flatMap((extension) => {
          const context = {
            name: extension.name,
            options: extension.options,
            storage: this.editor.extensionStorage[extension.name],
            editor,
            type: getSchemaTypeByName(extension.name, this.schema)
          };
          const plugins = [];
          const addKeyboardShortcuts = getExtensionField(
            extension,
            "addKeyboardShortcuts",
            context
          );
          let defaultBindings = {};
          if (extension.type === "mark" && getExtensionField(extension, "exitable", context)) {
            defaultBindings.ArrowRight = () => Mark.handleExit({ editor, mark: extension });
          }
          if (addKeyboardShortcuts) {
            const bindings = Object.fromEntries(
              Object.entries(addKeyboardShortcuts()).map(([shortcut, method]) => {
                return [shortcut, () => method({ editor })];
              })
            );
            defaultBindings = { ...defaultBindings, ...bindings };
          }
          const keyMapPlugin = (0, import_keymap.keymap)(defaultBindings);
          plugins.push(keyMapPlugin);
          const addInputRules = getExtensionField(extension, "addInputRules", context);
          if (isExtensionRulesEnabled(extension, editor.options.enableInputRules) && addInputRules) {
            const rules = addInputRules();
            if (rules && rules.length) {
              const inputResult = inputRulesPlugin({
                editor,
                rules
              });
              const inputPlugins = Array.isArray(inputResult) ? inputResult : [inputResult];
              plugins.push(...inputPlugins);
            }
          }
          const addPasteRules = getExtensionField(extension, "addPasteRules", context);
          if (isExtensionRulesEnabled(extension, editor.options.enablePasteRules) && addPasteRules) {
            const rules = addPasteRules();
            if (rules && rules.length) {
              const pasteRules = pasteRulesPlugin({ editor, rules });
              plugins.push(...pasteRules);
            }
          }
          const addProseMirrorPlugins = getExtensionField(
            extension,
            "addProseMirrorPlugins",
            context
          );
          if (addProseMirrorPlugins) {
            const proseMirrorPlugins = addProseMirrorPlugins();
            plugins.push(...proseMirrorPlugins);
          }
          return plugins;
        });
        return allPlugins;
      }
      /**
       * Get all attributes from the extensions.
       * @returns An array of attributes
       */
      get attributes() {
        return getAttributesFromExtensions(this.extensions);
      }
      /**
       * Get all node views from the extensions.
       * @returns An object with all node views where the key is the node name and the value is the node view function
       */
      get nodeViews() {
        const { editor } = this;
        const { nodeExtensions } = splitExtensions(this.extensions);
        return Object.fromEntries(
          nodeExtensions.filter((extension) => !!getExtensionField(extension, "addNodeView")).map((extension) => {
            const extensionAttributes = this.attributes.filter((attribute) => attribute.type === extension.name);
            const context = {
              name: extension.name,
              options: extension.options,
              storage: this.editor.extensionStorage[extension.name],
              editor,
              type: getNodeType(extension.name, this.schema)
            };
            const addNodeView = getExtensionField(extension, "addNodeView", context);
            if (!addNodeView) {
              return [];
            }
            const nodeViewResult = addNodeView();
            if (!nodeViewResult) {
              return [];
            }
            const nodeview = (node, view, getPos, decorations, innerDecorations) => {
              const HTMLAttributes = getRenderedAttributes(node, extensionAttributes);
              return nodeViewResult({
                // pass-through
                node,
                view,
                getPos,
                decorations,
                innerDecorations,
                // tiptap-specific
                editor,
                extension,
                HTMLAttributes
              });
            };
            return [extension.name, nodeview];
          })
        );
      }
      get markViews() {
        const { editor } = this;
        const { markExtensions } = splitExtensions(this.extensions);
        return Object.fromEntries(
          markExtensions.filter((extension) => !!getExtensionField(extension, "addMarkView")).map((extension) => {
            const extensionAttributes = this.attributes.filter((attribute) => attribute.type === extension.name);
            const context = {
              name: extension.name,
              options: extension.options,
              storage: this.editor.extensionStorage[extension.name],
              editor,
              type: getMarkType(extension.name, this.schema)
            };
            const addMarkView = getExtensionField(extension, "addMarkView", context);
            if (!addMarkView) {
              return [];
            }
            const markView = (mark, view, inline) => {
              const HTMLAttributes = getRenderedAttributes(mark, extensionAttributes);
              return addMarkView()({
                // pass-through
                mark,
                view,
                inline,
                // tiptap-specific
                editor,
                extension,
                HTMLAttributes,
                updateAttributes: (attrs) => {
                  updateMarkViewAttributes(mark, editor, attrs);
                }
              });
            };
            return [extension.name, markView];
          })
        );
      }
      /**
       * Go through all extensions, create extension storages & setup marks
       * & bind editor event listener.
       */
      setupExtensions() {
        const extensions2 = this.extensions;
        this.editor.extensionStorage = Object.fromEntries(
          extensions2.map((extension) => [extension.name, extension.storage])
        );
        extensions2.forEach((extension) => {
          var _a;
          const context = {
            name: extension.name,
            options: extension.options,
            storage: this.editor.extensionStorage[extension.name],
            editor: this.editor,
            type: getSchemaTypeByName(extension.name, this.schema)
          };
          if (extension.type === "mark") {
            const keepOnSplit = (_a = callOrReturn(getExtensionField(extension, "keepOnSplit", context))) != null ? _a : true;
            if (keepOnSplit) {
              this.splittableMarks.push(extension.name);
            }
          }
          const onBeforeCreate = getExtensionField(extension, "onBeforeCreate", context);
          const onCreate = getExtensionField(extension, "onCreate", context);
          const onUpdate = getExtensionField(extension, "onUpdate", context);
          const onSelectionUpdate = getExtensionField(
            extension,
            "onSelectionUpdate",
            context
          );
          const onTransaction = getExtensionField(extension, "onTransaction", context);
          const onFocus = getExtensionField(extension, "onFocus", context);
          const onBlur = getExtensionField(extension, "onBlur", context);
          const onDestroy = getExtensionField(extension, "onDestroy", context);
          if (onBeforeCreate) {
            this.editor.on("beforeCreate", onBeforeCreate);
          }
          if (onCreate) {
            this.editor.on("create", onCreate);
          }
          if (onUpdate) {
            this.editor.on("update", onUpdate);
          }
          if (onSelectionUpdate) {
            this.editor.on("selectionUpdate", onSelectionUpdate);
          }
          if (onTransaction) {
            this.editor.on("transaction", onTransaction);
          }
          if (onFocus) {
            this.editor.on("focus", onFocus);
          }
          if (onBlur) {
            this.editor.on("blur", onBlur);
          }
          if (onDestroy) {
            this.editor.on("destroy", onDestroy);
          }
        });
      }
    };
    ExtensionManager.resolve = resolveExtensions;
    ExtensionManager.sort = sortExtensions;
    ExtensionManager.flatten = flattenExtensions;
    var extensions_exports = {};
    __export2(extensions_exports, {
      ClipboardTextSerializer: () => ClipboardTextSerializer,
      Commands: () => Commands,
      Delete: () => Delete,
      Drop: () => Drop,
      Editable: () => Editable,
      FocusEvents: () => FocusEvents,
      Keymap: () => Keymap,
      Paste: () => Paste,
      Tabindex: () => Tabindex,
      TextDirection: () => TextDirection,
      focusEventsPluginKey: () => focusEventsPluginKey
    });
    var import_state14 = require_state();
    var Extension = class _Extension extends Extendable {
      constructor() {
        super(...arguments);
        this.type = "extension";
      }
      /**
       * Create a new Extension instance
       * @param config - Extension configuration object or a function that returns a configuration object
       */
      static create(config = {}) {
        const resolvedConfig = typeof config === "function" ? config() : config;
        return new _Extension(resolvedConfig);
      }
      configure(options) {
        return super.configure(options);
      }
      extend(extendedConfig) {
        const resolvedConfig = typeof extendedConfig === "function" ? extendedConfig() : extendedConfig;
        return super.extend(resolvedConfig);
      }
    };
    var ClipboardTextSerializer = Extension.create({
      name: "clipboardTextSerializer",
      addOptions() {
        return {
          blockSeparator: void 0
        };
      },
      addProseMirrorPlugins() {
        return [
          new import_state14.Plugin({
            key: new import_state14.PluginKey("clipboardTextSerializer"),
            props: {
              clipboardTextSerializer: () => {
                const { editor } = this;
                const { state: state2, schema } = editor;
                const { doc, selection } = state2;
                const { ranges } = selection;
                const from = Math.min(...ranges.map((range22) => range22.$from.pos));
                const to = Math.max(...ranges.map((range22) => range22.$to.pos));
                const textSerializers = getTextSerializersFromSchema(schema);
                const range2 = { from, to };
                return getTextBetween(doc, range2, {
                  ...this.options.blockSeparator !== void 0 ? { blockSeparator: this.options.blockSeparator } : {},
                  textSerializers
                });
              }
            }
          })
        ];
      }
    });
    var Commands = Extension.create({
      name: "commands",
      addCommands() {
        return {
          ...commands_exports
        };
      }
    });
    var import_transform9 = require_transform();
    var Delete = Extension.create({
      name: "delete",
      onUpdate({ transaction, appendedTransactions }) {
        var _a, _b, _c;
        const callback = () => {
          var _a2, _b2, _c2, _d;
          if ((_d = (_c2 = (_b2 = (_a2 = this.editor.options.coreExtensionOptions) == null ? void 0 : _a2.delete) == null ? void 0 : _b2.filterTransaction) == null ? void 0 : _c2.call(_b2, transaction)) != null ? _d : transaction.getMeta("y-sync$")) {
            return;
          }
          const nextTransaction = combineTransactionSteps(transaction.before, [transaction, ...appendedTransactions]);
          const changes = getChangedRanges(nextTransaction);
          changes.forEach((change) => {
            if (nextTransaction.mapping.mapResult(change.oldRange.from).deletedAfter && nextTransaction.mapping.mapResult(change.oldRange.to).deletedBefore) {
              nextTransaction.before.nodesBetween(change.oldRange.from, change.oldRange.to, (node, from) => {
                const to = from + node.nodeSize - 2;
                const isFullyWithinRange = change.oldRange.from <= from && to <= change.oldRange.to;
                this.editor.emit("delete", {
                  type: "node",
                  node,
                  from,
                  to,
                  newFrom: nextTransaction.mapping.map(from),
                  newTo: nextTransaction.mapping.map(to),
                  deletedRange: change.oldRange,
                  newRange: change.newRange,
                  partial: !isFullyWithinRange,
                  editor: this.editor,
                  transaction,
                  combinedTransform: nextTransaction
                });
              });
            }
          });
          const mapping = nextTransaction.mapping;
          nextTransaction.steps.forEach((step, index) => {
            var _a3, _b3;
            if (step instanceof import_transform9.RemoveMarkStep) {
              const newStart = mapping.slice(index).map(step.from, -1);
              const newEnd = mapping.slice(index).map(step.to);
              const oldStart = mapping.invert().map(newStart, -1);
              const oldEnd = mapping.invert().map(newEnd);
              const foundBeforeMark = (_a3 = nextTransaction.doc.nodeAt(newStart - 1)) == null ? void 0 : _a3.marks.some((mark) => mark.eq(step.mark));
              const foundAfterMark = (_b3 = nextTransaction.doc.nodeAt(newEnd)) == null ? void 0 : _b3.marks.some((mark) => mark.eq(step.mark));
              this.editor.emit("delete", {
                type: "mark",
                mark: step.mark,
                from: step.from,
                to: step.to,
                deletedRange: {
                  from: oldStart,
                  to: oldEnd
                },
                newRange: {
                  from: newStart,
                  to: newEnd
                },
                partial: Boolean(foundAfterMark || foundBeforeMark),
                editor: this.editor,
                transaction,
                combinedTransform: nextTransaction
              });
            }
          });
        };
        if ((_c = (_b = (_a = this.editor.options.coreExtensionOptions) == null ? void 0 : _a.delete) == null ? void 0 : _b.async) != null ? _c : true) {
          setTimeout(callback, 0);
        } else {
          callback();
        }
      }
    });
    var import_state15 = require_state();
    var Drop = Extension.create({
      name: "drop",
      addProseMirrorPlugins() {
        return [
          new import_state15.Plugin({
            key: new import_state15.PluginKey("tiptapDrop"),
            props: {
              handleDrop: (_, e, slice, moved) => {
                this.editor.emit("drop", {
                  editor: this.editor,
                  event: e,
                  slice,
                  moved
                });
              }
            }
          })
        ];
      }
    });
    var import_state16 = require_state();
    var Editable = Extension.create({
      name: "editable",
      addProseMirrorPlugins() {
        return [
          new import_state16.Plugin({
            key: new import_state16.PluginKey("editable"),
            props: {
              editable: () => this.editor.options.editable
            }
          })
        ];
      }
    });
    var import_state17 = require_state();
    var focusEventsPluginKey = new import_state17.PluginKey("focusEvents");
    var FocusEvents = Extension.create({
      name: "focusEvents",
      addProseMirrorPlugins() {
        const { editor } = this;
        return [
          new import_state17.Plugin({
            key: focusEventsPluginKey,
            props: {
              handleDOMEvents: {
                focus: (view, event) => {
                  editor.isFocused = true;
                  const transaction = editor.state.tr.setMeta("focus", { event }).setMeta("addToHistory", false);
                  view.dispatch(transaction);
                  return false;
                },
                blur: (view, event) => {
                  editor.isFocused = false;
                  const transaction = editor.state.tr.setMeta("blur", { event }).setMeta("addToHistory", false);
                  view.dispatch(transaction);
                  return false;
                }
              }
            }
          })
        ];
      }
    });
    var import_state18 = require_state();
    var Keymap = Extension.create({
      name: "keymap",
      addKeyboardShortcuts() {
        const handleBackspace = () => this.editor.commands.first(({ commands: commands2 }) => [
          () => commands2.undoInputRule(),
          // maybe convert first text block node to default node
          () => commands2.command(({ tr }) => {
            const { selection, doc } = tr;
            const { empty, $anchor } = selection;
            const { pos, parent } = $anchor;
            const $parentPos = $anchor.parent.isTextblock && pos > 0 ? tr.doc.resolve(pos - 1) : $anchor;
            const parentIsIsolating = $parentPos.parent.type.spec.isolating;
            const parentPos = $anchor.pos - $anchor.parentOffset;
            const isAtStart = parentIsIsolating && $parentPos.parent.childCount === 1 ? parentPos === $anchor.pos : import_state18.Selection.atStart(doc).from === pos;
            if (!empty || !parent.type.isTextblock || parent.textContent.length || !isAtStart || isAtStart && $anchor.parent.type.name === "paragraph") {
              return false;
            }
            return commands2.clearNodes();
          }),
          () => commands2.deleteSelection(),
          () => commands2.joinBackward(),
          () => commands2.selectNodeBackward()
        ]);
        const handleDelete = () => this.editor.commands.first(({ commands: commands2 }) => [
          () => commands2.deleteSelection(),
          () => commands2.deleteCurrentNode(),
          () => commands2.joinForward(),
          () => commands2.selectNodeForward()
        ]);
        const handleEnter = () => this.editor.commands.first(({ commands: commands2 }) => [
          () => commands2.newlineInCode(),
          () => commands2.createParagraphNear(),
          () => commands2.liftEmptyBlock(),
          () => commands2.splitBlock()
        ]);
        const baseKeymap = {
          Enter: handleEnter,
          "Mod-Enter": () => this.editor.commands.exitCode(),
          Backspace: handleBackspace,
          "Mod-Backspace": handleBackspace,
          "Shift-Backspace": handleBackspace,
          Delete: handleDelete,
          "Mod-Delete": handleDelete,
          "Mod-a": () => this.editor.commands.selectAll()
        };
        const pcKeymap = {
          ...baseKeymap
        };
        const macKeymap = {
          ...baseKeymap,
          "Ctrl-h": handleBackspace,
          "Alt-Backspace": handleBackspace,
          "Ctrl-d": handleDelete,
          "Ctrl-Alt-Backspace": handleDelete,
          "Alt-Delete": handleDelete,
          "Alt-d": handleDelete,
          "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
          "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
        };
        if (isiOS() || isMacOS()) {
          return macKeymap;
        }
        return pcKeymap;
      },
      addProseMirrorPlugins() {
        return [
          // With this plugin we check if the whole document was selected and deleted.
          // In this case we will additionally call `clearNodes()` to convert e.g. a heading
          // to a paragraph if necessary.
          // This is an alternative to ProseMirror's `AllSelection`, which doesn’t work well
          // with many other commands.
          new import_state18.Plugin({
            key: new import_state18.PluginKey("clearDocument"),
            appendTransaction: (transactions, oldState, newState) => {
              if (transactions.some((tr2) => tr2.getMeta("composition"))) {
                return;
              }
              const docChanges = transactions.some((transaction) => transaction.docChanged) && !oldState.doc.eq(newState.doc);
              const ignoreTr = transactions.some((transaction) => transaction.getMeta("preventClearDocument"));
              if (!docChanges || ignoreTr) {
                return;
              }
              const { empty, from, to } = oldState.selection;
              const allFrom = import_state18.Selection.atStart(oldState.doc).from;
              const allEnd = import_state18.Selection.atEnd(oldState.doc).to;
              const allWasSelected = from === allFrom && to === allEnd;
              if (empty || !allWasSelected) {
                return;
              }
              const isEmpty = isNodeEmpty(newState.doc);
              if (!isEmpty) {
                return;
              }
              const tr = newState.tr;
              const state2 = createChainableState({
                state: newState,
                transaction: tr
              });
              const { commands: commands2 } = new CommandManager({
                editor: this.editor,
                state: state2
              });
              commands2.clearNodes();
              if (!tr.steps.length) {
                return;
              }
              return tr;
            }
          })
        ];
      }
    });
    var import_state19 = require_state();
    var Paste = Extension.create({
      name: "paste",
      addProseMirrorPlugins() {
        return [
          new import_state19.Plugin({
            key: new import_state19.PluginKey("tiptapPaste"),
            props: {
              handlePaste: (_view, e, slice) => {
                this.editor.emit("paste", {
                  editor: this.editor,
                  event: e,
                  slice
                });
              }
            }
          })
        ];
      }
    });
    var import_state20 = require_state();
    var Tabindex = Extension.create({
      name: "tabindex",
      addProseMirrorPlugins() {
        return [
          new import_state20.Plugin({
            key: new import_state20.PluginKey("tabindex"),
            props: {
              attributes: () => this.editor.isEditable ? { tabindex: "0" } : {}
            }
          })
        ];
      }
    });
    var import_state21 = require_state();
    var TextDirection = Extension.create({
      name: "textDirection",
      addOptions() {
        return {
          direction: void 0
        };
      },
      addGlobalAttributes() {
        if (!this.options.direction) {
          return [];
        }
        const { nodeExtensions } = splitExtensions(this.extensions);
        return [
          {
            types: nodeExtensions.filter((extension) => extension.name !== "text").map((extension) => extension.name),
            attributes: {
              dir: {
                default: this.options.direction,
                parseHTML: (element) => {
                  const dir = element.getAttribute("dir");
                  if (dir && (dir === "ltr" || dir === "rtl" || dir === "auto")) {
                    return dir;
                  }
                  return this.options.direction;
                },
                renderHTML: (attributes) => {
                  if (!attributes.dir) {
                    return {};
                  }
                  return {
                    dir: attributes.dir
                  };
                }
              }
            }
          }
        ];
      },
      addProseMirrorPlugins() {
        return [
          new import_state21.Plugin({
            key: new import_state21.PluginKey("textDirection"),
            props: {
              attributes: () => {
                const direction = this.options.direction;
                if (!direction) {
                  return {};
                }
                return {
                  dir: direction
                };
              }
            }
          })
        ];
      }
    });
    var NodePos = class _NodePos {
      constructor(pos, editor, isBlock = false, node = null) {
        this.currentNode = null;
        this.actualDepth = null;
        this.isBlock = isBlock;
        this.resolvedPos = pos;
        this.editor = editor;
        this.currentNode = node;
      }
      get name() {
        return this.node.type.name;
      }
      get node() {
        return this.currentNode || this.resolvedPos.node();
      }
      get element() {
        return this.editor.view.domAtPos(this.pos).node;
      }
      get depth() {
        var _a;
        return (_a = this.actualDepth) != null ? _a : this.resolvedPos.depth;
      }
      get pos() {
        return this.resolvedPos.pos;
      }
      get content() {
        return this.node.content;
      }
      set content(content) {
        let from = this.from;
        let to = this.to;
        if (this.isBlock) {
          if (this.content.size === 0) {
            console.error(`You can\u2019t set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);
            return;
          }
          from = this.from + 1;
          to = this.to - 1;
        }
        this.editor.commands.insertContentAt({ from, to }, content);
      }
      get attributes() {
        return this.node.attrs;
      }
      get textContent() {
        return this.node.textContent;
      }
      get size() {
        return this.node.nodeSize;
      }
      get from() {
        if (this.isBlock) {
          return this.pos;
        }
        return this.resolvedPos.start(this.resolvedPos.depth);
      }
      get range() {
        return {
          from: this.from,
          to: this.to
        };
      }
      get to() {
        if (this.isBlock) {
          return this.pos + this.size;
        }
        return this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1);
      }
      get parent() {
        if (this.depth === 0) {
          return null;
        }
        const parentPos = this.resolvedPos.start(this.resolvedPos.depth - 1);
        const $pos = this.resolvedPos.doc.resolve(parentPos);
        return new _NodePos($pos, this.editor);
      }
      get before() {
        let $pos = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));
        if ($pos.depth !== this.depth) {
          $pos = this.resolvedPos.doc.resolve(this.from - 3);
        }
        return new _NodePos($pos, this.editor);
      }
      get after() {
        let $pos = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));
        if ($pos.depth !== this.depth) {
          $pos = this.resolvedPos.doc.resolve(this.to + 3);
        }
        return new _NodePos($pos, this.editor);
      }
      get children() {
        const children = [];
        this.node.content.forEach((node, offset) => {
          const isBlock = node.isBlock && !node.isTextblock;
          const isNonTextAtom = node.isAtom && !node.isText;
          const targetPos = this.pos + offset + (isNonTextAtom ? 0 : 1);
          if (targetPos < 0 || targetPos > this.resolvedPos.doc.nodeSize - 2) {
            return;
          }
          const $pos = this.resolvedPos.doc.resolve(targetPos);
          if (!isBlock && $pos.depth <= this.depth) {
            return;
          }
          const childNodePos = new _NodePos($pos, this.editor, isBlock, isBlock ? node : null);
          if (isBlock) {
            childNodePos.actualDepth = this.depth + 1;
          }
          children.push(new _NodePos($pos, this.editor, isBlock, isBlock ? node : null));
        });
        return children;
      }
      get firstChild() {
        return this.children[0] || null;
      }
      get lastChild() {
        const children = this.children;
        return children[children.length - 1] || null;
      }
      closest(selector, attributes = {}) {
        let node = null;
        let currentNode = this.parent;
        while (currentNode && !node) {
          if (currentNode.node.type.name === selector) {
            if (Object.keys(attributes).length > 0) {
              const nodeAttributes = currentNode.node.attrs;
              const attrKeys = Object.keys(attributes);
              for (let index = 0; index < attrKeys.length; index += 1) {
                const key = attrKeys[index];
                if (nodeAttributes[key] !== attributes[key]) {
                  break;
                }
              }
            } else {
              node = currentNode;
            }
          }
          currentNode = currentNode.parent;
        }
        return node;
      }
      querySelector(selector, attributes = {}) {
        return this.querySelectorAll(selector, attributes, true)[0] || null;
      }
      querySelectorAll(selector, attributes = {}, firstItemOnly = false) {
        let nodes = [];
        if (!this.children || this.children.length === 0) {
          return nodes;
        }
        const attrKeys = Object.keys(attributes);
        this.children.forEach((childPos) => {
          if (firstItemOnly && nodes.length > 0) {
            return;
          }
          if (childPos.node.type.name === selector) {
            const doesAllAttributesMatch = attrKeys.every((key) => attributes[key] === childPos.node.attrs[key]);
            if (doesAllAttributesMatch) {
              nodes.push(childPos);
            }
          }
          if (firstItemOnly && nodes.length > 0) {
            return;
          }
          nodes = nodes.concat(childPos.querySelectorAll(selector, attributes, firstItemOnly));
        });
        return nodes;
      }
      setAttribute(attributes) {
        const { tr } = this.editor.state;
        tr.setNodeMarkup(this.from, void 0, {
          ...this.node.attrs,
          ...attributes
        });
        this.editor.view.dispatch(tr);
      }
    };
    var style = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 0 !important;
  height: 0 !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}`;
    function createStyleTag(style2, nonce, suffix) {
      const tiptapStyleTag = document.querySelector(`style[data-tiptap-style${suffix ? `-${suffix}` : ""}]`);
      if (tiptapStyleTag !== null) {
        return tiptapStyleTag;
      }
      const styleNode = document.createElement("style");
      if (nonce) {
        styleNode.setAttribute("nonce", nonce);
      }
      styleNode.setAttribute(`data-tiptap-style${suffix ? `-${suffix}` : ""}`, "");
      styleNode.innerHTML = style2;
      document.getElementsByTagName("head")[0].appendChild(styleNode);
      return styleNode;
    }
    var Editor = class extends EventEmitter {
      constructor(options = {}) {
        super();
        this.css = null;
        this.className = "tiptap";
        this.editorView = null;
        this.isFocused = false;
        this.isInitialized = false;
        this.extensionStorage = {};
        this.instanceId = Math.random().toString(36).slice(2, 9);
        this.options = {
          element: typeof document !== "undefined" ? document.createElement("div") : null,
          content: "",
          injectCSS: true,
          injectNonce: void 0,
          extensions: [],
          autofocus: false,
          editable: true,
          textDirection: void 0,
          editorProps: {},
          parseOptions: {},
          coreExtensionOptions: {},
          enableInputRules: true,
          enablePasteRules: true,
          enableCoreExtensions: true,
          enableContentCheck: false,
          emitContentError: false,
          onBeforeCreate: () => null,
          onCreate: () => null,
          onMount: () => null,
          onUnmount: () => null,
          onUpdate: () => null,
          onSelectionUpdate: () => null,
          onTransaction: () => null,
          onFocus: () => null,
          onBlur: () => null,
          onDestroy: () => null,
          onContentError: ({ error }) => {
            throw error;
          },
          onPaste: () => null,
          onDrop: () => null,
          onDelete: () => null
        };
        this.isCapturingTransaction = false;
        this.capturedTransaction = null;
        this.setOptions(options);
        this.createExtensionManager();
        this.createCommandManager();
        this.createSchema();
        this.on("beforeCreate", this.options.onBeforeCreate);
        this.emit("beforeCreate", { editor: this });
        this.on("mount", this.options.onMount);
        this.on("unmount", this.options.onUnmount);
        this.on("contentError", this.options.onContentError);
        this.on("create", this.options.onCreate);
        this.on("update", this.options.onUpdate);
        this.on("selectionUpdate", this.options.onSelectionUpdate);
        this.on("transaction", this.options.onTransaction);
        this.on("focus", this.options.onFocus);
        this.on("blur", this.options.onBlur);
        this.on("destroy", this.options.onDestroy);
        this.on("drop", ({ event, slice, moved }) => this.options.onDrop(event, slice, moved));
        this.on("paste", ({ event, slice }) => this.options.onPaste(event, slice));
        this.on("delete", this.options.onDelete);
        const initialDoc = this.createDoc();
        const selection = resolveFocusPosition(initialDoc, this.options.autofocus);
        this.editorState = import_state22.EditorState.create({
          doc: initialDoc,
          schema: this.schema,
          selection: selection || void 0
        });
        if (this.options.element) {
          this.mount(this.options.element);
        }
      }
      /**
       * Attach the editor to the DOM, creating a new editor view.
       */
      mount(el) {
        if (typeof document === "undefined") {
          throw new Error(
            `[tiptap error]: The editor cannot be mounted because there is no 'document' defined in this environment.`
          );
        }
        this.createView(el);
        this.emit("mount", { editor: this });
        if (this.css && !document.head.contains(this.css)) {
          document.head.appendChild(this.css);
        }
        window.setTimeout(() => {
          if (this.isDestroyed) {
            return;
          }
          if (this.options.autofocus !== false && this.options.autofocus !== null) {
            this.commands.focus(this.options.autofocus);
          }
          this.emit("create", { editor: this });
          this.isInitialized = true;
        }, 0);
      }
      /**
       * Remove the editor from the DOM, but still allow remounting at a different point in time
       */
      unmount() {
        if (this.editorView) {
          const dom = this.editorView.dom;
          if (dom == null ? void 0 : dom.editor) {
            delete dom.editor;
          }
          this.editorView.destroy();
        }
        this.editorView = null;
        this.isInitialized = false;
        if (this.css && !document.querySelectorAll(`.${this.className}`).length) {
          try {
            if (typeof this.css.remove === "function") {
              this.css.remove();
            } else if (this.css.parentNode) {
              this.css.parentNode.removeChild(this.css);
            }
          } catch (error) {
            console.warn("Failed to remove CSS element:", error);
          }
        }
        this.css = null;
        this.emit("unmount", { editor: this });
      }
      /**
       * Returns the editor storage.
       */
      get storage() {
        return this.extensionStorage;
      }
      /**
       * An object of all registered commands.
       */
      get commands() {
        return this.commandManager.commands;
      }
      /**
       * Create a command chain to call multiple commands at once.
       */
      chain() {
        return this.commandManager.chain();
      }
      /**
       * Check if a command or a command chain can be executed. Without executing it.
       */
      can() {
        return this.commandManager.can();
      }
      /**
       * Inject CSS styles.
       */
      injectCSS() {
        if (this.options.injectCSS && typeof document !== "undefined") {
          this.css = createStyleTag(style, this.options.injectNonce);
        }
      }
      /**
       * Update editor options.
       *
       * @param options A list of options
       */
      setOptions(options = {}) {
        this.options = {
          ...this.options,
          ...options
        };
        if (!this.editorView || !this.state || this.isDestroyed) {
          return;
        }
        if (this.options.editorProps) {
          this.view.setProps(this.options.editorProps);
        }
        this.view.updateState(this.state);
      }
      /**
       * Update editable state of the editor.
       */
      setEditable(editable, emitUpdate = true) {
        this.setOptions({ editable });
        if (emitUpdate) {
          this.emit("update", { editor: this, transaction: this.state.tr, appendedTransactions: [] });
        }
      }
      /**
       * Returns whether the editor is editable.
       */
      get isEditable() {
        return this.options.editable && this.view && this.view.editable;
      }
      /**
       * Returns the editor state.
       */
      get view() {
        if (this.editorView) {
          return this.editorView;
        }
        return new Proxy(
          {
            state: this.editorState,
            updateState: (state2) => {
              this.editorState = state2;
            },
            dispatch: (tr) => {
              this.dispatchTransaction(tr);
            },
            // Stub some commonly accessed properties to prevent errors
            composing: false,
            dragging: null,
            editable: true,
            isDestroyed: false
          },
          {
            get: (obj, key) => {
              if (this.editorView) {
                return this.editorView[key];
              }
              if (key === "state") {
                return this.editorState;
              }
              if (key in obj) {
                return Reflect.get(obj, key);
              }
              throw new Error(
                `[tiptap error]: The editor view is not available. Cannot access view['${key}']. The editor may not be mounted yet.`
              );
            }
          }
        );
      }
      /**
       * Returns the editor state.
       */
      get state() {
        if (this.editorView) {
          this.editorState = this.view.state;
        }
        return this.editorState;
      }
      /**
       * Register a ProseMirror plugin.
       *
       * @param plugin A ProseMirror plugin
       * @param handlePlugins Control how to merge the plugin into the existing plugins.
       * @returns The new editor state
       */
      registerPlugin(plugin, handlePlugins) {
        const plugins = isFunction(handlePlugins) ? handlePlugins(plugin, [...this.state.plugins]) : [...this.state.plugins, plugin];
        const state2 = this.state.reconfigure({ plugins });
        this.view.updateState(state2);
        return state2;
      }
      /**
       * Unregister a ProseMirror plugin.
       *
       * @param nameOrPluginKeyToRemove The plugins name
       * @returns The new editor state or undefined if the editor is destroyed
       */
      unregisterPlugin(nameOrPluginKeyToRemove) {
        if (this.isDestroyed) {
          return void 0;
        }
        const prevPlugins = this.state.plugins;
        let plugins = prevPlugins;
        [].concat(nameOrPluginKeyToRemove).forEach((nameOrPluginKey) => {
          const name = typeof nameOrPluginKey === "string" ? `${nameOrPluginKey}$` : nameOrPluginKey.key;
          plugins = plugins.filter((plugin) => !plugin.key.startsWith(name));
        });
        if (prevPlugins.length === plugins.length) {
          return void 0;
        }
        const state2 = this.state.reconfigure({
          plugins
        });
        this.view.updateState(state2);
        return state2;
      }
      /**
       * Creates an extension manager.
       */
      createExtensionManager() {
        var _a, _b;
        const coreExtensions = this.options.enableCoreExtensions ? [
          Editable,
          ClipboardTextSerializer.configure({
            blockSeparator: (_b = (_a = this.options.coreExtensionOptions) == null ? void 0 : _a.clipboardTextSerializer) == null ? void 0 : _b.blockSeparator
          }),
          Commands,
          FocusEvents,
          Keymap,
          Tabindex,
          Drop,
          Paste,
          Delete,
          TextDirection.configure({
            direction: this.options.textDirection
          })
        ].filter((ext) => {
          if (typeof this.options.enableCoreExtensions === "object") {
            return this.options.enableCoreExtensions[ext.name] !== false;
          }
          return true;
        }) : [];
        const allExtensions = [...coreExtensions, ...this.options.extensions].filter((extension) => {
          return ["extension", "node", "mark"].includes(extension == null ? void 0 : extension.type);
        });
        this.extensionManager = new ExtensionManager(allExtensions, this);
      }
      /**
       * Creates an command manager.
       */
      createCommandManager() {
        this.commandManager = new CommandManager({
          editor: this
        });
      }
      /**
       * Creates a ProseMirror schema.
       */
      createSchema() {
        this.schema = this.extensionManager.schema;
      }
      /**
       * Creates the initial document.
       */
      createDoc() {
        let doc;
        try {
          doc = createDocument(this.options.content, this.schema, this.options.parseOptions, {
            errorOnInvalidContent: this.options.enableContentCheck
          });
        } catch (e) {
          if (!(e instanceof Error) || !["[tiptap error]: Invalid JSON content", "[tiptap error]: Invalid HTML content"].includes(e.message)) {
            throw e;
          }
          this.emit("contentError", {
            editor: this,
            error: e,
            disableCollaboration: () => {
              if ("collaboration" in this.storage && typeof this.storage.collaboration === "object" && this.storage.collaboration) {
                ;
                this.storage.collaboration.isDisabled = true;
              }
              this.options.extensions = this.options.extensions.filter((extension) => extension.name !== "collaboration");
              this.createExtensionManager();
            }
          });
          doc = createDocument(this.options.content, this.schema, this.options.parseOptions, {
            errorOnInvalidContent: false
          });
        }
        return doc;
      }
      /**
       * Creates a ProseMirror view.
       */
      createView(element) {
        var _a;
        this.editorView = new import_view.EditorView(element, {
          ...this.options.editorProps,
          attributes: {
            // add `role="textbox"` to the editor element
            role: "textbox",
            ...(_a = this.options.editorProps) == null ? void 0 : _a.attributes
          },
          dispatchTransaction: this.dispatchTransaction.bind(this),
          state: this.editorState,
          markViews: this.extensionManager.markViews,
          nodeViews: this.extensionManager.nodeViews
        });
        const newState = this.state.reconfigure({
          plugins: this.extensionManager.plugins
        });
        this.view.updateState(newState);
        this.prependClass();
        this.injectCSS();
        const dom = this.view.dom;
        dom.editor = this;
      }
      /**
       * Creates all node and mark views.
       */
      createNodeViews() {
        if (this.view.isDestroyed) {
          return;
        }
        this.view.setProps({
          markViews: this.extensionManager.markViews,
          nodeViews: this.extensionManager.nodeViews
        });
      }
      /**
       * Prepend class name to element.
       */
      prependClass() {
        this.view.dom.className = `${this.className} ${this.view.dom.className}`;
      }
      captureTransaction(fn) {
        this.isCapturingTransaction = true;
        fn();
        this.isCapturingTransaction = false;
        const tr = this.capturedTransaction;
        this.capturedTransaction = null;
        return tr;
      }
      /**
       * The callback over which to send transactions (state updates) produced by the view.
       *
       * @param transaction An editor state transaction
       */
      dispatchTransaction(transaction) {
        if (this.view.isDestroyed) {
          return;
        }
        if (this.isCapturingTransaction) {
          if (!this.capturedTransaction) {
            this.capturedTransaction = transaction;
            return;
          }
          transaction.steps.forEach((step) => {
            var _a;
            return (_a = this.capturedTransaction) == null ? void 0 : _a.step(step);
          });
          return;
        }
        const { state: state2, transactions } = this.state.applyTransaction(transaction);
        const selectionHasChanged = !this.state.selection.eq(state2.selection);
        const rootTrWasApplied = transactions.includes(transaction);
        const prevState = this.state;
        this.emit("beforeTransaction", {
          editor: this,
          transaction,
          nextState: state2
        });
        if (!rootTrWasApplied) {
          return;
        }
        this.view.updateState(state2);
        this.emit("transaction", {
          editor: this,
          transaction,
          appendedTransactions: transactions.slice(1)
        });
        if (selectionHasChanged) {
          this.emit("selectionUpdate", {
            editor: this,
            transaction
          });
        }
        const mostRecentFocusTr = transactions.findLast((tr) => tr.getMeta("focus") || tr.getMeta("blur"));
        const focus2 = mostRecentFocusTr == null ? void 0 : mostRecentFocusTr.getMeta("focus");
        const blur2 = mostRecentFocusTr == null ? void 0 : mostRecentFocusTr.getMeta("blur");
        if (focus2) {
          this.emit("focus", {
            editor: this,
            event: focus2.event,
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            transaction: mostRecentFocusTr
          });
        }
        if (blur2) {
          this.emit("blur", {
            editor: this,
            event: blur2.event,
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            transaction: mostRecentFocusTr
          });
        }
        if (transaction.getMeta("preventUpdate") || !transactions.some((tr) => tr.docChanged) || prevState.doc.eq(state2.doc)) {
          return;
        }
        this.emit("update", {
          editor: this,
          transaction,
          appendedTransactions: transactions.slice(1)
        });
      }
      /**
       * Get attributes of the currently selected node or mark.
       */
      getAttributes(nameOrType) {
        return getAttributes(this.state, nameOrType);
      }
      isActive(nameOrAttributes, attributesOrUndefined) {
        const name = typeof nameOrAttributes === "string" ? nameOrAttributes : null;
        const attributes = typeof nameOrAttributes === "string" ? attributesOrUndefined : nameOrAttributes;
        return isActive(this.state, name, attributes);
      }
      /**
       * Get the document as JSON.
       */
      getJSON() {
        return this.state.doc.toJSON();
      }
      /**
       * Get the document as HTML.
       */
      getHTML() {
        return getHTMLFromFragment(this.state.doc.content, this.schema);
      }
      /**
       * Get the document as text.
       */
      getText(options) {
        const { blockSeparator = "\n\n", textSerializers = {} } = options || {};
        return getText(this.state.doc, {
          blockSeparator,
          textSerializers: {
            ...getTextSerializersFromSchema(this.schema),
            ...textSerializers
          }
        });
      }
      /**
       * Check if there is no content.
       */
      get isEmpty() {
        return isNodeEmpty(this.state.doc);
      }
      /**
       * Destroy the editor.
       */
      destroy() {
        this.emit("destroy");
        this.unmount();
        this.removeAllListeners();
      }
      /**
       * Check if the editor is already destroyed.
       */
      get isDestroyed() {
        var _a, _b;
        return (_b = (_a = this.editorView) == null ? void 0 : _a.isDestroyed) != null ? _b : true;
      }
      $node(selector, attributes) {
        var _a;
        return ((_a = this.$doc) == null ? void 0 : _a.querySelector(selector, attributes)) || null;
      }
      $nodes(selector, attributes) {
        var _a;
        return ((_a = this.$doc) == null ? void 0 : _a.querySelectorAll(selector, attributes)) || null;
      }
      $pos(pos) {
        const $pos = this.state.doc.resolve(pos);
        return new NodePos($pos, this);
      }
      get $doc() {
        return this.$pos(0);
      }
    };
    function markInputRule(config) {
      return new InputRule({
        find: config.find,
        handler: ({ state: state2, range: range2, match }) => {
          const attributes = callOrReturn(config.getAttributes, void 0, match);
          if (attributes === false || attributes === null) {
            return null;
          }
          const { tr } = state2;
          const captureGroup = match[match.length - 1];
          const fullMatch = match[0];
          if (captureGroup) {
            const startSpaces = fullMatch.search(/\S/);
            const textStart = range2.from + fullMatch.indexOf(captureGroup);
            const textEnd = textStart + captureGroup.length;
            const excludedMarks = getMarksBetween(range2.from, range2.to, state2.doc).filter((item) => {
              const excluded = item.mark.type.excluded;
              return excluded.find((type2) => type2 === config.type && type2 !== item.mark.type);
            }).filter((item) => item.to > textStart);
            if (excludedMarks.length) {
              return null;
            }
            if (textEnd < range2.to) {
              tr.delete(textEnd, range2.to);
            }
            if (textStart > range2.from) {
              tr.delete(range2.from + startSpaces, textStart);
            }
            const markEnd = range2.from + startSpaces + captureGroup.length;
            tr.addMark(range2.from + startSpaces, markEnd, config.type.create(attributes || {}));
            tr.removeStoredMark(config.type);
          }
        },
        undoable: config.undoable
      });
    }
    function nodeInputRule(config) {
      return new InputRule({
        find: config.find,
        handler: ({ state: state2, range: range2, match }) => {
          const attributes = callOrReturn(config.getAttributes, void 0, match) || {};
          const { tr } = state2;
          const start = range2.from;
          let end = range2.to;
          const newNode = config.type.create(attributes);
          if (match[1]) {
            const offset = match[0].lastIndexOf(match[1]);
            let matchStart = start + offset;
            if (matchStart > end) {
              matchStart = end;
            } else {
              end = matchStart + match[1].length;
            }
            const lastChar = match[0][match[0].length - 1];
            tr.insertText(lastChar, start + match[0].length - 1);
            tr.replaceWith(matchStart, end, newNode);
          } else if (match[0]) {
            const insertionStart = config.type.isInline ? start : start - 1;
            tr.insert(insertionStart, config.type.create(attributes)).delete(tr.mapping.map(start), tr.mapping.map(end));
          }
          tr.scrollIntoView();
        },
        undoable: config.undoable
      });
    }
    function textblockTypeInputRule(config) {
      return new InputRule({
        find: config.find,
        handler: ({ state: state2, range: range2, match }) => {
          const $start = state2.doc.resolve(range2.from);
          const attributes = callOrReturn(config.getAttributes, void 0, match) || {};
          if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), config.type)) {
            return null;
          }
          state2.tr.delete(range2.from, range2.to).setBlockType(range2.from, range2.from, config.type, attributes);
        },
        undoable: config.undoable
      });
    }
    function textInputRule(config) {
      return new InputRule({
        find: config.find,
        handler: ({ state: state2, range: range2, match }) => {
          let insert = config.replace;
          let start = range2.from;
          const end = range2.to;
          if (match[1]) {
            const offset = match[0].lastIndexOf(match[1]);
            insert += match[0].slice(offset + match[1].length);
            start += offset;
            const cutOff = start - end;
            if (cutOff > 0) {
              insert = match[0].slice(offset - cutOff, offset) + insert;
              start = end;
            }
          }
          state2.tr.insertText(insert, start, end);
        },
        undoable: config.undoable
      });
    }
    var import_transform10 = require_transform();
    function wrappingInputRule(config) {
      return new InputRule({
        find: config.find,
        handler: ({ state: state2, range: range2, match, chain }) => {
          const attributes = callOrReturn(config.getAttributes, void 0, match) || {};
          const tr = state2.tr.delete(range2.from, range2.to);
          const $start = tr.doc.resolve(range2.from);
          const blockRange = $start.blockRange();
          const wrapping = blockRange && (0, import_transform10.findWrapping)(blockRange, config.type, attributes);
          if (!wrapping) {
            return null;
          }
          tr.wrap(blockRange, wrapping);
          if (config.keepMarks && config.editor) {
            const { selection, storedMarks } = state2;
            const { splittableMarks } = config.editor.extensionManager;
            const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
            if (marks) {
              const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
              tr.ensureMarks(filteredMarks);
            }
          }
          if (config.keepAttributes) {
            const nodeType = config.type.name === "bulletList" || config.type.name === "orderedList" ? "listItem" : "taskList";
            chain().updateAttributes(nodeType, attributes).run();
          }
          const before = tr.doc.resolve(range2.from - 1).nodeBefore;
          if (before && before.type === config.type && (0, import_transform10.canJoin)(tr.doc, range2.from - 1) && (!config.joinPredicate || config.joinPredicate(match, before))) {
            tr.join(range2.from - 1);
          }
        },
        undoable: config.undoable
      });
    }
    function Fragment6(props) {
      return props.children;
    }
    var h = (tag, attributes) => {
      if (tag === "slot") {
        return 0;
      }
      if (tag instanceof Function) {
        return tag(attributes);
      }
      const { children, ...rest } = attributes != null ? attributes : {};
      if (tag === "svg") {
        throw new Error("SVG elements are not supported in the JSX syntax, use the array syntax instead");
      }
      return [tag, rest, children];
    };
    var isTouchEvent = (e) => {
      return "touches" in e;
    };
    var ResizableNodeView = class {
      /**
       * Creates a new ResizableNodeView instance.
       *
       * The constructor sets up the resize handles, applies initial sizing from
       * node attributes, and configures all resize behavior options.
       *
       * @param options - Configuration options for the resizable node view
       */
      constructor(options) {
        this.directions = ["bottom-left", "bottom-right", "top-left", "top-right"];
        this.minSize = {
          height: 8,
          width: 8
        };
        this.preserveAspectRatio = false;
        this.classNames = {
          container: "",
          wrapper: "",
          handle: "",
          resizing: ""
        };
        this.initialWidth = 0;
        this.initialHeight = 0;
        this.aspectRatio = 1;
        this.isResizing = false;
        this.activeHandle = null;
        this.startX = 0;
        this.startY = 0;
        this.startWidth = 0;
        this.startHeight = 0;
        this.isShiftKeyPressed = false;
        this.handleMouseMove = (event) => {
          if (!this.isResizing || !this.activeHandle) {
            return;
          }
          const deltaX = event.clientX - this.startX;
          const deltaY = event.clientY - this.startY;
          this.handleResize(deltaX, deltaY);
        };
        this.handleTouchMove = (event) => {
          if (!this.isResizing || !this.activeHandle) {
            return;
          }
          const touch = event.touches[0];
          if (!touch) {
            return;
          }
          const deltaX = touch.clientX - this.startX;
          const deltaY = touch.clientY - this.startY;
          this.handleResize(deltaX, deltaY);
        };
        this.handleMouseUp = () => {
          if (!this.isResizing) {
            return;
          }
          const finalWidth = this.element.offsetWidth;
          const finalHeight = this.element.offsetHeight;
          this.onCommit(finalWidth, finalHeight);
          this.isResizing = false;
          this.activeHandle = null;
          this.container.dataset.resizeState = "false";
          if (this.classNames.resizing) {
            this.container.classList.remove(this.classNames.resizing);
          }
          document.removeEventListener("mousemove", this.handleMouseMove);
          document.removeEventListener("mouseup", this.handleMouseUp);
          document.removeEventListener("keydown", this.handleKeyDown);
          document.removeEventListener("keyup", this.handleKeyUp);
        };
        this.handleKeyDown = (event) => {
          if (event.key === "Shift") {
            this.isShiftKeyPressed = true;
          }
        };
        this.handleKeyUp = (event) => {
          if (event.key === "Shift") {
            this.isShiftKeyPressed = false;
          }
        };
        var _a, _b, _c, _d, _e;
        this.node = options.node;
        this.element = options.element;
        this.contentElement = options.contentElement;
        this.getPos = options.getPos;
        this.onResize = options.onResize;
        this.onCommit = options.onCommit;
        this.onUpdate = options.onUpdate;
        if ((_a = options.options) == null ? void 0 : _a.min) {
          this.minSize = {
            ...this.minSize,
            ...options.options.min
          };
        }
        if ((_b = options.options) == null ? void 0 : _b.max) {
          this.maxSize = options.options.max;
        }
        if ((_c = options == null ? void 0 : options.options) == null ? void 0 : _c.directions) {
          this.directions = options.options.directions;
        }
        if ((_d = options.options) == null ? void 0 : _d.preserveAspectRatio) {
          this.preserveAspectRatio = options.options.preserveAspectRatio;
        }
        if ((_e = options.options) == null ? void 0 : _e.className) {
          this.classNames = {
            container: options.options.className.container || "",
            wrapper: options.options.className.wrapper || "",
            handle: options.options.className.handle || "",
            resizing: options.options.className.resizing || ""
          };
        }
        this.wrapper = this.createWrapper();
        this.container = this.createContainer();
        this.applyInitialSize();
        this.attachHandles();
      }
      /**
       * Returns the top-level DOM node that should be placed in the editor.
       *
       * This is required by the ProseMirror NodeView interface. The container
       * includes the wrapper, handles, and the actual content element.
       *
       * @returns The container element to be inserted into the editor
       */
      get dom() {
        return this.container;
      }
      get contentDOM() {
        return this.contentElement;
      }
      /**
       * Called when the node's content or attributes change.
       *
       * Updates the internal node reference. If a custom `onUpdate` callback
       * was provided, it will be called to handle additional update logic.
       *
       * @param node - The new/updated node
       * @param decorations - Node decorations
       * @param innerDecorations - Inner decorations
       * @returns `false` if the node type has changed (requires full rebuild), otherwise the result of `onUpdate` or `true`
       */
      update(node, decorations, innerDecorations) {
        if (node.type !== this.node.type) {
          return false;
        }
        this.node = node;
        if (this.onUpdate) {
          return this.onUpdate(node, decorations, innerDecorations);
        }
        return true;
      }
      /**
       * Cleanup method called when the node view is being removed.
       *
       * Removes all event listeners to prevent memory leaks. This is required
       * by the ProseMirror NodeView interface. If a resize is active when
       * destroy is called, it will be properly cancelled.
       */
      destroy() {
        if (this.isResizing) {
          this.container.dataset.resizeState = "false";
          if (this.classNames.resizing) {
            this.container.classList.remove(this.classNames.resizing);
          }
          document.removeEventListener("mousemove", this.handleMouseMove);
          document.removeEventListener("mouseup", this.handleMouseUp);
          document.removeEventListener("keydown", this.handleKeyDown);
          document.removeEventListener("keyup", this.handleKeyUp);
          this.isResizing = false;
          this.activeHandle = null;
        }
        this.container.remove();
      }
      /**
       * Creates the outer container element.
       *
       * The container is the top-level element returned by the NodeView and
       * wraps the entire resizable node. It's set up with flexbox to handle
       * alignment and includes data attributes for styling and identification.
       *
       * @returns The container element
       */
      createContainer() {
        const element = document.createElement("div");
        element.dataset.resizeContainer = "";
        element.dataset.node = this.node.type.name;
        element.style.display = "flex";
        element.style.justifyContent = "flex-start";
        element.style.alignItems = "flex-start";
        if (this.classNames.container) {
          element.className = this.classNames.container;
        }
        element.appendChild(this.wrapper);
        return element;
      }
      /**
       * Creates the wrapper element that contains the content and handles.
       *
       * The wrapper uses relative positioning so that resize handles can be
       * positioned absolutely within it. This is the direct parent of the
       * content element being made resizable.
       *
       * @returns The wrapper element
       */
      createWrapper() {
        const element = document.createElement("div");
        element.style.position = "relative";
        element.style.display = "block";
        element.dataset.resizeWrapper = "";
        if (this.classNames.wrapper) {
          element.className = this.classNames.wrapper;
        }
        element.appendChild(this.element);
        return element;
      }
      /**
       * Creates a resize handle element for a specific direction.
       *
       * Each handle is absolutely positioned and includes a data attribute
       * identifying its direction for styling purposes.
       *
       * @param direction - The resize direction for this handle
       * @returns The handle element
       */
      createHandle(direction) {
        const handle = document.createElement("div");
        handle.dataset.resizeHandle = direction;
        handle.style.position = "absolute";
        if (this.classNames.handle) {
          handle.className = this.classNames.handle;
        }
        return handle;
      }
      /**
       * Positions a handle element according to its direction.
       *
       * Corner handles (e.g., 'top-left') are positioned at the intersection
       * of two edges. Edge handles (e.g., 'top') span the full width or height.
       *
       * @param handle - The handle element to position
       * @param direction - The direction determining the position
       */
      positionHandle(handle, direction) {
        const isTop = direction.includes("top");
        const isBottom = direction.includes("bottom");
        const isLeft = direction.includes("left");
        const isRight = direction.includes("right");
        if (isTop) {
          handle.style.top = "0";
        }
        if (isBottom) {
          handle.style.bottom = "0";
        }
        if (isLeft) {
          handle.style.left = "0";
        }
        if (isRight) {
          handle.style.right = "0";
        }
        if (direction === "top" || direction === "bottom") {
          handle.style.left = "0";
          handle.style.right = "0";
        }
        if (direction === "left" || direction === "right") {
          handle.style.top = "0";
          handle.style.bottom = "0";
        }
      }
      /**
       * Creates and attaches all resize handles to the wrapper.
       *
       * Iterates through the configured directions, creates a handle for each,
       * positions it, attaches the mousedown listener, and appends it to the DOM.
       */
      attachHandles() {
        this.directions.forEach((direction) => {
          const handle = this.createHandle(direction);
          this.positionHandle(handle, direction);
          handle.addEventListener("mousedown", (event) => this.handleResizeStart(event, direction));
          handle.addEventListener("touchstart", (event) => this.handleResizeStart(event, direction));
          this.wrapper.appendChild(handle);
        });
      }
      /**
       * Applies initial sizing from node attributes to the element.
       *
       * If width/height attributes exist on the node, they're applied to the element.
       * Otherwise, the element's natural/current dimensions are measured. The aspect
       * ratio is calculated for later use in aspect-ratio-preserving resizes.
       */
      applyInitialSize() {
        const width = this.node.attrs.width;
        const height = this.node.attrs.height;
        if (width) {
          this.element.style.width = `${width}px`;
          this.initialWidth = width;
        } else {
          this.initialWidth = this.element.offsetWidth;
        }
        if (height) {
          this.element.style.height = `${height}px`;
          this.initialHeight = height;
        } else {
          this.initialHeight = this.element.offsetHeight;
        }
        if (this.initialWidth > 0 && this.initialHeight > 0) {
          this.aspectRatio = this.initialWidth / this.initialHeight;
        }
      }
      /**
       * Initiates a resize operation when a handle is clicked.
       *
       * Captures the starting mouse position and element dimensions, sets up
       * the resize state, adds the resizing class and state attribute, and
       * attaches document-level listeners for mouse movement and keyboard input.
       *
       * @param event - The mouse down event
       * @param direction - The direction of the handle being dragged
       */
      handleResizeStart(event, direction) {
        event.preventDefault();
        event.stopPropagation();
        this.isResizing = true;
        this.activeHandle = direction;
        if (isTouchEvent(event)) {
          this.startX = event.touches[0].clientX;
          this.startY = event.touches[0].clientY;
        } else {
          this.startX = event.clientX;
          this.startY = event.clientY;
        }
        this.startWidth = this.element.offsetWidth;
        this.startHeight = this.element.offsetHeight;
        if (this.startWidth > 0 && this.startHeight > 0) {
          this.aspectRatio = this.startWidth / this.startHeight;
        }
        const pos = this.getPos();
        if (pos !== void 0) {
        }
        this.container.dataset.resizeState = "true";
        if (this.classNames.resizing) {
          this.container.classList.add(this.classNames.resizing);
        }
        document.addEventListener("mousemove", this.handleMouseMove);
        document.addEventListener("touchmove", this.handleTouchMove);
        document.addEventListener("mouseup", this.handleMouseUp);
        document.addEventListener("keydown", this.handleKeyDown);
        document.addEventListener("keyup", this.handleKeyUp);
      }
      handleResize(deltaX, deltaY) {
        if (!this.activeHandle) {
          return;
        }
        const shouldPreserveAspectRatio = this.preserveAspectRatio || this.isShiftKeyPressed;
        const { width, height } = this.calculateNewDimensions(this.activeHandle, deltaX, deltaY);
        const constrained = this.applyConstraints(width, height, shouldPreserveAspectRatio);
        this.element.style.width = `${constrained.width}px`;
        this.element.style.height = `${constrained.height}px`;
        if (this.onResize) {
          this.onResize(constrained.width, constrained.height);
        }
      }
      /**
       * Calculates new dimensions based on mouse delta and resize direction.
       *
       * Takes the starting dimensions and applies the mouse movement delta
       * according to the handle direction. For corner handles, both dimensions
       * are affected. For edge handles, only one dimension changes. If aspect
       * ratio should be preserved, delegates to applyAspectRatio.
       *
       * @param direction - The active resize handle direction
       * @param deltaX - Horizontal mouse movement since resize start
       * @param deltaY - Vertical mouse movement since resize start
       * @returns The calculated width and height
       */
      calculateNewDimensions(direction, deltaX, deltaY) {
        let newWidth = this.startWidth;
        let newHeight = this.startHeight;
        const isRight = direction.includes("right");
        const isLeft = direction.includes("left");
        const isBottom = direction.includes("bottom");
        const isTop = direction.includes("top");
        if (isRight) {
          newWidth = this.startWidth + deltaX;
        } else if (isLeft) {
          newWidth = this.startWidth - deltaX;
        }
        if (isBottom) {
          newHeight = this.startHeight + deltaY;
        } else if (isTop) {
          newHeight = this.startHeight - deltaY;
        }
        if (direction === "right" || direction === "left") {
          newWidth = this.startWidth + (isRight ? deltaX : -deltaX);
        }
        if (direction === "top" || direction === "bottom") {
          newHeight = this.startHeight + (isBottom ? deltaY : -deltaY);
        }
        const shouldPreserveAspectRatio = this.preserveAspectRatio || this.isShiftKeyPressed;
        if (shouldPreserveAspectRatio) {
          return this.applyAspectRatio(newWidth, newHeight, direction);
        }
        return { width: newWidth, height: newHeight };
      }
      /**
       * Applies min/max constraints to dimensions.
       *
       * When aspect ratio is NOT preserved, constraints are applied independently
       * to width and height. When aspect ratio IS preserved, constraints are
       * applied while maintaining the aspect ratio—if one dimension hits a limit,
       * the other is recalculated proportionally.
       *
       * This ensures that aspect ratio is never broken when constrained.
       *
       * @param width - The unconstrained width
       * @param height - The unconstrained height
       * @param preserveAspectRatio - Whether to maintain aspect ratio while constraining
       * @returns The constrained dimensions
       */
      applyConstraints(width, height, preserveAspectRatio) {
        var _a, _b, _c, _d;
        if (!preserveAspectRatio) {
          let constrainedWidth2 = Math.max(this.minSize.width, width);
          let constrainedHeight2 = Math.max(this.minSize.height, height);
          if ((_a = this.maxSize) == null ? void 0 : _a.width) {
            constrainedWidth2 = Math.min(this.maxSize.width, constrainedWidth2);
          }
          if ((_b = this.maxSize) == null ? void 0 : _b.height) {
            constrainedHeight2 = Math.min(this.maxSize.height, constrainedHeight2);
          }
          return { width: constrainedWidth2, height: constrainedHeight2 };
        }
        let constrainedWidth = width;
        let constrainedHeight = height;
        if (constrainedWidth < this.minSize.width) {
          constrainedWidth = this.minSize.width;
          constrainedHeight = constrainedWidth / this.aspectRatio;
        }
        if (constrainedHeight < this.minSize.height) {
          constrainedHeight = this.minSize.height;
          constrainedWidth = constrainedHeight * this.aspectRatio;
        }
        if (((_c = this.maxSize) == null ? void 0 : _c.width) && constrainedWidth > this.maxSize.width) {
          constrainedWidth = this.maxSize.width;
          constrainedHeight = constrainedWidth / this.aspectRatio;
        }
        if (((_d = this.maxSize) == null ? void 0 : _d.height) && constrainedHeight > this.maxSize.height) {
          constrainedHeight = this.maxSize.height;
          constrainedWidth = constrainedHeight * this.aspectRatio;
        }
        return { width: constrainedWidth, height: constrainedHeight };
      }
      /**
       * Adjusts dimensions to maintain the original aspect ratio.
       *
       * For horizontal handles (left/right), uses width as the primary dimension
       * and calculates height from it. For vertical handles (top/bottom), uses
       * height as primary and calculates width. For corner handles, uses width
       * as the primary dimension.
       *
       * @param width - The new width
       * @param height - The new height
       * @param direction - The active resize direction
       * @returns Dimensions adjusted to preserve aspect ratio
       */
      applyAspectRatio(width, height, direction) {
        const isHorizontal = direction === "left" || direction === "right";
        const isVertical = direction === "top" || direction === "bottom";
        if (isHorizontal) {
          return {
            width,
            height: width / this.aspectRatio
          };
        }
        if (isVertical) {
          return {
            width: height * this.aspectRatio,
            height
          };
        }
        return {
          width,
          height: width / this.aspectRatio
        };
      }
    };
    var ResizableNodeview = ResizableNodeView;
    var import_state23 = require_state();
    function canInsertNode(state2, nodeType) {
      const { selection } = state2;
      const { $from } = selection;
      if (selection instanceof import_state23.NodeSelection) {
        const index = $from.index();
        const parent = $from.parent;
        return parent.canReplaceWith(index, index + 1, nodeType);
      }
      let depth = $from.depth;
      while (depth >= 0) {
        const index = $from.index(depth);
        const parent = $from.node(depth);
        const match = parent.contentMatchAt(index);
        if (match.matchType(nodeType)) {
          return true;
        }
        depth -= 1;
      }
      return false;
    }
    function escapeForRegEx(string) {
      return string.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
    }
    function isString(value) {
      return typeof value === "string";
    }
    var markdown_exports = {};
    __export2(markdown_exports, {
      createAtomBlockMarkdownSpec: () => createAtomBlockMarkdownSpec,
      createBlockMarkdownSpec: () => createBlockMarkdownSpec,
      createInlineMarkdownSpec: () => createInlineMarkdownSpec,
      parseAttributes: () => parseAttributes,
      parseIndentedBlocks: () => parseIndentedBlocks,
      renderNestedMarkdownContent: () => renderNestedMarkdownContent,
      serializeAttributes: () => serializeAttributes
    });
    function parseAttributes(attrString) {
      if (!(attrString == null ? void 0 : attrString.trim())) {
        return {};
      }
      const attributes = {};
      const quotedStrings = [];
      const tempString = attrString.replace(/["']([^"']*)["']/g, (match) => {
        quotedStrings.push(match);
        return `__QUOTED_${quotedStrings.length - 1}__`;
      });
      const classMatches = tempString.match(/(?:^|\s)\.([a-zA-Z][\w-]*)/g);
      if (classMatches) {
        const classes = classMatches.map((match) => match.trim().slice(1));
        attributes.class = classes.join(" ");
      }
      const idMatch = tempString.match(/(?:^|\s)#([a-zA-Z][\w-]*)/);
      if (idMatch) {
        attributes.id = idMatch[1];
      }
      const kvRegex = /([a-zA-Z][\w-]*)\s*=\s*(__QUOTED_\d+__)/g;
      const kvMatches = Array.from(tempString.matchAll(kvRegex));
      kvMatches.forEach(([, key, quotedRef]) => {
        var _a;
        const quotedIndex = parseInt(((_a = quotedRef.match(/__QUOTED_(\d+)__/)) == null ? void 0 : _a[1]) || "0", 10);
        const quotedValue = quotedStrings[quotedIndex];
        if (quotedValue) {
          attributes[key] = quotedValue.slice(1, -1);
        }
      });
      const cleanString = tempString.replace(/(?:^|\s)\.([a-zA-Z][\w-]*)/g, "").replace(/(?:^|\s)#([a-zA-Z][\w-]*)/g, "").replace(/([a-zA-Z][\w-]*)\s*=\s*__QUOTED_\d+__/g, "").trim();
      if (cleanString) {
        const booleanAttrs = cleanString.split(/\s+/).filter(Boolean);
        booleanAttrs.forEach((attr) => {
          if (attr.match(/^[a-zA-Z][\w-]*$/)) {
            attributes[attr] = true;
          }
        });
      }
      return attributes;
    }
    function serializeAttributes(attributes) {
      if (!attributes || Object.keys(attributes).length === 0) {
        return "";
      }
      const parts = [];
      if (attributes.class) {
        const classes = String(attributes.class).split(/\s+/).filter(Boolean);
        classes.forEach((cls) => parts.push(`.${cls}`));
      }
      if (attributes.id) {
        parts.push(`#${attributes.id}`);
      }
      Object.entries(attributes).forEach(([key, value]) => {
        if (key === "class" || key === "id") {
          return;
        }
        if (value === true) {
          parts.push(key);
        } else if (value !== false && value != null) {
          parts.push(`${key}="${String(value)}"`);
        }
      });
      return parts.join(" ");
    }
    function createAtomBlockMarkdownSpec(options) {
      const {
        nodeName,
        name: markdownName,
        parseAttributes: parseAttributes2 = parseAttributes,
        serializeAttributes: serializeAttributes2 = serializeAttributes,
        defaultAttributes = {},
        requiredAttributes = [],
        allowedAttributes
      } = options;
      const blockName = markdownName || nodeName;
      const filterAttributes = (attrs) => {
        if (!allowedAttributes) {
          return attrs;
        }
        const filtered = {};
        allowedAttributes.forEach((key) => {
          if (key in attrs) {
            filtered[key] = attrs[key];
          }
        });
        return filtered;
      };
      return {
        parseMarkdown: (token, h2) => {
          const attrs = { ...defaultAttributes, ...token.attributes };
          return h2.createNode(nodeName, attrs, []);
        },
        markdownTokenizer: {
          name: nodeName,
          level: "block",
          start(src) {
            var _a;
            const regex = new RegExp(`^:::${blockName}(?:\\s|$)`, "m");
            const index = (_a = src.match(regex)) == null ? void 0 : _a.index;
            return index !== void 0 ? index : -1;
          },
          tokenize(src, _tokens, _lexer) {
            const regex = new RegExp(`^:::${blockName}(?:\\s+\\{([^}]*)\\})?\\s*:::(?:\\n|$)`);
            const match = src.match(regex);
            if (!match) {
              return void 0;
            }
            const attrString = match[1] || "";
            const attributes = parseAttributes2(attrString);
            const missingRequired = requiredAttributes.find((required) => !(required in attributes));
            if (missingRequired) {
              return void 0;
            }
            return {
              type: nodeName,
              raw: match[0],
              attributes
            };
          }
        },
        renderMarkdown: (node) => {
          const filteredAttrs = filterAttributes(node.attrs || {});
          const attrs = serializeAttributes2(filteredAttrs);
          const attrString = attrs ? ` {${attrs}}` : "";
          return `:::${blockName}${attrString} :::`;
        }
      };
    }
    function createBlockMarkdownSpec(options) {
      const {
        nodeName,
        name: markdownName,
        getContent,
        parseAttributes: parseAttributes2 = parseAttributes,
        serializeAttributes: serializeAttributes2 = serializeAttributes,
        defaultAttributes = {},
        content = "block",
        allowedAttributes
      } = options;
      const blockName = markdownName || nodeName;
      const filterAttributes = (attrs) => {
        if (!allowedAttributes) {
          return attrs;
        }
        const filtered = {};
        allowedAttributes.forEach((key) => {
          if (key in attrs) {
            filtered[key] = attrs[key];
          }
        });
        return filtered;
      };
      return {
        parseMarkdown: (token, h2) => {
          let nodeContent;
          if (getContent) {
            const contentResult = getContent(token);
            nodeContent = typeof contentResult === "string" ? [{ type: "text", text: contentResult }] : contentResult;
          } else if (content === "block") {
            nodeContent = h2.parseChildren(token.tokens || []);
          } else {
            nodeContent = h2.parseInline(token.tokens || []);
          }
          const attrs = { ...defaultAttributes, ...token.attributes };
          return h2.createNode(nodeName, attrs, nodeContent);
        },
        markdownTokenizer: {
          name: nodeName,
          level: "block",
          start(src) {
            var _a;
            const regex = new RegExp(`^:::${blockName}`, "m");
            const index = (_a = src.match(regex)) == null ? void 0 : _a.index;
            return index !== void 0 ? index : -1;
          },
          tokenize(src, _tokens, lexer) {
            var _a;
            const openingRegex = new RegExp(`^:::${blockName}(?:\\s+\\{([^}]*)\\})?\\s*\\n`);
            const openingMatch = src.match(openingRegex);
            if (!openingMatch) {
              return void 0;
            }
            const [openingTag, attrString = ""] = openingMatch;
            const attributes = parseAttributes2(attrString);
            let level = 1;
            const position = openingTag.length;
            let matchedContent = "";
            const blockPattern = /^:::([\w-]*)(\s.*)?/gm;
            const remaining = src.slice(position);
            blockPattern.lastIndex = 0;
            for (; ; ) {
              const match = blockPattern.exec(remaining);
              if (match === null) {
                break;
              }
              const matchPos = match.index;
              const blockType = match[1];
              if ((_a = match[2]) == null ? void 0 : _a.endsWith(":::")) {
                continue;
              }
              if (blockType) {
                level += 1;
              } else {
                level -= 1;
                if (level === 0) {
                  const rawContent = remaining.slice(0, matchPos);
                  matchedContent = rawContent.trim();
                  const fullMatch = src.slice(0, position + matchPos + match[0].length);
                  let contentTokens = [];
                  if (matchedContent) {
                    if (content === "block") {
                      contentTokens = lexer.blockTokens(rawContent);
                      contentTokens.forEach((token) => {
                        if (token.text && (!token.tokens || token.tokens.length === 0)) {
                          token.tokens = lexer.inlineTokens(token.text);
                        }
                      });
                      while (contentTokens.length > 0) {
                        const lastToken = contentTokens[contentTokens.length - 1];
                        if (lastToken.type === "paragraph" && (!lastToken.text || lastToken.text.trim() === "")) {
                          contentTokens.pop();
                        } else {
                          break;
                        }
                      }
                    } else {
                      contentTokens = lexer.inlineTokens(matchedContent);
                    }
                  }
                  return {
                    type: nodeName,
                    raw: fullMatch,
                    attributes,
                    content: matchedContent,
                    tokens: contentTokens
                  };
                }
              }
            }
            return void 0;
          }
        },
        renderMarkdown: (node, h2) => {
          const filteredAttrs = filterAttributes(node.attrs || {});
          const attrs = serializeAttributes2(filteredAttrs);
          const attrString = attrs ? ` {${attrs}}` : "";
          const renderedContent = h2.renderChildren(node.content || [], "\n\n");
          return `:::${blockName}${attrString}

${renderedContent}

:::`;
        }
      };
    }
    function parseShortcodeAttributes(attrString) {
      if (!attrString.trim()) {
        return {};
      }
      const attributes = {};
      const regex = /(\w+)=(?:"([^"]*)"|'([^']*)')/g;
      let match = regex.exec(attrString);
      while (match !== null) {
        const [, key, doubleQuoted, singleQuoted] = match;
        attributes[key] = doubleQuoted || singleQuoted;
        match = regex.exec(attrString);
      }
      return attributes;
    }
    function serializeShortcodeAttributes(attrs) {
      return Object.entries(attrs).filter(([, value]) => value !== void 0 && value !== null).map(([key, value]) => `${key}="${value}"`).join(" ");
    }
    function createInlineMarkdownSpec(options) {
      const {
        nodeName,
        name: shortcodeName,
        getContent,
        parseAttributes: parseAttributes2 = parseShortcodeAttributes,
        serializeAttributes: serializeAttributes2 = serializeShortcodeAttributes,
        defaultAttributes = {},
        selfClosing = false,
        allowedAttributes
      } = options;
      const shortcode = shortcodeName || nodeName;
      const filterAttributes = (attrs) => {
        if (!allowedAttributes) {
          return attrs;
        }
        const filtered = {};
        allowedAttributes.forEach((key) => {
          if (key in attrs) {
            filtered[key] = attrs[key];
          }
        });
        return filtered;
      };
      const escapedShortcode = shortcode.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      return {
        parseMarkdown: (token, h2) => {
          const attrs = { ...defaultAttributes, ...token.attributes };
          if (selfClosing) {
            return h2.createNode(nodeName, attrs);
          }
          const content = getContent ? getContent(token) : token.content || "";
          if (content) {
            return h2.createNode(nodeName, attrs, [h2.createTextNode(content)]);
          }
          return h2.createNode(nodeName, attrs, []);
        },
        markdownTokenizer: {
          name: nodeName,
          level: "inline",
          start(src) {
            const startPattern = selfClosing ? new RegExp(`\\[${escapedShortcode}\\s*[^\\]]*\\]`) : new RegExp(`\\[${escapedShortcode}\\s*[^\\]]*\\][\\s\\S]*?\\[\\/${escapedShortcode}\\]`);
            const match = src.match(startPattern);
            const index = match == null ? void 0 : match.index;
            return index !== void 0 ? index : -1;
          },
          tokenize(src, _tokens, _lexer) {
            const tokenPattern = selfClosing ? new RegExp(`^\\[${escapedShortcode}\\s*([^\\]]*)\\]`) : new RegExp(`^\\[${escapedShortcode}\\s*([^\\]]*)\\]([\\s\\S]*?)\\[\\/${escapedShortcode}\\]`);
            const match = src.match(tokenPattern);
            if (!match) {
              return void 0;
            }
            let content = "";
            let attrString = "";
            if (selfClosing) {
              const [, attrs] = match;
              attrString = attrs;
            } else {
              const [, attrs, contentMatch] = match;
              attrString = attrs;
              content = contentMatch || "";
            }
            const attributes = parseAttributes2(attrString.trim());
            return {
              type: nodeName,
              raw: match[0],
              content: content.trim(),
              attributes
            };
          }
        },
        renderMarkdown: (node) => {
          let content = "";
          if (getContent) {
            content = getContent(node);
          } else if (node.content && node.content.length > 0) {
            content = node.content.filter((child) => child.type === "text").map((child) => child.text).join("");
          }
          const filteredAttrs = filterAttributes(node.attrs || {});
          const attrs = serializeAttributes2(filteredAttrs);
          const attrString = attrs ? ` ${attrs}` : "";
          if (selfClosing) {
            return `[${shortcode}${attrString}]`;
          }
          return `[${shortcode}${attrString}]${content}[/${shortcode}]`;
        }
      };
    }
    function parseIndentedBlocks(src, config, lexer) {
      var _a, _b, _c, _d;
      const lines = src.split("\n");
      const items = [];
      let totalRaw = "";
      let i = 0;
      const baseIndentSize = config.baseIndentSize || 2;
      while (i < lines.length) {
        const currentLine = lines[i];
        const itemMatch = currentLine.match(config.itemPattern);
        if (!itemMatch) {
          if (items.length > 0) {
            break;
          } else if (currentLine.trim() === "") {
            i += 1;
            totalRaw = `${totalRaw}${currentLine}
`;
            continue;
          } else {
            return void 0;
          }
        }
        const itemData = config.extractItemData(itemMatch);
        const { indentLevel, mainContent } = itemData;
        totalRaw = `${totalRaw}${currentLine}
`;
        const itemContent = [mainContent];
        i += 1;
        while (i < lines.length) {
          const nextLine = lines[i];
          if (nextLine.trim() === "") {
            const nextNonEmptyIndex = lines.slice(i + 1).findIndex((l) => l.trim() !== "");
            if (nextNonEmptyIndex === -1) {
              break;
            }
            const nextNonEmpty = lines[i + 1 + nextNonEmptyIndex];
            const nextIndent2 = ((_b = (_a = nextNonEmpty.match(/^(\s*)/)) == null ? void 0 : _a[1]) == null ? void 0 : _b.length) || 0;
            if (nextIndent2 > indentLevel) {
              itemContent.push(nextLine);
              totalRaw = `${totalRaw}${nextLine}
`;
              i += 1;
              continue;
            } else {
              break;
            }
          }
          const nextIndent = ((_d = (_c = nextLine.match(/^(\s*)/)) == null ? void 0 : _c[1]) == null ? void 0 : _d.length) || 0;
          if (nextIndent > indentLevel) {
            itemContent.push(nextLine);
            totalRaw = `${totalRaw}${nextLine}
`;
            i += 1;
          } else {
            break;
          }
        }
        let nestedTokens;
        const nestedContent = itemContent.slice(1);
        if (nestedContent.length > 0) {
          const dedentedNested = nestedContent.map((nestedLine) => nestedLine.slice(indentLevel + baseIndentSize)).join("\n");
          if (dedentedNested.trim()) {
            if (config.customNestedParser) {
              nestedTokens = config.customNestedParser(dedentedNested);
            } else {
              nestedTokens = lexer.blockTokens(dedentedNested);
            }
          }
        }
        const token = config.createToken(itemData, nestedTokens);
        items.push(token);
      }
      if (items.length === 0) {
        return void 0;
      }
      return {
        items,
        raw: totalRaw
      };
    }
    function renderNestedMarkdownContent(node, h2, prefixOrGenerator, ctx) {
      if (!node || !Array.isArray(node.content)) {
        return "";
      }
      const prefix = typeof prefixOrGenerator === "function" ? prefixOrGenerator(ctx) : prefixOrGenerator;
      const [content, ...children] = node.content;
      const mainContent = h2.renderChildren([content]);
      const output = [`${prefix}${mainContent}`];
      if (children && children.length > 0) {
        children.forEach((child) => {
          const childContent = h2.renderChildren([child]);
          if (childContent) {
            const indentedChild = childContent.split("\n").map((line) => line ? h2.indent(line) : "").join("\n");
            output.push(indentedChild);
          }
        });
      }
      return output.join("\n");
    }
    function updateMarkViewAttributes(checkMark, editor, attrs = {}) {
      const { state: state2 } = editor;
      const { doc, tr } = state2;
      const thisMark = checkMark;
      doc.descendants((node, pos) => {
        const from = tr.mapping.map(pos);
        const to = tr.mapping.map(pos) + node.nodeSize;
        let foundMark = null;
        node.marks.forEach((mark) => {
          if (mark !== thisMark) {
            return false;
          }
          foundMark = mark;
        });
        if (!foundMark) {
          return;
        }
        let needsUpdate = false;
        Object.keys(attrs).forEach((k) => {
          if (attrs[k] !== foundMark.attrs[k]) {
            needsUpdate = true;
          }
        });
        if (needsUpdate) {
          const updatedMark = checkMark.type.create({
            ...checkMark.attrs,
            ...attrs
          });
          tr.removeMark(from, to, checkMark.type);
          tr.addMark(from, to, updatedMark);
        }
      });
      if (tr.docChanged) {
        editor.view.dispatch(tr);
      }
    }
    var MarkView = class {
      constructor(component, props, options) {
        this.component = component;
        this.editor = props.editor;
        this.options = { ...options };
        this.mark = props.mark;
        this.HTMLAttributes = props.HTMLAttributes;
      }
      get dom() {
        return this.editor.view.dom;
      }
      get contentDOM() {
        return null;
      }
      /**
       * Update the attributes of the mark in the document.
       * @param attrs The attributes to update.
       */
      updateAttributes(attrs, checkMark) {
        updateMarkViewAttributes(checkMark || this.mark, this.editor, attrs);
      }
      ignoreMutation(mutation) {
        if (!this.dom || !this.contentDOM) {
          return true;
        }
        if (typeof this.options.ignoreMutation === "function") {
          return this.options.ignoreMutation({ mutation });
        }
        if (mutation.type === "selection") {
          return false;
        }
        if (this.dom.contains(mutation.target) && mutation.type === "childList" && (isiOS() || isAndroid()) && this.editor.isFocused) {
          const changedNodes = [...Array.from(mutation.addedNodes), ...Array.from(mutation.removedNodes)];
          if (changedNodes.every((node) => node.isContentEditable)) {
            return false;
          }
        }
        if (this.contentDOM === mutation.target && mutation.type === "attributes") {
          return true;
        }
        if (this.contentDOM.contains(mutation.target)) {
          return false;
        }
        return true;
      }
    };
    var Node3 = class _Node extends Extendable {
      constructor() {
        super(...arguments);
        this.type = "node";
      }
      /**
       * Create a new Node instance
       * @param config - Node configuration object or a function that returns a configuration object
       */
      static create(config = {}) {
        const resolvedConfig = typeof config === "function" ? config() : config;
        return new _Node(resolvedConfig);
      }
      configure(options) {
        return super.configure(options);
      }
      extend(extendedConfig) {
        const resolvedConfig = typeof extendedConfig === "function" ? extendedConfig() : extendedConfig;
        return super.extend(resolvedConfig);
      }
    };
    var import_state24 = require_state();
    var NodeView = class {
      constructor(component, props, options) {
        this.isDragging = false;
        this.component = component;
        this.editor = props.editor;
        this.options = {
          stopEvent: null,
          ignoreMutation: null,
          ...options
        };
        this.extension = props.extension;
        this.node = props.node;
        this.decorations = props.decorations;
        this.innerDecorations = props.innerDecorations;
        this.view = props.view;
        this.HTMLAttributes = props.HTMLAttributes;
        this.getPos = props.getPos;
        this.mount();
      }
      mount() {
        return;
      }
      get dom() {
        return this.editor.view.dom;
      }
      get contentDOM() {
        return null;
      }
      onDragStart(event) {
        var _a, _b, _c, _d, _e, _f, _g;
        const { view } = this.editor;
        const target = event.target;
        const dragHandle = target.nodeType === 3 ? (_a = target.parentElement) == null ? void 0 : _a.closest("[data-drag-handle]") : target.closest("[data-drag-handle]");
        if (!this.dom || ((_b = this.contentDOM) == null ? void 0 : _b.contains(target)) || !dragHandle) {
          return;
        }
        let x = 0;
        let y = 0;
        if (this.dom !== dragHandle) {
          const domBox = this.dom.getBoundingClientRect();
          const handleBox = dragHandle.getBoundingClientRect();
          const offsetX = (_d = event.offsetX) != null ? _d : (_c = event.nativeEvent) == null ? void 0 : _c.offsetX;
          const offsetY = (_f = event.offsetY) != null ? _f : (_e = event.nativeEvent) == null ? void 0 : _e.offsetY;
          x = handleBox.x - domBox.x + offsetX;
          y = handleBox.y - domBox.y + offsetY;
        }
        const clonedNode = this.dom.cloneNode(true);
        try {
          const domBox = this.dom.getBoundingClientRect();
          clonedNode.style.width = `${Math.round(domBox.width)}px`;
          clonedNode.style.height = `${Math.round(domBox.height)}px`;
          clonedNode.style.boxSizing = "border-box";
          clonedNode.style.pointerEvents = "none";
        } catch {
        }
        let dragImageWrapper = null;
        try {
          dragImageWrapper = document.createElement("div");
          dragImageWrapper.style.position = "absolute";
          dragImageWrapper.style.top = "-9999px";
          dragImageWrapper.style.left = "-9999px";
          dragImageWrapper.style.pointerEvents = "none";
          dragImageWrapper.appendChild(clonedNode);
          document.body.appendChild(dragImageWrapper);
          (_g = event.dataTransfer) == null ? void 0 : _g.setDragImage(clonedNode, x, y);
        } finally {
          if (dragImageWrapper) {
            setTimeout(() => {
              try {
                dragImageWrapper == null ? void 0 : dragImageWrapper.remove();
              } catch {
              }
            }, 0);
          }
        }
        const pos = this.getPos();
        if (typeof pos !== "number") {
          return;
        }
        const selection = import_state24.NodeSelection.create(view.state.doc, pos);
        const transaction = view.state.tr.setSelection(selection);
        view.dispatch(transaction);
      }
      stopEvent(event) {
        var _a;
        if (!this.dom) {
          return false;
        }
        if (typeof this.options.stopEvent === "function") {
          return this.options.stopEvent({ event });
        }
        const target = event.target;
        const isInElement = this.dom.contains(target) && !((_a = this.contentDOM) == null ? void 0 : _a.contains(target));
        if (!isInElement) {
          return false;
        }
        const isDragEvent = event.type.startsWith("drag");
        const isDropEvent = event.type === "drop";
        const isInput = ["INPUT", "BUTTON", "SELECT", "TEXTAREA"].includes(target.tagName) || target.isContentEditable;
        if (isInput && !isDropEvent && !isDragEvent) {
          return true;
        }
        const { isEditable } = this.editor;
        const { isDragging } = this;
        const isDraggable = !!this.node.type.spec.draggable;
        const isSelectable = import_state24.NodeSelection.isSelectable(this.node);
        const isCopyEvent = event.type === "copy";
        const isPasteEvent = event.type === "paste";
        const isCutEvent = event.type === "cut";
        const isClickEvent = event.type === "mousedown";
        if (!isDraggable && isSelectable && isDragEvent && event.target === this.dom) {
          event.preventDefault();
        }
        if (isDraggable && isDragEvent && !isDragging && event.target === this.dom) {
          event.preventDefault();
          return false;
        }
        if (isDraggable && isEditable && !isDragging && isClickEvent) {
          const dragHandle = target.closest("[data-drag-handle]");
          const isValidDragHandle = dragHandle && (this.dom === dragHandle || this.dom.contains(dragHandle));
          if (isValidDragHandle) {
            this.isDragging = true;
            document.addEventListener(
              "dragend",
              () => {
                this.isDragging = false;
              },
              { once: true }
            );
            document.addEventListener(
              "drop",
              () => {
                this.isDragging = false;
              },
              { once: true }
            );
            document.addEventListener(
              "mouseup",
              () => {
                this.isDragging = false;
              },
              { once: true }
            );
          }
        }
        if (isDragging || isDropEvent || isCopyEvent || isPasteEvent || isCutEvent || isClickEvent && isSelectable) {
          return false;
        }
        return true;
      }
      /**
       * Called when a DOM [mutation](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver) or a selection change happens within the view.
       * @return `false` if the editor should re-read the selection or re-parse the range around the mutation
       * @return `true` if it can safely be ignored.
       */
      ignoreMutation(mutation) {
        if (!this.dom || !this.contentDOM) {
          return true;
        }
        if (typeof this.options.ignoreMutation === "function") {
          return this.options.ignoreMutation({ mutation });
        }
        if (this.node.isLeaf || this.node.isAtom) {
          return true;
        }
        if (mutation.type === "selection") {
          return false;
        }
        if (this.dom.contains(mutation.target) && mutation.type === "childList" && (isiOS() || isAndroid()) && this.editor.isFocused) {
          const changedNodes = [...Array.from(mutation.addedNodes), ...Array.from(mutation.removedNodes)];
          if (changedNodes.every((node) => node.isContentEditable)) {
            return false;
          }
        }
        if (this.contentDOM === mutation.target && mutation.type === "attributes") {
          return true;
        }
        if (this.contentDOM.contains(mutation.target)) {
          return false;
        }
        return true;
      }
      /**
       * Update the attributes of the prosemirror node.
       */
      updateAttributes(attributes) {
        this.editor.commands.command(({ tr }) => {
          const pos = this.getPos();
          if (typeof pos !== "number") {
            return false;
          }
          tr.setNodeMarkup(pos, void 0, {
            ...this.node.attrs,
            ...attributes
          });
          return true;
        });
      }
      /**
       * Delete the node.
       */
      deleteNode() {
        const from = this.getPos();
        if (typeof from !== "number") {
          return;
        }
        const to = from + this.node.nodeSize;
        this.editor.commands.deleteRange({ from, to });
      }
    };
    function markPasteRule(config) {
      return new PasteRule({
        find: config.find,
        handler: ({ state: state2, range: range2, match, pasteEvent }) => {
          const attributes = callOrReturn(config.getAttributes, void 0, match, pasteEvent);
          if (attributes === false || attributes === null) {
            return null;
          }
          const { tr } = state2;
          const captureGroup = match[match.length - 1];
          const fullMatch = match[0];
          let markEnd = range2.to;
          if (captureGroup) {
            const startSpaces = fullMatch.search(/\S/);
            const textStart = range2.from + fullMatch.indexOf(captureGroup);
            const textEnd = textStart + captureGroup.length;
            const excludedMarks = getMarksBetween(range2.from, range2.to, state2.doc).filter((item) => {
              const excluded = item.mark.type.excluded;
              return excluded.find((type2) => type2 === config.type && type2 !== item.mark.type);
            }).filter((item) => item.to > textStart);
            if (excludedMarks.length) {
              return null;
            }
            if (textEnd < range2.to) {
              tr.delete(textEnd, range2.to);
            }
            if (textStart > range2.from) {
              tr.delete(range2.from + startSpaces, textStart);
            }
            markEnd = range2.from + startSpaces + captureGroup.length;
            tr.addMark(range2.from + startSpaces, markEnd, config.type.create(attributes || {}));
            tr.removeStoredMark(config.type);
          }
        }
      });
    }
    function nodePasteRule(config) {
      return new PasteRule({
        find: config.find,
        handler({ match, chain, range: range2, pasteEvent }) {
          const attributes = callOrReturn(config.getAttributes, void 0, match, pasteEvent);
          const content = callOrReturn(config.getContent, void 0, attributes);
          if (attributes === false || attributes === null) {
            return null;
          }
          const node = { type: config.type.name, attrs: attributes };
          if (content) {
            node.content = content;
          }
          if (match.input) {
            chain().deleteRange(range2).insertContentAt(range2.from, node);
          }
        }
      });
    }
    function textPasteRule(config) {
      return new PasteRule({
        find: config.find,
        handler: ({ state: state2, range: range2, match }) => {
          let insert = config.replace;
          let start = range2.from;
          const end = range2.to;
          if (match[1]) {
            const offset = match[0].lastIndexOf(match[1]);
            insert += match[0].slice(offset + match[1].length);
            start += offset;
            const cutOff = start - end;
            if (cutOff > 0) {
              insert = match[0].slice(offset - cutOff, offset) + insert;
              start = end;
            }
          }
          state2.tr.insertText(insert, start, end);
        }
      });
    }
    var Tracker = class {
      constructor(transaction) {
        this.transaction = transaction;
        this.currentStep = this.transaction.steps.length;
      }
      map(position) {
        let deleted = false;
        const mappedPosition = this.transaction.steps.slice(this.currentStep).reduce((newPosition, step) => {
          const mapResult = step.getMap().mapResult(newPosition);
          if (mapResult.deleted) {
            deleted = true;
          }
          return mapResult.pos;
        }, position);
        return {
          position: mappedPosition,
          deleted
        };
      }
    };
  }
});

// node_modules/.pnpm/@tiptap+core@3.11.0_@tiptap+pm@3.11.0/node_modules/@tiptap/core/dist/jsx-runtime/jsx-runtime.cjs
var require_jsx_runtime = __commonJS({
  "node_modules/.pnpm/@tiptap+core@3.11.0_@tiptap+pm@3.11.0/node_modules/@tiptap/core/dist/jsx-runtime/jsx-runtime.cjs"(exports2, module2) {
    "use strict";
    var __defProp3 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp3 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp3(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp3.call(to, key) && key !== except)
            __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp3({}, "__esModule", { value: true }), mod);
    var jsx_runtime_exports = {};
    __export2(jsx_runtime_exports, {
      Fragment: () => Fragment2,
      createElement: () => h,
      h: () => h,
      jsx: () => h,
      jsxDEV: () => h,
      jsxs: () => h
    });
    module2.exports = __toCommonJS2(jsx_runtime_exports);
    function Fragment2(props) {
      return props.children;
    }
    var h = (tag, attributes) => {
      if (tag === "slot") {
        return 0;
      }
      if (tag instanceof Function) {
        return tag(attributes);
      }
      const { children, ...rest } = attributes != null ? attributes : {};
      if (tag === "svg") {
        throw new Error("SVG elements are not supported in the JSX syntax, use the array syntax instead");
      }
      return [tag, rest, children];
    };
  }
});

// node_modules/.pnpm/@tiptap+core@3.11.0_@tiptap+pm@3.11.0/node_modules/@tiptap/core/jsx-runtime/index.cjs
var require_jsx_runtime2 = __commonJS({
  "node_modules/.pnpm/@tiptap+core@3.11.0_@tiptap+pm@3.11.0/node_modules/@tiptap/core/jsx-runtime/index.cjs"(exports2, module2) {
    module2.exports = require_jsx_runtime();
  }
});

// node_modules/.pnpm/@tiptap+extension-blockquote@3.11.0_@tiptap+core@3.11.0_@tiptap+pm@3.11.0_/node_modules/@tiptap/extension-blockquote/dist/index.cjs
var require_dist10 = __commonJS({
  "node_modules/.pnpm/@tiptap+extension-blockquote@3.11.0_@tiptap+core@3.11.0_@tiptap+pm@3.11.0_/node_modules/@tiptap/extension-blockquote/dist/index.cjs"(exports2, module2) {
    "use strict";
    var __defProp3 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp3 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp3(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp3.call(to, key) && key !== except)
            __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp3({}, "__esModule", { value: true }), mod);
    var index_exports = {};
    __export2(index_exports, {
      Blockquote: () => Blockquote,
      default: () => index_default,
      inputRegex: () => inputRegex
    });
    module2.exports = __toCommonJS2(index_exports);
    var import_core = require_dist9();
    var import_jsx_runtime = require_jsx_runtime2();
    var inputRegex = /^\s*>\s$/;
    var Blockquote = import_core.Node.create({
      name: "blockquote",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      content: "block+",
      group: "block",
      defining: true,
      parseHTML() {
        return [{ tag: "blockquote" }];
      },
      renderHTML({ HTMLAttributes }) {
        return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("blockquote", { ...(0, import_core.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("slot", {}) });
      },
      parseMarkdown: (token, helpers) => {
        return helpers.createNode("blockquote", void 0, helpers.parseChildren(token.tokens || []));
      },
      renderMarkdown: (node, h) => {
        if (!node.content) {
          return "";
        }
        const prefix = ">";
        const result = [];
        node.content.forEach((child) => {
          const childContent = h.renderChildren([child]);
          const lines = childContent.split("\n");
          const linesWithPrefix = lines.map((line) => {
            if (line.trim() === "") {
              return prefix;
            }
            return `${prefix} ${line}`;
          });
          result.push(linesWithPrefix.join("\n"));
        });
        return result.join(`
${prefix}
`);
      },
      addCommands() {
        return {
          setBlockquote: () => ({ commands: commands2 }) => {
            return commands2.wrapIn(this.name);
          },
          toggleBlockquote: () => ({ commands: commands2 }) => {
            return commands2.toggleWrap(this.name);
          },
          unsetBlockquote: () => ({ commands: commands2 }) => {
            return commands2.lift(this.name);
          }
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Shift-b": () => this.editor.commands.toggleBlockquote()
        };
      },
      addInputRules() {
        return [
          (0, import_core.wrappingInputRule)({
            find: inputRegex,
            type: this.type
          })
        ];
      }
    });
    var index_default = Blockquote;
  }
});

// node_modules/.pnpm/@tiptap+extension-bold@3.11.0_@tiptap+core@3.11.0_@tiptap+pm@3.11.0_/node_modules/@tiptap/extension-bold/dist/index.cjs
var require_dist11 = __commonJS({
  "node_modules/.pnpm/@tiptap+extension-bold@3.11.0_@tiptap+core@3.11.0_@tiptap+pm@3.11.0_/node_modules/@tiptap/extension-bold/dist/index.cjs"(exports2, module2) {
    "use strict";
    var __defProp3 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp3 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp3(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp3.call(to, key) && key !== except)
            __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp3({}, "__esModule", { value: true }), mod);
    var index_exports = {};
    __export2(index_exports, {
      Bold: () => Bold,
      default: () => index_default,
      starInputRegex: () => starInputRegex,
      starPasteRegex: () => starPasteRegex,
      underscoreInputRegex: () => underscoreInputRegex,
      underscorePasteRegex: () => underscorePasteRegex
    });
    module2.exports = __toCommonJS2(index_exports);
    var import_core = require_dist9();
    var import_jsx_runtime = require_jsx_runtime2();
    var starInputRegex = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/;
    var starPasteRegex = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g;
    var underscoreInputRegex = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/;
    var underscorePasteRegex = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g;
    var Bold = import_core.Mark.create({
      name: "bold",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      parseHTML() {
        return [
          {
            tag: "strong"
          },
          {
            tag: "b",
            getAttrs: (node) => node.style.fontWeight !== "normal" && null
          },
          {
            style: "font-weight=400",
            clearMark: (mark) => mark.type.name === this.name
          },
          {
            style: "font-weight",
            getAttrs: (value) => /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null
          }
        ];
      },
      renderHTML({ HTMLAttributes }) {
        return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("strong", { ...(0, import_core.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("slot", {}) });
      },
      markdownTokenName: "strong",
      parseMarkdown: (token, helpers) => {
        return helpers.applyMark("bold", helpers.parseInline(token.tokens || []));
      },
      renderMarkdown: (node, h) => {
        return `**${h.renderChildren(node)}**`;
      },
      addCommands() {
        return {
          setBold: () => ({ commands: commands2 }) => {
            return commands2.setMark(this.name);
          },
          toggleBold: () => ({ commands: commands2 }) => {
            return commands2.toggleMark(this.name);
          },
          unsetBold: () => ({ commands: commands2 }) => {
            return commands2.unsetMark(this.name);
          }
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-b": () => this.editor.commands.toggleBold(),
          "Mod-B": () => this.editor.commands.toggleBold()
        };
      },
      addInputRules() {
        return [
          (0, import_core.markInputRule)({
            find: starInputRegex,
            type: this.type
          }),
          (0, import_core.markInputRule)({
            find: underscoreInputRegex,
            type: this.type
          })
        ];
      },
      addPasteRules() {
        return [
          (0, import_core.markPasteRule)({
            find: starPasteRegex,
            type: this.type
          }),
          (0, import_core.markPasteRule)({
            find: underscorePasteRegex,
            type: this.type
          })
        ];
      }
    });
    var index_default = Bold;
  }
});

// node_modules/.pnpm/@tiptap+extension-code@3.11.0_@tiptap+core@3.11.0_@tiptap+pm@3.11.0_/node_modules/@tiptap/extension-code/dist/index.cjs
var require_dist12 = __commonJS({
  "node_modules/.pnpm/@tiptap+extension-code@3.11.0_@tiptap+core@3.11.0_@tiptap+pm@3.11.0_/node_modules/@tiptap/extension-code/dist/index.cjs"(exports2, module2) {
    "use strict";
    var __defProp3 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp3 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp3(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp3.call(to, key) && key !== except)
            __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp3({}, "__esModule", { value: true }), mod);
    var index_exports = {};
    __export2(index_exports, {
      Code: () => Code,
      default: () => index_default,
      inputRegex: () => inputRegex,
      pasteRegex: () => pasteRegex
    });
    module2.exports = __toCommonJS2(index_exports);
    var import_core = require_dist9();
    var inputRegex = /(^|[^`])`([^`]+)`(?!`)$/;
    var pasteRegex = /(^|[^`])`([^`]+)`(?!`)/g;
    var Code = import_core.Mark.create({
      name: "code",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      excludes: "_",
      code: true,
      exitable: true,
      parseHTML() {
        return [{ tag: "code" }];
      },
      renderHTML({ HTMLAttributes }) {
        return ["code", (0, import_core.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];
      },
      markdownTokenName: "codespan",
      parseMarkdown: (token, helpers) => {
        return helpers.applyMark("code", [{ type: "text", text: token.text || "" }]);
      },
      renderMarkdown: (node, h) => {
        if (!node.content) {
          return "";
        }
        return `\`${h.renderChildren(node.content)}\``;
      },
      addCommands() {
        return {
          setCode: () => ({ commands: commands2 }) => {
            return commands2.setMark(this.name);
          },
          toggleCode: () => ({ commands: commands2 }) => {
            return commands2.toggleMark(this.name);
          },
          unsetCode: () => ({ commands: commands2 }) => {
            return commands2.unsetMark(this.name);
          }
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-e": () => this.editor.commands.toggleCode()
        };
      },
      addInputRules() {
        return [
          (0, import_core.markInputRule)({
            find: inputRegex,
            type: this.type
          })
        ];
      },
      addPasteRules() {
        return [
          (0, import_core.markPasteRule)({
            find: pasteRegex,
            type: this.type
          })
        ];
      }
    });
    var index_default = Code;
  }
});

// node_modules/.pnpm/@tiptap+extension-code-block@3.11.0_@tiptap+core@3.11.0_@tiptap+pm@3.11.0__@tiptap+pm@3.11.0/node_modules/@tiptap/extension-code-block/dist/index.cjs
var require_dist13 = __commonJS({
  "node_modules/.pnpm/@tiptap+extension-code-block@3.11.0_@tiptap+core@3.11.0_@tiptap+pm@3.11.0__@tiptap+pm@3.11.0/node_modules/@tiptap/extension-code-block/dist/index.cjs"(exports2, module2) {
    "use strict";
    var __defProp3 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp3 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp3(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp3.call(to, key) && key !== except)
            __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp3({}, "__esModule", { value: true }), mod);
    var index_exports = {};
    __export2(index_exports, {
      CodeBlock: () => CodeBlock,
      backtickInputRegex: () => backtickInputRegex,
      default: () => index_default,
      tildeInputRegex: () => tildeInputRegex
    });
    module2.exports = __toCommonJS2(index_exports);
    var import_core = require_dist9();
    var import_state = require_state();
    var DEFAULT_TAB_SIZE = 4;
    var backtickInputRegex = /^```([a-z]+)?[\s\n]$/;
    var tildeInputRegex = /^~~~([a-z]+)?[\s\n]$/;
    var CodeBlock = import_core.Node.create({
      name: "codeBlock",
      addOptions() {
        return {
          languageClassPrefix: "language-",
          exitOnTripleEnter: true,
          exitOnArrowDown: true,
          defaultLanguage: null,
          enableTabIndentation: false,
          tabSize: DEFAULT_TAB_SIZE,
          HTMLAttributes: {}
        };
      },
      content: "text*",
      marks: "",
      group: "block",
      code: true,
      defining: true,
      addAttributes() {
        return {
          language: {
            default: this.options.defaultLanguage,
            parseHTML: (element) => {
              var _a;
              const { languageClassPrefix } = this.options;
              if (!languageClassPrefix) {
                return null;
              }
              const classNames = [...((_a = element.firstElementChild) == null ? void 0 : _a.classList) || []];
              const languages = classNames.filter((className) => className.startsWith(languageClassPrefix)).map((className) => className.replace(languageClassPrefix, ""));
              const language = languages[0];
              if (!language) {
                return null;
              }
              return language;
            },
            rendered: false
          }
        };
      },
      parseHTML() {
        return [
          {
            tag: "pre",
            preserveWhitespace: "full"
          }
        ];
      },
      renderHTML({ node, HTMLAttributes }) {
        return [
          "pre",
          (0, import_core.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),
          [
            "code",
            {
              class: node.attrs.language ? this.options.languageClassPrefix + node.attrs.language : null
            },
            0
          ]
        ];
      },
      markdownTokenName: "code",
      parseMarkdown: (token, helpers) => {
        var _a;
        if (((_a = token.raw) == null ? void 0 : _a.startsWith("```")) === false && token.codeBlockStyle !== "indented") {
          return [];
        }
        return helpers.createNode(
          "codeBlock",
          { language: token.lang || null },
          token.text ? [helpers.createTextNode(token.text)] : []
        );
      },
      renderMarkdown: (node, h) => {
        var _a;
        let output = "";
        const language = ((_a = node.attrs) == null ? void 0 : _a.language) || "";
        if (!node.content) {
          output = `\`\`\`${language}

\`\`\``;
        } else {
          const lines = [`\`\`\`${language}`, h.renderChildren(node.content), "```"];
          output = lines.join("\n");
        }
        return output;
      },
      addCommands() {
        return {
          setCodeBlock: (attributes) => ({ commands: commands2 }) => {
            return commands2.setNode(this.name, attributes);
          },
          toggleCodeBlock: (attributes) => ({ commands: commands2 }) => {
            return commands2.toggleNode(this.name, "paragraph", attributes);
          }
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(),
          // remove code block when at start of document or code block is empty
          Backspace: () => {
            const { empty, $anchor } = this.editor.state.selection;
            const isAtStart = $anchor.pos === 1;
            if (!empty || $anchor.parent.type.name !== this.name) {
              return false;
            }
            if (isAtStart || !$anchor.parent.textContent.length) {
              return this.editor.commands.clearNodes();
            }
            return false;
          },
          // handle tab indentation
          Tab: ({ editor }) => {
            var _a;
            if (!this.options.enableTabIndentation) {
              return false;
            }
            const tabSize = (_a = this.options.tabSize) != null ? _a : DEFAULT_TAB_SIZE;
            const { state: state2 } = editor;
            const { selection } = state2;
            const { $from, empty } = selection;
            if ($from.parent.type !== this.type) {
              return false;
            }
            const indent = " ".repeat(tabSize);
            if (empty) {
              return editor.commands.insertContent(indent);
            }
            return editor.commands.command(({ tr }) => {
              const { from, to } = selection;
              const text = state2.doc.textBetween(from, to, "\n", "\n");
              const lines = text.split("\n");
              const indentedText = lines.map((line) => indent + line).join("\n");
              tr.replaceWith(from, to, state2.schema.text(indentedText));
              return true;
            });
          },
          // handle shift+tab reverse indentation
          "Shift-Tab": ({ editor }) => {
            var _a;
            if (!this.options.enableTabIndentation) {
              return false;
            }
            const tabSize = (_a = this.options.tabSize) != null ? _a : DEFAULT_TAB_SIZE;
            const { state: state2 } = editor;
            const { selection } = state2;
            const { $from, empty } = selection;
            if ($from.parent.type !== this.type) {
              return false;
            }
            if (empty) {
              return editor.commands.command(({ tr }) => {
                var _a2;
                const { pos } = $from;
                const codeBlockStart = $from.start();
                const codeBlockEnd = $from.end();
                const allText = state2.doc.textBetween(codeBlockStart, codeBlockEnd, "\n", "\n");
                const lines = allText.split("\n");
                let currentLineIndex = 0;
                let charCount = 0;
                const relativeCursorPos = pos - codeBlockStart;
                for (let i = 0; i < lines.length; i += 1) {
                  if (charCount + lines[i].length >= relativeCursorPos) {
                    currentLineIndex = i;
                    break;
                  }
                  charCount += lines[i].length + 1;
                }
                const currentLine = lines[currentLineIndex];
                const leadingSpaces = ((_a2 = currentLine.match(/^ */)) == null ? void 0 : _a2[0]) || "";
                const spacesToRemove = Math.min(leadingSpaces.length, tabSize);
                if (spacesToRemove === 0) {
                  return true;
                }
                let lineStartPos = codeBlockStart;
                for (let i = 0; i < currentLineIndex; i += 1) {
                  lineStartPos += lines[i].length + 1;
                }
                tr.delete(lineStartPos, lineStartPos + spacesToRemove);
                const cursorPosInLine = pos - lineStartPos;
                if (cursorPosInLine <= spacesToRemove) {
                  tr.setSelection(import_state.TextSelection.create(tr.doc, lineStartPos));
                }
                return true;
              });
            }
            return editor.commands.command(({ tr }) => {
              const { from, to } = selection;
              const text = state2.doc.textBetween(from, to, "\n", "\n");
              const lines = text.split("\n");
              const reverseIndentText = lines.map((line) => {
                var _a2;
                const leadingSpaces = ((_a2 = line.match(/^ */)) == null ? void 0 : _a2[0]) || "";
                const spacesToRemove = Math.min(leadingSpaces.length, tabSize);
                return line.slice(spacesToRemove);
              }).join("\n");
              tr.replaceWith(from, to, state2.schema.text(reverseIndentText));
              return true;
            });
          },
          // exit node on triple enter
          Enter: ({ editor }) => {
            if (!this.options.exitOnTripleEnter) {
              return false;
            }
            const { state: state2 } = editor;
            const { selection } = state2;
            const { $from, empty } = selection;
            if (!empty || $from.parent.type !== this.type) {
              return false;
            }
            const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;
            const endsWithDoubleNewline = $from.parent.textContent.endsWith("\n\n");
            if (!isAtEnd || !endsWithDoubleNewline) {
              return false;
            }
            return editor.chain().command(({ tr }) => {
              tr.delete($from.pos - 2, $from.pos);
              return true;
            }).exitCode().run();
          },
          // exit node on arrow down
          ArrowDown: ({ editor }) => {
            if (!this.options.exitOnArrowDown) {
              return false;
            }
            const { state: state2 } = editor;
            const { selection, doc } = state2;
            const { $from, empty } = selection;
            if (!empty || $from.parent.type !== this.type) {
              return false;
            }
            const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;
            if (!isAtEnd) {
              return false;
            }
            const after = $from.after();
            if (after === void 0) {
              return false;
            }
            const nodeAfter = doc.nodeAt(after);
            if (nodeAfter) {
              return editor.commands.command(({ tr }) => {
                tr.setSelection(import_state.Selection.near(doc.resolve(after)));
                return true;
              });
            }
            return editor.commands.exitCode();
          }
        };
      },
      addInputRules() {
        return [
          (0, import_core.textblockTypeInputRule)({
            find: backtickInputRegex,
            type: this.type,
            getAttributes: (match) => ({
              language: match[1]
            })
          }),
          (0, import_core.textblockTypeInputRule)({
            find: tildeInputRegex,
            type: this.type,
            getAttributes: (match) => ({
              language: match[1]
            })
          })
        ];
      },
      addProseMirrorPlugins() {
        return [
          // this plugin creates a code block for pasted content from VS Code
          // we can also detect the copied code language
          new import_state.Plugin({
            key: new import_state.PluginKey("codeBlockVSCodeHandler"),
            props: {
              handlePaste: (view, event) => {
                if (!event.clipboardData) {
                  return false;
                }
                if (this.editor.isActive(this.type.name)) {
                  return false;
                }
                const text = event.clipboardData.getData("text/plain");
                const vscode = event.clipboardData.getData("vscode-editor-data");
                const vscodeData = vscode ? JSON.parse(vscode) : void 0;
                const language = vscodeData == null ? void 0 : vscodeData.mode;
                if (!text || !language) {
                  return false;
                }
                const { tr, schema } = view.state;
                const textNode = schema.text(text.replace(/\r\n?/g, "\n"));
                tr.replaceSelectionWith(this.type.create({ language }, textNode));
                if (tr.selection.$from.parent.type !== this.type) {
                  tr.setSelection(import_state.TextSelection.near(tr.doc.resolve(Math.max(0, tr.selection.from - 2))));
                }
                tr.setMeta("paste", true);
                view.dispatch(tr);
                return true;
              }
            }
          })
        ];
      }
    });
    var index_default = CodeBlock;
  }
});

// node_modules/.pnpm/@tiptap+extension-document@3.11.0_@tiptap+core@3.11.0_@tiptap+pm@3.11.0_/node_modules/@tiptap/extension-document/dist/index.cjs
var require_dist14 = __commonJS({
  "node_modules/.pnpm/@tiptap+extension-document@3.11.0_@tiptap+core@3.11.0_@tiptap+pm@3.11.0_/node_modules/@tiptap/extension-document/dist/index.cjs"(exports2, module2) {
    "use strict";
    var __defProp3 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp3 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp3(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp3.call(to, key) && key !== except)
            __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp3({}, "__esModule", { value: true }), mod);
    var index_exports = {};
    __export2(index_exports, {
      Document: () => Document2,
      default: () => index_default
    });
    module2.exports = __toCommonJS2(index_exports);
    var import_core = require_dist9();
    var Document2 = import_core.Node.create({
      name: "doc",
      topNode: true,
      content: "block+",
      renderMarkdown: (node, h) => {
        if (!node.content) {
          return "";
        }
        return h.renderChildren(node.content, "\n\n");
      }
    });
    var index_default = Document2;
  }
});

// node_modules/.pnpm/@tiptap+extension-hard-break@3.11.0_@tiptap+core@3.11.0_@tiptap+pm@3.11.0_/node_modules/@tiptap/extension-hard-break/dist/index.cjs
var require_dist15 = __commonJS({
  "node_modules/.pnpm/@tiptap+extension-hard-break@3.11.0_@tiptap+core@3.11.0_@tiptap+pm@3.11.0_/node_modules/@tiptap/extension-hard-break/dist/index.cjs"(exports2, module2) {
    "use strict";
    var __defProp3 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp3 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp3(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp3.call(to, key) && key !== except)
            __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp3({}, "__esModule", { value: true }), mod);
    var index_exports = {};
    __export2(index_exports, {
      HardBreak: () => HardBreak,
      default: () => index_default
    });
    module2.exports = __toCommonJS2(index_exports);
    var import_core = require_dist9();
    var HardBreak = import_core.Node.create({
      name: "hardBreak",
      markdownTokenName: "br",
      addOptions() {
        return {
          keepMarks: true,
          HTMLAttributes: {}
        };
      },
      inline: true,
      group: "inline",
      selectable: false,
      linebreakReplacement: true,
      parseHTML() {
        return [{ tag: "br" }];
      },
      renderHTML({ HTMLAttributes }) {
        return ["br", (0, import_core.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes)];
      },
      renderText() {
        return "\n";
      },
      renderMarkdown: () => `  
`,
      parseMarkdown: () => {
        return {
          type: "hardBreak"
        };
      },
      addCommands() {
        return {
          setHardBreak: () => ({ commands: commands2, chain, state: state2, editor }) => {
            return commands2.first([
              () => commands2.exitCode(),
              () => commands2.command(() => {
                const { selection, storedMarks } = state2;
                if (selection.$from.parent.type.spec.isolating) {
                  return false;
                }
                const { keepMarks } = this.options;
                const { splittableMarks } = editor.extensionManager;
                const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
                return chain().insertContent({ type: this.name }).command(({ tr, dispatch }) => {
                  if (dispatch && marks && keepMarks) {
                    const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
                    tr.ensureMarks(filteredMarks);
                  }
                  return true;
                }).run();
              })
            ]);
          }
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Enter": () => this.editor.commands.setHardBreak(),
          "Shift-Enter": () => this.editor.commands.setHardBreak()
        };
      }
    });
    var index_default = HardBreak;
  }
});

// node_modules/.pnpm/@tiptap+extension-heading@3.11.0_@tiptap+core@3.11.0_@tiptap+pm@3.11.0_/node_modules/@tiptap/extension-heading/dist/index.cjs
var require_dist16 = __commonJS({
  "node_modules/.pnpm/@tiptap+extension-heading@3.11.0_@tiptap+core@3.11.0_@tiptap+pm@3.11.0_/node_modules/@tiptap/extension-heading/dist/index.cjs"(exports2, module2) {
    "use strict";
    var __defProp3 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp3 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp3(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp3.call(to, key) && key !== except)
            __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp3({}, "__esModule", { value: true }), mod);
    var index_exports = {};
    __export2(index_exports, {
      Heading: () => Heading,
      default: () => index_default
    });
    module2.exports = __toCommonJS2(index_exports);
    var import_core = require_dist9();
    var Heading = import_core.Node.create({
      name: "heading",
      addOptions() {
        return {
          levels: [1, 2, 3, 4, 5, 6],
          HTMLAttributes: {}
        };
      },
      content: "inline*",
      group: "block",
      defining: true,
      addAttributes() {
        return {
          level: {
            default: 1,
            rendered: false
          }
        };
      },
      parseHTML() {
        return this.options.levels.map((level) => ({
          tag: `h${level}`,
          attrs: { level }
        }));
      },
      renderHTML({ node, HTMLAttributes }) {
        const hasLevel = this.options.levels.includes(node.attrs.level);
        const level = hasLevel ? node.attrs.level : this.options.levels[0];
        return [`h${level}`, (0, import_core.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];
      },
      parseMarkdown: (token, helpers) => {
        return helpers.createNode("heading", { level: token.depth || 1 }, helpers.parseInline(token.tokens || []));
      },
      renderMarkdown: (node, h) => {
        var _a;
        const level = ((_a = node.attrs) == null ? void 0 : _a.level) ? parseInt(node.attrs.level, 10) : 1;
        const headingChars = "#".repeat(level);
        if (!node.content) {
          return "";
        }
        return `${headingChars} ${h.renderChildren(node.content)}`;
      },
      addCommands() {
        return {
          setHeading: (attributes) => ({ commands: commands2 }) => {
            if (!this.options.levels.includes(attributes.level)) {
              return false;
            }
            return commands2.setNode(this.name, attributes);
          },
          toggleHeading: (attributes) => ({ commands: commands2 }) => {
            if (!this.options.levels.includes(attributes.level)) {
              return false;
            }
            return commands2.toggleNode(this.name, "paragraph", attributes);
          }
        };
      },
      addKeyboardShortcuts() {
        return this.options.levels.reduce(
          (items, level) => ({
            ...items,
            ...{
              [`Mod-Alt-${level}`]: () => this.editor.commands.toggleHeading({ level })
            }
          }),
          {}
        );
      },
      addInputRules() {
        return this.options.levels.map((level) => {
          return (0, import_core.textblockTypeInputRule)({
            find: new RegExp(`^(#{${Math.min(...this.options.levels)},${level}})\\s$`),
            type: this.type,
            getAttributes: {
              level
            }
          });
        });
      }
    });
    var index_default = Heading;
  }
});

// node_modules/.pnpm/@tiptap+extension-horizontal-rule@3.11.0_@tiptap+core@3.11.0_@tiptap+pm@3.11.0__@tiptap+pm@3.11.0/node_modules/@tiptap/extension-horizontal-rule/dist/index.cjs
var require_dist17 = __commonJS({
  "node_modules/.pnpm/@tiptap+extension-horizontal-rule@3.11.0_@tiptap+core@3.11.0_@tiptap+pm@3.11.0__@tiptap+pm@3.11.0/node_modules/@tiptap/extension-horizontal-rule/dist/index.cjs"(exports2, module2) {
    "use strict";
    var __defProp3 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp3 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp3(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp3.call(to, key) && key !== except)
            __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp3({}, "__esModule", { value: true }), mod);
    var index_exports = {};
    __export2(index_exports, {
      HorizontalRule: () => HorizontalRule,
      default: () => index_default
    });
    module2.exports = __toCommonJS2(index_exports);
    var import_core = require_dist9();
    var import_state = require_state();
    var HorizontalRule = import_core.Node.create({
      name: "horizontalRule",
      addOptions() {
        return {
          HTMLAttributes: {},
          nextNodeType: "paragraph"
        };
      },
      group: "block",
      parseHTML() {
        return [{ tag: "hr" }];
      },
      renderHTML({ HTMLAttributes }) {
        return ["hr", (0, import_core.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes)];
      },
      markdownTokenName: "hr",
      parseMarkdown: (token, helpers) => {
        return helpers.createNode("horizontalRule");
      },
      renderMarkdown: () => {
        return "---";
      },
      addCommands() {
        return {
          setHorizontalRule: () => ({ chain, state: state2 }) => {
            if (!(0, import_core.canInsertNode)(state2, state2.schema.nodes[this.name])) {
              return false;
            }
            const { selection } = state2;
            const { $to: $originTo } = selection;
            const currentChain = chain();
            if ((0, import_core.isNodeSelection)(selection)) {
              currentChain.insertContentAt($originTo.pos, {
                type: this.name
              });
            } else {
              currentChain.insertContent({ type: this.name });
            }
            return currentChain.command(({ state: chainState, tr, dispatch }) => {
              if (dispatch) {
                const { $to } = tr.selection;
                const posAfter = $to.end();
                if ($to.nodeAfter) {
                  if ($to.nodeAfter.isTextblock) {
                    tr.setSelection(import_state.TextSelection.create(tr.doc, $to.pos + 1));
                  } else if ($to.nodeAfter.isBlock) {
                    tr.setSelection(import_state.NodeSelection.create(tr.doc, $to.pos));
                  } else {
                    tr.setSelection(import_state.TextSelection.create(tr.doc, $to.pos));
                  }
                } else {
                  const nodeType = chainState.schema.nodes[this.options.nextNodeType] || $to.parent.type.contentMatch.defaultType;
                  const node = nodeType == null ? void 0 : nodeType.create();
                  if (node) {
                    tr.insert(posAfter, node);
                    tr.setSelection(import_state.TextSelection.create(tr.doc, posAfter + 1));
                  }
                }
                tr.scrollIntoView();
              }
              return true;
            }).run();
          }
        };
      },
      addInputRules() {
        return [
          (0, import_core.nodeInputRule)({
            find: /^(?:---|—-|___\s|\*\*\*\s)$/,
            type: this.type
          })
        ];
      }
    });
    var index_default = HorizontalRule;
  }
});

// node_modules/.pnpm/@tiptap+extension-italic@3.11.0_@tiptap+core@3.11.0_@tiptap+pm@3.11.0_/node_modules/@tiptap/extension-italic/dist/index.cjs
var require_dist18 = __commonJS({
  "node_modules/.pnpm/@tiptap+extension-italic@3.11.0_@tiptap+core@3.11.0_@tiptap+pm@3.11.0_/node_modules/@tiptap/extension-italic/dist/index.cjs"(exports2, module2) {
    "use strict";
    var __defProp3 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp3 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp3(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp3.call(to, key) && key !== except)
            __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp3({}, "__esModule", { value: true }), mod);
    var index_exports = {};
    __export2(index_exports, {
      Italic: () => Italic,
      default: () => index_default,
      starInputRegex: () => starInputRegex,
      starPasteRegex: () => starPasteRegex,
      underscoreInputRegex: () => underscoreInputRegex,
      underscorePasteRegex: () => underscorePasteRegex
    });
    module2.exports = __toCommonJS2(index_exports);
    var import_core = require_dist9();
    var starInputRegex = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/;
    var starPasteRegex = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g;
    var underscoreInputRegex = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/;
    var underscorePasteRegex = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g;
    var Italic = import_core.Mark.create({
      name: "italic",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      parseHTML() {
        return [
          {
            tag: "em"
          },
          {
            tag: "i",
            getAttrs: (node) => node.style.fontStyle !== "normal" && null
          },
          {
            style: "font-style=normal",
            clearMark: (mark) => mark.type.name === this.name
          },
          {
            style: "font-style=italic"
          }
        ];
      },
      renderHTML({ HTMLAttributes }) {
        return ["em", (0, import_core.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];
      },
      addCommands() {
        return {
          setItalic: () => ({ commands: commands2 }) => {
            return commands2.setMark(this.name);
          },
          toggleItalic: () => ({ commands: commands2 }) => {
            return commands2.toggleMark(this.name);
          },
          unsetItalic: () => ({ commands: commands2 }) => {
            return commands2.unsetMark(this.name);
          }
        };
      },
      markdownTokenName: "em",
      parseMarkdown: (token, helpers) => {
        return helpers.applyMark("italic", helpers.parseInline(token.tokens || []));
      },
      renderMarkdown: (node, h) => {
        return `*${h.renderChildren(node)}*`;
      },
      addKeyboardShortcuts() {
        return {
          "Mod-i": () => this.editor.commands.toggleItalic(),
          "Mod-I": () => this.editor.commands.toggleItalic()
        };
      },
      addInputRules() {
        return [
          (0, import_core.markInputRule)({
            find: starInputRegex,
            type: this.type
          }),
          (0, import_core.markInputRule)({
            find: underscoreInputRegex,
            type: this.type
          })
        ];
      },
      addPasteRules() {
        return [
          (0, import_core.markPasteRule)({
            find: starPasteRegex,
            type: this.type
          }),
          (0, import_core.markPasteRule)({
            find: underscorePasteRegex,
            type: this.type
          })
        ];
      }
    });
    var index_default = Italic;
  }
});

// node_modules/.pnpm/linkifyjs@4.3.2/node_modules/linkifyjs/dist/linkify.cjs
var require_linkify = __commonJS({
  "node_modules/.pnpm/linkifyjs@4.3.2/node_modules/linkifyjs/dist/linkify.cjs"(exports2) {
    "use strict";
    var encodedTlds = "aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4w0s2x0a2z0ure5ba0by2idu3namex4d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dad1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3nd0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0axi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp3ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5m\xF6gensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2";
    var encodedUtlds = "\u03B5\u03BB1\u03C52\u0431\u04331\u0435\u043B3\u0434\u0435\u0442\u04384\u0435\u044E2\u043A\u0430\u0442\u043E\u043B\u0438\u043A6\u043E\u043C3\u043C\u043A\u04342\u043E\u043D1\u0441\u043A\u0432\u04306\u043E\u043D\u043B\u0430\u0439\u043D5\u0440\u04333\u0440\u0443\u04412\u04442\u0441\u0430\u0439\u04423\u0440\u04313\u0443\u043A\u04403\u049B\u0430\u04373\u0570\u0561\u05753\u05D9\u05E9\u05E8\u05D0\u05DC5\u05E7\u05D5\u05DD3\u0627\u0628\u0648\u0638\u0628\u064A5\u0631\u0627\u0645\u0643\u06485\u0644\u0627\u0631\u062F\u06464\u0628\u062D\u0631\u064A\u06465\u062C\u0632\u0627\u0626\u06315\u0633\u0639\u0648\u062F\u064A\u06296\u0639\u0644\u064A\u0627\u06465\u0645\u063A\u0631\u06285\u0645\u0627\u0631\u0627\u062A5\u06CC\u0631\u0627\u06465\u0628\u0627\u0631\u062A2\u0632\u0627\u06314\u064A\u062A\u06433\u06BE\u0627\u0631\u062A5\u062A\u0648\u0646\u06334\u0633\u0648\u062F\u0627\u06463\u0631\u064A\u06295\u0634\u0628\u0643\u06294\u0639\u0631\u0627\u06422\u06282\u0645\u0627\u06464\u0641\u0644\u0633\u0637\u064A\u06466\u0642\u0637\u06313\u0643\u0627\u062B\u0648\u0644\u064A\u06436\u0648\u06453\u0645\u0635\u06312\u0644\u064A\u0633\u064A\u06275\u0648\u0631\u064A\u062A\u0627\u0646\u064A\u06277\u0642\u06394\u0647\u0645\u0631\u0627\u06475\u067E\u0627\u06A9\u0633\u062A\u0627\u06467\u0680\u0627\u0631\u062A4\u0915\u0949\u092E3\u0928\u0947\u091F3\u092D\u093E\u0930\u09240\u092E\u094D3\u094B\u09245\u0938\u0902\u0917\u0920\u09285\u09AC\u09BE\u0982\u09B2\u09BE5\u09AD\u09BE\u09B0\u09A42\u09F0\u09A44\u0A2D\u0A3E\u0A30\u0A244\u0AAD\u0ABE\u0AB0\u0AA44\u0B2D\u0B3E\u0B30\u0B244\u0B87\u0BA8\u0BCD\u0BA4\u0BBF\u0BAF\u0BBE6\u0BB2\u0B99\u0BCD\u0B95\u0BC86\u0B9A\u0BBF\u0B99\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0BC2\u0BB0\u0BCD11\u0C2D\u0C3E\u0C30\u0C24\u0C4D5\u0CAD\u0CBE\u0CB0\u0CA44\u0D2D\u0D3E\u0D30\u0D24\u0D025\u0DBD\u0D82\u0D9A\u0DCF4\u0E04\u0E2D\u0E213\u0E44\u0E17\u0E223\u0EA5\u0EB2\u0EA73\u10D2\u10D42\u307F\u3093\u306A3\u30A2\u30DE\u30BE\u30F34\u30AF\u30E9\u30A6\u30C94\u30B0\u30FC\u30B0\u30EB4\u30B3\u30E02\u30B9\u30C8\u30A23\u30BB\u30FC\u30EB3\u30D5\u30A1\u30C3\u30B7\u30E7\u30F36\u30DD\u30A4\u30F3\u30C84\u4E16\u754C2\u4E2D\u4FE11\u56FD1\u570B1\u6587\u7F513\u4E9A\u9A6C\u900A3\u4F01\u4E1A2\u4F5B\u5C712\u4FE1\u606F2\u5065\u5EB72\u516B\u53662\u516C\u53F81\u76CA2\u53F0\u6E7E1\u70632\u5546\u57CE1\u5E971\u68072\u5609\u91CC0\u5927\u9152\u5E975\u5728\u7EBF2\u5927\u62FF2\u5929\u4E3B\u65593\u5A31\u4E502\u5BB6\u96FB2\u5E7F\u4E1C2\u5FAE\u535A2\u6148\u55842\u6211\u7231\u4F603\u624B\u673A2\u62DB\u80582\u653F\u52A11\u5E9C2\u65B0\u52A0\u57612\u95FB2\u65F6\u5C1A2\u66F8\u7C4D2\u673A\u67842\u6DE1\u9A6C\u95213\u6E38\u620F2\u6FB3\u95802\u70B9\u770B2\u79FB\u52A82\u7EC4\u7EC7\u673A\u67844\u7F51\u57401\u5E971\u7AD91\u7EDC2\u8054\u901A2\u8C37\u6B4C2\u8D2D\u72692\u901A\u8CA92\u96C6\u56E22\u96FB\u8A0A\u76C8\u79D14\u98DE\u5229\u6D663\u98DF\u54C12\u9910\u53852\u9999\u683C\u91CC\u62C93\u6E2F2\uB2F7\uB1371\uCEF42\uC0BC\uC1312\uD55C\uAD6D2";
    var numeric = "numeric";
    var ascii = "ascii";
    var alpha = "alpha";
    var asciinumeric = "asciinumeric";
    var alphanumeric = "alphanumeric";
    var domain = "domain";
    var emoji = "emoji";
    var scheme = "scheme";
    var slashscheme = "slashscheme";
    var whitespace = "whitespace";
    function registerGroup(name, groups) {
      if (!(name in groups)) {
        groups[name] = [];
      }
      return groups[name];
    }
    function addToGroups(t, flags, groups) {
      if (flags[numeric]) {
        flags[asciinumeric] = true;
        flags[alphanumeric] = true;
      }
      if (flags[ascii]) {
        flags[asciinumeric] = true;
        flags[alpha] = true;
      }
      if (flags[asciinumeric]) {
        flags[alphanumeric] = true;
      }
      if (flags[alpha]) {
        flags[alphanumeric] = true;
      }
      if (flags[alphanumeric]) {
        flags[domain] = true;
      }
      if (flags[emoji]) {
        flags[domain] = true;
      }
      for (const k in flags) {
        const group = registerGroup(k, groups);
        if (group.indexOf(t) < 0) {
          group.push(t);
        }
      }
    }
    function flagsForToken(t, groups) {
      const result = {};
      for (const c in groups) {
        if (groups[c].indexOf(t) >= 0) {
          result[c] = true;
        }
      }
      return result;
    }
    function State(token = null) {
      this.j = {};
      this.jr = [];
      this.jd = null;
      this.t = token;
    }
    State.groups = {};
    State.prototype = {
      accepts() {
        return !!this.t;
      },
      /**
       * Follow an existing transition from the given input to the next state.
       * Does not mutate.
       * @param {string} input character or token type to transition on
       * @returns {?State<T>} the next state, if any
       */
      go(input) {
        const state2 = this;
        const nextState = state2.j[input];
        if (nextState) {
          return nextState;
        }
        for (let i = 0; i < state2.jr.length; i++) {
          const regex = state2.jr[i][0];
          const nextState2 = state2.jr[i][1];
          if (nextState2 && regex.test(input)) {
            return nextState2;
          }
        }
        return state2.jd;
      },
      /**
       * Whether the state has a transition for the given input. Set the second
       * argument to true to only look for an exact match (and not a default or
       * regular-expression-based transition)
       * @param {string} input
       * @param {boolean} exactOnly
       */
      has(input, exactOnly = false) {
        return exactOnly ? input in this.j : !!this.go(input);
      },
      /**
       * Short for "transition all"; create a transition from the array of items
       * in the given list to the same final resulting state.
       * @param {string | string[]} inputs Group of inputs to transition on
       * @param {Transition<T> | State<T>} [next] Transition options
       * @param {Flags} [flags] Collections flags to add token to
       * @param {Collections<T>} [groups] Master list of token groups
       */
      ta(inputs, next, flags, groups) {
        for (let i = 0; i < inputs.length; i++) {
          this.tt(inputs[i], next, flags, groups);
        }
      },
      /**
       * Short for "take regexp transition"; defines a transition for this state
       * when it encounters a token which matches the given regular expression
       * @param {RegExp} regexp Regular expression transition (populate first)
       * @param {T | State<T>} [next] Transition options
       * @param {Flags} [flags] Collections flags to add token to
       * @param {Collections<T>} [groups] Master list of token groups
       * @returns {State<T>} taken after the given input
       */
      tr(regexp2, next, flags, groups) {
        groups = groups || State.groups;
        let nextState;
        if (next && next.j) {
          nextState = next;
        } else {
          nextState = new State(next);
          if (flags && groups) {
            addToGroups(next, flags, groups);
          }
        }
        this.jr.push([regexp2, nextState]);
        return nextState;
      },
      /**
       * Short for "take transitions", will take as many sequential transitions as
       * the length of the given input and returns the
       * resulting final state.
       * @param {string | string[]} input
       * @param {T | State<T>} [next] Transition options
       * @param {Flags} [flags] Collections flags to add token to
       * @param {Collections<T>} [groups] Master list of token groups
       * @returns {State<T>} taken after the given input
       */
      ts(input, next, flags, groups) {
        let state2 = this;
        const len = input.length;
        if (!len) {
          return state2;
        }
        for (let i = 0; i < len - 1; i++) {
          state2 = state2.tt(input[i]);
        }
        return state2.tt(input[len - 1], next, flags, groups);
      },
      /**
       * Short for "take transition", this is a method for building/working with
       * state machines.
       *
       * If a state already exists for the given input, returns it.
       *
       * If a token is specified, that state will emit that token when reached by
       * the linkify engine.
       *
       * If no state exists, it will be initialized with some default transitions
       * that resemble existing default transitions.
       *
       * If a state is given for the second argument, that state will be
       * transitioned to on the given input regardless of what that input
       * previously did.
       *
       * Specify a token group flags to define groups that this token belongs to.
       * The token will be added to corresponding entires in the given groups
       * object.
       *
       * @param {string} input character, token type to transition on
       * @param {T | State<T>} [next] Transition options
       * @param {Flags} [flags] Collections flags to add token to
       * @param {Collections<T>} [groups] Master list of groups
       * @returns {State<T>} taken after the given input
       */
      tt(input, next, flags, groups) {
        groups = groups || State.groups;
        const state2 = this;
        if (next && next.j) {
          state2.j[input] = next;
          return next;
        }
        const t = next;
        let nextState, templateState = state2.go(input);
        if (templateState) {
          nextState = new State();
          Object.assign(nextState.j, templateState.j);
          nextState.jr.push.apply(nextState.jr, templateState.jr);
          nextState.jd = templateState.jd;
          nextState.t = templateState.t;
        } else {
          nextState = new State();
        }
        if (t) {
          if (groups) {
            if (nextState.t && typeof nextState.t === "string") {
              const allFlags = Object.assign(flagsForToken(nextState.t, groups), flags);
              addToGroups(t, allFlags, groups);
            } else if (flags) {
              addToGroups(t, flags, groups);
            }
          }
          nextState.t = t;
        }
        state2.j[input] = nextState;
        return nextState;
      }
    };
    var ta = (state2, input, next, flags, groups) => state2.ta(input, next, flags, groups);
    var tr = (state2, regexp2, next, flags, groups) => state2.tr(regexp2, next, flags, groups);
    var ts = (state2, input, next, flags, groups) => state2.ts(input, next, flags, groups);
    var tt = (state2, input, next, flags, groups) => state2.tt(input, next, flags, groups);
    var WORD = "WORD";
    var UWORD = "UWORD";
    var ASCIINUMERICAL = "ASCIINUMERICAL";
    var ALPHANUMERICAL = "ALPHANUMERICAL";
    var LOCALHOST = "LOCALHOST";
    var TLD = "TLD";
    var UTLD = "UTLD";
    var SCHEME = "SCHEME";
    var SLASH_SCHEME = "SLASH_SCHEME";
    var NUM = "NUM";
    var WS = "WS";
    var NL = "NL";
    var OPENBRACE = "OPENBRACE";
    var CLOSEBRACE = "CLOSEBRACE";
    var OPENBRACKET = "OPENBRACKET";
    var CLOSEBRACKET = "CLOSEBRACKET";
    var OPENPAREN = "OPENPAREN";
    var CLOSEPAREN = "CLOSEPAREN";
    var OPENANGLEBRACKET = "OPENANGLEBRACKET";
    var CLOSEANGLEBRACKET = "CLOSEANGLEBRACKET";
    var FULLWIDTHLEFTPAREN = "FULLWIDTHLEFTPAREN";
    var FULLWIDTHRIGHTPAREN = "FULLWIDTHRIGHTPAREN";
    var LEFTCORNERBRACKET = "LEFTCORNERBRACKET";
    var RIGHTCORNERBRACKET = "RIGHTCORNERBRACKET";
    var LEFTWHITECORNERBRACKET = "LEFTWHITECORNERBRACKET";
    var RIGHTWHITECORNERBRACKET = "RIGHTWHITECORNERBRACKET";
    var FULLWIDTHLESSTHAN = "FULLWIDTHLESSTHAN";
    var FULLWIDTHGREATERTHAN = "FULLWIDTHGREATERTHAN";
    var AMPERSAND = "AMPERSAND";
    var APOSTROPHE = "APOSTROPHE";
    var ASTERISK = "ASTERISK";
    var AT = "AT";
    var BACKSLASH = "BACKSLASH";
    var BACKTICK = "BACKTICK";
    var CARET = "CARET";
    var COLON = "COLON";
    var COMMA = "COMMA";
    var DOLLAR = "DOLLAR";
    var DOT = "DOT";
    var EQUALS = "EQUALS";
    var EXCLAMATION = "EXCLAMATION";
    var HYPHEN = "HYPHEN";
    var PERCENT = "PERCENT";
    var PIPE = "PIPE";
    var PLUS = "PLUS";
    var POUND = "POUND";
    var QUERY = "QUERY";
    var QUOTE = "QUOTE";
    var FULLWIDTHMIDDLEDOT = "FULLWIDTHMIDDLEDOT";
    var SEMI = "SEMI";
    var SLASH = "SLASH";
    var TILDE = "TILDE";
    var UNDERSCORE = "UNDERSCORE";
    var EMOJI$1 = "EMOJI";
    var SYM = "SYM";
    var tk = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      ALPHANUMERICAL,
      AMPERSAND,
      APOSTROPHE,
      ASCIINUMERICAL,
      ASTERISK,
      AT,
      BACKSLASH,
      BACKTICK,
      CARET,
      CLOSEANGLEBRACKET,
      CLOSEBRACE,
      CLOSEBRACKET,
      CLOSEPAREN,
      COLON,
      COMMA,
      DOLLAR,
      DOT,
      EMOJI: EMOJI$1,
      EQUALS,
      EXCLAMATION,
      FULLWIDTHGREATERTHAN,
      FULLWIDTHLEFTPAREN,
      FULLWIDTHLESSTHAN,
      FULLWIDTHMIDDLEDOT,
      FULLWIDTHRIGHTPAREN,
      HYPHEN,
      LEFTCORNERBRACKET,
      LEFTWHITECORNERBRACKET,
      LOCALHOST,
      NL,
      NUM,
      OPENANGLEBRACKET,
      OPENBRACE,
      OPENBRACKET,
      OPENPAREN,
      PERCENT,
      PIPE,
      PLUS,
      POUND,
      QUERY,
      QUOTE,
      RIGHTCORNERBRACKET,
      RIGHTWHITECORNERBRACKET,
      SCHEME,
      SEMI,
      SLASH,
      SLASH_SCHEME,
      SYM,
      TILDE,
      TLD,
      UNDERSCORE,
      UTLD,
      UWORD,
      WORD,
      WS
    });
    var ASCII_LETTER = /[a-z]/;
    var LETTER = /\p{L}/u;
    var EMOJI = /\p{Emoji}/u;
    var EMOJI_VARIATION$1 = /\ufe0f/;
    var DIGIT = /\d/;
    var SPACE = /\s/;
    var regexp = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      ASCII_LETTER,
      DIGIT,
      EMOJI,
      EMOJI_VARIATION: EMOJI_VARIATION$1,
      LETTER,
      SPACE
    });
    var CR = "\r";
    var LF = "\n";
    var EMOJI_VARIATION = "\uFE0F";
    var EMOJI_JOINER = "\u200D";
    var OBJECT_REPLACEMENT = "\uFFFC";
    var tlds = null;
    var utlds = null;
    function init$2(customSchemes = []) {
      const groups = {};
      State.groups = groups;
      const Start = new State();
      if (tlds == null) {
        tlds = decodeTlds(encodedTlds);
      }
      if (utlds == null) {
        utlds = decodeTlds(encodedUtlds);
      }
      tt(Start, "'", APOSTROPHE);
      tt(Start, "{", OPENBRACE);
      tt(Start, "}", CLOSEBRACE);
      tt(Start, "[", OPENBRACKET);
      tt(Start, "]", CLOSEBRACKET);
      tt(Start, "(", OPENPAREN);
      tt(Start, ")", CLOSEPAREN);
      tt(Start, "<", OPENANGLEBRACKET);
      tt(Start, ">", CLOSEANGLEBRACKET);
      tt(Start, "\uFF08", FULLWIDTHLEFTPAREN);
      tt(Start, "\uFF09", FULLWIDTHRIGHTPAREN);
      tt(Start, "\u300C", LEFTCORNERBRACKET);
      tt(Start, "\u300D", RIGHTCORNERBRACKET);
      tt(Start, "\u300E", LEFTWHITECORNERBRACKET);
      tt(Start, "\u300F", RIGHTWHITECORNERBRACKET);
      tt(Start, "\uFF1C", FULLWIDTHLESSTHAN);
      tt(Start, "\uFF1E", FULLWIDTHGREATERTHAN);
      tt(Start, "&", AMPERSAND);
      tt(Start, "*", ASTERISK);
      tt(Start, "@", AT);
      tt(Start, "`", BACKTICK);
      tt(Start, "^", CARET);
      tt(Start, ":", COLON);
      tt(Start, ",", COMMA);
      tt(Start, "$", DOLLAR);
      tt(Start, ".", DOT);
      tt(Start, "=", EQUALS);
      tt(Start, "!", EXCLAMATION);
      tt(Start, "-", HYPHEN);
      tt(Start, "%", PERCENT);
      tt(Start, "|", PIPE);
      tt(Start, "+", PLUS);
      tt(Start, "#", POUND);
      tt(Start, "?", QUERY);
      tt(Start, '"', QUOTE);
      tt(Start, "/", SLASH);
      tt(Start, ";", SEMI);
      tt(Start, "~", TILDE);
      tt(Start, "_", UNDERSCORE);
      tt(Start, "\\", BACKSLASH);
      tt(Start, "\u30FB", FULLWIDTHMIDDLEDOT);
      const Num = tr(Start, DIGIT, NUM, {
        [numeric]: true
      });
      tr(Num, DIGIT, Num);
      const Asciinumeric = tr(Num, ASCII_LETTER, ASCIINUMERICAL, {
        [asciinumeric]: true
      });
      const Alphanumeric = tr(Num, LETTER, ALPHANUMERICAL, {
        [alphanumeric]: true
      });
      const Word = tr(Start, ASCII_LETTER, WORD, {
        [ascii]: true
      });
      tr(Word, DIGIT, Asciinumeric);
      tr(Word, ASCII_LETTER, Word);
      tr(Asciinumeric, DIGIT, Asciinumeric);
      tr(Asciinumeric, ASCII_LETTER, Asciinumeric);
      const UWord = tr(Start, LETTER, UWORD, {
        [alpha]: true
      });
      tr(UWord, ASCII_LETTER);
      tr(UWord, DIGIT, Alphanumeric);
      tr(UWord, LETTER, UWord);
      tr(Alphanumeric, DIGIT, Alphanumeric);
      tr(Alphanumeric, ASCII_LETTER);
      tr(Alphanumeric, LETTER, Alphanumeric);
      const Nl2 = tt(Start, LF, NL, {
        [whitespace]: true
      });
      const Cr = tt(Start, CR, WS, {
        [whitespace]: true
      });
      const Ws = tr(Start, SPACE, WS, {
        [whitespace]: true
      });
      tt(Start, OBJECT_REPLACEMENT, Ws);
      tt(Cr, LF, Nl2);
      tt(Cr, OBJECT_REPLACEMENT, Ws);
      tr(Cr, SPACE, Ws);
      tt(Ws, CR);
      tt(Ws, LF);
      tr(Ws, SPACE, Ws);
      tt(Ws, OBJECT_REPLACEMENT, Ws);
      const Emoji = tr(Start, EMOJI, EMOJI$1, {
        [emoji]: true
      });
      tt(Emoji, "#");
      tr(Emoji, EMOJI, Emoji);
      tt(Emoji, EMOJI_VARIATION, Emoji);
      const EmojiJoiner = tt(Emoji, EMOJI_JOINER);
      tt(EmojiJoiner, "#");
      tr(EmojiJoiner, EMOJI, Emoji);
      const wordjr = [[ASCII_LETTER, Word], [DIGIT, Asciinumeric]];
      const uwordjr = [[ASCII_LETTER, null], [LETTER, UWord], [DIGIT, Alphanumeric]];
      for (let i = 0; i < tlds.length; i++) {
        fastts(Start, tlds[i], TLD, WORD, wordjr);
      }
      for (let i = 0; i < utlds.length; i++) {
        fastts(Start, utlds[i], UTLD, UWORD, uwordjr);
      }
      addToGroups(TLD, {
        tld: true,
        ascii: true
      }, groups);
      addToGroups(UTLD, {
        utld: true,
        alpha: true
      }, groups);
      fastts(Start, "file", SCHEME, WORD, wordjr);
      fastts(Start, "mailto", SCHEME, WORD, wordjr);
      fastts(Start, "http", SLASH_SCHEME, WORD, wordjr);
      fastts(Start, "https", SLASH_SCHEME, WORD, wordjr);
      fastts(Start, "ftp", SLASH_SCHEME, WORD, wordjr);
      fastts(Start, "ftps", SLASH_SCHEME, WORD, wordjr);
      addToGroups(SCHEME, {
        scheme: true,
        ascii: true
      }, groups);
      addToGroups(SLASH_SCHEME, {
        slashscheme: true,
        ascii: true
      }, groups);
      customSchemes = customSchemes.sort((a, b) => a[0] > b[0] ? 1 : -1);
      for (let i = 0; i < customSchemes.length; i++) {
        const sch = customSchemes[i][0];
        const optionalSlashSlash = customSchemes[i][1];
        const flags = optionalSlashSlash ? {
          [scheme]: true
        } : {
          [slashscheme]: true
        };
        if (sch.indexOf("-") >= 0) {
          flags[domain] = true;
        } else if (!ASCII_LETTER.test(sch)) {
          flags[numeric] = true;
        } else if (DIGIT.test(sch)) {
          flags[asciinumeric] = true;
        } else {
          flags[ascii] = true;
        }
        ts(Start, sch, sch, flags);
      }
      ts(Start, "localhost", LOCALHOST, {
        ascii: true
      });
      Start.jd = new State(SYM);
      return {
        start: Start,
        tokens: Object.assign({
          groups
        }, tk)
      };
    }
    function run$1(start, str) {
      const iterable = stringToArray(str.replace(/[A-Z]/g, (c) => c.toLowerCase()));
      const charCount = iterable.length;
      const tokens = [];
      let cursor = 0;
      let charCursor = 0;
      while (charCursor < charCount) {
        let state2 = start;
        let nextState = null;
        let tokenLength = 0;
        let latestAccepting = null;
        let sinceAccepts = -1;
        let charsSinceAccepts = -1;
        while (charCursor < charCount && (nextState = state2.go(iterable[charCursor]))) {
          state2 = nextState;
          if (state2.accepts()) {
            sinceAccepts = 0;
            charsSinceAccepts = 0;
            latestAccepting = state2;
          } else if (sinceAccepts >= 0) {
            sinceAccepts += iterable[charCursor].length;
            charsSinceAccepts++;
          }
          tokenLength += iterable[charCursor].length;
          cursor += iterable[charCursor].length;
          charCursor++;
        }
        cursor -= sinceAccepts;
        charCursor -= charsSinceAccepts;
        tokenLength -= sinceAccepts;
        tokens.push({
          t: latestAccepting.t,
          // token type/name
          v: str.slice(cursor - tokenLength, cursor),
          // string value
          s: cursor - tokenLength,
          // start index
          e: cursor
          // end index (excluding)
        });
      }
      return tokens;
    }
    function stringToArray(str) {
      const result = [];
      const len = str.length;
      let index = 0;
      while (index < len) {
        let first = str.charCodeAt(index);
        let second;
        let char = first < 55296 || first > 56319 || index + 1 === len || (second = str.charCodeAt(index + 1)) < 56320 || second > 57343 ? str[index] : str.slice(index, index + 2);
        result.push(char);
        index += char.length;
      }
      return result;
    }
    function fastts(state2, input, t, defaultt, jr) {
      let next;
      const len = input.length;
      for (let i = 0; i < len - 1; i++) {
        const char = input[i];
        if (state2.j[char]) {
          next = state2.j[char];
        } else {
          next = new State(defaultt);
          next.jr = jr.slice();
          state2.j[char] = next;
        }
        state2 = next;
      }
      next = new State(t);
      next.jr = jr.slice();
      state2.j[input[len - 1]] = next;
      return next;
    }
    function decodeTlds(encoded) {
      const words = [];
      const stack = [];
      let i = 0;
      let digits = "0123456789";
      while (i < encoded.length) {
        let popDigitCount = 0;
        while (digits.indexOf(encoded[i + popDigitCount]) >= 0) {
          popDigitCount++;
        }
        if (popDigitCount > 0) {
          words.push(stack.join(""));
          for (let popCount = parseInt(encoded.substring(i, i + popDigitCount), 10); popCount > 0; popCount--) {
            stack.pop();
          }
          i += popDigitCount;
        } else {
          stack.push(encoded[i]);
          i++;
        }
      }
      return words;
    }
    var defaults = {
      defaultProtocol: "http",
      events: null,
      format: noop2,
      formatHref: noop2,
      nl2br: false,
      tagName: "a",
      target: null,
      rel: null,
      validate: true,
      truncate: Infinity,
      className: null,
      attributes: null,
      ignoreTags: [],
      render: null
    };
    function Options(opts, defaultRender = null) {
      let o = Object.assign({}, defaults);
      if (opts) {
        o = Object.assign(o, opts instanceof Options ? opts.o : opts);
      }
      const ignoredTags = o.ignoreTags;
      const uppercaseIgnoredTags = [];
      for (let i = 0; i < ignoredTags.length; i++) {
        uppercaseIgnoredTags.push(ignoredTags[i].toUpperCase());
      }
      this.o = o;
      if (defaultRender) {
        this.defaultRender = defaultRender;
      }
      this.ignoreTags = uppercaseIgnoredTags;
    }
    Options.prototype = {
      o: defaults,
      /**
       * @type string[]
       */
      ignoreTags: [],
      /**
       * @param {IntermediateRepresentation} ir
       * @returns {any}
       */
      defaultRender(ir) {
        return ir;
      },
      /**
       * Returns true or false based on whether a token should be displayed as a
       * link based on the user options.
       * @param {MultiToken} token
       * @returns {boolean}
       */
      check(token) {
        return this.get("validate", token.toString(), token);
      },
      // Private methods
      /**
       * Resolve an option's value based on the value of the option and the given
       * params. If operator and token are specified and the target option is
       * callable, automatically calls the function with the given argument.
       * @template {keyof Opts} K
       * @param {K} key Name of option to use
       * @param {string} [operator] will be passed to the target option if it's a
       * function. If not specified, RAW function value gets returned
       * @param {MultiToken} [token] The token from linkify.tokenize
       * @returns {Opts[K] | any}
       */
      get(key, operator, token) {
        const isCallable2 = operator != null;
        let option = this.o[key];
        if (!option) {
          return option;
        }
        if (typeof option === "object") {
          option = token.t in option ? option[token.t] : defaults[key];
          if (typeof option === "function" && isCallable2) {
            option = option(operator, token);
          }
        } else if (typeof option === "function" && isCallable2) {
          option = option(operator, token.t, token);
        }
        return option;
      },
      /**
       * @template {keyof Opts} L
       * @param {L} key Name of options object to use
       * @param {string} [operator]
       * @param {MultiToken} [token]
       * @returns {Opts[L] | any}
       */
      getObj(key, operator, token) {
        let obj = this.o[key];
        if (typeof obj === "function" && operator != null) {
          obj = obj(operator, token.t, token);
        }
        return obj;
      },
      /**
       * Convert the given token to a rendered element that may be added to the
       * calling-interface's DOM
       * @param {MultiToken} token Token to render to an HTML element
       * @returns {any} Render result; e.g., HTML string, DOM element, React
       *   Component, etc.
       */
      render(token) {
        const ir = token.render(this);
        const renderFn = this.get("render", null, token) || this.defaultRender;
        return renderFn(ir, token.t, token);
      }
    };
    function noop2(val) {
      return val;
    }
    var options = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      Options,
      defaults
    });
    function MultiToken(value, tokens) {
      this.t = "token";
      this.v = value;
      this.tk = tokens;
    }
    MultiToken.prototype = {
      isLink: false,
      /**
       * Return the string this token represents.
       * @return {string}
       */
      toString() {
        return this.v;
      },
      /**
       * What should the value for this token be in the `href` HTML attribute?
       * Returns the `.toString` value by default.
       * @param {string} [scheme]
       * @return {string}
       */
      toHref(scheme2) {
        return this.toString();
      },
      /**
       * @param {Options} options Formatting options
       * @returns {string}
       */
      toFormattedString(options2) {
        const val = this.toString();
        const truncate = options2.get("truncate", val, this);
        const formatted = options2.get("format", val, this);
        return truncate && formatted.length > truncate ? formatted.substring(0, truncate) + "\u2026" : formatted;
      },
      /**
       *
       * @param {Options} options
       * @returns {string}
       */
      toFormattedHref(options2) {
        return options2.get("formatHref", this.toHref(options2.get("defaultProtocol")), this);
      },
      /**
       * The start index of this token in the original input string
       * @returns {number}
       */
      startIndex() {
        return this.tk[0].s;
      },
      /**
       * The end index of this token in the original input string (up to this
       * index but not including it)
       * @returns {number}
       */
      endIndex() {
        return this.tk[this.tk.length - 1].e;
      },
      /**
      	Returns an object  of relevant values for this token, which includes keys
      	* type - Kind of token ('url', 'email', etc.)
      	* value - Original text
      	* href - The value that should be added to the anchor tag's href
      		attribute
      		@method toObject
      	@param {string} [protocol] `'http'` by default
      */
      toObject(protocol = defaults.defaultProtocol) {
        return {
          type: this.t,
          value: this.toString(),
          isLink: this.isLink,
          href: this.toHref(protocol),
          start: this.startIndex(),
          end: this.endIndex()
        };
      },
      /**
       *
       * @param {Options} options Formatting option
       */
      toFormattedObject(options2) {
        return {
          type: this.t,
          value: this.toFormattedString(options2),
          isLink: this.isLink,
          href: this.toFormattedHref(options2),
          start: this.startIndex(),
          end: this.endIndex()
        };
      },
      /**
       * Whether this token should be rendered as a link according to the given options
       * @param {Options} options
       * @returns {boolean}
       */
      validate(options2) {
        return options2.get("validate", this.toString(), this);
      },
      /**
       * Return an object that represents how this link should be rendered.
       * @param {Options} options Formattinng options
       */
      render(options2) {
        const token = this;
        const href = this.toHref(options2.get("defaultProtocol"));
        const formattedHref = options2.get("formatHref", href, this);
        const tagName = options2.get("tagName", href, token);
        const content = this.toFormattedString(options2);
        const attributes = {};
        const className = options2.get("className", href, token);
        const target = options2.get("target", href, token);
        const rel = options2.get("rel", href, token);
        const attrs = options2.getObj("attributes", href, token);
        const eventListeners = options2.getObj("events", href, token);
        attributes.href = formattedHref;
        if (className) {
          attributes.class = className;
        }
        if (target) {
          attributes.target = target;
        }
        if (rel) {
          attributes.rel = rel;
        }
        if (attrs) {
          Object.assign(attributes, attrs);
        }
        return {
          tagName,
          attributes,
          content,
          eventListeners
        };
      }
    };
    function createTokenClass(type2, props) {
      class Token extends MultiToken {
        constructor(value, tokens) {
          super(value, tokens);
          this.t = type2;
        }
      }
      for (const p in props) {
        Token.prototype[p] = props[p];
      }
      Token.t = type2;
      return Token;
    }
    var Email = createTokenClass("email", {
      isLink: true,
      toHref() {
        return "mailto:" + this.toString();
      }
    });
    var Text2 = createTokenClass("text");
    var Nl = createTokenClass("nl");
    var Url = createTokenClass("url", {
      isLink: true,
      /**
      	Lowercases relevant parts of the domain and adds the protocol if
      	required. Note that this will not escape unsafe HTML characters in the
      	URL.
      		@param {string} [scheme] default scheme (e.g., 'https')
      	@return {string} the full href
      */
      toHref(scheme2 = defaults.defaultProtocol) {
        return this.hasProtocol() ? this.v : `${scheme2}://${this.v}`;
      },
      /**
       * Check whether this URL token has a protocol
       * @return {boolean}
       */
      hasProtocol() {
        const tokens = this.tk;
        return tokens.length >= 2 && tokens[0].t !== LOCALHOST && tokens[1].t === COLON;
      }
    });
    var multi = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      Base: MultiToken,
      Email,
      MultiToken,
      Nl,
      Text: Text2,
      Url,
      createTokenClass
    });
    var makeState = (arg) => new State(arg);
    function init$1({
      groups
    }) {
      const qsAccepting = groups.domain.concat([AMPERSAND, ASTERISK, AT, BACKSLASH, BACKTICK, CARET, DOLLAR, EQUALS, HYPHEN, NUM, PERCENT, PIPE, PLUS, POUND, SLASH, SYM, TILDE, UNDERSCORE]);
      const qsNonAccepting = [APOSTROPHE, COLON, COMMA, DOT, EXCLAMATION, PERCENT, QUERY, QUOTE, SEMI, OPENANGLEBRACKET, CLOSEANGLEBRACKET, OPENBRACE, CLOSEBRACE, CLOSEBRACKET, OPENBRACKET, OPENPAREN, CLOSEPAREN, FULLWIDTHLEFTPAREN, FULLWIDTHRIGHTPAREN, LEFTCORNERBRACKET, RIGHTCORNERBRACKET, LEFTWHITECORNERBRACKET, RIGHTWHITECORNERBRACKET, FULLWIDTHLESSTHAN, FULLWIDTHGREATERTHAN];
      const localpartAccepting = [AMPERSAND, APOSTROPHE, ASTERISK, BACKSLASH, BACKTICK, CARET, DOLLAR, EQUALS, HYPHEN, OPENBRACE, CLOSEBRACE, PERCENT, PIPE, PLUS, POUND, QUERY, SLASH, SYM, TILDE, UNDERSCORE];
      const Start = makeState();
      const Localpart = tt(Start, TILDE);
      ta(Localpart, localpartAccepting, Localpart);
      ta(Localpart, groups.domain, Localpart);
      const Domain = makeState(), Scheme = makeState(), SlashScheme = makeState();
      ta(Start, groups.domain, Domain);
      ta(Start, groups.scheme, Scheme);
      ta(Start, groups.slashscheme, SlashScheme);
      ta(Domain, localpartAccepting, Localpart);
      ta(Domain, groups.domain, Domain);
      const LocalpartAt = tt(Domain, AT);
      tt(Localpart, AT, LocalpartAt);
      tt(Scheme, AT, LocalpartAt);
      tt(SlashScheme, AT, LocalpartAt);
      const LocalpartDot = tt(Localpart, DOT);
      ta(LocalpartDot, localpartAccepting, Localpart);
      ta(LocalpartDot, groups.domain, Localpart);
      const EmailDomain = makeState();
      ta(LocalpartAt, groups.domain, EmailDomain);
      ta(EmailDomain, groups.domain, EmailDomain);
      const EmailDomainDot = tt(EmailDomain, DOT);
      ta(EmailDomainDot, groups.domain, EmailDomain);
      const Email$1 = makeState(Email);
      ta(EmailDomainDot, groups.tld, Email$1);
      ta(EmailDomainDot, groups.utld, Email$1);
      tt(LocalpartAt, LOCALHOST, Email$1);
      const EmailDomainHyphen = tt(EmailDomain, HYPHEN);
      tt(EmailDomainHyphen, HYPHEN, EmailDomainHyphen);
      ta(EmailDomainHyphen, groups.domain, EmailDomain);
      ta(Email$1, groups.domain, EmailDomain);
      tt(Email$1, DOT, EmailDomainDot);
      tt(Email$1, HYPHEN, EmailDomainHyphen);
      const EmailColon = tt(Email$1, COLON);
      ta(EmailColon, groups.numeric, Email);
      const DomainHyphen = tt(Domain, HYPHEN);
      const DomainDot = tt(Domain, DOT);
      tt(DomainHyphen, HYPHEN, DomainHyphen);
      ta(DomainHyphen, groups.domain, Domain);
      ta(DomainDot, localpartAccepting, Localpart);
      ta(DomainDot, groups.domain, Domain);
      const DomainDotTld = makeState(Url);
      ta(DomainDot, groups.tld, DomainDotTld);
      ta(DomainDot, groups.utld, DomainDotTld);
      ta(DomainDotTld, groups.domain, Domain);
      ta(DomainDotTld, localpartAccepting, Localpart);
      tt(DomainDotTld, DOT, DomainDot);
      tt(DomainDotTld, HYPHEN, DomainHyphen);
      tt(DomainDotTld, AT, LocalpartAt);
      const DomainDotTldColon = tt(DomainDotTld, COLON);
      const DomainDotTldColonPort = makeState(Url);
      ta(DomainDotTldColon, groups.numeric, DomainDotTldColonPort);
      const Url$1 = makeState(Url);
      const UrlNonaccept = makeState();
      ta(Url$1, qsAccepting, Url$1);
      ta(Url$1, qsNonAccepting, UrlNonaccept);
      ta(UrlNonaccept, qsAccepting, Url$1);
      ta(UrlNonaccept, qsNonAccepting, UrlNonaccept);
      tt(DomainDotTld, SLASH, Url$1);
      tt(DomainDotTldColonPort, SLASH, Url$1);
      const SchemeColon = tt(Scheme, COLON);
      const SlashSchemeColon = tt(SlashScheme, COLON);
      const SlashSchemeColonSlash = tt(SlashSchemeColon, SLASH);
      const UriPrefix = tt(SlashSchemeColonSlash, SLASH);
      ta(Scheme, groups.domain, Domain);
      tt(Scheme, DOT, DomainDot);
      tt(Scheme, HYPHEN, DomainHyphen);
      ta(SlashScheme, groups.domain, Domain);
      tt(SlashScheme, DOT, DomainDot);
      tt(SlashScheme, HYPHEN, DomainHyphen);
      ta(SchemeColon, groups.domain, Url$1);
      tt(SchemeColon, SLASH, Url$1);
      tt(SchemeColon, QUERY, Url$1);
      ta(UriPrefix, groups.domain, Url$1);
      ta(UriPrefix, qsAccepting, Url$1);
      tt(UriPrefix, SLASH, Url$1);
      const bracketPairs = [
        [OPENBRACE, CLOSEBRACE],
        // {}
        [OPENBRACKET, CLOSEBRACKET],
        // []
        [OPENPAREN, CLOSEPAREN],
        // ()
        [OPENANGLEBRACKET, CLOSEANGLEBRACKET],
        // <>
        [FULLWIDTHLEFTPAREN, FULLWIDTHRIGHTPAREN],
        // （）
        [LEFTCORNERBRACKET, RIGHTCORNERBRACKET],
        // 「」
        [LEFTWHITECORNERBRACKET, RIGHTWHITECORNERBRACKET],
        // 『』
        [FULLWIDTHLESSTHAN, FULLWIDTHGREATERTHAN]
        // ＜＞
      ];
      for (let i = 0; i < bracketPairs.length; i++) {
        const [OPEN, CLOSE] = bracketPairs[i];
        const UrlOpen = tt(Url$1, OPEN);
        tt(UrlNonaccept, OPEN, UrlOpen);
        tt(UrlOpen, CLOSE, Url$1);
        const UrlOpenQ = makeState(Url);
        ta(UrlOpen, qsAccepting, UrlOpenQ);
        const UrlOpenSyms = makeState();
        ta(UrlOpen, qsNonAccepting);
        ta(UrlOpenQ, qsAccepting, UrlOpenQ);
        ta(UrlOpenQ, qsNonAccepting, UrlOpenSyms);
        ta(UrlOpenSyms, qsAccepting, UrlOpenQ);
        ta(UrlOpenSyms, qsNonAccepting, UrlOpenSyms);
        tt(UrlOpenQ, CLOSE, Url$1);
        tt(UrlOpenSyms, CLOSE, Url$1);
      }
      tt(Start, LOCALHOST, DomainDotTld);
      tt(Start, NL, Nl);
      return {
        start: Start,
        tokens: tk
      };
    }
    function run(start, input, tokens) {
      let len = tokens.length;
      let cursor = 0;
      let multis = [];
      let textTokens = [];
      while (cursor < len) {
        let state2 = start;
        let secondState = null;
        let nextState = null;
        let multiLength = 0;
        let latestAccepting = null;
        let sinceAccepts = -1;
        while (cursor < len && !(secondState = state2.go(tokens[cursor].t))) {
          textTokens.push(tokens[cursor++]);
        }
        while (cursor < len && (nextState = secondState || state2.go(tokens[cursor].t))) {
          secondState = null;
          state2 = nextState;
          if (state2.accepts()) {
            sinceAccepts = 0;
            latestAccepting = state2;
          } else if (sinceAccepts >= 0) {
            sinceAccepts++;
          }
          cursor++;
          multiLength++;
        }
        if (sinceAccepts < 0) {
          cursor -= multiLength;
          if (cursor < len) {
            textTokens.push(tokens[cursor]);
            cursor++;
          }
        } else {
          if (textTokens.length > 0) {
            multis.push(initMultiToken(Text2, input, textTokens));
            textTokens = [];
          }
          cursor -= sinceAccepts;
          multiLength -= sinceAccepts;
          const Multi = latestAccepting.t;
          const subtokens = tokens.slice(cursor - multiLength, cursor);
          multis.push(initMultiToken(Multi, input, subtokens));
        }
      }
      if (textTokens.length > 0) {
        multis.push(initMultiToken(Text2, input, textTokens));
      }
      return multis;
    }
    function initMultiToken(Multi, input, tokens) {
      const startIdx = tokens[0].s;
      const endIdx = tokens[tokens.length - 1].e;
      const value = input.slice(startIdx, endIdx);
      return new Multi(value, tokens);
    }
    var warn = typeof console !== "undefined" && console && console.warn || (() => {
    });
    var warnAdvice = "until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.";
    var INIT = {
      scanner: null,
      parser: null,
      tokenQueue: [],
      pluginQueue: [],
      customSchemes: [],
      initialized: false
    };
    function reset() {
      State.groups = {};
      INIT.scanner = null;
      INIT.parser = null;
      INIT.tokenQueue = [];
      INIT.pluginQueue = [];
      INIT.customSchemes = [];
      INIT.initialized = false;
      return INIT;
    }
    function registerTokenPlugin(name, plugin) {
      if (typeof plugin !== "function") {
        throw new Error(`linkifyjs: Invalid token plugin ${plugin} (expects function)`);
      }
      for (let i = 0; i < INIT.tokenQueue.length; i++) {
        if (name === INIT.tokenQueue[i][0]) {
          warn(`linkifyjs: token plugin "${name}" already registered - will be overwritten`);
          INIT.tokenQueue[i] = [name, plugin];
          return;
        }
      }
      INIT.tokenQueue.push([name, plugin]);
      if (INIT.initialized) {
        warn(`linkifyjs: already initialized - will not register token plugin "${name}" ${warnAdvice}`);
      }
    }
    function registerPlugin(name, plugin) {
      if (typeof plugin !== "function") {
        throw new Error(`linkifyjs: Invalid plugin ${plugin} (expects function)`);
      }
      for (let i = 0; i < INIT.pluginQueue.length; i++) {
        if (name === INIT.pluginQueue[i][0]) {
          warn(`linkifyjs: plugin "${name}" already registered - will be overwritten`);
          INIT.pluginQueue[i] = [name, plugin];
          return;
        }
      }
      INIT.pluginQueue.push([name, plugin]);
      if (INIT.initialized) {
        warn(`linkifyjs: already initialized - will not register plugin "${name}" ${warnAdvice}`);
      }
    }
    function registerCustomProtocol(scheme2, optionalSlashSlash = false) {
      if (INIT.initialized) {
        warn(`linkifyjs: already initialized - will not register custom scheme "${scheme2}" ${warnAdvice}`);
      }
      if (!/^[0-9a-z]+(-[0-9a-z]+)*$/.test(scheme2)) {
        throw new Error(`linkifyjs: incorrect scheme format.
1. Must only contain digits, lowercase ASCII letters or "-"
2. Cannot start or end with "-"
3. "-" cannot repeat`);
      }
      INIT.customSchemes.push([scheme2, optionalSlashSlash]);
    }
    function init() {
      INIT.scanner = init$2(INIT.customSchemes);
      for (let i = 0; i < INIT.tokenQueue.length; i++) {
        INIT.tokenQueue[i][1]({
          scanner: INIT.scanner
        });
      }
      INIT.parser = init$1(INIT.scanner.tokens);
      for (let i = 0; i < INIT.pluginQueue.length; i++) {
        INIT.pluginQueue[i][1]({
          scanner: INIT.scanner,
          parser: INIT.parser
        });
      }
      INIT.initialized = true;
      return INIT;
    }
    function tokenize(str) {
      if (!INIT.initialized) {
        init();
      }
      return run(INIT.parser.start, str, run$1(INIT.scanner.start, str));
    }
    tokenize.scan = run$1;
    function find(str, type2 = null, opts = null) {
      if (type2 && typeof type2 === "object") {
        if (opts) {
          throw Error(`linkifyjs: Invalid link type ${type2}; must be a string`);
        }
        opts = type2;
        type2 = null;
      }
      const options2 = new Options(opts);
      const tokens = tokenize(str);
      const filtered = [];
      for (let i = 0; i < tokens.length; i++) {
        const token = tokens[i];
        if (token.isLink && (!type2 || token.t === type2) && options2.check(token)) {
          filtered.push(token.toFormattedObject(options2));
        }
      }
      return filtered;
    }
    function test(str, type2 = null) {
      const tokens = tokenize(str);
      return tokens.length === 1 && tokens[0].isLink && (!type2 || tokens[0].t === type2);
    }
    exports2.MultiToken = MultiToken;
    exports2.Options = Options;
    exports2.State = State;
    exports2.createTokenClass = createTokenClass;
    exports2.find = find;
    exports2.init = init;
    exports2.multi = multi;
    exports2.options = options;
    exports2.regexp = regexp;
    exports2.registerCustomProtocol = registerCustomProtocol;
    exports2.registerPlugin = registerPlugin;
    exports2.registerTokenPlugin = registerTokenPlugin;
    exports2.reset = reset;
    exports2.stringToArray = stringToArray;
    exports2.test = test;
    exports2.text = multi;
    exports2.tokenize = tokenize;
  }
});

// node_modules/.pnpm/@tiptap+extension-link@3.11.0_@tiptap+core@3.11.0_@tiptap+pm@3.11.0__@tiptap+pm@3.11.0/node_modules/@tiptap/extension-link/dist/index.cjs
var require_dist19 = __commonJS({
  "node_modules/.pnpm/@tiptap+extension-link@3.11.0_@tiptap+core@3.11.0_@tiptap+pm@3.11.0__@tiptap+pm@3.11.0/node_modules/@tiptap/extension-link/dist/index.cjs"(exports2, module2) {
    "use strict";
    var __defProp3 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp3 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp3(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp3.call(to, key) && key !== except)
            __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp3({}, "__esModule", { value: true }), mod);
    var index_exports = {};
    __export2(index_exports, {
      Link: () => Link,
      default: () => index_default,
      isAllowedUri: () => isAllowedUri,
      pasteRegex: () => pasteRegex
    });
    module2.exports = __toCommonJS2(index_exports);
    var import_core3 = require_dist9();
    var import_linkifyjs3 = require_linkify();
    var import_core = require_dist9();
    var import_state = require_state();
    var import_linkifyjs = require_linkify();
    var UNICODE_WHITESPACE_PATTERN = "[\0- \xA0\u1680\u180E\u2000-\u2029\u205F\u3000]";
    var UNICODE_WHITESPACE_REGEX = new RegExp(UNICODE_WHITESPACE_PATTERN);
    var UNICODE_WHITESPACE_REGEX_END = new RegExp(`${UNICODE_WHITESPACE_PATTERN}$`);
    var UNICODE_WHITESPACE_REGEX_GLOBAL = new RegExp(UNICODE_WHITESPACE_PATTERN, "g");
    function isValidLinkStructure(tokens) {
      if (tokens.length === 1) {
        return tokens[0].isLink;
      }
      if (tokens.length === 3 && tokens[1].isLink) {
        return ["()", "[]"].includes(tokens[0].value + tokens[2].value);
      }
      return false;
    }
    function autolink(options) {
      return new import_state.Plugin({
        key: new import_state.PluginKey("autolink"),
        appendTransaction: (transactions, oldState, newState) => {
          const docChanges = transactions.some((transaction) => transaction.docChanged) && !oldState.doc.eq(newState.doc);
          const preventAutolink = transactions.some((transaction) => transaction.getMeta("preventAutolink"));
          if (!docChanges || preventAutolink) {
            return;
          }
          const { tr } = newState;
          const transform = (0, import_core.combineTransactionSteps)(oldState.doc, [...transactions]);
          const changes = (0, import_core.getChangedRanges)(transform);
          changes.forEach(({ newRange }) => {
            const nodesInChangedRanges = (0, import_core.findChildrenInRange)(newState.doc, newRange, (node) => node.isTextblock);
            let textBlock;
            let textBeforeWhitespace;
            if (nodesInChangedRanges.length > 1) {
              textBlock = nodesInChangedRanges[0];
              textBeforeWhitespace = newState.doc.textBetween(
                textBlock.pos,
                textBlock.pos + textBlock.node.nodeSize,
                void 0,
                " "
              );
            } else if (nodesInChangedRanges.length) {
              const endText = newState.doc.textBetween(newRange.from, newRange.to, " ", " ");
              if (!UNICODE_WHITESPACE_REGEX_END.test(endText)) {
                return;
              }
              textBlock = nodesInChangedRanges[0];
              textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, newRange.to, void 0, " ");
            }
            if (textBlock && textBeforeWhitespace) {
              const wordsBeforeWhitespace = textBeforeWhitespace.split(UNICODE_WHITESPACE_REGEX).filter(Boolean);
              if (wordsBeforeWhitespace.length <= 0) {
                return false;
              }
              const lastWordBeforeSpace = wordsBeforeWhitespace[wordsBeforeWhitespace.length - 1];
              const lastWordAndBlockOffset = textBlock.pos + textBeforeWhitespace.lastIndexOf(lastWordBeforeSpace);
              if (!lastWordBeforeSpace) {
                return false;
              }
              const linksBeforeSpace = (0, import_linkifyjs.tokenize)(lastWordBeforeSpace).map((t) => t.toObject(options.defaultProtocol));
              if (!isValidLinkStructure(linksBeforeSpace)) {
                return false;
              }
              linksBeforeSpace.filter((link) => link.isLink).map((link) => ({
                ...link,
                from: lastWordAndBlockOffset + link.start + 1,
                to: lastWordAndBlockOffset + link.end + 1
              })).filter((link) => {
                if (!newState.schema.marks.code) {
                  return true;
                }
                return !newState.doc.rangeHasMark(link.from, link.to, newState.schema.marks.code);
              }).filter((link) => options.validate(link.value)).filter((link) => options.shouldAutoLink(link.value)).forEach((link) => {
                if ((0, import_core.getMarksBetween)(link.from, link.to, newState.doc).some((item) => item.mark.type === options.type)) {
                  return;
                }
                tr.addMark(
                  link.from,
                  link.to,
                  options.type.create({
                    href: link.href
                  })
                );
              });
            }
          });
          if (!tr.steps.length) {
            return;
          }
          return tr;
        }
      });
    }
    var import_core2 = require_dist9();
    var import_state2 = require_state();
    function clickHandler(options) {
      return new import_state2.Plugin({
        key: new import_state2.PluginKey("handleClickLink"),
        props: {
          handleClick: (view, pos, event) => {
            var _a, _b;
            if (event.button !== 0) {
              return false;
            }
            if (!view.editable) {
              return false;
            }
            let link = null;
            if (event.target instanceof HTMLAnchorElement) {
              link = event.target;
            } else {
              let a = event.target;
              const els = [];
              while (a.nodeName !== "DIV") {
                els.push(a);
                a = a.parentNode;
              }
              link = els.find((value) => value.nodeName === "A");
            }
            if (!link) {
              return false;
            }
            const attrs = (0, import_core2.getAttributes)(view.state, options.type.name);
            const href = (_a = link == null ? void 0 : link.href) != null ? _a : attrs.href;
            const target = (_b = link == null ? void 0 : link.target) != null ? _b : attrs.target;
            if (options.enableClickSelection) {
              options.editor.commands.extendMarkRange(options.type.name);
            }
            if (link && href) {
              window.open(href, target);
              return true;
            }
            return false;
          }
        }
      });
    }
    var import_state3 = require_state();
    var import_linkifyjs2 = require_linkify();
    function pasteHandler(options) {
      return new import_state3.Plugin({
        key: new import_state3.PluginKey("handlePasteLink"),
        props: {
          handlePaste: (view, _event, slice) => {
            const { shouldAutoLink } = options;
            const { state: state2 } = view;
            const { selection } = state2;
            const { empty } = selection;
            if (empty) {
              return false;
            }
            let textContent = "";
            slice.content.forEach((node) => {
              textContent += node.textContent;
            });
            const link = (0, import_linkifyjs2.find)(textContent, { defaultProtocol: options.defaultProtocol }).find(
              (item) => item.isLink && item.value === textContent
            );
            if (!textContent || !link || shouldAutoLink !== void 0 && !shouldAutoLink(link.href)) {
              return false;
            }
            return options.editor.commands.setMark(options.type, {
              href: link.href
            });
          }
        }
      });
    }
    var pasteRegex = /https?:\/\/(?:www\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-zA-Z]{2,}\b(?:[-a-zA-Z0-9@:%._+~#=?!&/]*)(?:[-a-zA-Z0-9@:%._+~#=?!&/]*)/gi;
    function isAllowedUri(uri2, protocols) {
      const allowedProtocols = ["http", "https", "ftp", "ftps", "mailto", "tel", "callto", "sms", "cid", "xmpp"];
      if (protocols) {
        protocols.forEach((protocol) => {
          const nextProtocol = typeof protocol === "string" ? protocol : protocol.scheme;
          if (nextProtocol) {
            allowedProtocols.push(nextProtocol);
          }
        });
      }
      return !uri2 || uri2.replace(UNICODE_WHITESPACE_REGEX_GLOBAL, "").match(
        new RegExp(
          // eslint-disable-next-line no-useless-escape
          `^(?:(?:${allowedProtocols.join("|")}):|[^a-z]|[a-z0-9+.-]+(?:[^a-z+.-:]|$))`,
          "i"
        )
      );
    }
    var Link = import_core3.Mark.create({
      name: "link",
      priority: 1e3,
      keepOnSplit: false,
      exitable: true,
      onCreate() {
        if (this.options.validate && !this.options.shouldAutoLink) {
          this.options.shouldAutoLink = this.options.validate;
          console.warn("The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead.");
        }
        this.options.protocols.forEach((protocol) => {
          if (typeof protocol === "string") {
            (0, import_linkifyjs3.registerCustomProtocol)(protocol);
            return;
          }
          (0, import_linkifyjs3.registerCustomProtocol)(protocol.scheme, protocol.optionalSlashes);
        });
      },
      onDestroy() {
        (0, import_linkifyjs3.reset)();
      },
      inclusive() {
        return this.options.autolink;
      },
      addOptions() {
        return {
          openOnClick: true,
          enableClickSelection: false,
          linkOnPaste: true,
          autolink: true,
          protocols: [],
          defaultProtocol: "http",
          HTMLAttributes: {
            target: "_blank",
            rel: "noopener noreferrer nofollow",
            class: null
          },
          isAllowedUri: (url, ctx) => !!isAllowedUri(url, ctx.protocols),
          validate: (url) => !!url,
          shouldAutoLink: (url) => !!url
        };
      },
      addAttributes() {
        return {
          href: {
            default: null,
            parseHTML(element) {
              return element.getAttribute("href");
            }
          },
          target: {
            default: this.options.HTMLAttributes.target
          },
          rel: {
            default: this.options.HTMLAttributes.rel
          },
          class: {
            default: this.options.HTMLAttributes.class
          }
        };
      },
      parseHTML() {
        return [
          {
            tag: "a[href]",
            getAttrs: (dom) => {
              const href = dom.getAttribute("href");
              if (!href || !this.options.isAllowedUri(href, {
                defaultValidate: (url) => !!isAllowedUri(url, this.options.protocols),
                protocols: this.options.protocols,
                defaultProtocol: this.options.defaultProtocol
              })) {
                return false;
              }
              return null;
            }
          }
        ];
      },
      renderHTML({ HTMLAttributes }) {
        if (!this.options.isAllowedUri(HTMLAttributes.href, {
          defaultValidate: (href) => !!isAllowedUri(href, this.options.protocols),
          protocols: this.options.protocols,
          defaultProtocol: this.options.defaultProtocol
        })) {
          return ["a", (0, import_core3.mergeAttributes)(this.options.HTMLAttributes, { ...HTMLAttributes, href: "" }), 0];
        }
        return ["a", (0, import_core3.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];
      },
      markdownTokenName: "link",
      parseMarkdown: (token, helpers) => {
        return helpers.applyMark("link", helpers.parseInline(token.tokens || []), {
          href: token.href,
          title: token.title || null
        });
      },
      renderMarkdown: (node, h) => {
        var _a;
        const href = ((_a = node.attrs) == null ? void 0 : _a.href) || "";
        const text = h.renderChildren(node);
        return `[${text}](${href})`;
      },
      addCommands() {
        return {
          setLink: (attributes) => ({ chain }) => {
            const { href } = attributes;
            if (!this.options.isAllowedUri(href, {
              defaultValidate: (url) => !!isAllowedUri(url, this.options.protocols),
              protocols: this.options.protocols,
              defaultProtocol: this.options.defaultProtocol
            })) {
              return false;
            }
            return chain().setMark(this.name, attributes).setMeta("preventAutolink", true).run();
          },
          toggleLink: (attributes) => ({ chain }) => {
            const { href } = attributes || {};
            if (href && !this.options.isAllowedUri(href, {
              defaultValidate: (url) => !!isAllowedUri(url, this.options.protocols),
              protocols: this.options.protocols,
              defaultProtocol: this.options.defaultProtocol
            })) {
              return false;
            }
            return chain().toggleMark(this.name, attributes, { extendEmptyMarkRange: true }).setMeta("preventAutolink", true).run();
          },
          unsetLink: () => ({ chain }) => {
            return chain().unsetMark(this.name, { extendEmptyMarkRange: true }).setMeta("preventAutolink", true).run();
          }
        };
      },
      addPasteRules() {
        return [
          (0, import_core3.markPasteRule)({
            find: (text) => {
              const foundLinks = [];
              if (text) {
                const { protocols, defaultProtocol } = this.options;
                const links = (0, import_linkifyjs3.find)(text).filter(
                  (item) => item.isLink && this.options.isAllowedUri(item.value, {
                    defaultValidate: (href) => !!isAllowedUri(href, protocols),
                    protocols,
                    defaultProtocol
                  })
                );
                if (links.length) {
                  links.forEach((link) => {
                    if (!this.options.shouldAutoLink(link.value)) {
                      return;
                    }
                    foundLinks.push({
                      text: link.value,
                      data: {
                        href: link.href
                      },
                      index: link.start
                    });
                  });
                }
              }
              return foundLinks;
            },
            type: this.type,
            getAttributes: (match) => {
              var _a;
              return {
                href: (_a = match.data) == null ? void 0 : _a.href
              };
            }
          })
        ];
      },
      addProseMirrorPlugins() {
        const plugins = [];
        const { protocols, defaultProtocol } = this.options;
        if (this.options.autolink) {
          plugins.push(
            autolink({
              type: this.type,
              defaultProtocol: this.options.defaultProtocol,
              validate: (url) => this.options.isAllowedUri(url, {
                defaultValidate: (href) => !!isAllowedUri(href, protocols),
                protocols,
                defaultProtocol
              }),
              shouldAutoLink: this.options.shouldAutoLink
            })
          );
        }
        if (this.options.openOnClick === true) {
          plugins.push(
            clickHandler({
              type: this.type,
              editor: this.editor,
              enableClickSelection: this.options.enableClickSelection
            })
          );
        }
        if (this.options.linkOnPaste) {
          plugins.push(
            pasteHandler({
              editor: this.editor,
              defaultProtocol: this.options.defaultProtocol,
              type: this.type,
              shouldAutoLink: this.options.shouldAutoLink
            })
          );
        }
        return plugins;
      }
    });
    var index_default = Link;
  }
});

// node_modules/.pnpm/@tiptap+extension-list@3.11.0_@tiptap+core@3.11.0_@tiptap+pm@3.11.0__@tiptap+pm@3.11.0/node_modules/@tiptap/extension-list/dist/index.cjs
var require_dist20 = __commonJS({
  "node_modules/.pnpm/@tiptap+extension-list@3.11.0_@tiptap+core@3.11.0_@tiptap+pm@3.11.0__@tiptap+pm@3.11.0/node_modules/@tiptap/extension-list/dist/index.cjs"(exports2, module2) {
    "use strict";
    var __defProp3 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp3 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp3(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp3.call(to, key) && key !== except)
            __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp3({}, "__esModule", { value: true }), mod);
    var index_exports = {};
    __export2(index_exports, {
      BulletList: () => BulletList,
      ListItem: () => ListItem,
      ListKeymap: () => ListKeymap,
      ListKit: () => ListKit,
      OrderedList: () => OrderedList,
      TaskItem: () => TaskItem,
      TaskList: () => TaskList,
      bulletListInputRegex: () => bulletListInputRegex,
      inputRegex: () => inputRegex,
      listHelpers: () => listHelpers_exports,
      orderedListInputRegex: () => orderedListInputRegex
    });
    module2.exports = __toCommonJS2(index_exports);
    var import_core = require_dist9();
    var ListItemName = "listItem";
    var TextStyleName = "textStyle";
    var bulletListInputRegex = /^\s*([-+*])\s$/;
    var BulletList = import_core.Node.create({
      name: "bulletList",
      addOptions() {
        return {
          itemTypeName: "listItem",
          HTMLAttributes: {},
          keepMarks: false,
          keepAttributes: false
        };
      },
      group: "block list",
      content() {
        return `${this.options.itemTypeName}+`;
      },
      parseHTML() {
        return [{ tag: "ul" }];
      },
      renderHTML({ HTMLAttributes }) {
        return ["ul", (0, import_core.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];
      },
      markdownTokenName: "list",
      parseMarkdown: (token, helpers) => {
        if (token.type !== "list" || token.ordered) {
          return [];
        }
        return {
          type: "bulletList",
          content: token.items ? helpers.parseChildren(token.items) : []
        };
      },
      renderMarkdown: (node, h) => {
        if (!node.content) {
          return "";
        }
        return h.renderChildren(node.content, "\n");
      },
      markdownOptions: {
        indentsContent: true
      },
      addCommands() {
        return {
          toggleBulletList: () => ({ commands: commands2, chain }) => {
            if (this.options.keepAttributes) {
              return chain().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItemName, this.editor.getAttributes(TextStyleName)).run();
            }
            return commands2.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);
          }
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Shift-8": () => this.editor.commands.toggleBulletList()
        };
      },
      addInputRules() {
        let inputRule = (0, import_core.wrappingInputRule)({
          find: bulletListInputRegex,
          type: this.type
        });
        if (this.options.keepMarks || this.options.keepAttributes) {
          inputRule = (0, import_core.wrappingInputRule)({
            find: bulletListInputRegex,
            type: this.type,
            keepMarks: this.options.keepMarks,
            keepAttributes: this.options.keepAttributes,
            getAttributes: () => {
              return this.editor.getAttributes(TextStyleName);
            },
            editor: this.editor
          });
        }
        return [inputRule];
      }
    });
    var import_core2 = require_dist9();
    var ListItem = import_core2.Node.create({
      name: "listItem",
      addOptions() {
        return {
          HTMLAttributes: {},
          bulletListTypeName: "bulletList",
          orderedListTypeName: "orderedList"
        };
      },
      content: "paragraph block*",
      defining: true,
      parseHTML() {
        return [
          {
            tag: "li"
          }
        ];
      },
      renderHTML({ HTMLAttributes }) {
        return ["li", (0, import_core2.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];
      },
      markdownTokenName: "list_item",
      parseMarkdown: (token, helpers) => {
        if (token.type !== "list_item") {
          return [];
        }
        let content = [];
        if (token.tokens && token.tokens.length > 0) {
          const hasParagraphTokens = token.tokens.some((t) => t.type === "paragraph");
          if (hasParagraphTokens) {
            content = helpers.parseChildren(token.tokens);
          } else {
            const firstToken = token.tokens[0];
            if (firstToken && firstToken.type === "text" && firstToken.tokens && firstToken.tokens.length > 0) {
              const inlineContent = helpers.parseInline(firstToken.tokens);
              content = [
                {
                  type: "paragraph",
                  content: inlineContent
                }
              ];
              if (token.tokens.length > 1) {
                const remainingTokens = token.tokens.slice(1);
                const additionalContent = helpers.parseChildren(remainingTokens);
                content.push(...additionalContent);
              }
            } else {
              content = helpers.parseChildren(token.tokens);
            }
          }
        }
        if (content.length === 0) {
          content = [
            {
              type: "paragraph",
              content: []
            }
          ];
        }
        return {
          type: "listItem",
          content
        };
      },
      renderMarkdown: (node, h, ctx) => {
        return (0, import_core2.renderNestedMarkdownContent)(
          node,
          h,
          (context) => {
            if (context.parentType === "bulletList") {
              return "- ";
            }
            if (context.parentType === "orderedList") {
              return `${context.index + 1}. `;
            }
            return "- ";
          },
          ctx
        );
      },
      addKeyboardShortcuts() {
        return {
          Enter: () => this.editor.commands.splitListItem(this.name),
          Tab: () => this.editor.commands.sinkListItem(this.name),
          "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
        };
      }
    });
    var import_core8 = require_dist9();
    var listHelpers_exports = {};
    __export2(listHelpers_exports, {
      findListItemPos: () => findListItemPos,
      getNextListDepth: () => getNextListDepth,
      handleBackspace: () => handleBackspace,
      handleDelete: () => handleDelete,
      hasListBefore: () => hasListBefore,
      hasListItemAfter: () => hasListItemAfter,
      hasListItemBefore: () => hasListItemBefore,
      listItemHasSubList: () => listItemHasSubList,
      nextListIsDeeper: () => nextListIsDeeper,
      nextListIsHigher: () => nextListIsHigher
    });
    var import_core3 = require_dist9();
    var findListItemPos = (typeOrName, state2) => {
      const { $from } = state2.selection;
      const nodeType = (0, import_core3.getNodeType)(typeOrName, state2.schema);
      let currentNode = null;
      let currentDepth = $from.depth;
      let currentPos = $from.pos;
      let targetDepth = null;
      while (currentDepth > 0 && targetDepth === null) {
        currentNode = $from.node(currentDepth);
        if (currentNode.type === nodeType) {
          targetDepth = currentDepth;
        } else {
          currentDepth -= 1;
          currentPos -= 1;
        }
      }
      if (targetDepth === null) {
        return null;
      }
      return { $pos: state2.doc.resolve(currentPos), depth: targetDepth };
    };
    var import_core4 = require_dist9();
    var getNextListDepth = (typeOrName, state2) => {
      const listItemPos = findListItemPos(typeOrName, state2);
      if (!listItemPos) {
        return false;
      }
      const [, depth] = (0, import_core4.getNodeAtPosition)(state2, typeOrName, listItemPos.$pos.pos + 4);
      return depth;
    };
    var import_core6 = require_dist9();
    var hasListBefore = (editorState, name, parentListTypes) => {
      const { $anchor } = editorState.selection;
      const previousNodePos = Math.max(0, $anchor.pos - 2);
      const previousNode = editorState.doc.resolve(previousNodePos).node();
      if (!previousNode || !parentListTypes.includes(previousNode.type.name)) {
        return false;
      }
      return true;
    };
    var hasListItemBefore = (typeOrName, state2) => {
      var _a;
      const { $anchor } = state2.selection;
      const $targetPos = state2.doc.resolve($anchor.pos - 2);
      if ($targetPos.index() === 0) {
        return false;
      }
      if (((_a = $targetPos.nodeBefore) == null ? void 0 : _a.type.name) !== typeOrName) {
        return false;
      }
      return true;
    };
    var import_core5 = require_dist9();
    var listItemHasSubList = (typeOrName, state2, node) => {
      if (!node) {
        return false;
      }
      const nodeType = (0, import_core5.getNodeType)(typeOrName, state2.schema);
      let hasSubList = false;
      node.descendants((child) => {
        if (child.type === nodeType) {
          hasSubList = true;
        }
      });
      return hasSubList;
    };
    var handleBackspace = (editor, name, parentListTypes) => {
      if (editor.commands.undoInputRule()) {
        return true;
      }
      if (editor.state.selection.from !== editor.state.selection.to) {
        return false;
      }
      if (!(0, import_core6.isNodeActive)(editor.state, name) && hasListBefore(editor.state, name, parentListTypes)) {
        const { $anchor } = editor.state.selection;
        const $listPos = editor.state.doc.resolve($anchor.before() - 1);
        const listDescendants = [];
        $listPos.node().descendants((node, pos) => {
          if (node.type.name === name) {
            listDescendants.push({ node, pos });
          }
        });
        const lastItem = listDescendants.at(-1);
        if (!lastItem) {
          return false;
        }
        const $lastItemPos = editor.state.doc.resolve($listPos.start() + lastItem.pos + 1);
        return editor.chain().cut({ from: $anchor.start() - 1, to: $anchor.end() + 1 }, $lastItemPos.end()).joinForward().run();
      }
      if (!(0, import_core6.isNodeActive)(editor.state, name)) {
        return false;
      }
      if (!(0, import_core6.isAtStartOfNode)(editor.state)) {
        return false;
      }
      const listItemPos = findListItemPos(name, editor.state);
      if (!listItemPos) {
        return false;
      }
      const $prev = editor.state.doc.resolve(listItemPos.$pos.pos - 2);
      const prevNode = $prev.node(listItemPos.depth);
      const previousListItemHasSubList = listItemHasSubList(name, editor.state, prevNode);
      if (hasListItemBefore(name, editor.state) && !previousListItemHasSubList) {
        return editor.commands.joinItemBackward();
      }
      return editor.chain().liftListItem(name).run();
    };
    var import_core7 = require_dist9();
    var nextListIsDeeper = (typeOrName, state2) => {
      const listDepth = getNextListDepth(typeOrName, state2);
      const listItemPos = findListItemPos(typeOrName, state2);
      if (!listItemPos || !listDepth) {
        return false;
      }
      if (listDepth > listItemPos.depth) {
        return true;
      }
      return false;
    };
    var nextListIsHigher = (typeOrName, state2) => {
      const listDepth = getNextListDepth(typeOrName, state2);
      const listItemPos = findListItemPos(typeOrName, state2);
      if (!listItemPos || !listDepth) {
        return false;
      }
      if (listDepth < listItemPos.depth) {
        return true;
      }
      return false;
    };
    var handleDelete = (editor, name) => {
      if (!(0, import_core7.isNodeActive)(editor.state, name)) {
        return false;
      }
      if (!(0, import_core7.isAtEndOfNode)(editor.state, name)) {
        return false;
      }
      const { selection } = editor.state;
      const { $from, $to } = selection;
      if (!selection.empty && $from.sameParent($to)) {
        return false;
      }
      if (nextListIsDeeper(name, editor.state)) {
        return editor.chain().focus(editor.state.selection.from + 4).lift(name).joinBackward().run();
      }
      if (nextListIsHigher(name, editor.state)) {
        return editor.chain().joinForward().joinBackward().run();
      }
      return editor.commands.joinItemForward();
    };
    var hasListItemAfter = (typeOrName, state2) => {
      var _a;
      const { $anchor } = state2.selection;
      const $targetPos = state2.doc.resolve($anchor.pos - $anchor.parentOffset - 2);
      if ($targetPos.index() === $targetPos.parent.childCount - 1) {
        return false;
      }
      if (((_a = $targetPos.nodeAfter) == null ? void 0 : _a.type.name) !== typeOrName) {
        return false;
      }
      return true;
    };
    var ListKeymap = import_core8.Extension.create({
      name: "listKeymap",
      addOptions() {
        return {
          listTypes: [
            {
              itemName: "listItem",
              wrapperNames: ["bulletList", "orderedList"]
            },
            {
              itemName: "taskItem",
              wrapperNames: ["taskList"]
            }
          ]
        };
      },
      addKeyboardShortcuts() {
        return {
          Delete: ({ editor }) => {
            let handled = false;
            this.options.listTypes.forEach(({ itemName }) => {
              if (editor.state.schema.nodes[itemName] === void 0) {
                return;
              }
              if (handleDelete(editor, itemName)) {
                handled = true;
              }
            });
            return handled;
          },
          "Mod-Delete": ({ editor }) => {
            let handled = false;
            this.options.listTypes.forEach(({ itemName }) => {
              if (editor.state.schema.nodes[itemName] === void 0) {
                return;
              }
              if (handleDelete(editor, itemName)) {
                handled = true;
              }
            });
            return handled;
          },
          Backspace: ({ editor }) => {
            let handled = false;
            this.options.listTypes.forEach(({ itemName, wrapperNames }) => {
              if (editor.state.schema.nodes[itemName] === void 0) {
                return;
              }
              if (handleBackspace(editor, itemName, wrapperNames)) {
                handled = true;
              }
            });
            return handled;
          },
          "Mod-Backspace": ({ editor }) => {
            let handled = false;
            this.options.listTypes.forEach(({ itemName, wrapperNames }) => {
              if (editor.state.schema.nodes[itemName] === void 0) {
                return;
              }
              if (handleBackspace(editor, itemName, wrapperNames)) {
                handled = true;
              }
            });
            return handled;
          }
        };
      }
    });
    var import_core12 = require_dist9();
    var import_core9 = require_dist9();
    var ORDERED_LIST_ITEM_REGEX = /^(\s*)(\d+)\.\s+(.*)$/;
    var INDENTED_LINE_REGEX = /^\s/;
    function collectOrderedListItems(lines) {
      const listItems = [];
      let currentLineIndex = 0;
      let consumed = 0;
      while (currentLineIndex < lines.length) {
        const line = lines[currentLineIndex];
        const match = line.match(ORDERED_LIST_ITEM_REGEX);
        if (!match) {
          break;
        }
        const [, indent, number, content] = match;
        const indentLevel = indent.length;
        let itemContent = content;
        let nextLineIndex = currentLineIndex + 1;
        const itemLines = [line];
        while (nextLineIndex < lines.length) {
          const nextLine = lines[nextLineIndex];
          const nextMatch = nextLine.match(ORDERED_LIST_ITEM_REGEX);
          if (nextMatch) {
            break;
          }
          if (nextLine.trim() === "") {
            itemLines.push(nextLine);
            itemContent += "\n";
            nextLineIndex += 1;
          } else if (nextLine.match(INDENTED_LINE_REGEX)) {
            itemLines.push(nextLine);
            itemContent += `
${nextLine.slice(indentLevel + 2)}`;
            nextLineIndex += 1;
          } else {
            break;
          }
        }
        listItems.push({
          indent: indentLevel,
          number: parseInt(number, 10),
          content: itemContent.trim(),
          raw: itemLines.join("\n")
        });
        consumed = nextLineIndex;
        currentLineIndex = nextLineIndex;
      }
      return [listItems, consumed];
    }
    function buildNestedStructure(items, baseIndent, lexer) {
      var _a;
      const result = [];
      let currentIndex = 0;
      while (currentIndex < items.length) {
        const item = items[currentIndex];
        if (item.indent === baseIndent) {
          const contentLines = item.content.split("\n");
          const mainText = ((_a = contentLines[0]) == null ? void 0 : _a.trim()) || "";
          const tokens = [];
          if (mainText) {
            tokens.push({
              type: "paragraph",
              raw: mainText,
              tokens: lexer.inlineTokens(mainText)
            });
          }
          const additionalContent = contentLines.slice(1).join("\n").trim();
          if (additionalContent) {
            const blockTokens = lexer.blockTokens(additionalContent);
            tokens.push(...blockTokens);
          }
          let lookAheadIndex = currentIndex + 1;
          const nestedItems = [];
          while (lookAheadIndex < items.length && items[lookAheadIndex].indent > baseIndent) {
            nestedItems.push(items[lookAheadIndex]);
            lookAheadIndex += 1;
          }
          if (nestedItems.length > 0) {
            const nextIndent = Math.min(...nestedItems.map((nestedItem) => nestedItem.indent));
            const nestedListItems = buildNestedStructure(nestedItems, nextIndent, lexer);
            tokens.push({
              type: "list",
              ordered: true,
              start: nestedItems[0].number,
              items: nestedListItems,
              raw: nestedItems.map((nestedItem) => nestedItem.raw).join("\n")
            });
          }
          result.push({
            type: "list_item",
            raw: item.raw,
            tokens
          });
          currentIndex = lookAheadIndex;
        } else {
          currentIndex += 1;
        }
      }
      return result;
    }
    function parseListItems(items, helpers) {
      return items.map((item) => {
        if (item.type !== "list_item") {
          return helpers.parseChildren([item])[0];
        }
        const content = [];
        if (item.tokens && item.tokens.length > 0) {
          item.tokens.forEach((itemToken) => {
            if (itemToken.type === "paragraph" || itemToken.type === "list" || itemToken.type === "blockquote" || itemToken.type === "code") {
              content.push(...helpers.parseChildren([itemToken]));
            } else if (itemToken.type === "text" && itemToken.tokens) {
              const inlineContent = helpers.parseChildren([itemToken]);
              content.push({
                type: "paragraph",
                content: inlineContent
              });
            } else {
              const parsed = helpers.parseChildren([itemToken]);
              if (parsed.length > 0) {
                content.push(...parsed);
              }
            }
          });
        }
        return {
          type: "listItem",
          content
        };
      });
    }
    var ListItemName2 = "listItem";
    var TextStyleName2 = "textStyle";
    var orderedListInputRegex = /^(\d+)\.\s$/;
    var OrderedList = import_core9.Node.create({
      name: "orderedList",
      addOptions() {
        return {
          itemTypeName: "listItem",
          HTMLAttributes: {},
          keepMarks: false,
          keepAttributes: false
        };
      },
      group: "block list",
      content() {
        return `${this.options.itemTypeName}+`;
      },
      addAttributes() {
        return {
          start: {
            default: 1,
            parseHTML: (element) => {
              return element.hasAttribute("start") ? parseInt(element.getAttribute("start") || "", 10) : 1;
            }
          },
          type: {
            default: null,
            parseHTML: (element) => element.getAttribute("type")
          }
        };
      },
      parseHTML() {
        return [
          {
            tag: "ol"
          }
        ];
      },
      renderHTML({ HTMLAttributes }) {
        const { start, ...attributesWithoutStart } = HTMLAttributes;
        return start === 1 ? ["ol", (0, import_core9.mergeAttributes)(this.options.HTMLAttributes, attributesWithoutStart), 0] : ["ol", (0, import_core9.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];
      },
      markdownTokenName: "list",
      parseMarkdown: (token, helpers) => {
        if (token.type !== "list" || !token.ordered) {
          return [];
        }
        const startValue = token.start || 1;
        const content = token.items ? parseListItems(token.items, helpers) : [];
        if (startValue !== 1) {
          return {
            type: "orderedList",
            attrs: { start: startValue },
            content
          };
        }
        return {
          type: "orderedList",
          content
        };
      },
      renderMarkdown: (node, h) => {
        if (!node.content) {
          return "";
        }
        return h.renderChildren(node.content, "\n");
      },
      markdownTokenizer: {
        name: "orderedList",
        level: "block",
        start: (src) => {
          const match = src.match(/^(\s*)(\d+)\.\s+/);
          const index = match == null ? void 0 : match.index;
          return index !== void 0 ? index : -1;
        },
        tokenize: (src, _tokens, lexer) => {
          var _a;
          const lines = src.split("\n");
          const [listItems, consumed] = collectOrderedListItems(lines);
          if (listItems.length === 0) {
            return void 0;
          }
          const items = buildNestedStructure(listItems, 0, lexer);
          if (items.length === 0) {
            return void 0;
          }
          const startValue = ((_a = listItems[0]) == null ? void 0 : _a.number) || 1;
          return {
            type: "list",
            ordered: true,
            start: startValue,
            items,
            raw: lines.slice(0, consumed).join("\n")
          };
        }
      },
      markdownOptions: {
        indentsContent: true
      },
      addCommands() {
        return {
          toggleOrderedList: () => ({ commands: commands2, chain }) => {
            if (this.options.keepAttributes) {
              return chain().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItemName2, this.editor.getAttributes(TextStyleName2)).run();
            }
            return commands2.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);
          }
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Shift-7": () => this.editor.commands.toggleOrderedList()
        };
      },
      addInputRules() {
        let inputRule = (0, import_core9.wrappingInputRule)({
          find: orderedListInputRegex,
          type: this.type,
          getAttributes: (match) => ({ start: +match[1] }),
          joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1]
        });
        if (this.options.keepMarks || this.options.keepAttributes) {
          inputRule = (0, import_core9.wrappingInputRule)({
            find: orderedListInputRegex,
            type: this.type,
            keepMarks: this.options.keepMarks,
            keepAttributes: this.options.keepAttributes,
            getAttributes: (match) => ({ start: +match[1], ...this.editor.getAttributes(TextStyleName2) }),
            joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1],
            editor: this.editor
          });
        }
        return [inputRule];
      }
    });
    var import_core10 = require_dist9();
    var inputRegex = /^\s*(\[([( |x])?\])\s$/;
    var TaskItem = import_core10.Node.create({
      name: "taskItem",
      addOptions() {
        return {
          nested: false,
          HTMLAttributes: {},
          taskListTypeName: "taskList",
          a11y: void 0
        };
      },
      content() {
        return this.options.nested ? "paragraph block*" : "paragraph+";
      },
      defining: true,
      addAttributes() {
        return {
          checked: {
            default: false,
            keepOnSplit: false,
            parseHTML: (element) => {
              const dataChecked = element.getAttribute("data-checked");
              return dataChecked === "" || dataChecked === "true";
            },
            renderHTML: (attributes) => ({
              "data-checked": attributes.checked
            })
          }
        };
      },
      parseHTML() {
        return [
          {
            tag: `li[data-type="${this.name}"]`,
            priority: 51
          }
        ];
      },
      renderHTML({ node, HTMLAttributes }) {
        return [
          "li",
          (0, import_core10.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes, {
            "data-type": this.name
          }),
          [
            "label",
            [
              "input",
              {
                type: "checkbox",
                checked: node.attrs.checked ? "checked" : null
              }
            ],
            ["span"]
          ],
          ["div", 0]
        ];
      },
      parseMarkdown: (token, h) => {
        const content = [];
        if (token.tokens && token.tokens.length > 0) {
          content.push(h.createNode("paragraph", {}, h.parseInline(token.tokens)));
        } else if (token.text) {
          content.push(h.createNode("paragraph", {}, [h.createNode("text", { text: token.text })]));
        } else {
          content.push(h.createNode("paragraph", {}, []));
        }
        if (token.nestedTokens && token.nestedTokens.length > 0) {
          const nestedContent = h.parseChildren(token.nestedTokens);
          content.push(...nestedContent);
        }
        return h.createNode("taskItem", { checked: token.checked || false }, content);
      },
      renderMarkdown: (node, h) => {
        var _a;
        const checkedChar = ((_a = node.attrs) == null ? void 0 : _a.checked) ? "x" : " ";
        const prefix = `- [${checkedChar}] `;
        return (0, import_core10.renderNestedMarkdownContent)(node, h, prefix);
      },
      addKeyboardShortcuts() {
        const shortcuts = {
          Enter: () => this.editor.commands.splitListItem(this.name),
          "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
        };
        if (!this.options.nested) {
          return shortcuts;
        }
        return {
          ...shortcuts,
          Tab: () => this.editor.commands.sinkListItem(this.name)
        };
      },
      addNodeView() {
        return ({ node, HTMLAttributes, getPos, editor }) => {
          const listItem = document.createElement("li");
          const checkboxWrapper = document.createElement("label");
          const checkboxStyler = document.createElement("span");
          const checkbox = document.createElement("input");
          const content = document.createElement("div");
          const updateA11Y = (currentNode) => {
            var _a, _b;
            checkbox.ariaLabel = ((_b = (_a = this.options.a11y) == null ? void 0 : _a.checkboxLabel) == null ? void 0 : _b.call(_a, currentNode, checkbox.checked)) || `Task item checkbox for ${currentNode.textContent || "empty task item"}`;
          };
          updateA11Y(node);
          checkboxWrapper.contentEditable = "false";
          checkbox.type = "checkbox";
          checkbox.addEventListener("mousedown", (event) => event.preventDefault());
          checkbox.addEventListener("change", (event) => {
            if (!editor.isEditable && !this.options.onReadOnlyChecked) {
              checkbox.checked = !checkbox.checked;
              return;
            }
            const { checked } = event.target;
            if (editor.isEditable && typeof getPos === "function") {
              editor.chain().focus(void 0, { scrollIntoView: false }).command(({ tr }) => {
                const position = getPos();
                if (typeof position !== "number") {
                  return false;
                }
                const currentNode = tr.doc.nodeAt(position);
                tr.setNodeMarkup(position, void 0, {
                  ...currentNode == null ? void 0 : currentNode.attrs,
                  checked
                });
                return true;
              }).run();
            }
            if (!editor.isEditable && this.options.onReadOnlyChecked) {
              if (!this.options.onReadOnlyChecked(node, checked)) {
                checkbox.checked = !checkbox.checked;
              }
            }
          });
          Object.entries(this.options.HTMLAttributes).forEach(([key, value]) => {
            listItem.setAttribute(key, value);
          });
          listItem.dataset.checked = node.attrs.checked;
          checkbox.checked = node.attrs.checked;
          checkboxWrapper.append(checkbox, checkboxStyler);
          listItem.append(checkboxWrapper, content);
          Object.entries(HTMLAttributes).forEach(([key, value]) => {
            listItem.setAttribute(key, value);
          });
          return {
            dom: listItem,
            contentDOM: content,
            update: (updatedNode) => {
              if (updatedNode.type !== this.type) {
                return false;
              }
              listItem.dataset.checked = updatedNode.attrs.checked;
              checkbox.checked = updatedNode.attrs.checked;
              updateA11Y(updatedNode);
              return true;
            }
          };
        };
      },
      addInputRules() {
        return [
          (0, import_core10.wrappingInputRule)({
            find: inputRegex,
            type: this.type,
            getAttributes: (match) => ({
              checked: match[match.length - 1] === "x"
            })
          })
        ];
      }
    });
    var import_core11 = require_dist9();
    var TaskList = import_core11.Node.create({
      name: "taskList",
      addOptions() {
        return {
          itemTypeName: "taskItem",
          HTMLAttributes: {}
        };
      },
      group: "block list",
      content() {
        return `${this.options.itemTypeName}+`;
      },
      parseHTML() {
        return [
          {
            tag: `ul[data-type="${this.name}"]`,
            priority: 51
          }
        ];
      },
      renderHTML({ HTMLAttributes }) {
        return ["ul", (0, import_core11.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes, { "data-type": this.name }), 0];
      },
      parseMarkdown: (token, h) => {
        return h.createNode("taskList", {}, h.parseChildren(token.items || []));
      },
      renderMarkdown: (node, h) => {
        if (!node.content) {
          return "";
        }
        return h.renderChildren(node.content, "\n");
      },
      markdownTokenizer: {
        name: "taskList",
        level: "block",
        start(src) {
          var _a;
          const index = (_a = src.match(/^\s*[-+*]\s+\[([ xX])\]\s+/)) == null ? void 0 : _a.index;
          return index !== void 0 ? index : -1;
        },
        tokenize(src, tokens, lexer) {
          const parseTaskListContent = (content) => {
            const nestedResult = (0, import_core11.parseIndentedBlocks)(
              content,
              {
                itemPattern: /^(\s*)([-+*])\s+\[([ xX])\]\s+(.*)$/,
                extractItemData: (match) => ({
                  indentLevel: match[1].length,
                  mainContent: match[4],
                  checked: match[3].toLowerCase() === "x"
                }),
                createToken: (data, nestedTokens) => ({
                  type: "taskItem",
                  raw: "",
                  mainContent: data.mainContent,
                  indentLevel: data.indentLevel,
                  checked: data.checked,
                  text: data.mainContent,
                  tokens: lexer.inlineTokens(data.mainContent),
                  nestedTokens
                }),
                // Allow recursive nesting
                customNestedParser: parseTaskListContent
              },
              lexer
            );
            if (nestedResult) {
              return [
                {
                  type: "taskList",
                  raw: nestedResult.raw,
                  items: nestedResult.items
                }
              ];
            }
            return lexer.blockTokens(content);
          };
          const result = (0, import_core11.parseIndentedBlocks)(
            src,
            {
              itemPattern: /^(\s*)([-+*])\s+\[([ xX])\]\s+(.*)$/,
              extractItemData: (match) => ({
                indentLevel: match[1].length,
                mainContent: match[4],
                checked: match[3].toLowerCase() === "x"
              }),
              createToken: (data, nestedTokens) => ({
                type: "taskItem",
                raw: "",
                mainContent: data.mainContent,
                indentLevel: data.indentLevel,
                checked: data.checked,
                text: data.mainContent,
                tokens: lexer.inlineTokens(data.mainContent),
                nestedTokens
              }),
              // Use the recursive parser for nested content
              customNestedParser: parseTaskListContent
            },
            lexer
          );
          if (!result) {
            return void 0;
          }
          return {
            type: "taskList",
            raw: result.raw,
            items: result.items
          };
        }
      },
      markdownOptions: {
        indentsContent: true
      },
      addCommands() {
        return {
          toggleTaskList: () => ({ commands: commands2 }) => {
            return commands2.toggleList(this.name, this.options.itemTypeName);
          }
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Shift-9": () => this.editor.commands.toggleTaskList()
        };
      }
    });
    var ListKit = import_core12.Extension.create({
      name: "listKit",
      addExtensions() {
        const extensions2 = [];
        if (this.options.bulletList !== false) {
          extensions2.push(BulletList.configure(this.options.bulletList));
        }
        if (this.options.listItem !== false) {
          extensions2.push(ListItem.configure(this.options.listItem));
        }
        if (this.options.listKeymap !== false) {
          extensions2.push(ListKeymap.configure(this.options.listKeymap));
        }
        if (this.options.orderedList !== false) {
          extensions2.push(OrderedList.configure(this.options.orderedList));
        }
        if (this.options.taskItem !== false) {
          extensions2.push(TaskItem.configure(this.options.taskItem));
        }
        if (this.options.taskList !== false) {
          extensions2.push(TaskList.configure(this.options.taskList));
        }
        return extensions2;
      }
    });
  }
});

// node_modules/.pnpm/@tiptap+extension-paragraph@3.11.0_@tiptap+core@3.11.0_@tiptap+pm@3.11.0_/node_modules/@tiptap/extension-paragraph/dist/index.cjs
var require_dist21 = __commonJS({
  "node_modules/.pnpm/@tiptap+extension-paragraph@3.11.0_@tiptap+core@3.11.0_@tiptap+pm@3.11.0_/node_modules/@tiptap/extension-paragraph/dist/index.cjs"(exports2, module2) {
    "use strict";
    var __defProp3 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp3 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp3(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp3.call(to, key) && key !== except)
            __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp3({}, "__esModule", { value: true }), mod);
    var index_exports = {};
    __export2(index_exports, {
      Paragraph: () => Paragraph3,
      default: () => index_default
    });
    module2.exports = __toCommonJS2(index_exports);
    var import_core = require_dist9();
    var Paragraph3 = import_core.Node.create({
      name: "paragraph",
      priority: 1e3,
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      group: "block",
      content: "inline*",
      parseHTML() {
        return [{ tag: "p" }];
      },
      renderHTML({ HTMLAttributes }) {
        return ["p", (0, import_core.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];
      },
      parseMarkdown: (token, helpers) => {
        const tokens = token.tokens || [];
        if (tokens.length === 1 && tokens[0].type === "image") {
          return helpers.parseChildren([tokens[0]]);
        }
        return helpers.createNode(
          "paragraph",
          void 0,
          // no attributes for paragraph
          helpers.parseInline(tokens)
        );
      },
      renderMarkdown: (node, h) => {
        if (!node || !Array.isArray(node.content)) {
          return "";
        }
        return h.renderChildren(node.content);
      },
      addCommands() {
        return {
          setParagraph: () => ({ commands: commands2 }) => {
            return commands2.setNode(this.name);
          }
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Alt-0": () => this.editor.commands.setParagraph()
        };
      }
    });
    var index_default = Paragraph3;
  }
});

// node_modules/.pnpm/@tiptap+extension-strike@3.11.0_@tiptap+core@3.11.0_@tiptap+pm@3.11.0_/node_modules/@tiptap/extension-strike/dist/index.cjs
var require_dist22 = __commonJS({
  "node_modules/.pnpm/@tiptap+extension-strike@3.11.0_@tiptap+core@3.11.0_@tiptap+pm@3.11.0_/node_modules/@tiptap/extension-strike/dist/index.cjs"(exports2, module2) {
    "use strict";
    var __defProp3 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp3 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp3(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp3.call(to, key) && key !== except)
            __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp3({}, "__esModule", { value: true }), mod);
    var index_exports = {};
    __export2(index_exports, {
      Strike: () => Strike,
      default: () => index_default,
      inputRegex: () => inputRegex,
      pasteRegex: () => pasteRegex
    });
    module2.exports = __toCommonJS2(index_exports);
    var import_core = require_dist9();
    var inputRegex = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/;
    var pasteRegex = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g;
    var Strike = import_core.Mark.create({
      name: "strike",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      parseHTML() {
        return [
          {
            tag: "s"
          },
          {
            tag: "del"
          },
          {
            tag: "strike"
          },
          {
            style: "text-decoration",
            consuming: false,
            getAttrs: (style) => style.includes("line-through") ? {} : false
          }
        ];
      },
      renderHTML({ HTMLAttributes }) {
        return ["s", (0, import_core.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];
      },
      markdownTokenName: "del",
      parseMarkdown: (token, helpers) => {
        return helpers.applyMark("strike", helpers.parseInline(token.tokens || []));
      },
      renderMarkdown: (node, h) => {
        return `~~${h.renderChildren(node)}~~`;
      },
      addCommands() {
        return {
          setStrike: () => ({ commands: commands2 }) => {
            return commands2.setMark(this.name);
          },
          toggleStrike: () => ({ commands: commands2 }) => {
            return commands2.toggleMark(this.name);
          },
          unsetStrike: () => ({ commands: commands2 }) => {
            return commands2.unsetMark(this.name);
          }
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Shift-s": () => this.editor.commands.toggleStrike()
        };
      },
      addInputRules() {
        return [
          (0, import_core.markInputRule)({
            find: inputRegex,
            type: this.type
          })
        ];
      },
      addPasteRules() {
        return [
          (0, import_core.markPasteRule)({
            find: pasteRegex,
            type: this.type
          })
        ];
      }
    });
    var index_default = Strike;
  }
});

// node_modules/.pnpm/@tiptap+extension-text@3.11.0_@tiptap+core@3.11.0_@tiptap+pm@3.11.0_/node_modules/@tiptap/extension-text/dist/index.cjs
var require_dist23 = __commonJS({
  "node_modules/.pnpm/@tiptap+extension-text@3.11.0_@tiptap+core@3.11.0_@tiptap+pm@3.11.0_/node_modules/@tiptap/extension-text/dist/index.cjs"(exports2, module2) {
    "use strict";
    var __defProp3 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp3 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp3(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp3.call(to, key) && key !== except)
            __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp3({}, "__esModule", { value: true }), mod);
    var index_exports = {};
    __export2(index_exports, {
      Text: () => Text2,
      default: () => index_default
    });
    module2.exports = __toCommonJS2(index_exports);
    var import_core = require_dist9();
    var Text2 = import_core.Node.create({
      name: "text",
      group: "inline",
      parseMarkdown: (token) => {
        return {
          type: "text",
          text: token.text || ""
        };
      },
      renderMarkdown: (node) => node.text || ""
    });
    var index_default = Text2;
  }
});

// node_modules/.pnpm/@tiptap+extension-underline@3.11.0_@tiptap+core@3.11.0_@tiptap+pm@3.11.0_/node_modules/@tiptap/extension-underline/dist/index.cjs
var require_dist24 = __commonJS({
  "node_modules/.pnpm/@tiptap+extension-underline@3.11.0_@tiptap+core@3.11.0_@tiptap+pm@3.11.0_/node_modules/@tiptap/extension-underline/dist/index.cjs"(exports2, module2) {
    "use strict";
    var __defProp3 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp3 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp3(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp3.call(to, key) && key !== except)
            __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp3({}, "__esModule", { value: true }), mod);
    var index_exports = {};
    __export2(index_exports, {
      Underline: () => Underline2,
      default: () => index_default
    });
    module2.exports = __toCommonJS2(index_exports);
    var import_core = require_dist9();
    var Underline2 = import_core.Mark.create({
      name: "underline",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      parseHTML() {
        return [
          {
            tag: "u"
          },
          {
            style: "text-decoration",
            consuming: false,
            getAttrs: (style) => style.includes("underline") ? {} : false
          }
        ];
      },
      renderHTML({ HTMLAttributes }) {
        return ["u", (0, import_core.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];
      },
      parseMarkdown(token, helpers) {
        return helpers.applyMark(this.name || "underline", helpers.parseInline(token.tokens || []));
      },
      renderMarkdown(node, helpers) {
        return `++${helpers.renderChildren(node)}++`;
      },
      markdownTokenizer: {
        name: "underline",
        level: "inline",
        start(src) {
          return src.indexOf("++");
        },
        tokenize(src, _tokens, lexer) {
          const rule = /^(\+\+)([\s\S]+?)(\+\+)/;
          const match = rule.exec(src);
          if (!match) {
            return void 0;
          }
          const innerContent = match[2].trim();
          return {
            type: "underline",
            raw: match[0],
            text: innerContent,
            tokens: lexer.inlineTokens(innerContent)
          };
        }
      },
      addCommands() {
        return {
          setUnderline: () => ({ commands: commands2 }) => {
            return commands2.setMark(this.name);
          },
          toggleUnderline: () => ({ commands: commands2 }) => {
            return commands2.toggleMark(this.name);
          },
          unsetUnderline: () => ({ commands: commands2 }) => {
            return commands2.unsetMark(this.name);
          }
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-u": () => this.editor.commands.toggleUnderline(),
          "Mod-U": () => this.editor.commands.toggleUnderline()
        };
      }
    });
    var index_default = Underline2;
  }
});

// node_modules/.pnpm/prosemirror-dropcursor@1.8.2/node_modules/prosemirror-dropcursor/dist/index.cjs
var require_dist25 = __commonJS({
  "node_modules/.pnpm/prosemirror-dropcursor@1.8.2/node_modules/prosemirror-dropcursor/dist/index.cjs"(exports2) {
    "use strict";
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return _typeof(key) === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (_typeof(input) !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (_typeof(res) !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var prosemirrorState = require_dist4();
    var prosemirrorTransform = require_dist3();
    function dropCursor() {
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      return new prosemirrorState.Plugin({
        view: function view(editorView) {
          return new DropCursorView(editorView, options);
        }
      });
    }
    var DropCursorView = (function() {
      function DropCursorView2(editorView, options) {
        var _this = this;
        _classCallCheck(this, DropCursorView2);
        var _a;
        this.editorView = editorView;
        this.cursorPos = null;
        this.element = null;
        this.timeout = -1;
        this.width = (_a = options.width) !== null && _a !== void 0 ? _a : 1;
        this.color = options.color === false ? void 0 : options.color || "black";
        this["class"] = options["class"];
        this.handlers = ["dragover", "dragend", "drop", "dragleave"].map(function(name) {
          var handler = function handler2(e) {
            _this[name](e);
          };
          editorView.dom.addEventListener(name, handler);
          return {
            name,
            handler
          };
        });
      }
      _createClass(DropCursorView2, [{
        key: "destroy",
        value: function destroy() {
          var _this2 = this;
          this.handlers.forEach(function(_ref) {
            var name = _ref.name, handler = _ref.handler;
            return _this2.editorView.dom.removeEventListener(name, handler);
          });
        }
      }, {
        key: "update",
        value: function update(editorView, prevState) {
          if (this.cursorPos != null && prevState.doc != editorView.state.doc) {
            if (this.cursorPos > editorView.state.doc.content.size) this.setCursor(null);
            else this.updateOverlay();
          }
        }
      }, {
        key: "setCursor",
        value: function setCursor(pos) {
          if (pos == this.cursorPos) return;
          this.cursorPos = pos;
          if (pos == null) {
            this.element.parentNode.removeChild(this.element);
            this.element = null;
          } else {
            this.updateOverlay();
          }
        }
      }, {
        key: "updateOverlay",
        value: function updateOverlay() {
          var $pos = this.editorView.state.doc.resolve(this.cursorPos);
          var isBlock = !$pos.parent.inlineContent, rect;
          var editorDOM = this.editorView.dom, editorRect = editorDOM.getBoundingClientRect();
          var scaleX = editorRect.width / editorDOM.offsetWidth, scaleY = editorRect.height / editorDOM.offsetHeight;
          if (isBlock) {
            var before = $pos.nodeBefore, after = $pos.nodeAfter;
            if (before || after) {
              var node = this.editorView.nodeDOM(this.cursorPos - (before ? before.nodeSize : 0));
              if (node) {
                var nodeRect = node.getBoundingClientRect();
                var top = before ? nodeRect.bottom : nodeRect.top;
                if (before && after) top = (top + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2;
                var halfWidth = this.width / 2 * scaleY;
                rect = {
                  left: nodeRect.left,
                  right: nodeRect.right,
                  top: top - halfWidth,
                  bottom: top + halfWidth
                };
              }
            }
          }
          if (!rect) {
            var coords = this.editorView.coordsAtPos(this.cursorPos);
            var _halfWidth = this.width / 2 * scaleX;
            rect = {
              left: coords.left - _halfWidth,
              right: coords.left + _halfWidth,
              top: coords.top,
              bottom: coords.bottom
            };
          }
          var parent = this.editorView.dom.offsetParent;
          if (!this.element) {
            this.element = parent.appendChild(document.createElement("div"));
            if (this["class"]) this.element.className = this["class"];
            this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;";
            if (this.color) {
              this.element.style.backgroundColor = this.color;
            }
          }
          this.element.classList.toggle("prosemirror-dropcursor-block", isBlock);
          this.element.classList.toggle("prosemirror-dropcursor-inline", !isBlock);
          var parentLeft, parentTop;
          if (!parent || parent == document.body && getComputedStyle(parent).position == "static") {
            parentLeft = -pageXOffset;
            parentTop = -pageYOffset;
          } else {
            var _rect = parent.getBoundingClientRect();
            var parentScaleX = _rect.width / parent.offsetWidth, parentScaleY = _rect.height / parent.offsetHeight;
            parentLeft = _rect.left - parent.scrollLeft * parentScaleX;
            parentTop = _rect.top - parent.scrollTop * parentScaleY;
          }
          this.element.style.left = (rect.left - parentLeft) / scaleX + "px";
          this.element.style.top = (rect.top - parentTop) / scaleY + "px";
          this.element.style.width = (rect.right - rect.left) / scaleX + "px";
          this.element.style.height = (rect.bottom - rect.top) / scaleY + "px";
        }
      }, {
        key: "scheduleRemoval",
        value: function scheduleRemoval(timeout) {
          var _this3 = this;
          clearTimeout(this.timeout);
          this.timeout = setTimeout(function() {
            return _this3.setCursor(null);
          }, timeout);
        }
      }, {
        key: "dragover",
        value: function dragover(event) {
          if (!this.editorView.editable) return;
          var pos = this.editorView.posAtCoords({
            left: event.clientX,
            top: event.clientY
          });
          var node = pos && pos.inside >= 0 && this.editorView.state.doc.nodeAt(pos.inside);
          var disableDropCursor = node && node.type.spec.disableDropCursor;
          var disabled = typeof disableDropCursor == "function" ? disableDropCursor(this.editorView, pos, event) : disableDropCursor;
          if (pos && !disabled) {
            var target = pos.pos;
            if (this.editorView.dragging && this.editorView.dragging.slice) {
              var point = prosemirrorTransform.dropPoint(this.editorView.state.doc, target, this.editorView.dragging.slice);
              if (point != null) target = point;
            }
            this.setCursor(target);
            this.scheduleRemoval(5e3);
          }
        }
      }, {
        key: "dragend",
        value: function dragend() {
          this.scheduleRemoval(20);
        }
      }, {
        key: "drop",
        value: function drop() {
          this.scheduleRemoval(20);
        }
      }, {
        key: "dragleave",
        value: function dragleave(event) {
          if (!this.editorView.dom.contains(event.relatedTarget)) this.setCursor(null);
        }
      }]);
      return DropCursorView2;
    })();
    exports2.dropCursor = dropCursor;
  }
});

// node_modules/.pnpm/@tiptap+pm@3.11.0/node_modules/@tiptap/pm/dist/dropcursor/index.cjs
var require_dropcursor = __commonJS({
  "node_modules/.pnpm/@tiptap+pm@3.11.0/node_modules/@tiptap/pm/dist/dropcursor/index.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function _createStarExport(obj) {
      Object.keys(obj).filter((key) => key !== "default" && key !== "__esModule").forEach((key) => {
        if (exports2.hasOwnProperty(key)) {
          return;
        }
        Object.defineProperty(exports2, key, { enumerable: true, configurable: true, get: () => obj[key] });
      });
    }
    var _prosemirrordropcursor = require_dist25();
    _createStarExport(_prosemirrordropcursor);
  }
});

// node_modules/.pnpm/prosemirror-gapcursor@1.4.0/node_modules/prosemirror-gapcursor/dist/index.cjs
var require_dist26 = __commonJS({
  "node_modules/.pnpm/prosemirror-gapcursor@1.4.0/node_modules/prosemirror-gapcursor/dist/index.cjs"(exports2) {
    "use strict";
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return _typeof(key) === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (_typeof(input) !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (_typeof(res) !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      Object.defineProperty(subClass, "prototype", { writable: false });
      if (superClass) _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    var prosemirrorKeymap = require_dist8();
    var prosemirrorState = require_dist4();
    var prosemirrorModel = require_dist2();
    var prosemirrorView = require_dist7();
    var GapCursor = (function(_prosemirrorState$Sel) {
      _inherits(GapCursor2, _prosemirrorState$Sel);
      var _super = _createSuper(GapCursor2);
      function GapCursor2($pos) {
        _classCallCheck(this, GapCursor2);
        return _super.call(this, $pos, $pos);
      }
      _createClass(GapCursor2, [{
        key: "map",
        value: function map(doc, mapping) {
          var $pos = doc.resolve(mapping.map(this.head));
          return GapCursor2.valid($pos) ? new GapCursor2($pos) : prosemirrorState.Selection.near($pos);
        }
      }, {
        key: "content",
        value: function content() {
          return prosemirrorModel.Slice.empty;
        }
      }, {
        key: "eq",
        value: function eq(other) {
          return other instanceof GapCursor2 && other.head == this.head;
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          return {
            type: "gapcursor",
            pos: this.head
          };
        }
      }, {
        key: "getBookmark",
        value: function getBookmark() {
          return new GapBookmark(this.anchor);
        }
      }], [{
        key: "fromJSON",
        value: function fromJSON(doc, json) {
          if (typeof json.pos != "number") throw new RangeError("Invalid input for GapCursor.fromJSON");
          return new GapCursor2(doc.resolve(json.pos));
        }
      }, {
        key: "valid",
        value: function valid($pos) {
          var parent = $pos.parent;
          if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos)) return false;
          var override = parent.type.spec.allowGapCursor;
          if (override != null) return override;
          var deflt = parent.contentMatchAt($pos.index()).defaultType;
          return deflt && deflt.isTextblock;
        }
      }, {
        key: "findGapCursorFrom",
        value: function findGapCursorFrom($pos, dir) {
          var mustMove = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
          search: for (; ; ) {
            if (!mustMove && GapCursor2.valid($pos)) return $pos;
            var pos = $pos.pos, next = null;
            for (var d = $pos.depth; ; d--) {
              var parent = $pos.node(d);
              if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {
                next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);
                break;
              } else if (d == 0) {
                return null;
              }
              pos += dir;
              var $cur = $pos.doc.resolve(pos);
              if (GapCursor2.valid($cur)) return $cur;
            }
            for (; ; ) {
              var inside = dir > 0 ? next.firstChild : next.lastChild;
              if (!inside) {
                if (next.isAtom && !next.isText && !prosemirrorState.NodeSelection.isSelectable(next)) {
                  $pos = $pos.doc.resolve(pos + next.nodeSize * dir);
                  mustMove = false;
                  continue search;
                }
                break;
              }
              next = inside;
              pos += dir;
              var _$cur = $pos.doc.resolve(pos);
              if (GapCursor2.valid(_$cur)) return _$cur;
            }
            return null;
          }
        }
      }]);
      return GapCursor2;
    })(prosemirrorState.Selection);
    GapCursor.prototype.visible = false;
    GapCursor.findFrom = GapCursor.findGapCursorFrom;
    prosemirrorState.Selection.jsonID("gapcursor", GapCursor);
    var GapBookmark = (function() {
      function GapBookmark2(pos) {
        _classCallCheck(this, GapBookmark2);
        this.pos = pos;
      }
      _createClass(GapBookmark2, [{
        key: "map",
        value: function map(mapping) {
          return new GapBookmark2(mapping.map(this.pos));
        }
      }, {
        key: "resolve",
        value: function resolve(doc) {
          var $pos = doc.resolve(this.pos);
          return GapCursor.valid($pos) ? new GapCursor($pos) : prosemirrorState.Selection.near($pos);
        }
      }]);
      return GapBookmark2;
    })();
    function needsGap(type2) {
      return type2.isAtom || type2.spec.isolating || type2.spec.createGapCursor;
    }
    function closedBefore($pos) {
      for (var d = $pos.depth; d >= 0; d--) {
        var index = $pos.index(d), parent = $pos.node(d);
        if (index == 0) {
          if (parent.type.spec.isolating) return true;
          continue;
        }
        for (var before = parent.child(index - 1); ; before = before.lastChild) {
          if (before.childCount == 0 && !before.inlineContent || needsGap(before.type)) return true;
          if (before.inlineContent) return false;
        }
      }
      return true;
    }
    function closedAfter($pos) {
      for (var d = $pos.depth; d >= 0; d--) {
        var index = $pos.indexAfter(d), parent = $pos.node(d);
        if (index == parent.childCount) {
          if (parent.type.spec.isolating) return true;
          continue;
        }
        for (var after = parent.child(index); ; after = after.firstChild) {
          if (after.childCount == 0 && !after.inlineContent || needsGap(after.type)) return true;
          if (after.inlineContent) return false;
        }
      }
      return true;
    }
    function gapCursor() {
      return new prosemirrorState.Plugin({
        props: {
          decorations: drawGapCursor,
          createSelectionBetween: function createSelectionBetween(_view, $anchor, $head) {
            return $anchor.pos == $head.pos && GapCursor.valid($head) ? new GapCursor($head) : null;
          },
          handleClick,
          handleKeyDown,
          handleDOMEvents: {
            beforeinput
          }
        }
      });
    }
    var handleKeyDown = prosemirrorKeymap.keydownHandler({
      "ArrowLeft": arrow("horiz", -1),
      "ArrowRight": arrow("horiz", 1),
      "ArrowUp": arrow("vert", -1),
      "ArrowDown": arrow("vert", 1)
    });
    function arrow(axis, dir) {
      var dirStr = axis == "vert" ? dir > 0 ? "down" : "up" : dir > 0 ? "right" : "left";
      return function(state2, dispatch, view) {
        var sel = state2.selection;
        var $start = dir > 0 ? sel.$to : sel.$from, mustMove = sel.empty;
        if (sel instanceof prosemirrorState.TextSelection) {
          if (!view.endOfTextblock(dirStr) || $start.depth == 0) return false;
          mustMove = false;
          $start = state2.doc.resolve(dir > 0 ? $start.after() : $start.before());
        }
        var $found = GapCursor.findGapCursorFrom($start, dir, mustMove);
        if (!$found) return false;
        if (dispatch) dispatch(state2.tr.setSelection(new GapCursor($found)));
        return true;
      };
    }
    function handleClick(view, pos, event) {
      if (!view || !view.editable) return false;
      var $pos = view.state.doc.resolve(pos);
      if (!GapCursor.valid($pos)) return false;
      var clickPos = view.posAtCoords({
        left: event.clientX,
        top: event.clientY
      });
      if (clickPos && clickPos.inside > -1 && prosemirrorState.NodeSelection.isSelectable(view.state.doc.nodeAt(clickPos.inside))) return false;
      view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));
      return true;
    }
    function beforeinput(view, event) {
      if (event.inputType != "insertCompositionText" || !(view.state.selection instanceof GapCursor)) return false;
      var $from = view.state.selection.$from;
      var insert = $from.parent.contentMatchAt($from.index()).findWrapping(view.state.schema.nodes.text);
      if (!insert) return false;
      var frag = prosemirrorModel.Fragment.empty;
      for (var i = insert.length - 1; i >= 0; i--) frag = prosemirrorModel.Fragment.from(insert[i].createAndFill(null, frag));
      var tr = view.state.tr.replace($from.pos, $from.pos, new prosemirrorModel.Slice(frag, 0, 0));
      tr.setSelection(prosemirrorState.TextSelection.near(tr.doc.resolve($from.pos + 1)));
      view.dispatch(tr);
      return false;
    }
    function drawGapCursor(state2) {
      if (!(state2.selection instanceof GapCursor)) return null;
      var node = document.createElement("div");
      node.className = "ProseMirror-gapcursor";
      return prosemirrorView.DecorationSet.create(state2.doc, [prosemirrorView.Decoration.widget(state2.selection.head, node, {
        key: "gapcursor"
      })]);
    }
    exports2.GapCursor = GapCursor;
    exports2.gapCursor = gapCursor;
  }
});

// node_modules/.pnpm/@tiptap+pm@3.11.0/node_modules/@tiptap/pm/dist/gapcursor/index.cjs
var require_gapcursor = __commonJS({
  "node_modules/.pnpm/@tiptap+pm@3.11.0/node_modules/@tiptap/pm/dist/gapcursor/index.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function _createStarExport(obj) {
      Object.keys(obj).filter((key) => key !== "default" && key !== "__esModule").forEach((key) => {
        if (exports2.hasOwnProperty(key)) {
          return;
        }
        Object.defineProperty(exports2, key, { enumerable: true, configurable: true, get: () => obj[key] });
      });
    }
    var _prosemirrorgapcursor = require_dist26();
    _createStarExport(_prosemirrorgapcursor);
  }
});

// node_modules/.pnpm/rope-sequence@1.3.4/node_modules/rope-sequence/dist/index.cjs
var require_dist27 = __commonJS({
  "node_modules/.pnpm/rope-sequence@1.3.4/node_modules/rope-sequence/dist/index.cjs"(exports2, module2) {
    "use strict";
    var GOOD_LEAF_SIZE = 200;
    var RopeSequence = function RopeSequence2() {
    };
    RopeSequence.prototype.append = function append(other) {
      if (!other.length) {
        return this;
      }
      other = RopeSequence.from(other);
      return !this.length && other || other.length < GOOD_LEAF_SIZE && this.leafAppend(other) || this.length < GOOD_LEAF_SIZE && other.leafPrepend(this) || this.appendInner(other);
    };
    RopeSequence.prototype.prepend = function prepend(other) {
      if (!other.length) {
        return this;
      }
      return RopeSequence.from(other).append(this);
    };
    RopeSequence.prototype.appendInner = function appendInner(other) {
      return new Append(this, other);
    };
    RopeSequence.prototype.slice = function slice(from, to) {
      if (from === void 0) from = 0;
      if (to === void 0) to = this.length;
      if (from >= to) {
        return RopeSequence.empty;
      }
      return this.sliceInner(Math.max(0, from), Math.min(this.length, to));
    };
    RopeSequence.prototype.get = function get2(i) {
      if (i < 0 || i >= this.length) {
        return void 0;
      }
      return this.getInner(i);
    };
    RopeSequence.prototype.forEach = function forEach(f, from, to) {
      if (from === void 0) from = 0;
      if (to === void 0) to = this.length;
      if (from <= to) {
        this.forEachInner(f, from, to, 0);
      } else {
        this.forEachInvertedInner(f, from, to, 0);
      }
    };
    RopeSequence.prototype.map = function map(f, from, to) {
      if (from === void 0) from = 0;
      if (to === void 0) to = this.length;
      var result = [];
      this.forEach(function(elt, i) {
        return result.push(f(elt, i));
      }, from, to);
      return result;
    };
    RopeSequence.from = function from(values) {
      if (values instanceof RopeSequence) {
        return values;
      }
      return values && values.length ? new Leaf(values) : RopeSequence.empty;
    };
    var Leaf = /* @__PURE__ */ (function(RopeSequence2) {
      function Leaf2(values) {
        RopeSequence2.call(this);
        this.values = values;
      }
      if (RopeSequence2) Leaf2.__proto__ = RopeSequence2;
      Leaf2.prototype = Object.create(RopeSequence2 && RopeSequence2.prototype);
      Leaf2.prototype.constructor = Leaf2;
      var prototypeAccessors = { length: { configurable: true }, depth: { configurable: true } };
      Leaf2.prototype.flatten = function flatten() {
        return this.values;
      };
      Leaf2.prototype.sliceInner = function sliceInner(from, to) {
        if (from == 0 && to == this.length) {
          return this;
        }
        return new Leaf2(this.values.slice(from, to));
      };
      Leaf2.prototype.getInner = function getInner(i) {
        return this.values[i];
      };
      Leaf2.prototype.forEachInner = function forEachInner(f, from, to, start) {
        for (var i = from; i < to; i++) {
          if (f(this.values[i], start + i) === false) {
            return false;
          }
        }
      };
      Leaf2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from, to, start) {
        for (var i = from - 1; i >= to; i--) {
          if (f(this.values[i], start + i) === false) {
            return false;
          }
        }
      };
      Leaf2.prototype.leafAppend = function leafAppend(other) {
        if (this.length + other.length <= GOOD_LEAF_SIZE) {
          return new Leaf2(this.values.concat(other.flatten()));
        }
      };
      Leaf2.prototype.leafPrepend = function leafPrepend(other) {
        if (this.length + other.length <= GOOD_LEAF_SIZE) {
          return new Leaf2(other.flatten().concat(this.values));
        }
      };
      prototypeAccessors.length.get = function() {
        return this.values.length;
      };
      prototypeAccessors.depth.get = function() {
        return 0;
      };
      Object.defineProperties(Leaf2.prototype, prototypeAccessors);
      return Leaf2;
    })(RopeSequence);
    RopeSequence.empty = new Leaf([]);
    var Append = /* @__PURE__ */ (function(RopeSequence2) {
      function Append2(left, right) {
        RopeSequence2.call(this);
        this.left = left;
        this.right = right;
        this.length = left.length + right.length;
        this.depth = Math.max(left.depth, right.depth) + 1;
      }
      if (RopeSequence2) Append2.__proto__ = RopeSequence2;
      Append2.prototype = Object.create(RopeSequence2 && RopeSequence2.prototype);
      Append2.prototype.constructor = Append2;
      Append2.prototype.flatten = function flatten() {
        return this.left.flatten().concat(this.right.flatten());
      };
      Append2.prototype.getInner = function getInner(i) {
        return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length);
      };
      Append2.prototype.forEachInner = function forEachInner(f, from, to, start) {
        var leftLen = this.left.length;
        if (from < leftLen && this.left.forEachInner(f, from, Math.min(to, leftLen), start) === false) {
          return false;
        }
        if (to > leftLen && this.right.forEachInner(f, Math.max(from - leftLen, 0), Math.min(this.length, to) - leftLen, start + leftLen) === false) {
          return false;
        }
      };
      Append2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from, to, start) {
        var leftLen = this.left.length;
        if (from > leftLen && this.right.forEachInvertedInner(f, from - leftLen, Math.max(to, leftLen) - leftLen, start + leftLen) === false) {
          return false;
        }
        if (to < leftLen && this.left.forEachInvertedInner(f, Math.min(from, leftLen), to, start) === false) {
          return false;
        }
      };
      Append2.prototype.sliceInner = function sliceInner(from, to) {
        if (from == 0 && to == this.length) {
          return this;
        }
        var leftLen = this.left.length;
        if (to <= leftLen) {
          return this.left.slice(from, to);
        }
        if (from >= leftLen) {
          return this.right.slice(from - leftLen, to - leftLen);
        }
        return this.left.slice(from, leftLen).append(this.right.slice(0, to - leftLen));
      };
      Append2.prototype.leafAppend = function leafAppend(other) {
        var inner = this.right.leafAppend(other);
        if (inner) {
          return new Append2(this.left, inner);
        }
      };
      Append2.prototype.leafPrepend = function leafPrepend(other) {
        var inner = this.left.leafPrepend(other);
        if (inner) {
          return new Append2(inner, this.right);
        }
      };
      Append2.prototype.appendInner = function appendInner(other) {
        if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1) {
          return new Append2(this.left, new Append2(this.right, other));
        }
        return new Append2(this, other);
      };
      return Append2;
    })(RopeSequence);
    module2.exports = RopeSequence;
  }
});

// node_modules/.pnpm/prosemirror-history@1.5.0/node_modules/prosemirror-history/dist/index.cjs
var require_dist28 = __commonJS({
  "node_modules/.pnpm/prosemirror-history@1.5.0/node_modules/prosemirror-history/dist/index.cjs"(exports2) {
    "use strict";
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return _typeof(key) === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (_typeof(input) !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (_typeof(res) !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var RopeSequence = require_dist27();
    var prosemirrorTransform = require_dist3();
    var prosemirrorState = require_dist4();
    var max_empty_items = 500;
    var Branch = (function() {
      function Branch2(items, eventCount) {
        _classCallCheck(this, Branch2);
        this.items = items;
        this.eventCount = eventCount;
      }
      _createClass(Branch2, [{
        key: "popEvent",
        value: function popEvent(state2, preserveItems) {
          var _this = this;
          if (this.eventCount == 0) return null;
          var end = this.items.length;
          for (; ; end--) {
            var next = this.items.get(end - 1);
            if (next.selection) {
              --end;
              break;
            }
          }
          var remap, mapFrom;
          if (preserveItems) {
            remap = this.remapping(end, this.items.length);
            mapFrom = remap.maps.length;
          }
          var transform = state2.tr;
          var selection, remaining;
          var addAfter = [], addBefore = [];
          this.items.forEach(function(item, i) {
            if (!item.step) {
              if (!remap) {
                remap = _this.remapping(end, i + 1);
                mapFrom = remap.maps.length;
              }
              mapFrom--;
              addBefore.push(item);
              return;
            }
            if (remap) {
              addBefore.push(new Item2(item.map));
              var step = item.step.map(remap.slice(mapFrom)), map;
              if (step && transform.maybeStep(step).doc) {
                map = transform.mapping.maps[transform.mapping.maps.length - 1];
                addAfter.push(new Item2(map, void 0, void 0, addAfter.length + addBefore.length));
              }
              mapFrom--;
              if (map) remap.appendMap(map, mapFrom);
            } else {
              transform.maybeStep(item.step);
            }
            if (item.selection) {
              selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;
              remaining = new Branch2(_this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), _this.eventCount - 1);
              return false;
            }
          }, this.items.length, 0);
          return {
            remaining,
            transform,
            selection
          };
        }
      }, {
        key: "addTransform",
        value: function addTransform(transform, selection, histOptions, preserveItems) {
          var newItems = [], eventCount = this.eventCount;
          var oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;
          for (var i = 0; i < transform.steps.length; i++) {
            var step = transform.steps[i].invert(transform.docs[i]);
            var item = new Item2(transform.mapping.maps[i], step, selection), merged = void 0;
            if (merged = lastItem && lastItem.merge(item)) {
              item = merged;
              if (i) newItems.pop();
              else oldItems = oldItems.slice(0, oldItems.length - 1);
            }
            newItems.push(item);
            if (selection) {
              eventCount++;
              selection = void 0;
            }
            if (!preserveItems) lastItem = item;
          }
          var overflow = eventCount - histOptions.depth;
          if (overflow > DEPTH_OVERFLOW) {
            oldItems = cutOffEvents(oldItems, overflow);
            eventCount -= overflow;
          }
          return new Branch2(oldItems.append(newItems), eventCount);
        }
      }, {
        key: "remapping",
        value: function remapping(from, to) {
          var maps = new prosemirrorTransform.Mapping();
          this.items.forEach(function(item, i) {
            var mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from ? maps.maps.length - item.mirrorOffset : void 0;
            maps.appendMap(item.map, mirrorPos);
          }, from, to);
          return maps;
        }
      }, {
        key: "addMaps",
        value: function addMaps(array) {
          if (this.eventCount == 0) return this;
          return new Branch2(this.items.append(array.map(function(map) {
            return new Item2(map);
          })), this.eventCount);
        }
      }, {
        key: "rebased",
        value: function rebased(rebasedTransform, rebasedCount) {
          if (!this.eventCount) return this;
          var rebasedItems = [], start = Math.max(0, this.items.length - rebasedCount);
          var mapping = rebasedTransform.mapping;
          var newUntil = rebasedTransform.steps.length;
          var eventCount = this.eventCount;
          this.items.forEach(function(item) {
            if (item.selection) eventCount--;
          }, start);
          var iRebased = rebasedCount;
          this.items.forEach(function(item) {
            var pos = mapping.getMirror(--iRebased);
            if (pos == null) return;
            newUntil = Math.min(newUntil, pos);
            var map = mapping.maps[pos];
            if (item.step) {
              var step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);
              var selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));
              if (selection) eventCount++;
              rebasedItems.push(new Item2(map, step, selection));
            } else {
              rebasedItems.push(new Item2(map));
            }
          }, start);
          var newMaps = [];
          for (var i = rebasedCount; i < newUntil; i++) newMaps.push(new Item2(mapping.maps[i]));
          var items = this.items.slice(0, start).append(newMaps).append(rebasedItems);
          var branch = new Branch2(items, eventCount);
          if (branch.emptyItemCount() > max_empty_items) branch = branch.compress(this.items.length - rebasedItems.length);
          return branch;
        }
      }, {
        key: "emptyItemCount",
        value: function emptyItemCount() {
          var count = 0;
          this.items.forEach(function(item) {
            if (!item.step) count++;
          });
          return count;
        }
      }, {
        key: "compress",
        value: function compress() {
          var upto = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.items.length;
          var remap = this.remapping(0, upto), mapFrom = remap.maps.length;
          var items = [], events2 = 0;
          this.items.forEach(function(item, i) {
            if (i >= upto) {
              items.push(item);
              if (item.selection) events2++;
            } else if (item.step) {
              var step = item.step.map(remap.slice(mapFrom)), map = step && step.getMap();
              mapFrom--;
              if (map) remap.appendMap(map, mapFrom);
              if (step) {
                var selection = item.selection && item.selection.map(remap.slice(mapFrom));
                if (selection) events2++;
                var newItem = new Item2(map.invert(), step, selection), merged, last = items.length - 1;
                if (merged = items.length && items[last].merge(newItem)) items[last] = merged;
                else items.push(newItem);
              }
            } else if (item.map) {
              mapFrom--;
            }
          }, this.items.length, 0);
          return new Branch2(RopeSequence.from(items.reverse()), events2);
        }
      }]);
      return Branch2;
    })();
    Branch.empty = new Branch(RopeSequence.empty, 0);
    function cutOffEvents(items, n) {
      var cutPoint;
      items.forEach(function(item, i) {
        if (item.selection && n-- == 0) {
          cutPoint = i;
          return false;
        }
      });
      return items.slice(cutPoint);
    }
    var Item2 = (function() {
      function Item3(map, step, selection, mirrorOffset) {
        _classCallCheck(this, Item3);
        this.map = map;
        this.step = step;
        this.selection = selection;
        this.mirrorOffset = mirrorOffset;
      }
      _createClass(Item3, [{
        key: "merge",
        value: function merge(other) {
          if (this.step && other.step && !other.selection) {
            var step = other.step.merge(this.step);
            if (step) return new Item3(step.getMap().invert(), step, this.selection);
          }
        }
      }]);
      return Item3;
    })();
    var HistoryState = _createClass(function HistoryState2(done, undone, prevRanges, prevTime, prevComposition) {
      _classCallCheck(this, HistoryState2);
      this.done = done;
      this.undone = undone;
      this.prevRanges = prevRanges;
      this.prevTime = prevTime;
      this.prevComposition = prevComposition;
    });
    var DEPTH_OVERFLOW = 20;
    function applyTransaction(history2, state2, tr, options) {
      var historyTr = tr.getMeta(historyKey), rebased;
      if (historyTr) return historyTr.historyState;
      if (tr.getMeta(closeHistoryKey)) history2 = new HistoryState(history2.done, history2.undone, null, 0, -1);
      var appended = tr.getMeta("appendedTransaction");
      if (tr.steps.length == 0) {
        return history2;
      } else if (appended && appended.getMeta(historyKey)) {
        if (appended.getMeta(historyKey).redo) return new HistoryState(history2.done.addTransform(tr, void 0, options, mustPreserveItems(state2)), history2.undone, rangesFor(tr.mapping.maps), history2.prevTime, history2.prevComposition);
        else return new HistoryState(history2.done, history2.undone.addTransform(tr, void 0, options, mustPreserveItems(state2)), null, history2.prevTime, history2.prevComposition);
      } else if (tr.getMeta("addToHistory") !== false && !(appended && appended.getMeta("addToHistory") === false)) {
        var composition = tr.getMeta("composition");
        var newGroup = history2.prevTime == 0 || !appended && history2.prevComposition != composition && (history2.prevTime < (tr.time || 0) - options.newGroupDelay || !isAdjacentTo(tr, history2.prevRanges));
        var prevRanges = appended ? mapRanges(history2.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps);
        return new HistoryState(history2.done.addTransform(tr, newGroup ? state2.selection.getBookmark() : void 0, options, mustPreserveItems(state2)), Branch.empty, prevRanges, tr.time, composition == null ? history2.prevComposition : composition);
      } else if (rebased = tr.getMeta("rebased")) {
        return new HistoryState(history2.done.rebased(tr, rebased), history2.undone.rebased(tr, rebased), mapRanges(history2.prevRanges, tr.mapping), history2.prevTime, history2.prevComposition);
      } else {
        return new HistoryState(history2.done.addMaps(tr.mapping.maps), history2.undone.addMaps(tr.mapping.maps), mapRanges(history2.prevRanges, tr.mapping), history2.prevTime, history2.prevComposition);
      }
    }
    function isAdjacentTo(transform, prevRanges) {
      if (!prevRanges) return false;
      if (!transform.docChanged) return true;
      var adjacent = false;
      transform.mapping.maps[0].forEach(function(start, end) {
        for (var i = 0; i < prevRanges.length; i += 2) if (start <= prevRanges[i + 1] && end >= prevRanges[i]) adjacent = true;
      });
      return adjacent;
    }
    function rangesFor(maps) {
      var result = [];
      for (var i = maps.length - 1; i >= 0 && result.length == 0; i--) maps[i].forEach(function(_from, _to, from, to) {
        return result.push(from, to);
      });
      return result;
    }
    function mapRanges(ranges, mapping) {
      if (!ranges) return null;
      var result = [];
      for (var i = 0; i < ranges.length; i += 2) {
        var from = mapping.map(ranges[i], 1), to = mapping.map(ranges[i + 1], -1);
        if (from <= to) result.push(from, to);
      }
      return result;
    }
    function histTransaction(history2, state2, redo2) {
      var preserveItems = mustPreserveItems(state2);
      var histOptions = historyKey.get(state2).spec.config;
      var pop = (redo2 ? history2.undone : history2.done).popEvent(state2, preserveItems);
      if (!pop) return null;
      var selection = pop.selection.resolve(pop.transform.doc);
      var added = (redo2 ? history2.done : history2.undone).addTransform(pop.transform, state2.selection.getBookmark(), histOptions, preserveItems);
      var newHist = new HistoryState(redo2 ? added : pop.remaining, redo2 ? pop.remaining : added, null, 0, -1);
      return pop.transform.setSelection(selection).setMeta(historyKey, {
        redo: redo2,
        historyState: newHist
      });
    }
    var cachedPreserveItems = false;
    var cachedPreserveItemsPlugins = null;
    function mustPreserveItems(state2) {
      var plugins = state2.plugins;
      if (cachedPreserveItemsPlugins != plugins) {
        cachedPreserveItems = false;
        cachedPreserveItemsPlugins = plugins;
        for (var i = 0; i < plugins.length; i++) if (plugins[i].spec.historyPreserveItems) {
          cachedPreserveItems = true;
          break;
        }
      }
      return cachedPreserveItems;
    }
    function closeHistory(tr) {
      return tr.setMeta(closeHistoryKey, true);
    }
    var historyKey = new prosemirrorState.PluginKey("history");
    var closeHistoryKey = new prosemirrorState.PluginKey("closeHistory");
    function history() {
      var config = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      config = {
        depth: config.depth || 100,
        newGroupDelay: config.newGroupDelay || 500
      };
      return new prosemirrorState.Plugin({
        key: historyKey,
        state: {
          init: function init() {
            return new HistoryState(Branch.empty, Branch.empty, null, 0, -1);
          },
          apply: function apply(tr, hist, state2) {
            return applyTransaction(hist, state2, tr, config);
          }
        },
        config,
        props: {
          handleDOMEvents: {
            beforeinput: function beforeinput(view, e) {
              var inputType = e.inputType;
              var command = inputType == "historyUndo" ? undo : inputType == "historyRedo" ? redo : null;
              if (!command || !view.editable) return false;
              e.preventDefault();
              return command(view.state, view.dispatch);
            }
          }
        }
      });
    }
    function buildCommand(redo2, scroll) {
      return function(state2, dispatch) {
        var hist = historyKey.getState(state2);
        if (!hist || (redo2 ? hist.undone : hist.done).eventCount == 0) return false;
        if (dispatch) {
          var tr = histTransaction(hist, state2, redo2);
          if (tr) dispatch(scroll ? tr.scrollIntoView() : tr);
        }
        return true;
      };
    }
    var undo = buildCommand(false, true);
    var redo = buildCommand(true, true);
    var undoNoScroll = buildCommand(false, false);
    var redoNoScroll = buildCommand(true, false);
    function undoDepth(state2) {
      var hist = historyKey.getState(state2);
      return hist ? hist.done.eventCount : 0;
    }
    function redoDepth(state2) {
      var hist = historyKey.getState(state2);
      return hist ? hist.undone.eventCount : 0;
    }
    function isHistoryTransaction(tr) {
      return tr.getMeta(historyKey) != null;
    }
    exports2.closeHistory = closeHistory;
    exports2.history = history;
    exports2.isHistoryTransaction = isHistoryTransaction;
    exports2.redo = redo;
    exports2.redoDepth = redoDepth;
    exports2.redoNoScroll = redoNoScroll;
    exports2.undo = undo;
    exports2.undoDepth = undoDepth;
    exports2.undoNoScroll = undoNoScroll;
  }
});

// node_modules/.pnpm/@tiptap+pm@3.11.0/node_modules/@tiptap/pm/dist/history/index.cjs
var require_history = __commonJS({
  "node_modules/.pnpm/@tiptap+pm@3.11.0/node_modules/@tiptap/pm/dist/history/index.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function _createStarExport(obj) {
      Object.keys(obj).filter((key) => key !== "default" && key !== "__esModule").forEach((key) => {
        if (exports2.hasOwnProperty(key)) {
          return;
        }
        Object.defineProperty(exports2, key, { enumerable: true, configurable: true, get: () => obj[key] });
      });
    }
    var _prosemirrorhistory = require_dist28();
    _createStarExport(_prosemirrorhistory);
  }
});

// node_modules/.pnpm/@tiptap+extensions@3.11.0_@tiptap+core@3.11.0_@tiptap+pm@3.11.0__@tiptap+pm@3.11.0/node_modules/@tiptap/extensions/dist/index.cjs
var require_dist29 = __commonJS({
  "node_modules/.pnpm/@tiptap+extensions@3.11.0_@tiptap+core@3.11.0_@tiptap+pm@3.11.0__@tiptap+pm@3.11.0/node_modules/@tiptap/extensions/dist/index.cjs"(exports2, module2) {
    "use strict";
    var __defProp3 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp3 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp3(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp3.call(to, key) && key !== except)
            __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp3({}, "__esModule", { value: true }), mod);
    var index_exports = {};
    __export2(index_exports, {
      CharacterCount: () => CharacterCount,
      Dropcursor: () => Dropcursor,
      Focus: () => Focus,
      Gapcursor: () => Gapcursor,
      Placeholder: () => Placeholder,
      Selection: () => Selection,
      TrailingNode: () => TrailingNode,
      UndoRedo: () => UndoRedo
    });
    module2.exports = __toCommonJS2(index_exports);
    var import_core = require_dist9();
    var import_state = require_state();
    var CharacterCount = import_core.Extension.create({
      name: "characterCount",
      addOptions() {
        return {
          limit: null,
          mode: "textSize",
          textCounter: (text) => text.length,
          wordCounter: (text) => text.split(" ").filter((word) => word !== "").length
        };
      },
      addStorage() {
        return {
          characters: () => 0,
          words: () => 0
        };
      },
      onBeforeCreate() {
        this.storage.characters = (options) => {
          const node = (options == null ? void 0 : options.node) || this.editor.state.doc;
          const mode = (options == null ? void 0 : options.mode) || this.options.mode;
          if (mode === "textSize") {
            const text = node.textBetween(0, node.content.size, void 0, " ");
            return this.options.textCounter(text);
          }
          return node.nodeSize;
        };
        this.storage.words = (options) => {
          const node = (options == null ? void 0 : options.node) || this.editor.state.doc;
          const text = node.textBetween(0, node.content.size, " ", " ");
          return this.options.wordCounter(text);
        };
      },
      addProseMirrorPlugins() {
        let initialEvaluationDone = false;
        return [
          new import_state.Plugin({
            key: new import_state.PluginKey("characterCount"),
            appendTransaction: (transactions, oldState, newState) => {
              if (initialEvaluationDone) {
                return;
              }
              const limit = this.options.limit;
              if (limit === null || limit === void 0 || limit === 0) {
                initialEvaluationDone = true;
                return;
              }
              const initialContentSize = this.storage.characters({ node: newState.doc });
              if (initialContentSize > limit) {
                const over = initialContentSize - limit;
                const from = 0;
                const to = over;
                console.warn(
                  `[CharacterCount] Initial content exceeded limit of ${limit} characters. Content was automatically trimmed.`
                );
                const tr = newState.tr.deleteRange(from, to);
                initialEvaluationDone = true;
                return tr;
              }
              initialEvaluationDone = true;
            },
            filterTransaction: (transaction, state2) => {
              const limit = this.options.limit;
              if (!transaction.docChanged || limit === 0 || limit === null || limit === void 0) {
                return true;
              }
              const oldSize = this.storage.characters({ node: state2.doc });
              const newSize = this.storage.characters({ node: transaction.doc });
              if (newSize <= limit) {
                return true;
              }
              if (oldSize > limit && newSize > limit && newSize <= oldSize) {
                return true;
              }
              if (oldSize > limit && newSize > limit && newSize > oldSize) {
                return false;
              }
              const isPaste = transaction.getMeta("paste");
              if (!isPaste) {
                return false;
              }
              const pos = transaction.selection.$head.pos;
              const over = newSize - limit;
              const from = pos - over;
              const to = pos;
              transaction.deleteRange(from, to);
              const updatedSize = this.storage.characters({ node: transaction.doc });
              if (updatedSize > limit) {
                return false;
              }
              return true;
            }
          })
        ];
      }
    });
    var import_core2 = require_dist9();
    var import_dropcursor = require_dropcursor();
    var Dropcursor = import_core2.Extension.create({
      name: "dropCursor",
      addOptions() {
        return {
          color: "currentColor",
          width: 1,
          class: void 0
        };
      },
      addProseMirrorPlugins() {
        return [(0, import_dropcursor.dropCursor)(this.options)];
      }
    });
    var import_core3 = require_dist9();
    var import_state2 = require_state();
    var import_view = require_view();
    var Focus = import_core3.Extension.create({
      name: "focus",
      addOptions() {
        return {
          className: "has-focus",
          mode: "all"
        };
      },
      addProseMirrorPlugins() {
        return [
          new import_state2.Plugin({
            key: new import_state2.PluginKey("focus"),
            props: {
              decorations: ({ doc, selection }) => {
                const { isEditable, isFocused } = this.editor;
                const { anchor } = selection;
                const decorations = [];
                if (!isEditable || !isFocused) {
                  return import_view.DecorationSet.create(doc, []);
                }
                let maxLevels = 0;
                if (this.options.mode === "deepest") {
                  doc.descendants((node, pos) => {
                    if (node.isText) {
                      return;
                    }
                    const isCurrent = anchor >= pos && anchor <= pos + node.nodeSize - 1;
                    if (!isCurrent) {
                      return false;
                    }
                    maxLevels += 1;
                  });
                }
                let currentLevel = 0;
                doc.descendants((node, pos) => {
                  if (node.isText) {
                    return false;
                  }
                  const isCurrent = anchor >= pos && anchor <= pos + node.nodeSize - 1;
                  if (!isCurrent) {
                    return false;
                  }
                  currentLevel += 1;
                  const outOfScope = this.options.mode === "deepest" && maxLevels - currentLevel > 0 || this.options.mode === "shallowest" && currentLevel > 1;
                  if (outOfScope) {
                    return this.options.mode === "deepest";
                  }
                  decorations.push(
                    import_view.Decoration.node(pos, pos + node.nodeSize, {
                      class: this.options.className
                    })
                  );
                });
                return import_view.DecorationSet.create(doc, decorations);
              }
            }
          })
        ];
      }
    });
    var import_core4 = require_dist9();
    var import_gapcursor = require_gapcursor();
    var Gapcursor = import_core4.Extension.create({
      name: "gapCursor",
      addProseMirrorPlugins() {
        return [(0, import_gapcursor.gapCursor)()];
      },
      extendNodeSchema(extension) {
        var _a;
        const context = {
          name: extension.name,
          options: extension.options,
          storage: extension.storage
        };
        return {
          allowGapCursor: (_a = (0, import_core4.callOrReturn)((0, import_core4.getExtensionField)(extension, "allowGapCursor", context))) != null ? _a : null
        };
      }
    });
    var import_core5 = require_dist9();
    var import_state3 = require_state();
    var import_view2 = require_view();
    var Placeholder = import_core5.Extension.create({
      name: "placeholder",
      addOptions() {
        return {
          emptyEditorClass: "is-editor-empty",
          emptyNodeClass: "is-empty",
          placeholder: "Write something \u2026",
          showOnlyWhenEditable: true,
          showOnlyCurrent: true,
          includeChildren: false
        };
      },
      addProseMirrorPlugins() {
        return [
          new import_state3.Plugin({
            key: new import_state3.PluginKey("placeholder"),
            props: {
              decorations: ({ doc, selection }) => {
                const active = this.editor.isEditable || !this.options.showOnlyWhenEditable;
                const { anchor } = selection;
                const decorations = [];
                if (!active) {
                  return null;
                }
                const isEmptyDoc = this.editor.isEmpty;
                doc.descendants((node, pos) => {
                  const hasAnchor = anchor >= pos && anchor <= pos + node.nodeSize;
                  const isEmpty = !node.isLeaf && (0, import_core5.isNodeEmpty)(node);
                  if ((hasAnchor || !this.options.showOnlyCurrent) && isEmpty) {
                    const classes = [this.options.emptyNodeClass];
                    if (isEmptyDoc) {
                      classes.push(this.options.emptyEditorClass);
                    }
                    const decoration = import_view2.Decoration.node(pos, pos + node.nodeSize, {
                      class: classes.join(" "),
                      "data-placeholder": typeof this.options.placeholder === "function" ? this.options.placeholder({
                        editor: this.editor,
                        node,
                        pos,
                        hasAnchor
                      }) : this.options.placeholder
                    });
                    decorations.push(decoration);
                  }
                  return this.options.includeChildren;
                });
                return import_view2.DecorationSet.create(doc, decorations);
              }
            }
          })
        ];
      }
    });
    var import_core6 = require_dist9();
    var import_state4 = require_state();
    var import_view3 = require_view();
    var Selection = import_core6.Extension.create({
      name: "selection",
      addOptions() {
        return {
          className: "selection"
        };
      },
      addProseMirrorPlugins() {
        const { editor, options } = this;
        return [
          new import_state4.Plugin({
            key: new import_state4.PluginKey("selection"),
            props: {
              decorations(state2) {
                if (state2.selection.empty || editor.isFocused || !editor.isEditable || (0, import_core6.isNodeSelection)(state2.selection) || editor.view.dragging) {
                  return null;
                }
                return import_view3.DecorationSet.create(state2.doc, [
                  import_view3.Decoration.inline(state2.selection.from, state2.selection.to, {
                    class: options.className
                  })
                ]);
              }
            }
          })
        ];
      }
    });
    var import_core7 = require_dist9();
    var import_state5 = require_state();
    function nodeEqualsType({ types: types2, node }) {
      return node && Array.isArray(types2) && types2.includes(node.type) || (node == null ? void 0 : node.type) === types2;
    }
    var TrailingNode = import_core7.Extension.create({
      name: "trailingNode",
      addOptions() {
        return {
          node: void 0,
          notAfter: []
        };
      },
      addProseMirrorPlugins() {
        var _a;
        const plugin = new import_state5.PluginKey(this.name);
        const defaultNode = ((_a = this.editor.schema.topNodeType.contentMatch.defaultType) == null ? void 0 : _a.name) || this.options.node || "paragraph";
        const disabledNodes = Object.entries(this.editor.schema.nodes).map(([, value]) => value).filter((node) => (this.options.notAfter || []).concat(defaultNode).includes(node.name));
        return [
          new import_state5.Plugin({
            key: plugin,
            appendTransaction: (_, __, state2) => {
              const { doc, tr, schema } = state2;
              const shouldInsertNodeAtEnd = plugin.getState(state2);
              const endPosition = doc.content.size;
              const type2 = schema.nodes[defaultNode];
              if (!shouldInsertNodeAtEnd) {
                return;
              }
              return tr.insert(endPosition, type2.create());
            },
            state: {
              init: (_, state2) => {
                const lastNode = state2.tr.doc.lastChild;
                return !nodeEqualsType({ node: lastNode, types: disabledNodes });
              },
              apply: (tr, value) => {
                if (!tr.docChanged) {
                  return value;
                }
                if (tr.getMeta("__uniqueIDTransaction")) {
                  return value;
                }
                const lastNode = tr.doc.lastChild;
                return !nodeEqualsType({ node: lastNode, types: disabledNodes });
              }
            }
          })
        ];
      }
    });
    var import_core8 = require_dist9();
    var import_history = require_history();
    var UndoRedo = import_core8.Extension.create({
      name: "undoRedo",
      addOptions() {
        return {
          depth: 100,
          newGroupDelay: 500
        };
      },
      addCommands() {
        return {
          undo: () => ({ state: state2, dispatch }) => {
            return (0, import_history.undo)(state2, dispatch);
          },
          redo: () => ({ state: state2, dispatch }) => {
            return (0, import_history.redo)(state2, dispatch);
          }
        };
      },
      addProseMirrorPlugins() {
        return [(0, import_history.history)(this.options)];
      },
      addKeyboardShortcuts() {
        return {
          "Mod-z": () => this.editor.commands.undo(),
          "Shift-Mod-z": () => this.editor.commands.redo(),
          "Mod-y": () => this.editor.commands.redo(),
          // Russian keyboard layouts
          "Mod-\u044F": () => this.editor.commands.undo(),
          "Shift-Mod-\u044F": () => this.editor.commands.redo()
        };
      }
    });
  }
});

// node_modules/.pnpm/@tiptap+starter-kit@3.11.0/node_modules/@tiptap/starter-kit/dist/index.cjs
var require_dist30 = __commonJS({
  "node_modules/.pnpm/@tiptap+starter-kit@3.11.0/node_modules/@tiptap/starter-kit/dist/index.cjs"(exports2, module2) {
    "use strict";
    var __defProp3 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp3 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp3(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp3.call(to, key) && key !== except)
            __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp3({}, "__esModule", { value: true }), mod);
    var index_exports = {};
    __export2(index_exports, {
      StarterKit: () => StarterKit,
      default: () => index_default
    });
    module2.exports = __toCommonJS2(index_exports);
    var import_core = require_dist9();
    var import_extension_blockquote = require_dist10();
    var import_extension_bold = require_dist11();
    var import_extension_code = require_dist12();
    var import_extension_code_block = require_dist13();
    var import_extension_document = require_dist14();
    var import_extension_hard_break = require_dist15();
    var import_extension_heading = require_dist16();
    var import_extension_horizontal_rule = require_dist17();
    var import_extension_italic = require_dist18();
    var import_extension_link = require_dist19();
    var import_extension_list = require_dist20();
    var import_extension_paragraph = require_dist21();
    var import_extension_strike = require_dist22();
    var import_extension_text = require_dist23();
    var import_extension_underline = require_dist24();
    var import_extensions = require_dist29();
    var StarterKit = import_core.Extension.create({
      name: "starterKit",
      addExtensions() {
        var _a, _b, _c, _d;
        const extensions2 = [];
        if (this.options.bold !== false) {
          extensions2.push(import_extension_bold.Bold.configure(this.options.bold));
        }
        if (this.options.blockquote !== false) {
          extensions2.push(import_extension_blockquote.Blockquote.configure(this.options.blockquote));
        }
        if (this.options.bulletList !== false) {
          extensions2.push(import_extension_list.BulletList.configure(this.options.bulletList));
        }
        if (this.options.code !== false) {
          extensions2.push(import_extension_code.Code.configure(this.options.code));
        }
        if (this.options.codeBlock !== false) {
          extensions2.push(import_extension_code_block.CodeBlock.configure(this.options.codeBlock));
        }
        if (this.options.document !== false) {
          extensions2.push(import_extension_document.Document.configure(this.options.document));
        }
        if (this.options.dropcursor !== false) {
          extensions2.push(import_extensions.Dropcursor.configure(this.options.dropcursor));
        }
        if (this.options.gapcursor !== false) {
          extensions2.push(import_extensions.Gapcursor.configure(this.options.gapcursor));
        }
        if (this.options.hardBreak !== false) {
          extensions2.push(import_extension_hard_break.HardBreak.configure(this.options.hardBreak));
        }
        if (this.options.heading !== false) {
          extensions2.push(import_extension_heading.Heading.configure(this.options.heading));
        }
        if (this.options.undoRedo !== false) {
          extensions2.push(import_extensions.UndoRedo.configure(this.options.undoRedo));
        }
        if (this.options.horizontalRule !== false) {
          extensions2.push(import_extension_horizontal_rule.HorizontalRule.configure(this.options.horizontalRule));
        }
        if (this.options.italic !== false) {
          extensions2.push(import_extension_italic.Italic.configure(this.options.italic));
        }
        if (this.options.listItem !== false) {
          extensions2.push(import_extension_list.ListItem.configure(this.options.listItem));
        }
        if (this.options.listKeymap !== false) {
          extensions2.push(import_extension_list.ListKeymap.configure((_a = this.options) == null ? void 0 : _a.listKeymap));
        }
        if (this.options.link !== false) {
          extensions2.push(import_extension_link.Link.configure((_b = this.options) == null ? void 0 : _b.link));
        }
        if (this.options.orderedList !== false) {
          extensions2.push(import_extension_list.OrderedList.configure(this.options.orderedList));
        }
        if (this.options.paragraph !== false) {
          extensions2.push(import_extension_paragraph.Paragraph.configure(this.options.paragraph));
        }
        if (this.options.strike !== false) {
          extensions2.push(import_extension_strike.Strike.configure(this.options.strike));
        }
        if (this.options.text !== false) {
          extensions2.push(import_extension_text.Text.configure(this.options.text));
        }
        if (this.options.underline !== false) {
          extensions2.push(import_extension_underline.Underline.configure((_c = this.options) == null ? void 0 : _c.underline));
        }
        if (this.options.trailingNode !== false) {
          extensions2.push(import_extensions.TrailingNode.configure((_d = this.options) == null ? void 0 : _d.trailingNode));
        }
        return extensions2;
      }
    });
    var index_default = StarterKit;
  }
});

// node_modules/.pnpm/@tiptap+extension-subscript@3.11.0_@tiptap+core@3.11.0_@tiptap+pm@3.11.0__@tiptap+pm@3.11.0/node_modules/@tiptap/extension-subscript/dist/index.cjs
var require_dist31 = __commonJS({
  "node_modules/.pnpm/@tiptap+extension-subscript@3.11.0_@tiptap+core@3.11.0_@tiptap+pm@3.11.0__@tiptap+pm@3.11.0/node_modules/@tiptap/extension-subscript/dist/index.cjs"(exports2, module2) {
    "use strict";
    var __defProp3 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp3 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp3(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp3.call(to, key) && key !== except)
            __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp3({}, "__esModule", { value: true }), mod);
    var index_exports = {};
    __export2(index_exports, {
      Subscript: () => Subscript,
      default: () => index_default
    });
    module2.exports = __toCommonJS2(index_exports);
    var import_core = require_dist9();
    var Subscript = import_core.Mark.create({
      name: "subscript",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      parseHTML() {
        return [
          {
            tag: "sub"
          },
          {
            style: "vertical-align",
            getAttrs(value) {
              if (value !== "sub") {
                return false;
              }
              return null;
            }
          }
        ];
      },
      renderHTML({ HTMLAttributes }) {
        return ["sub", (0, import_core.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];
      },
      addCommands() {
        return {
          setSubscript: () => ({ commands: commands2 }) => {
            return commands2.setMark(this.name);
          },
          toggleSubscript: () => ({ commands: commands2 }) => {
            return commands2.toggleMark(this.name);
          },
          unsetSubscript: () => ({ commands: commands2 }) => {
            return commands2.unsetMark(this.name);
          }
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-,": () => this.editor.commands.toggleSubscript()
        };
      }
    });
    var index_default = Subscript;
  }
});

// node_modules/.pnpm/@tiptap+extension-superscript@3.11.0_@tiptap+core@3.11.0_@tiptap+pm@3.11.0__@tiptap+pm@3.11.0/node_modules/@tiptap/extension-superscript/dist/index.cjs
var require_dist32 = __commonJS({
  "node_modules/.pnpm/@tiptap+extension-superscript@3.11.0_@tiptap+core@3.11.0_@tiptap+pm@3.11.0__@tiptap+pm@3.11.0/node_modules/@tiptap/extension-superscript/dist/index.cjs"(exports2, module2) {
    "use strict";
    var __defProp3 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp3 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp3(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp3.call(to, key) && key !== except)
            __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp3({}, "__esModule", { value: true }), mod);
    var index_exports = {};
    __export2(index_exports, {
      Superscript: () => Superscript,
      default: () => index_default
    });
    module2.exports = __toCommonJS2(index_exports);
    var import_core = require_dist9();
    var Superscript = import_core.Mark.create({
      name: "superscript",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      parseHTML() {
        return [
          {
            tag: "sup"
          },
          {
            style: "vertical-align",
            getAttrs(value) {
              if (value !== "super") {
                return false;
              }
              return null;
            }
          }
        ];
      },
      renderHTML({ HTMLAttributes }) {
        return ["sup", (0, import_core.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];
      },
      addCommands() {
        return {
          setSuperscript: () => ({ commands: commands2 }) => {
            return commands2.setMark(this.name);
          },
          toggleSuperscript: () => ({ commands: commands2 }) => {
            return commands2.toggleMark(this.name);
          },
          unsetSuperscript: () => ({ commands: commands2 }) => {
            return commands2.unsetMark(this.name);
          }
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-.": () => this.editor.commands.toggleSuperscript()
        };
      }
    });
    var index_default = Superscript;
  }
});

// node_modules/.pnpm/@tiptap+extension-text-style@3.11.0_@tiptap+core@3.11.0_@tiptap+pm@3.11.0_/node_modules/@tiptap/extension-text-style/dist/index.cjs
var require_dist33 = __commonJS({
  "node_modules/.pnpm/@tiptap+extension-text-style@3.11.0_@tiptap+core@3.11.0_@tiptap+pm@3.11.0_/node_modules/@tiptap/extension-text-style/dist/index.cjs"(exports2, module2) {
    "use strict";
    var __defProp3 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp3 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp3(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp3.call(to, key) && key !== except)
            __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp3({}, "__esModule", { value: true }), mod);
    var index_exports = {};
    __export2(index_exports, {
      BackgroundColor: () => BackgroundColor,
      Color: () => Color2,
      FontFamily: () => FontFamily,
      FontSize: () => FontSize,
      LineHeight: () => LineHeight,
      TextStyle: () => TextStyle,
      TextStyleKit: () => TextStyleKit
    });
    module2.exports = __toCommonJS2(index_exports);
    var import_core = require_dist9();
    var MAX_FIND_CHILD_SPAN_DEPTH = 20;
    var findChildSpans = (element, depth = 0) => {
      const childSpans = [];
      if (!element.children.length || depth > MAX_FIND_CHILD_SPAN_DEPTH) {
        return childSpans;
      }
      Array.from(element.children).forEach((child) => {
        if (child.tagName === "SPAN") {
          childSpans.push(child);
        } else if (child.children.length) {
          childSpans.push(...findChildSpans(child, depth + 1));
        }
      });
      return childSpans;
    };
    var mergeNestedSpanStyles = (element) => {
      if (!element.children.length) {
        return;
      }
      const childSpans = findChildSpans(element);
      if (!childSpans) {
        return;
      }
      childSpans.forEach((childSpan) => {
        var _a, _b;
        const childStyle = childSpan.getAttribute("style");
        const closestParentSpanStyleOfChild = (_b = (_a = childSpan.parentElement) == null ? void 0 : _a.closest("span")) == null ? void 0 : _b.getAttribute("style");
        childSpan.setAttribute("style", `${closestParentSpanStyleOfChild};${childStyle}`);
      });
    };
    var TextStyle = import_core.Mark.create({
      name: "textStyle",
      priority: 101,
      addOptions() {
        return {
          HTMLAttributes: {},
          mergeNestedSpanStyles: true
        };
      },
      parseHTML() {
        return [
          {
            tag: "span",
            consuming: false,
            getAttrs: (element) => {
              const hasStyles = element.hasAttribute("style");
              if (!hasStyles) {
                return false;
              }
              if (this.options.mergeNestedSpanStyles) {
                mergeNestedSpanStyles(element);
              }
              return {};
            }
          }
        ];
      },
      renderHTML({ HTMLAttributes }) {
        return ["span", (0, import_core.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];
      },
      addCommands() {
        return {
          toggleTextStyle: (attributes) => ({ commands: commands2 }) => {
            return commands2.toggleMark(this.name, attributes);
          },
          removeEmptyTextStyle: () => ({ tr }) => {
            const { selection } = tr;
            tr.doc.nodesBetween(selection.from, selection.to, (node, pos) => {
              if (node.isTextblock) {
                return true;
              }
              if (!node.marks.filter((mark) => mark.type === this.type).some((mark) => Object.values(mark.attrs).some((value) => !!value))) {
                tr.removeMark(pos, pos + node.nodeSize, this.type);
              }
            });
            return true;
          }
        };
      }
    });
    var import_core2 = require_dist9();
    var BackgroundColor = import_core2.Extension.create({
      name: "backgroundColor",
      addOptions() {
        return {
          types: ["textStyle"]
        };
      },
      addGlobalAttributes() {
        return [
          {
            types: this.options.types,
            attributes: {
              backgroundColor: {
                default: null,
                parseHTML: (element) => {
                  var _a;
                  const styleAttr = element.getAttribute("style");
                  if (styleAttr) {
                    const decls = styleAttr.split(";").map((s) => s.trim()).filter(Boolean);
                    for (let i = decls.length - 1; i >= 0; i -= 1) {
                      const parts = decls[i].split(":");
                      if (parts.length >= 2) {
                        const prop = parts[0].trim().toLowerCase();
                        const val = parts.slice(1).join(":").trim();
                        if (prop === "background-color") {
                          return val.replace(/['"]+/g, "");
                        }
                      }
                    }
                  }
                  return (_a = element.style.backgroundColor) == null ? void 0 : _a.replace(/['"]+/g, "");
                },
                renderHTML: (attributes) => {
                  if (!attributes.backgroundColor) {
                    return {};
                  }
                  return {
                    style: `background-color: ${attributes.backgroundColor}`
                  };
                }
              }
            }
          }
        ];
      },
      addCommands() {
        return {
          setBackgroundColor: (backgroundColor) => ({ chain }) => {
            return chain().setMark("textStyle", { backgroundColor }).run();
          },
          unsetBackgroundColor: () => ({ chain }) => {
            return chain().setMark("textStyle", { backgroundColor: null }).removeEmptyTextStyle().run();
          }
        };
      }
    });
    var import_core3 = require_dist9();
    var Color2 = import_core3.Extension.create({
      name: "color",
      addOptions() {
        return {
          types: ["textStyle"]
        };
      },
      addGlobalAttributes() {
        return [
          {
            types: this.options.types,
            attributes: {
              color: {
                default: null,
                parseHTML: (element) => {
                  var _a;
                  const styleAttr = element.getAttribute("style");
                  if (styleAttr) {
                    const decls = styleAttr.split(";").map((s) => s.trim()).filter(Boolean);
                    for (let i = decls.length - 1; i >= 0; i -= 1) {
                      const parts = decls[i].split(":");
                      if (parts.length >= 2) {
                        const prop = parts[0].trim().toLowerCase();
                        const val = parts.slice(1).join(":").trim();
                        if (prop === "color") {
                          return val.replace(/['"]+/g, "");
                        }
                      }
                    }
                  }
                  return (_a = element.style.color) == null ? void 0 : _a.replace(/['"]+/g, "");
                },
                renderHTML: (attributes) => {
                  if (!attributes.color) {
                    return {};
                  }
                  return {
                    style: `color: ${attributes.color}`
                  };
                }
              }
            }
          }
        ];
      },
      addCommands() {
        return {
          setColor: (color) => ({ chain }) => {
            return chain().setMark("textStyle", { color }).run();
          },
          unsetColor: () => ({ chain }) => {
            return chain().setMark("textStyle", { color: null }).removeEmptyTextStyle().run();
          }
        };
      }
    });
    var import_core4 = require_dist9();
    var FontFamily = import_core4.Extension.create({
      name: "fontFamily",
      addOptions() {
        return {
          types: ["textStyle"]
        };
      },
      addGlobalAttributes() {
        return [
          {
            types: this.options.types,
            attributes: {
              fontFamily: {
                default: null,
                parseHTML: (element) => element.style.fontFamily,
                renderHTML: (attributes) => {
                  if (!attributes.fontFamily) {
                    return {};
                  }
                  return {
                    style: `font-family: ${attributes.fontFamily}`
                  };
                }
              }
            }
          }
        ];
      },
      addCommands() {
        return {
          setFontFamily: (fontFamily) => ({ chain }) => {
            return chain().setMark("textStyle", { fontFamily }).run();
          },
          unsetFontFamily: () => ({ chain }) => {
            return chain().setMark("textStyle", { fontFamily: null }).removeEmptyTextStyle().run();
          }
        };
      }
    });
    var import_core5 = require_dist9();
    var FontSize = import_core5.Extension.create({
      name: "fontSize",
      addOptions() {
        return {
          types: ["textStyle"]
        };
      },
      addGlobalAttributes() {
        return [
          {
            types: this.options.types,
            attributes: {
              fontSize: {
                default: null,
                parseHTML: (element) => element.style.fontSize,
                renderHTML: (attributes) => {
                  if (!attributes.fontSize) {
                    return {};
                  }
                  return {
                    style: `font-size: ${attributes.fontSize}`
                  };
                }
              }
            }
          }
        ];
      },
      addCommands() {
        return {
          setFontSize: (fontSize) => ({ chain }) => {
            return chain().setMark("textStyle", { fontSize }).run();
          },
          unsetFontSize: () => ({ chain }) => {
            return chain().setMark("textStyle", { fontSize: null }).removeEmptyTextStyle().run();
          }
        };
      }
    });
    var import_core6 = require_dist9();
    var LineHeight = import_core6.Extension.create({
      name: "lineHeight",
      addOptions() {
        return {
          types: ["textStyle"]
        };
      },
      addGlobalAttributes() {
        return [
          {
            types: this.options.types,
            attributes: {
              lineHeight: {
                default: null,
                parseHTML: (element) => element.style.lineHeight,
                renderHTML: (attributes) => {
                  if (!attributes.lineHeight) {
                    return {};
                  }
                  return {
                    style: `line-height: ${attributes.lineHeight}`
                  };
                }
              }
            }
          }
        ];
      },
      addCommands() {
        return {
          setLineHeight: (lineHeight) => ({ chain }) => {
            return chain().setMark("textStyle", { lineHeight }).run();
          },
          unsetLineHeight: () => ({ chain }) => {
            return chain().setMark("textStyle", { lineHeight: null }).removeEmptyTextStyle().run();
          }
        };
      }
    });
    var import_core7 = require_dist9();
    var TextStyleKit = import_core7.Extension.create({
      name: "textStyleKit",
      addExtensions() {
        const extensions2 = [];
        if (this.options.backgroundColor !== false) {
          extensions2.push(BackgroundColor.configure(this.options.backgroundColor));
        }
        if (this.options.color !== false) {
          extensions2.push(Color2.configure(this.options.color));
        }
        if (this.options.fontFamily !== false) {
          extensions2.push(FontFamily.configure(this.options.fontFamily));
        }
        if (this.options.fontSize !== false) {
          extensions2.push(FontSize.configure(this.options.fontSize));
        }
        if (this.options.lineHeight !== false) {
          extensions2.push(LineHeight.configure(this.options.lineHeight));
        }
        if (this.options.textStyle !== false) {
          extensions2.push(TextStyle.configure(this.options.textStyle));
        }
        return extensions2;
      }
    });
  }
});

// src/popover-menu.js
var require_popover_menu = __commonJS({
  "src/popover-menu.js"(exports2, module2) {
    var { setIcon } = require("obsidian");
    var PopoverMenu = class {
      constructor(editor, containerEl, styleOptions = []) {
        this.editor = editor;
        this.containerEl = containerEl;
        this.styleOptions = styleOptions;
        this.el = null;
        this.isVisible = false;
        this.currentMode = "default";
        this.handleClickOutside = this.handleClickOutside.bind(this);
      }
      updateStyleOptions(newOptions) {
        this.styleOptions = newOptions;
        if (this.el && this.sections && this.sections[0]) {
          this.sections[0].empty();
          const options = (this.styleOptions || []).map((opt) => ({
            label: opt.label,
            value: opt.value,
            action: () => this.applyStyle(opt.value)
          }));
          this.styleSelect = this.createSelectMenu(this.sections[0], options);
        }
      }
      applyStyle(value) {
        if (!this.editor) return;
        let isHeading = false;
        let level = 1;
        if (value.startsWith("heading-")) {
          isHeading = true;
          level = parseInt(value.split("-")[1], 10);
        } else if (value === "title") {
          isHeading = true;
          level = 1;
        }
        if (isHeading) {
          this.editor.chain().focus().toggleHeading({ level }).updateAttributes("heading", { class: value }).run();
        } else {
          this.editor.chain().focus().setParagraph().updateAttributes("paragraph", { class: value }).run();
        }
      }
      create() {
        this.el = document.createElement("div");
        this.el.addClass("colophon-popover");
        this.containerEl.appendChild(this.el);
        this.sections = [];
        const styleSection = this.el.createDiv("colophon-popover-section");
        const options = (this.styleOptions || []).map((opt) => ({
          label: opt.label,
          value: opt.value,
          action: () => this.applyStyle(opt.value)
        }));
        this.styleSelect = this.createSelectMenu(styleSection, options);
        this.sections.push(styleSection);
        const formatSection = this.el.createDiv("colophon-popover-section");
        this.createIconButton(formatSection, "bold", () => this.editor.chain().focus().toggleBold().run(), "isActive", "bold");
        this.createIconButton(formatSection, "italic", () => this.editor.chain().focus().toggleItalic().run(), "isActive", "italic");
        this.createIconButton(formatSection, "underline", () => this.editor.chain().focus().toggleUnderline().run(), "isActive", "underline");
        this.createIconButton(formatSection, "strikethrough", () => this.editor.chain().focus().toggleStrike().run(), "isActive", "strike");
        this.sections.push(formatSection);
        const advancedSection = this.el.createDiv("colophon-popover-section");
        this.createIconButton(advancedSection, "superscript", () => this.editor.chain().focus().toggleSuperscript().run(), "isActive", "superscript");
        this.createIconButton(advancedSection, "subscript", () => this.editor.chain().focus().toggleSubscript().run(), "isActive", "subscript");
        const smallCapsBtn = this.createIconButton(advancedSection, "type", () => this.editor.chain().focus().toggleSmallCaps().run(), "isActive", "smallCaps");
        smallCapsBtn.setAttribute("aria-label", "Small Caps");
        this.sections.push(advancedSection);
      }
      createSelectMenu(parent, options) {
        const container = parent.createDiv("colophon-select-container");
        const trigger = container.createEl("button", { cls: "colophon-select-trigger" });
        const labelSpan = trigger.createSpan({ cls: "colophon-select-label", text: "Select Style" });
        const iconSpan = trigger.createSpan({ cls: "colophon-select-icon" });
        setIcon(iconSpan, "chevron-down");
        const dropdown = container.createDiv("colophon-select-dropdown");
        dropdown.style.display = "none";
        trigger.addEventListener("click", (e) => {
          e.preventDefault();
          e.stopPropagation();
          const isHidden = dropdown.style.display === "none";
          dropdown.style.display = isHidden ? "block" : "none";
        });
        options.forEach((opt) => {
          const item = dropdown.createEl("div", { cls: "colophon-select-item" });
          item.dataset.value = opt.value;
          item.createSpan({ text: opt.label });
          item.addEventListener("click", (e) => {
            e.preventDefault();
            e.stopPropagation();
            opt.action();
            this.hide();
          });
        });
        return { container, trigger, labelSpan, dropdown, options };
      }
      updateSelectMenu() {
        if (!this.styleSelect || !this.editor) return;
        let activeValue = "body";
        for (const opt of this.styleOptions || []) {
          const value = opt.value;
          let isMatch = false;
          if (value.startsWith("heading-") || value === "title") {
            if (this.editor.isActive("heading", { class: value })) {
              isMatch = true;
            }
          } else {
            if (this.editor.isActive("paragraph", { class: value })) {
              isMatch = true;
            }
          }
          if (isMatch) {
            activeValue = value;
            break;
          }
        }
        const activeOption = this.styleSelect.options.find((o) => o.value === activeValue);
        this.styleSelect.labelSpan.innerText = activeOption ? activeOption.label : "Select Style";
        const items = this.styleSelect.dropdown.querySelectorAll(".colophon-select-item");
        items.forEach((item) => {
          if (item.dataset.value === activeValue) {
            item.addClass("is-selected");
          } else {
            item.removeClass("is-selected");
          }
        });
      }
      setMode(mode) {
        this.currentMode = mode;
        if (!this.el) this.create();
        if (mode === "footnote") {
          if (this.sections[0]) this.sections[0].style.display = "none";
        } else {
          if (this.sections[0]) this.sections[0].style.display = "flex";
        }
      }
      createIconButton(parent, icon, action, checkMethod, checkArg) {
        const btn = parent.createEl("button", { cls: "colophon-popover-icon-btn" });
        const iconSpan = btn.createSpan();
        setIcon(iconSpan, icon);
        btn.addEventListener("click", (e) => {
          e.preventDefault();
          e.stopPropagation();
          action();
          this.hide();
        });
        btn._checkState = () => {
          if (this.editor && this.editor.isActive(checkArg)) {
            btn.addClass("is-active");
          } else {
            btn.removeClass("is-active");
          }
        };
        return btn;
      }
      updateButtonStates() {
        const btns = this.el.querySelectorAll(".colophon-popover-icon-btn");
        btns.forEach((btn) => {
          if (btn._checkState) btn._checkState();
        });
      }
      show(targetRect) {
        if (!this.el || !this.el.isConnected) {
          if (this.el) this.el.remove();
          this.create();
          this.setMode(this.currentMode);
        }
        this.updateSelectMenu();
        this.updateButtonStates();
        this.el.addClass("is-visible");
        this.isVisible = true;
        const popoverWidth = this.el.offsetWidth;
        const popoverHeight = this.el.offsetHeight;
        const containerWidth = this.containerEl.offsetWidth;
        let left = targetRect.left + targetRect.width / 2 - popoverWidth / 2;
        let top = targetRect.top - popoverHeight - 10;
        const padding = 10;
        const scrollTop = this.containerEl.scrollTop;
        const scrollLeft = this.containerEl.scrollLeft;
        if (left < scrollLeft + padding) {
          left = scrollLeft + padding;
        } else if (left + popoverWidth > scrollLeft + containerWidth - padding) {
          left = scrollLeft + containerWidth - popoverWidth - padding;
        }
        if (top < scrollTop + padding) {
          top = targetRect.top + targetRect.height + 10;
        }
        this.el.style.left = `${left}px`;
        this.el.style.top = `${top}px`;
        document.addEventListener("click", this.handleClickOutside);
      }
      hide() {
        if (this.el) {
          this.el.removeClass("is-visible");
          this.isVisible = false;
          document.removeEventListener("click", this.handleClickOutside);
          if (this.styleSelect && this.styleSelect.dropdown) {
            this.styleSelect.dropdown.style.display = "none";
          }
        }
      }
      handleClickOutside(e) {
        if (this.el && !this.el.contains(e.target)) {
          this.hide();
        }
      }
      destroy() {
        if (this.el) {
          this.el.remove();
        }
        document.removeEventListener("click", this.handleClickOutside);
      }
    };
    module2.exports = PopoverMenu;
  }
});

// src/extensions/footnote.js
var require_footnote = __commonJS({
  "src/extensions/footnote.js"(exports2, module2) {
    var { Node: Node2, mergeAttributes } = require_dist9();
    var Footnote2 = Node2.create({
      name: "footnote",
      group: "inline",
      inline: true,
      atom: true,
      addAttributes() {
        return {
          id: {
            default: null,
            parseHTML: (element) => element.getAttribute("data-id"),
            renderHTML: (attributes) => {
              return {
                "data-id": attributes.id
              };
            }
          },
          number: {
            default: null
            // Number is transient, calculated at render time usually, but we can store it for now
            // or rely on the decoration logic. For simplicity, let's try to keep it in sync or just render a placeholder if needed.
            // Actually, for a simple implementation, we might just render [*] and let the view handle the numbering,
            // but Tiptap nodes can be reactive.
            // Let's stick to ID for the data model.
          }
        };
      },
      parseHTML() {
        return [
          {
            tag: 'span[data-type="footnote"]'
          }
        ];
      },
      renderHTML({ HTMLAttributes }) {
        return [
          "span",
          mergeAttributes(HTMLAttributes, { "data-type": "footnote", class: "colophon-footnote" }),
          ["sup", HTMLAttributes.number || "#"]
        ];
      },
      addCommands() {
        return {
          addFootnote: () => ({ commands: commands2 }) => {
            const id = `fn-${Date.now()}`;
            return commands2.insertContent({
              type: this.name,
              attrs: { id, number: "#" }
              // Initial placeholder
            });
          }
        };
      }
    });
    module2.exports = Footnote2;
  }
});

// src/extensions/substitutions.js
var require_substitutions = __commonJS({
  "src/extensions/substitutions.js"(exports2, module2) {
    var { Extension, InputRule } = require_dist9();
    var Substitutions = Extension.create({
      name: "substitutions",
      addOptions() {
        return {
          smartQuotes: true,
          smartDashes: true,
          doubleQuoteStyle: "\u201C|\u201D",
          singleQuoteStyle: "\u2018|\u2019"
        };
      },
      addInputRules() {
        const rules = [];
        if (this.options.smartDashes) {
          rules.push(new InputRule({
            find: /---\s$/,
            handler: ({ state: state2, range: range2 }) => {
              return state2.tr.insertText("\u2014 ", range2.from, range2.to);
            }
          }));
          rules.push(new InputRule({
            find: /--\s$/,
            handler: ({ state: state2, range: range2 }) => {
              return state2.tr.insertText("\u2013 ", range2.from, range2.to);
            }
          }));
        }
        if (this.options.smartQuotes) {
          const [openDouble, closeDouble] = this.options.doubleQuoteStyle.split("|");
          const [openSingle, closeSingle] = this.options.singleQuoteStyle.split("|");
          rules.push(new InputRule({
            find: /(?:^|[\s\{\[\(\<'"\u2018\u201C])(")$/,
            handler: ({ state: state2, range: range2, match }) => {
              const matchText = match[0];
              const prefix = matchText.substring(0, matchText.length - 1);
              return state2.tr.insertText(prefix + openDouble, range2.from, range2.to);
            }
          }));
          rules.push(new InputRule({
            find: /"$/,
            handler: ({ state: state2, range: range2 }) => {
              return state2.tr.insertText(closeDouble, range2.from, range2.to);
            }
          }));
          rules.push(new InputRule({
            find: /(?:^|[\s\{\[\(\<'"\u2018\u201C])(')$/,
            handler: ({ state: state2, range: range2, match }) => {
              const matchText = match[0];
              const prefix = matchText.substring(0, matchText.length - 1);
              return state2.tr.insertText(prefix + openSingle, range2.from, range2.to);
            }
          }));
          rules.push(new InputRule({
            find: /'$/,
            handler: ({ state: state2, range: range2 }) => {
              return state2.tr.insertText(closeSingle, range2.from, range2.to);
            }
          }));
        }
        return rules;
      }
    });
    module2.exports = Substitutions;
  }
});

// src/link-suggest-modal.js
var require_link_suggest_modal = __commonJS({
  "src/link-suggest-modal.js"(exports2, module2) {
    var { SuggestModal } = require("obsidian");
    var { TextSelection } = require_state();
    var LinkSuggestModal = class extends SuggestModal {
      constructor(app, editor, range2) {
        super(app);
        this.app = app;
        this.editor = editor;
        this.range = range2;
        this.updateListener = () => this.updateAndFilterSuggestions();
      }
      onOpen() {
        super.onOpen();
        this.editor.on("update", this.updateListener);
        this.updateAndFilterSuggestions();
      }
      onClose() {
        super.onClose();
        this.editor.off("update", this.updateListener);
      }
      updateAndFilterSuggestions() {
        const query = this.getEditorQuery();
        if (query === null) {
          this.close();
          return;
        }
        this.inputEl.value = query;
        this.onInput();
      }
      getEditorQuery() {
        try {
          const currentState = this.editor.state;
          const currentPos = currentState.selection.from;
          if (currentPos < this.range.from + 2) return null;
          if (currentState.doc.textBetween(this.range.from, this.range.from + 2) !== "[[") return null;
          return currentState.doc.textBetween(this.range.from + 2, currentPos);
        } catch (e) {
          return null;
        }
      }
      getSuggestions(query) {
        const files = this.app.vault.getMarkdownFiles();
        if (!query) return files;
        const lowerCaseQuery = query.toLowerCase();
        return files.filter(
          (file) => file.path.toLowerCase().includes(lowerCaseQuery) || file.basename.toLowerCase().includes(lowerCaseQuery)
        );
      }
      renderSuggestion(file, el) {
        el.createEl("div", { text: file.basename });
        el.createEl("small", { text: file.path });
      }
      onChooseSuggestion(file, evt) {
        const linkText = file.basename;
        if (this.editor && !this.editor.isDestroyed) {
          const { schema, tr } = this.editor.state;
          const from = this.range.from;
          const to = this.editor.state.selection.from;
          tr.replaceWith(from, to, schema.text(linkText, [
            schema.marks.internallink.create({ href: linkText })
          ]));
          this.editor.view.dispatch(tr);
        }
      }
    };
    module2.exports = LinkSuggestModal;
  }
});

// src/extensions/internallink.js
var require_internallink = __commonJS({
  "src/extensions/internallink.js"(exports2, module2) {
    var { Mark, InputRule, mergeAttributes } = require_dist9();
    var { Plugin: Plugin2, PluginKey } = require_state();
    var LinkSuggestModal = require_link_suggest_modal();
    var InternalLink = Mark.create({
      name: "internallink",
      inclusive: false,
      addOptions() {
        return {
          app: null,
          // Obsidian App instance
          HTMLAttributes: {
            class: "internal-link"
          }
        };
      },
      parseHTML() {
        return [
          {
            tag: "a.internal-link"
          }
        ];
      },
      addAttributes() {
        return {
          href: {
            default: null
          },
          text: {
            default: null
          }
        };
      },
      renderHTML({ HTMLAttributes }) {
        return ["a", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
      },
      addInputRules() {
        return [
          new InputRule({
            find: /\[\[([^|\]]+)(?:\|([^\]]+))?\]\]$/,
            handler: ({ state: state2, range: range2, match }) => {
              const { tr } = state2;
              const start = range2.from;
              const end = range2.to;
              const href = match[1];
              const alias = match[2];
              const text = alias || href;
              tr.replaceWith(start, end, state2.schema.text(text, [
                state2.schema.marks.internallink.create({ href, text: alias })
              ]));
              return tr;
            }
          })
        ];
      },
      addProseMirrorPlugins() {
        const extension = this;
        const editor = extension.editor;
        const findMarkRange = ($pos, markType) => {
          const mark = $pos.marks().find((m) => m.type === markType);
          if (!mark) return null;
          let from = $pos.pos, to = $pos.pos;
          let startIndex = $pos.index();
          for (let i = startIndex; i >= 0; i--) {
            const node = $pos.parent.child(i);
            if (mark.isInSet(node.marks)) {
              from = $pos.start() + node.content.findIndex(node).offset;
            } else {
              break;
            }
          }
          for (let i = startIndex; i < $pos.parent.childCount; i++) {
            const node = $pos.parent.child(i);
            if (mark.isInSet(node.marks)) {
              to = $pos.start() + node.content.findIndex(node).offset + node.nodeSize;
            } else {
              break;
            }
          }
          return { from, to, mark };
        };
        const livePreviewPlugin = new Plugin2({
          key: new PluginKey("internallink-live-preview"),
          state: {
            init() {
              return { activeLink: null };
            },
            apply(tr, value, oldState, newState) {
              const { selection } = tr;
              const oldActiveLink = value.activeLink;
              let activeLink = null;
              if (oldActiveLink) {
                const { from, to } = oldActiveLink;
                const mappedFrom = tr.mapping.map(from);
                const mappedTo = tr.mapping.map(to);
                if (selection.from >= mappedFrom && selection.to <= mappedTo) {
                  activeLink = { from: mappedFrom, to: mappedTo, text: newState.doc.textBetween(mappedFrom, mappedTo) };
                }
              }
              if (selection.empty) {
                const markRange = findMarkRange(selection.$from, newState.schema.marks.internallink);
                if (markRange) {
                  const { from, to, mark } = markRange;
                  const alias = mark.attrs.text;
                  const text = alias ? `[[${mark.attrs.href}|${alias}]]` : `[[${mark.attrs.href}]]`;
                  activeLink = { from, to, text, mark };
                }
              }
              if (JSON.stringify(activeLink) === JSON.stringify(oldActiveLink)) {
                return value;
              }
              return { activeLink };
            }
          },
          view(editorView) {
            return {
              update: (view, prevState) => {
                const pluginState = this.key.getState(view.state);
                const prevPluginState = this.key.getState(prevState);
                if (pluginState.activeLink && !prevPluginState.activeLink) {
                  const { from, to, text } = pluginState.activeLink;
                  view.dispatch(
                    view.state.tr.removeMark(from, to).replaceWith(from, to, view.state.schema.text(text)).setMeta("addToHistory", false)
                  );
                } else if (!pluginState.activeLink && prevPluginState.activeLink) {
                  const { from, to } = prevPluginState.activeLink;
                  const text = prevState.doc.textBetween(from, to);
                  const match = text.match(/\[\[([^|\]]+)(?:\|([^\]]+))?\]\]/);
                  const tr = view.state.tr;
                  if (match) {
                    const href = match[1];
                    const alias = match[2];
                    const linkText = alias || href;
                    tr.replaceWith(from, to, view.state.schema.text(linkText, [
                      view.state.schema.marks.internallink.create({ href, text: alias })
                    ]));
                  } else {
                  }
                  if (tr.docChanged) {
                    view.dispatch(tr);
                  }
                }
              }
            };
          }
        });
        const suggestionPlugin = new Plugin2({
          props: {
            handleDOMEvents: {
              click(view, event) {
                const target = event.target.closest(".internal-link");
                if (!target) return false;
                const href = target.getAttribute("href");
                if (href && extension.options.app) {
                  event.preventDefault();
                  event.stopPropagation();
                  const sourcePath = extension.options.getFilePath ? extension.options.getFilePath() : "";
                  const isMod = navigator.platform.toUpperCase().indexOf("MAC") >= 0 ? event.metaKey : event.ctrlKey;
                  const isAlt = event.altKey;
                  if (isMod && isAlt) {
                    extension.options.app.workspace.openLinkText(href, sourcePath, "split");
                  } else if (isMod) {
                    extension.options.app.workspace.openLinkText(href, sourcePath, "tab");
                  } else {
                    extension.options.app.workspace.openLinkText(href, sourcePath, false);
                  }
                  return true;
                }
                return false;
              }
            },
            handleTextInput(view, from, to, text) {
              if (text === "[" && extension.options.app) {
                const prevChar = view.state.doc.textBetween(from - 1, from);
                if (prevChar === "[") {
                  setTimeout(() => {
                    const modal = new LinkSuggestModal(extension.options.app, extension.editor, { from: from - 1, to: from + 1 });
                    modal.open();
                  }, 0);
                }
              }
              return false;
            }
          }
        });
        return [suggestionPlugin, livePreviewPlugin];
      }
    });
    module2.exports = InternalLink;
  }
});

// src/extensions/standard-link.js
var require_standard_link = __commonJS({
  "src/extensions/standard-link.js"(exports2, module2) {
    var { Mark, InputRule, mergeAttributes } = require_dist9();
    var { Plugin: Plugin2 } = require_state();
    var StandardLink = Mark.create({
      name: "standardLink",
      inclusive: false,
      addOptions() {
        return {
          app: null,
          // Obsidian App instance
          HTMLAttributes: {
            class: "standard-link"
          }
        };
      },
      addAttributes() {
        return {
          href: {
            default: null
          }
        };
      },
      parseHTML() {
        return [
          {
            tag: "a[href]:not(.internal-link)"
          }
        ];
      },
      renderHTML({ HTMLAttributes }) {
        return ["a", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
      },
      addInputRules() {
        return [
          new InputRule({
            find: /\[([^\]]+)\]\(([^)]+)\)$/,
            handler: ({ state: state2, range: range2, match }) => {
              const { tr } = state2;
              const start = range2.from;
              const end = range2.to;
              const text = match[1];
              const href = match[2];
              tr.replaceWith(start, end, state2.schema.text(text, [
                state2.schema.marks.standardLink.create({ href })
              ]));
              return tr;
            }
          })
        ];
      },
      addProseMirrorPlugins() {
        const extension = this;
        return [
          new Plugin2({
            props: {
              handleDOMEvents: {
                click(view, event) {
                  const target = event.target.closest("a.standard-link");
                  if (!target) return false;
                  const href = target.getAttribute("href");
                  if (href && extension.options.app) {
                    event.preventDefault();
                    event.stopPropagation();
                    const isExternal = /^(http|https|mailto|tel):/.test(href);
                    if (isExternal) {
                      window.open(href, "_blank");
                      return true;
                    }
                    const sourcePath = extension.options.getFilePath ? extension.options.getFilePath() : "";
                    const isMod = navigator.platform.toUpperCase().indexOf("MAC") >= 0 ? event.metaKey : event.ctrlKey;
                    const isAlt = event.altKey;
                    if (isMod && isAlt) {
                      extension.options.app.workspace.openLinkText(href, sourcePath, "split");
                    } else if (isMod) {
                      extension.options.app.workspace.openLinkText(href, sourcePath, "tab");
                    } else {
                      extension.options.app.workspace.openLinkText(href, sourcePath, false);
                    }
                    return true;
                  }
                  return false;
                }
              }
            }
          })
        ];
      }
    });
    module2.exports = StandardLink;
  }
});

// src/style-manager.js
var require_style_manager = __commonJS({
  "src/style-manager.js"(exports2, module2) {
    var StyleManager = class {
      constructor() {
        this.styles = {};
      }
      /**
       * Parses the style configuration and generates CSS.
       * @param {Object} stylesConfig - The configuration object (parsed YAML).
       * @returns {string} The generated CSS string.
       */
      generateCSS(stylesConfig) {
        this.styles = stylesConfig;
        let css = "";
        let scale = 1;
        if (stylesConfig["scale"]) {
          const scaleStr = String(stylesConfig["scale"]);
          if (scaleStr.endsWith("%")) {
            scale = parseFloat(scaleStr) / 100;
          } else {
            scale = parseFloat(scaleStr);
          }
          if (isNaN(scale)) scale = 1;
        }
        for (const [key, styleDef] of Object.entries(stylesConfig)) {
          if (key === "scale") continue;
          const selector = this.getSelector(key);
          const rules = this.mapStyleToCSS(styleDef, scale);
          if (rules) {
            css += `${selector} {
${rules}
}
`;
          }
        }
        return css;
      }
      /**
       * Returns the CSS selector for a given style key.
       * @param {string} key - The style key (e.g., 'heading-1', 'body').
       * @returns {string} The CSS selector.
       */
      getSelector(key) {
        const base = ".colophon-workspace .ProseMirror";
        if (key.startsWith("heading-")) {
          const level = key.split("-")[1];
          return `${base} h${level}.${key}`;
        } else if (key === "title") {
          return `${base} h1.title`;
        } else if (key === "supertitle") {
          return `${base} p.supertitle`;
        } else if (key === "footnote") {
          return `.colophon-footnote-editor-content p`;
        } else if (key === "footnote-number") {
          return `span.colophon-footnote-number`;
        } else {
          return `${base} p.${key}`;
        }
      }
      /**
       * Maps a single style definition to CSS rules.
       * @param {Object} styleDef - The style definition object.
       * @returns {string} The CSS rules string.
       */
      mapStyleToCSS(styleDef, scale = 1) {
        const rules = [];
        if (styleDef["font-family"]) {
          rules.push(`    font-family: "${styleDef["font-family"]}", serif;`);
        }
        if (styleDef["font-size"]) {
          rules.push(`    font-size: ${this.convertValue(styleDef["font-size"], "font-size", scale)};`);
        }
        if (styleDef["text-align"]) {
          rules.push(`    text-align: ${styleDef["text-align"]};`);
        }
        if (styleDef["line-spacing"]) {
          rules.push(`    line-height: ${this.convertValue(styleDef["line-spacing"], "line-spacing", scale)};`);
        }
        if (styleDef["before-paragraph"]) {
          rules.push(`    margin-top: ${this.convertValue(styleDef["before-paragraph"], "spacing", scale)};`);
        }
        if (styleDef["after-paragraph"]) {
          rules.push(`    margin-bottom: ${this.convertValue(styleDef["after-paragraph"], "spacing", scale)};`);
        }
        if (styleDef["first-indent"]) {
          rules.push(`    text-indent: ${this.convertValue(styleDef["first-indent"], "indent", scale)};`);
        }
        if (styleDef["left-indent"]) {
          rules.push(`    margin-left: ${this.convertValue(styleDef["left-indent"], "indent", scale)};`);
        }
        if (styleDef["right-indent"]) {
          rules.push(`    margin-right: ${this.convertValue(styleDef["right-indent"], "indent", scale)};`);
        }
        if (styleDef["font-variant"]) {
          const variant = styleDef["font-variant"].toLowerCase();
          if (variant === "italic") {
            rules.push(`    font-style: italic;`);
          } else if (variant === "bold") {
            rules.push(`    font-weight: bold;`);
          } else if (variant === "small-caps") {
            rules.push(`    font-variant: small-caps;`);
          } else {
            rules.push(`    font-style: normal;`);
            rules.push(`    font-weight: normal;`);
            rules.push(`    font-variant: normal;`);
          }
        }
        if (styleDef["capitalization"]) {
          if (styleDef["capitalization"] === "small-caps") {
            rules.push(`    font-variant: small-caps;`);
          } else {
            rules.push(`    text-transform: ${styleDef["capitalization"]};`);
          }
        }
        if (styleDef["character-spacing"]) {
          rules.push(`    letter-spacing: ${styleDef["character-spacing"]};`);
        }
        if (styleDef["keep-with-next"]) {
          rules.push(`    page-break-after: avoid;`);
          rules.push(`    break-after: avoid;`);
        }
        if (styleDef["color"]) {
          rules.push(`    color: ${styleDef["color"]};`);
        }
        if (styleDef["font-weight"]) {
          rules.push(`    font-weight: ${styleDef["font-weight"]};`);
        }
        return rules.join("\n");
      }
      convertValue(value, type2, scale = 1) {
        if (typeof value !== "string" && typeof value !== "number") return value;
        const strVal = String(value);
        const numVal = parseFloat(strVal);
        if (isNaN(numVal)) return value;
        const scaledVal = numVal * scale;
        if (strVal.endsWith("in")) {
          return `${(scaledVal * 6).toFixed(3)}rem`;
        }
        if (type2 === "font-size") {
          if (strVal.endsWith("pt")) {
            return `${(scaledVal / 12).toFixed(3)}rem`;
          }
        } else if (type2 === "indent") {
        } else if (type2 === "line-spacing") {
          if (strVal.endsWith("pt")) {
            return `${(scaledVal / 12).toFixed(3)}rem`;
          }
          if (!strVal.match(/[a-z%]/i)) {
            return strVal;
          }
        } else if (type2 === "spacing") {
          if (strVal.endsWith("pt")) {
            return `${(scaledVal / 12).toFixed(3)}rem`;
          }
        }
        return value;
      }
      /**
       * Returns a list of options for the UI select menu.
       * @param {Object} stylesConfig 
       * @returns {Array} Array of { label, value, action? }
       */
      getStyleOptions(stylesConfig) {
        const options = [];
        for (const [key, styleDef] of Object.entries(stylesConfig)) {
          if (key === "scale") continue;
          if (key === "footnote") continue;
          if (key === "footnote-number") continue;
          options.push({
            label: styleDef.name || key,
            value: key
            // We don't define the action here, the UI component should handle the action based on the value
            // because it needs access to the editor instance.
          });
        }
        return options;
      }
    };
    module2.exports = StyleManager;
  }
});

// src/default-styles.js
var require_default_styles = __commonJS({
  "src/default-styles.js"(exports2, module2) {
    var DEFAULT_STYLES = {
      "scale": "100%",
      "supertitle": {
        "name": "Supertitle",
        "font-size": "11.5pt",
        "text-align": "center",
        "line-spacing": "14pt",
        "before-paragraph": "0pt",
        "after-paragraph": "18pt",
        "font-family": "Minion 3",
        "font-variant": "Regular"
      },
      "title": {
        "name": "Title",
        "font-size": "18pt",
        "text-align": "center",
        "line-spacing": "18pt",
        "before-paragraph": "0pt",
        "after-paragraph": "36pt",
        "font-family": "Minion 3",
        "font-variant": "Regular"
      },
      "body-first": {
        "name": "Body First",
        "font-size": "11.5pt",
        "text-align": "left",
        "first-indent": "0in",
        "left-indent": "0in",
        "right-indent": "0in",
        "line-spacing": "14pt",
        "before-paragraph": "0pt",
        "after-paragraph": "0pt",
        "font-family": "Minion 3",
        "font-variant": "Regular",
        "following-style": "body"
      },
      "body": {
        "name": "Body",
        "font-size": "11.5pt",
        "text-align": "left",
        "first-indent": "0.3in",
        "left-indent": "0in",
        "right-indent": "0in",
        "line-spacing": "14pt",
        "before-paragraph": "0pt",
        "after-paragraph": "0pt",
        "font-family": "Minion 3",
        "font-variant": "Regular"
      },
      "footnote": {
        "name": "Footnote",
        "font-size": "10pt",
        "text-align": "left",
        "first-indent": "0in",
        "left-indent": "0in",
        "right-indent": "0in",
        "line-spacing": "13pt",
        "before-paragraph": "0pt",
        "after-paragraph": "0pt",
        "font-family": "Minion 3 Caption",
        "font-variant": "Regular",
        "space-between-notes": "10pt",
        "format": "1, 2, 3, \u2026",
        "numbering": "continuous",
        "type": "footnotes"
      },
      "footnote-number": {
        "name": "Footnote Number",
        "font-weight": "bold",
        "color": "var(--text-accent)"
      },
      "heading-1": {
        "name": "Heading 1",
        "font-size": "11.5pt",
        "text-align": "left",
        "first-indent": "0in",
        "left-indent": "0in",
        "right-indent": "0in",
        "line-spacing": "28pt",
        "before-paragraph": "28pt",
        "after-paragraph": "14pt",
        "font-family": "Minion 3",
        "font-variant": "Italic",
        "keep-with-next": true,
        "following-style": "body-first"
      },
      "heading-2": {
        "name": "Heading 2",
        "font-size": "11.5pt",
        "text-align": "left",
        "first-indent": "0in",
        "left-indent": "0in",
        "right-indent": "0in",
        "line-spacing": "28pt",
        "before-paragraph": "28pt",
        "after-paragraph": "14pt",
        "font-family": "Minion 3",
        "font-variant": "Regular",
        "capitalization": "small-caps",
        "character-spacing": "2%",
        "keep-with-next": true,
        "following-style": "body-first"
      },
      "heading-3": {
        "name": "Heading 3",
        "font-size": "11.5pt",
        "text-align": "center",
        "first-indent": "0in",
        "left-indent": "0in",
        "right-indent": "0in",
        "line-spacing": "28pt",
        "before-paragraph": "28pt",
        "after-paragraph": "14pt",
        "font-family": "Minion 3",
        "font-variant": "Regular",
        "keep-with-next": true,
        "following-style": "body-first"
      }
    };
    module2.exports = DEFAULT_STYLES;
  }
});

// src/tiptap-adapter.js
var require_tiptap_adapter = __commonJS({
  "src/tiptap-adapter.js"(exports2, module2) {
    var { Editor, Mark, Extension, mergeAttributes } = require_dist9();
    var { StarterKit } = require_dist30();
    var { Paragraph: Paragraph3 } = require_dist21();
    var { Heading } = require_dist16();
    var Underline2 = require_dist24();
    var Subscript = require_dist31();
    var Superscript = require_dist32();
    var TextStyle = require_dist33();
    var { InputRule } = require_dist9();
    var PopoverMenu = require_popover_menu();
    var Footnote2 = require_footnote();
    var Substitutions = require_substitutions();
    var InternalLink = require_internallink();
    var StandardLink = require_standard_link();
    var StyleManager = require_style_manager();
    var DEFAULT_STYLES = require_default_styles();
    var { parseYaml } = require("obsidian");
    var EnterKeyHandler = Extension.create({
      name: "enterKeyHandler",
      addKeyboardShortcuts() {
        return {
          "Enter": () => {
            const { state: state2 } = this.editor;
            const { $from } = state2.selection;
            const currentNode = $from.parent;
            if (currentNode.attrs.class !== "body") {
              return this.editor.chain().focus().splitBlock().setNode("paragraph", { class: "body" }).run();
            }
            return this.editor.commands.splitBlock();
          }
        };
      }
    });
    var CustomParagraph = Paragraph3.extend({
      addAttributes() {
        return {
          class: {
            default: "body",
            parseHTML: (element) => element.getAttribute("class"),
            renderHTML: (attributes) => {
              if (!attributes.class) {
                return {};
              }
              return { class: attributes.class };
            }
          }
        };
      }
    });
    var CustomHeading = Heading.extend({
      addAttributes() {
        return {
          ...this.parent?.(),
          level: {
            default: 1,
            keepOnSplit: false
          },
          class: {
            default: "heading-1",
            parseHTML: (element) => element.getAttribute("class"),
            renderHTML: (attributes) => {
              if (!attributes.class) {
                return {};
              }
              return { class: attributes.class };
            }
          }
        };
      }
    });
    var SmallCaps = Mark.create({
      name: "smallCaps",
      parseHTML() {
        return [
          {
            style: "font-variant",
            getAttrs: (value) => value === "small-caps" ? {} : false
          }
        ];
      },
      renderHTML({ HTMLAttributes }) {
        return ["span", mergeAttributes(HTMLAttributes, { style: "font-variant: small-caps" }), 0];
      },
      addCommands() {
        return {
          toggleSmallCaps: () => ({ commands: commands2 }) => {
            return commands2.toggleMark(this.name);
          }
        };
      }
    });
    var TiptapAdapter = class {
      constructor(app, containerEl, isSpellcheckEnabled, settings, onUpdate) {
        this.app = app;
        this.containerEl = containerEl;
        this.isSpellcheckEnabled = isSpellcheckEnabled;
        this.settings = settings;
        this.onUpdate = onUpdate;
        this.editor = null;
        this.isLoaded = false;
        this.popover = null;
        this.footnotes = [];
        this.listeners = [];
        this.styleManager = new StyleManager();
        this.styleOptions = [];
      }
      normalizeDoc(doc) {
        if (!doc || !doc.content) {
          return doc;
        }
        doc.content.forEach((node) => {
          if (node.type === "paragraph") {
            if (!node.attrs || node.attrs.class === null || node.attrs.class === void 0) {
              node.attrs = { ...node.attrs, class: "body" };
            }
          } else if (node.type === "heading") {
            if (!node.attrs || node.attrs.class === null || node.attrs.class === void 0) {
              const level = node.attrs?.level || 1;
              node.attrs = { ...node.attrs, class: `heading-${level}` };
            }
          }
        });
        return doc;
      }
      subscribe(callback) {
        this.listeners.push(callback);
        return () => {
          this.listeners = this.listeners.filter((cb) => cb !== callback);
        };
      }
      updateSettings(newSettings) {
        const oldPadding = this.settings.textColumnBottomPadding;
        this.settings = newSettings;
        this.loadStyles();
        if (this.editor && oldPadding !== newSettings.textColumnBottomPadding) {
          this.handleScroll();
        }
      }
      load(markdown2, data, filePath) {
        this.filePath = filePath;
        if (this.editor) {
          this.editor.destroy();
        }
        let content = null;
        if (data) {
          if (data.doc) {
            content = data.doc;
            this.footnotes = data.footnotes || [];
          } else {
            content = data;
            this.footnotes = [];
          }
        }
        if (!content) {
          content = {
            type: "doc",
            content: markdown2.split("\n\n").map((text) => ({
              type: "paragraph",
              content: text.trim() ? [{ type: "text", text: text.trim() }] : []
            }))
          };
          this.footnotes = [];
        }
        content = this.normalizeDoc(content);
        this.initEditor(content);
        this.isLoaded = true;
      }
      initEditor(content) {
        const editorHost = this.containerEl.createDiv("colophon-editor-host");
        this.loadStyles().then(() => {
        });
        this.editor = new Editor({
          element: editorHost,
          extensions: [
            StarterKit.configure({
              paragraph: false,
              heading: false
            }),
            EnterKeyHandler,
            CustomParagraph,
            CustomHeading,
            Underline2,
            Subscript,
            Superscript,
            TextStyle,
            SmallCaps,
            Footnote2,
            Substitutions.configure({
              smartQuotes: this.settings.smartQuotes,
              smartDashes: this.settings.smartDashes,
              doubleQuoteStyle: this.settings.doubleQuoteStyle,
              singleQuoteStyle: this.settings.singleQuoteStyle
            }),
            InternalLink.configure({
              app: this.app,
              getFilePath: () => this.filePath
            }),
            StandardLink.configure({
              app: this.app,
              getFilePath: () => this.filePath
            })
          ],
          editorProps: {
            attributes: {
              spellcheck: this.isSpellcheckEnabled ? "true" : "false"
            }
          },
          content,
          onUpdate: ({ editor }) => {
            this.triggerUpdate();
          },
          onSelectionUpdate: ({ editor }) => {
            this.handleScroll();
          }
        });
        this.popover = new PopoverMenu(this.editor, this.containerEl, this.styleOptions || []);
        this.popover.setMode("default");
        this.editor.view.dom.addEventListener("contextmenu", (e) => {
          const { from, to } = this.editor.state.selection;
          if (from !== to) {
            e.preventDefault();
            const selection = window.getSelection();
            if (selection.rangeCount > 0) {
              const range2 = selection.getRangeAt(0);
              const selectionRect = range2.getBoundingClientRect();
              const containerRect = this.containerEl.getBoundingClientRect();
              const targetRect = {
                left: selectionRect.left - containerRect.left + this.containerEl.scrollLeft,
                top: selectionRect.top - containerRect.top + this.containerEl.scrollTop,
                width: selectionRect.width,
                height: selectionRect.height
              };
              this.popover.show(targetRect);
            }
          }
        });
      }
      async loadStyles() {
        try {
          let styles2 = { ...DEFAULT_STYLES };
          const stylesFolder = this.settings.stylesFolder || "snippets";
          const folderPath = `${this.app.vault.configDir}/${stylesFolder}`;
          if (await this.app.vault.adapter.exists(folderPath)) {
            for (const fileName of this.settings.enabledStyles || []) {
              const filePath = `${folderPath}/${fileName}`;
              if (await this.app.vault.adapter.exists(filePath)) {
                try {
                  const content = await this.app.vault.adapter.read(filePath);
                  const userStyles = parseYaml(content);
                  for (const [key, styleDef] of Object.entries(userStyles)) {
                    if (styles2[key] && typeof styles2[key] === "object" && typeof styleDef === "object") {
                      styles2[key] = { ...styles2[key], ...styleDef };
                    } else {
                      styles2[key] = styleDef;
                    }
                  }
                } catch (err) {
                  console.error(`Colophon: Failed to load style file ${fileName}`, err);
                }
              }
            }
          }
          const css = this.styleManager.generateCSS(styles2);
          this.injectStyles(css);
          this.styleOptions = this.styleManager.getStyleOptions(styles2);
          if (this.popover) {
            this.popover.updateStyleOptions(this.styleOptions);
          }
        } catch (e) {
          console.error("Colophon: Failed to load styles", e);
        }
      }
      injectStyles(css) {
        const styleId = "colophon-dynamic-styles";
        let styleEl = document.getElementById(styleId);
        if (!styleEl) {
          styleEl = document.createElement("style");
          styleEl.id = styleId;
          document.head.appendChild(styleEl);
        }
        styleEl.textContent = css;
      }
      handleScroll() {
        if (!this.editor || !this.editor.view.hasFocus()) {
          return;
        }
        const { state: state2 } = this.editor;
        if (!state2.selection.empty) {
          return;
        }
        const view = this.editor.view;
        const pos = state2.selection.from;
        const cursorCoords = view.coordsAtPos(pos);
        const containerRect = this.containerEl.getBoundingClientRect();
        const paddingPercent = this.settings.textColumnBottomPadding || 0;
        const thresholdPercent = 1 - paddingPercent / 100;
        const thresholdY = containerRect.top + containerRect.height * thresholdPercent;
        if (cursorCoords.bottom > thresholdY) {
          const scrollAmount = cursorCoords.bottom - thresholdY;
          this.containerEl.scrollBy({
            top: scrollAmount,
            behavior: "smooth"
          });
        }
      }
      triggerUpdate() {
        if (!this.editor) return;
        const footnotesInDoc = [];
        let index = 1;
        let hasChanges = false;
        this.editor.state.doc.descendants((node, pos) => {
          if (node.type.name === "footnote") {
            const number = String(index++);
            footnotesInDoc.push({
              id: node.attrs.id,
              number,
              pos
            });
            if (node.attrs.number !== number) {
              hasChanges = true;
            }
          }
        });
        const newFootnotesList = footnotesInDoc.map((fn) => {
          const existing = this.footnotes.find((f) => f.id === fn.id);
          return {
            id: fn.id,
            number: fn.number,
            content: existing ? existing.content : ""
          };
        });
        this.footnotes = newFootnotesList;
        if (hasChanges) {
          Promise.resolve().then(() => {
            if (!this.editor || this.editor.isDestroyed) return;
            const tr = this.editor.state.tr;
            let modified = false;
            this.editor.state.doc.descendants((node, pos) => {
              if (node.type.name === "footnote") {
                const targetNumber = footnotesInDoc.find((f) => f.id === node.attrs.id)?.number;
                if (targetNumber && node.attrs.number !== targetNumber) {
                  tr.setNodeMarkup(pos, null, { ...node.attrs, number: targetNumber });
                  modified = true;
                }
              }
            });
            if (modified) {
              this.editor.view.dispatch(tr);
            }
          });
        }
        if (this.onUpdate) {
          this.onUpdate({
            doc: this.editor.getJSON(),
            footnotes: this.footnotes
          });
        }
        this.listeners.forEach((listener) => listener());
      }
      addFootnote() {
        if (this.editor) {
          const id = `fn-${Date.now()}`;
          this.editor.chain().focus().insertContent({
            type: "footnote",
            attrs: { id, number: "#" }
          }).run();
          return id;
        }
      }
      updateFootnote(id, content) {
        const fn = this.footnotes.find((f) => f.id === id);
        if (fn) {
          fn.content = content;
          if (this.onUpdate) {
            this.onUpdate({
              doc: this.editor.getJSON(),
              footnotes: this.footnotes
            });
          }
        }
      }
      getFootnotes() {
        return this.footnotes;
      }
      destroy() {
        if (this.popover) {
          this.popover.destroy();
        }
        if (this.editor) {
          this.editor.destroy();
          this.editor = null;
        }
      }
      focus() {
        if (this.editor) {
          this.editor.commands.focus();
        }
      }
    };
    module2.exports = TiptapAdapter;
  }
});

// src/io.js
var require_io = __commonJS({
  "src/io.js"(exports2, module2) {
    function parseFile(content) {
      let markdown2 = content;
      let frontmatter = "";
      let data = null;
      const fmRegex = /^---\n[\s\S]*?\n---\n/;
      const fmMatch = content.match(fmRegex);
      if (fmMatch) {
        frontmatter = fmMatch[0];
        markdown2 = markdown2.substring(frontmatter.length);
      }
      const sidecarRegex = /%% colophon:data\s*(\{[\s\S]*?\})\s*%%$/;
      const scMatch = markdown2.match(sidecarRegex);
      if (scMatch) {
        try {
          data = JSON.parse(scMatch[1]);
          markdown2 = markdown2.replace(sidecarRegex, "").trimEnd();
        } catch (e) {
          console.error("Colophon: Failed to parse sidecar data", e);
        }
      }
      return { markdown: markdown2, data, frontmatter };
    }
    function serializeFile(markdown2, data, frontmatter = "") {
      let content = frontmatter + markdown2;
      if (data) {
        const json = JSON.stringify(data, null, 2);
        content = `${content.trimEnd()}

%% colophon:data ${json} %%`;
      }
      return content;
    }
    module2.exports = {
      parseFile,
      serializeFile
    };
  }
});

// src/view.js
var require_view2 = __commonJS({
  "src/view.js"(exports2, module2) {
    var { FileView, WorkspaceLeaf: WorkspaceLeaf2, Notice: Notice2, debounce } = require("obsidian");
    var TiptapAdapter = require_tiptap_adapter();
    var { parseFile, serializeFile } = require_io();
    var VIEW_TYPE2 = "colophon-view";
    var ColophonView2 = class extends FileView {
      constructor(leaf, settings, plugin) {
        super(leaf);
        this.plugin = plugin;
        this.settings = settings || { textColumnWidth: 1080 };
        this.adapter = null;
        this.data = null;
        this.markdownBody = "";
        this.frontmatter = "";
        this.themeToggleBtn = null;
        this.loaderEl = null;
        this.isForcedLight = false;
        this.save = debounce(this.save.bind(this), 1e3, true);
      }
      getViewType() {
        return VIEW_TYPE2;
      }
      getDisplayText() {
        return this.file ? this.file.basename : "No File";
      }
      getIcon() {
        return "feather";
      }
      async onOpen() {
        this.contentEl.empty();
        this.contentEl.addClass("colophon-workspace");
        this.applySettings();
        this.themeToggleBtn = this.addAction("sun-moon", "Enable white canvas mode for this note", () => {
          this.toggleTheme();
        });
        this.showLoader();
        const isSpellcheckEnabled = this.app.vault.getConfig("spellcheck");
        this.adapter = new TiptapAdapter(this.app, this.contentEl, isSpellcheckEnabled, this.settings, (newData) => {
          this.data = newData;
          this.save();
        });
        this.registerEvent(this.app.workspace.on("css-change", () => {
          if (this.isForcedLight) {
            this.updateCanvasTheme();
          }
        }));
      }
      onPaneMenu(menu, source) {
        super.onPaneMenu(menu, source);
        menu.addItem((item) => {
          item.setTitle("Export to DOCX").setIcon("document").onClick(async () => {
            this.plugin.exportToDocx(this);
          });
        });
      }
      showLoader() {
        if (this.loaderEl) return;
        this.loaderEl = this.contentEl.createDiv("colophon-loader");
        this.loaderEl.createDiv("colophon-loader-spinner");
        this.loaderEl.createSpan({ text: "Loading Manuscript..." });
      }
      hideLoader() {
        if (this.loaderEl) {
          this.loaderEl.remove();
          this.loaderEl = null;
        }
      }
      toggleTheme() {
        this.isForcedLight = !this.isForcedLight;
        if (this.themeToggleBtn) {
          this.themeToggleBtn.classList.toggle("is-active", this.isForcedLight);
          if (this.isForcedLight) {
            this.themeToggleBtn.setAttribute("aria-label", "Disable white canvas mode for this note");
          } else {
            this.themeToggleBtn.setAttribute("aria-label", "Enable white canvas mode for this note");
          }
        }
        this.updateCanvasTheme();
      }
      updateCanvasTheme() {
        const varsToHandle = [
          "--background-primary",
          "--text-normal",
          "--text-muted",
          "--text-accent",
          "--text-selection",
          "--background-modifier-border"
        ];
        if (this.isForcedLight) {
          const themeVars = this.extractThemeVars("theme-light");
          for (const [key, value] of Object.entries(themeVars)) {
            if (value) {
              this.contentEl.style.setProperty(key, value);
            }
          }
          this.contentEl.classList.add("colophon-forced-theme");
        } else {
          for (const key of varsToHandle) {
            this.contentEl.style.removeProperty(key);
          }
          this.contentEl.classList.remove("colophon-forced-theme");
        }
      }
      extractThemeVars(themeClass) {
        const dummy = document.createElement("div");
        dummy.classList.add(themeClass);
        dummy.style.display = "none";
        document.body.appendChild(dummy);
        const style = window.getComputedStyle(dummy);
        const vars = {
          "--background-primary": style.getPropertyValue("--background-primary").trim(),
          "--text-normal": style.getPropertyValue("--text-normal").trim(),
          "--text-muted": style.getPropertyValue("--text-muted").trim(),
          "--text-accent": style.getPropertyValue("--text-accent").trim(),
          "--text-selection": style.getPropertyValue("--text-selection").trim(),
          "--background-modifier-border": style.getPropertyValue("--background-modifier-border").trim()
        };
        document.body.removeChild(dummy);
        return vars;
      }
      updateSettings(newSettings) {
        this.settings = newSettings;
        this.applySettings();
        if (this.adapter) {
          this.adapter.updateSettings(this.settings);
        }
      }
      applySettings() {
        if (this.contentEl) {
          this.contentEl.style.setProperty("--colophon-editor-width", `${this.settings.textColumnWidth}px`);
        }
      }
      async onClose() {
        if (this.adapter) {
          this.adapter.destroy();
        }
      }
      async onLoadFile(file) {
        if (!this.loaderEl && !this.adapter?.isLoaded) {
          this.showLoader();
        }
        const content = await this.app.vault.read(file);
        const { markdown: markdown2, data, frontmatter } = parseFile(content);
        this.markdownBody = markdown2;
        this.data = data;
        this.frontmatter = frontmatter;
        if (this.adapter) {
          this.adapter.load(markdown2, data, this.file.path);
          this.hideLoader();
        }
      }
      async onUnloadFile(file) {
        if (this.adapter) {
        }
      }
      async save() {
        if (!this.file || !this.data) return;
        const newContent = serializeFile(this.markdownBody, this.data, this.frontmatter);
        await this.app.vault.modify(this.file, newContent);
      }
      async insertFootnote() {
        if (this.adapter) {
          const id = this.adapter.addFootnote();
          if (id) {
            await this.plugin.activateFootnoteView();
            const leaves = this.app.workspace.getLeavesOfType("colophon-footnote-view");
            if (leaves.length > 0) {
              const view = leaves[0].view;
              if (view) {
                view.render();
                setTimeout(() => {
                  view.focusFootnote(id);
                }, 50);
              }
            }
          }
        }
      }
    };
    module2.exports = {
      ColophonView: ColophonView2,
      VIEW_TYPE: VIEW_TYPE2
    };
  }
});

// src/footnote-view.js
var require_footnote_view = __commonJS({
  "src/footnote-view.js"(exports2, module2) {
    var { ItemView, WorkspaceLeaf: WorkspaceLeaf2, Notice: Notice2, setIcon } = require("obsidian");
    var { Editor, mergeAttributes } = require_dist9();
    var { StarterKit } = require_dist30();
    var Underline2 = require_dist24();
    var Subscript = require_dist31();
    var Superscript = require_dist32();
    var TextStyle = require_dist33();
    var PopoverMenu = require_popover_menu();
    var Substitutions = require_substitutions();
    var InternalLink = require_internallink();
    var FOOTNOTE_VIEW_TYPE2 = "colophon-footnote-view";
    var FootnoteView2 = class extends ItemView {
      constructor(leaf, settings, isSpellcheckEnabled) {
        super(leaf);
        this.settings = settings || { smartQuotes: true, smartDashes: true, doubleQuoteStyle: "\u201C|\u201D", singleQuoteStyle: "\u2018|\u2019" };
        this.isSpellcheckEnabled = isSpellcheckEnabled;
        this.adapter = null;
        this.editors = /* @__PURE__ */ new Map();
        this.popover = null;
      }
      getViewType() {
        return FOOTNOTE_VIEW_TYPE2;
      }
      getDisplayText() {
        return "Footnotes";
      }
      getIcon() {
        return "list-ordered";
      }
      async onOpen() {
        const container = this.contentEl;
        container.empty();
        container.addClass("colophon-footnote-view");
        this.popover = new PopoverMenu(null, container);
        this.popover.setMode("footnote");
        this.render();
      }
      async onClose() {
        this.editors.forEach((editor) => editor.destroy());
        this.editors.clear();
        if (this.popover) {
          this.popover.destroy();
        }
        if (this.unsubscribe) {
          this.unsubscribe();
          this.unsubscribe = null;
        }
      }
      updateSettings(newSettings) {
        this.settings = newSettings;
        this.render(true);
      }
      setAdapter(adapter) {
        if (this.unsubscribe) {
          this.unsubscribe();
          this.unsubscribe = null;
        }
        this.adapter = adapter;
        if (this.adapter) {
          this.unsubscribe = this.adapter.subscribe(() => {
            this.render();
          });
        }
        this.render();
      }
      render(force = false) {
        const container = this.contentEl;
        if (!this.adapter) {
          container.empty();
          this.editors.forEach((editor) => editor.destroy());
          this.editors.clear();
          container.createEl("div", {
            text: "No active manuscript.",
            cls: "colophon-footnote-empty"
          });
          return;
        }
        const footnotes = this.adapter.getFootnotes();
        if (!footnotes || footnotes.length === 0) {
          container.empty();
          this.editors.forEach((editor) => editor.destroy());
          this.editors.clear();
          container.createEl("div", {
            text: "No footnotes yet.",
            cls: "colophon-footnote-empty"
          });
          return;
        }
        let list = container.querySelector(".colophon-footnote-list");
        if (!list) {
          container.empty();
          list = container.createEl("div", { cls: "colophon-footnote-list" });
        }
        const activeIds = new Set(footnotes.map((f) => f.id));
        for (const [id, editor] of this.editors) {
          if (!activeIds.has(id) || force) {
            editor.destroy();
            this.editors.delete(id);
            const el = list.querySelector(`[data-footnote-id="${id}"]`);
            if (el) el.remove();
          }
        }
        footnotes.forEach((fn, index) => {
          let item = list.querySelector(`[data-footnote-id="${fn.id}"]`);
          if (!item) {
            item = list.createEl("div", { cls: "colophon-footnote-item" });
            item.dataset.footnoteId = fn.id;
            const header = item.createEl("div", { cls: "colophon-footnote-header" });
            header.createSpan({ text: `${fn.number || index + 1}. `, cls: "colophon-footnote-number" });
            const editorContainer = item.createEl("div", { cls: "colophon-footnote-editor-container" });
            const editor = new Editor({
              element: editorContainer,
              extensions: [
                StarterKit,
                Underline2,
                Subscript,
                Superscript,
                TextStyle,
                Substitutions.configure({
                  smartQuotes: this.settings.smartQuotes,
                  smartDashes: this.settings.smartDashes,
                  doubleQuoteStyle: this.settings.doubleQuoteStyle,
                  singleQuoteStyle: this.settings.singleQuoteStyle
                }),
                InternalLink.configure({
                  app: this.app
                })
              ],
              content: fn.content,
              // Handles string or JSON
              onUpdate: ({ editor: editor2 }) => {
                this.adapter.updateFootnote(fn.id, editor2.getJSON());
              },
              editorProps: {
                attributes: {
                  class: "colophon-footnote-editor-content",
                  spellcheck: this.isSpellcheckEnabled ? "true" : "false"
                }
              }
            });
            editor.view.dom.addEventListener("contextmenu", (e) => {
              const { from, to } = editor.state.selection;
              if (from !== to) {
                e.preventDefault();
                e.stopPropagation();
                this.popover.editor = editor;
                const selection = window.getSelection();
                if (selection.rangeCount > 0) {
                  const range2 = selection.getRangeAt(0);
                  const selectionRect = range2.getBoundingClientRect();
                  const containerRect = this.contentEl.getBoundingClientRect();
                  const targetRect = {
                    left: selectionRect.left - containerRect.left + this.contentEl.scrollLeft,
                    top: selectionRect.top - containerRect.top + this.contentEl.scrollTop,
                    width: selectionRect.width,
                    height: selectionRect.height
                  };
                  this.popover.show(targetRect);
                }
              }
            });
            this.editors.set(fn.id, editor);
          } else {
            const numberSpan = item.querySelector(".colophon-footnote-number");
            if (numberSpan) numberSpan.innerText = `${fn.number || index + 1}. `;
          }
        });
        footnotes.forEach((fn) => {
          const item = list.querySelector(`[data-footnote-id="${fn.id}"]`);
          if (item) list.appendChild(item);
        });
      }
      focusFootnote(id) {
        const editor = this.editors.get(id);
        if (editor) {
          editor.commands.focus();
          const item = this.contentEl.querySelector(`[data-footnote-id="${id}"]`);
          if (item) {
            item.scrollIntoView({ behavior: "smooth", block: "center" });
          }
        }
      }
      getFocusedEditor() {
        for (const editor of this.editors.values()) {
          if (editor.isFocused) {
            return editor;
          }
        }
        return null;
      }
    };
    module2.exports = {
      FootnoteView: FootnoteView2,
      FOOTNOTE_VIEW_TYPE: FOOTNOTE_VIEW_TYPE2
    };
  }
});

// node_modules/.pnpm/docx@9.5.1/node_modules/docx/dist/index.mjs
function getDefaultExportFromCjs$1(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function requireEvents() {
  if (hasRequiredEvents) return events.exports;
  hasRequiredEvents = 1;
  var R = typeof Reflect === "object" ? Reflect : null;
  var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  };
  var ReflectOwnKeys;
  if (R && typeof R.ownKeys === "function") {
    ReflectOwnKeys = R.ownKeys;
  } else if (Object.getOwnPropertySymbols) {
    ReflectOwnKeys = function ReflectOwnKeys2(target) {
      return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
    };
  } else {
    ReflectOwnKeys = function ReflectOwnKeys2(target) {
      return Object.getOwnPropertyNames(target);
    };
  }
  function ProcessEmitWarning(warning) {
    if (console && console.warn) console.warn(warning);
  }
  var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
    return value !== value;
  };
  function EventEmitter() {
    EventEmitter.init.call(this);
  }
  events.exports = EventEmitter;
  events.exports.once = once;
  EventEmitter.EventEmitter = EventEmitter;
  EventEmitter.prototype._events = void 0;
  EventEmitter.prototype._eventsCount = 0;
  EventEmitter.prototype._maxListeners = void 0;
  var defaultMaxListeners = 10;
  function checkListener(listener) {
    if (typeof listener !== "function") {
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
    }
  }
  Object.defineProperty(EventEmitter, "defaultMaxListeners", {
    enumerable: true,
    get: function() {
      return defaultMaxListeners;
    },
    set: function(arg) {
      if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
      }
      defaultMaxListeners = arg;
    }
  });
  EventEmitter.init = function() {
    if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
      this._events = /* @__PURE__ */ Object.create(null);
      this._eventsCount = 0;
    }
    this._maxListeners = this._maxListeners || void 0;
  };
  EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
    if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
    }
    this._maxListeners = n;
    return this;
  };
  function _getMaxListeners(that) {
    if (that._maxListeners === void 0)
      return EventEmitter.defaultMaxListeners;
    return that._maxListeners;
  }
  EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
    return _getMaxListeners(this);
  };
  EventEmitter.prototype.emit = function emit(type2) {
    var args = [];
    for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
    var doError = type2 === "error";
    var events2 = this._events;
    if (events2 !== void 0)
      doError = doError && events2.error === void 0;
    else if (!doError)
      return false;
    if (doError) {
      var er;
      if (args.length > 0)
        er = args[0];
      if (er instanceof Error) {
        throw er;
      }
      var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
      err.context = er;
      throw err;
    }
    var handler = events2[type2];
    if (handler === void 0)
      return false;
    if (typeof handler === "function") {
      ReflectApply(handler, this, args);
    } else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i = 0; i < len; ++i)
        ReflectApply(listeners[i], this, args);
    }
    return true;
  };
  function _addListener(target, type2, listener, prepend) {
    var m;
    var events2;
    var existing;
    checkListener(listener);
    events2 = target._events;
    if (events2 === void 0) {
      events2 = target._events = /* @__PURE__ */ Object.create(null);
      target._eventsCount = 0;
    } else {
      if (events2.newListener !== void 0) {
        target.emit(
          "newListener",
          type2,
          listener.listener ? listener.listener : listener
        );
        events2 = target._events;
      }
      existing = events2[type2];
    }
    if (existing === void 0) {
      existing = events2[type2] = listener;
      ++target._eventsCount;
    } else {
      if (typeof existing === "function") {
        existing = events2[type2] = prepend ? [listener, existing] : [existing, listener];
      } else if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
      m = _getMaxListeners(target);
      if (m > 0 && existing.length > m && !existing.warned) {
        existing.warned = true;
        var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type2) + " listeners added. Use emitter.setMaxListeners() to increase limit");
        w.name = "MaxListenersExceededWarning";
        w.emitter = target;
        w.type = type2;
        w.count = existing.length;
        ProcessEmitWarning(w);
      }
    }
    return target;
  }
  EventEmitter.prototype.addListener = function addListener(type2, listener) {
    return _addListener(this, type2, listener, false);
  };
  EventEmitter.prototype.on = EventEmitter.prototype.addListener;
  EventEmitter.prototype.prependListener = function prependListener(type2, listener) {
    return _addListener(this, type2, listener, true);
  };
  function onceWrapper() {
    if (!this.fired) {
      this.target.removeListener(this.type, this.wrapFn);
      this.fired = true;
      if (arguments.length === 0)
        return this.listener.call(this.target);
      return this.listener.apply(this.target, arguments);
    }
  }
  function _onceWrap(target, type2, listener) {
    var state2 = { fired: false, wrapFn: void 0, target, type: type2, listener };
    var wrapped = onceWrapper.bind(state2);
    wrapped.listener = listener;
    state2.wrapFn = wrapped;
    return wrapped;
  }
  EventEmitter.prototype.once = function once2(type2, listener) {
    checkListener(listener);
    this.on(type2, _onceWrap(this, type2, listener));
    return this;
  };
  EventEmitter.prototype.prependOnceListener = function prependOnceListener(type2, listener) {
    checkListener(listener);
    this.prependListener(type2, _onceWrap(this, type2, listener));
    return this;
  };
  EventEmitter.prototype.removeListener = function removeListener(type2, listener) {
    var list, events2, position, i, originalListener;
    checkListener(listener);
    events2 = this._events;
    if (events2 === void 0)
      return this;
    list = events2[type2];
    if (list === void 0)
      return this;
    if (list === listener || list.listener === listener) {
      if (--this._eventsCount === 0)
        this._events = /* @__PURE__ */ Object.create(null);
      else {
        delete events2[type2];
        if (events2.removeListener)
          this.emit("removeListener", type2, list.listener || listener);
      }
    } else if (typeof list !== "function") {
      position = -1;
      for (i = list.length - 1; i >= 0; i--) {
        if (list[i] === listener || list[i].listener === listener) {
          originalListener = list[i].listener;
          position = i;
          break;
        }
      }
      if (position < 0)
        return this;
      if (position === 0)
        list.shift();
      else {
        spliceOne(list, position);
      }
      if (list.length === 1)
        events2[type2] = list[0];
      if (events2.removeListener !== void 0)
        this.emit("removeListener", type2, originalListener || listener);
    }
    return this;
  };
  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
  EventEmitter.prototype.removeAllListeners = function removeAllListeners(type2) {
    var listeners, events2, i;
    events2 = this._events;
    if (events2 === void 0)
      return this;
    if (events2.removeListener === void 0) {
      if (arguments.length === 0) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      } else if (events2[type2] !== void 0) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else
          delete events2[type2];
      }
      return this;
    }
    if (arguments.length === 0) {
      var keys = Object.keys(events2);
      var key;
      for (i = 0; i < keys.length; ++i) {
        key = keys[i];
        if (key === "removeListener") continue;
        this.removeAllListeners(key);
      }
      this.removeAllListeners("removeListener");
      this._events = /* @__PURE__ */ Object.create(null);
      this._eventsCount = 0;
      return this;
    }
    listeners = events2[type2];
    if (typeof listeners === "function") {
      this.removeListener(type2, listeners);
    } else if (listeners !== void 0) {
      for (i = listeners.length - 1; i >= 0; i--) {
        this.removeListener(type2, listeners[i]);
      }
    }
    return this;
  };
  function _listeners(target, type2, unwrap) {
    var events2 = target._events;
    if (events2 === void 0)
      return [];
    var evlistener = events2[type2];
    if (evlistener === void 0)
      return [];
    if (typeof evlistener === "function")
      return unwrap ? [evlistener.listener || evlistener] : [evlistener];
    return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
  }
  EventEmitter.prototype.listeners = function listeners(type2) {
    return _listeners(this, type2, true);
  };
  EventEmitter.prototype.rawListeners = function rawListeners(type2) {
    return _listeners(this, type2, false);
  };
  EventEmitter.listenerCount = function(emitter, type2) {
    if (typeof emitter.listenerCount === "function") {
      return emitter.listenerCount(type2);
    } else {
      return listenerCount.call(emitter, type2);
    }
  };
  EventEmitter.prototype.listenerCount = listenerCount;
  function listenerCount(type2) {
    var events2 = this._events;
    if (events2 !== void 0) {
      var evlistener = events2[type2];
      if (typeof evlistener === "function") {
        return 1;
      } else if (evlistener !== void 0) {
        return evlistener.length;
      }
    }
    return 0;
  }
  EventEmitter.prototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
  };
  function arrayClone(arr, n) {
    var copy = new Array(n);
    for (var i = 0; i < n; ++i)
      copy[i] = arr[i];
    return copy;
  }
  function spliceOne(list, index) {
    for (; index + 1 < list.length; index++)
      list[index] = list[index + 1];
    list.pop();
  }
  function unwrapListeners(arr) {
    var ret = new Array(arr.length);
    for (var i = 0; i < ret.length; ++i) {
      ret[i] = arr[i].listener || arr[i];
    }
    return ret;
  }
  function once(emitter, name) {
    return new Promise(function(resolve, reject) {
      function errorListener(err) {
        emitter.removeListener(name, resolver);
        reject(err);
      }
      function resolver() {
        if (typeof emitter.removeListener === "function") {
          emitter.removeListener("error", errorListener);
        }
        resolve([].slice.call(arguments));
      }
      eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
      if (name !== "error") {
        addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
      }
    });
  }
  function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
    if (typeof emitter.on === "function") {
      eventTargetAgnosticAddListener(emitter, "error", handler, flags);
    }
  }
  function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
    if (typeof emitter.on === "function") {
      if (flags.once) {
        emitter.once(name, listener);
      } else {
        emitter.on(name, listener);
      }
    } else if (typeof emitter.addEventListener === "function") {
      emitter.addEventListener(name, function wrapListener(arg) {
        if (flags.once) {
          emitter.removeEventListener(name, wrapListener);
        }
        listener(arg);
      });
    } else {
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
    }
  }
  return events.exports;
}
function requireInherits_browser() {
  if (hasRequiredInherits_browser) return inherits_browser.exports;
  hasRequiredInherits_browser = 1;
  if (typeof Object.create === "function") {
    inherits_browser.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    inherits_browser.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
  return inherits_browser.exports;
}
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e2) {
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      return cachedClearTimeout.call(null, marker);
    } catch (e2) {
      return cachedClearTimeout.call(this, marker);
    }
  }
}
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
function noop() {
}
function requireStreamBrowser() {
  if (hasRequiredStreamBrowser) return streamBrowser;
  hasRequiredStreamBrowser = 1;
  streamBrowser = requireEvents().EventEmitter;
  return streamBrowser;
}
function requireBase64Js() {
  if (hasRequiredBase64Js) return base64Js;
  hasRequiredBase64Js = 1;
  base64Js.byteLength = byteLength;
  base64Js.toByteArray = toByteArray;
  base64Js.fromByteArray = fromByteArray;
  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
  function getLens(b64) {
    var len2 = b64.length;
    if (len2 % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    var validLen = b64.indexOf("=");
    if (validLen === -1) validLen = len2;
    var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
    return [validLen, placeHoldersLen];
  }
  function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i2;
    for (i2 = 0; i2 < len2; i2 += 4) {
      tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
      arr[curByte++] = tmp >> 16 & 255;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 2) {
      tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 1) {
      tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    return arr;
  }
  function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
  }
  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for (var i2 = start; i2 < end; i2 += 3) {
      tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
      output.push(tripletToBase64(tmp));
    }
    return output.join("");
  }
  function fromByteArray(uint8) {
    var tmp;
    var len2 = uint8.length;
    var extraBytes = len2 % 3;
    var parts = [];
    var maxChunkLength = 16383;
    for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
      parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
    }
    if (extraBytes === 1) {
      tmp = uint8[len2 - 1];
      parts.push(
        lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
      );
    } else if (extraBytes === 2) {
      tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
      parts.push(
        lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
      );
    }
    return parts.join("");
  }
  return base64Js;
}
function requireIeee754() {
  if (hasRequiredIeee754) return ieee754;
  hasRequiredIeee754 = 1;
  ieee754.read = function(buffer2, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer2[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer2[offset + i], i += d, nBits -= 8) {
    }
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer2[offset + i], i += d, nBits -= 8) {
    }
    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : (s ? -1 : 1) * Infinity;
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  };
  ieee754.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }
      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }
    for (; mLen >= 8; buffer2[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
    }
    e = e << mLen | m;
    eLen += mLen;
    for (; eLen > 0; buffer2[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
    }
    buffer2[offset + i - d] |= s * 128;
  };
  return ieee754;
}
function requireBuffer() {
  if (hasRequiredBuffer) return buffer;
  hasRequiredBuffer = 1;
  (function(exports2) {
    var base64 = requireBase64Js();
    var ieee7542 = requireIeee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports2.Buffer = Buffer2;
    exports2.SlowBuffer = SlowBuffer;
    exports2.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports2.kMaxLength = K_MAX_LENGTH;
    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        var arr = new Uint8Array(1);
        var proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer2.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this)) return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer2.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this)) return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      var buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function Buffer2(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer2.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      var valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer2.from(valueOf, encodingOrOffset, length);
      }
      var b = fromObject(value);
      if (b) return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer2.from(
          value[Symbol.toPrimitive]("string"),
          encodingOrOffset,
          length
        );
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer2.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer2, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer2.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      var length = byteLength(string, encoding) | 0;
      var buf = createBuffer(length);
      var actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      var length = array.length < 0 ? 0 : checked(array.length) | 0;
      var buf = createBuffer(length);
      for (var i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        var copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      var buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer2.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer2.alloc(+length);
    }
    Buffer2.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer2.prototype;
    };
    Buffer2.compare = function compare(a, b) {
      if (isInstance(a, Uint8Array)) a = Buffer2.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array)) b = Buffer2.from(b, b.offset, b.byteLength);
      if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a === b) return 0;
      var x = a.length;
      var y = b.length;
      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      var i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      var buffer2 = Buffer2.allocUnsafe(length);
      var pos = 0;
      for (i = 0; i < list.length; ++i) {
        var buf = list[i];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer2.length) {
            Buffer2.from(buf).copy(buffer2, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer2,
              buf,
              pos
            );
          }
        } else if (!Buffer2.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer2, pos);
        }
        pos += buf.length;
      }
      return buffer2;
    };
    function byteLength(string, encoding) {
      if (Buffer2.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      var len = string.length;
      var mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0) return 0;
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      var loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding) encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.prototype._isBuffer = true;
    function swap(b, n, m) {
      var i = b[n];
      b[n] = b[m];
      b[m] = i;
    }
    Buffer2.prototype.swap16 = function swap16() {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString() {
      var length = this.length;
      if (length === 0) return "";
      if (arguments.length === 0) return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
    Buffer2.prototype.equals = function equals(b) {
      if (!Buffer2.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
      if (this === b) return true;
      return Buffer2.compare(this, b) === 0;
    };
    Buffer2.prototype.inspect = function inspect() {
      var str = "";
      var max2 = exports2.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max2).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max2) str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
    }
    Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer2.from(target, target.offset, target.byteLength);
      }
      if (!Buffer2.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target) return 0;
      var x = thisEnd - thisStart;
      var y = end - start;
      var len = Math.min(x, y);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);
      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
      if (buffer2.length === 0) return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer2.length - 1;
      }
      if (byteOffset < 0) byteOffset = buffer2.length + byteOffset;
      if (byteOffset >= buffer2.length) {
        if (dir) return -1;
        else byteOffset = buffer2.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
      }
      if (typeof val === "string") {
        val = Buffer2.from(val, encoding);
      }
      if (Buffer2.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i2) {
        if (indexSize === 1) {
          return buf[i2];
        } else {
          return buf.readUInt16BE(i2 * indexSize);
        }
      }
      var i;
      if (dir) {
        var foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          var found = true;
          for (var j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break;
            }
          }
          if (found) return i;
        }
      }
      return -1;
    }
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      var remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      var strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      for (var i = 0; i < length; ++i) {
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer2.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0) encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      var remaining = this.length - offset;
      if (length === void 0 || length > remaining) length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding) encoding = "utf8";
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      var res = [];
      var i = start;
      while (i < end) {
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      var len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      var res = "";
      var i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      var len = buf.length;
      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;
      var out = "";
      for (var i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      var bytes = buf.slice(start, end);
      var res = "";
      for (var i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    Buffer2.prototype.slice = function slice(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start) end = start;
      var newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer2.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
      if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      var val = this[offset + --byteLength2];
      var mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      var i = byteLength2;
      var mul = 1;
      var val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128)) return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee7542.read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee7542.read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee7542.read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee7542.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max2, min2) {
      if (!Buffer2.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max2 || value < min2) throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
    }
    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var mul = 1;
      var i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var i = byteLength2 - 1;
      var mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i = byteLength2 - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
      if (value < 0) value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0) value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function checkIEEE754(buf, value, offset, ext, max2, min2) {
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
      if (offset < 0) throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4);
      }
      ieee7542.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8);
      }
      ieee7542.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer2.isBuffer(target)) throw new TypeError("argument should be a Buffer");
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;
      if (end === start) return 0;
      if (target.length === 0 || this.length === 0) return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
      if (end < 0) throw new RangeError("sourceEnd out of bounds");
      if (end > this.length) end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val) val = 0;
      var i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        var bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
        var len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2) return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;
      var bytes = [];
      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0) break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0) break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0) break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0) break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      var c, hi, lo;
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      for (var i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
      }
      return i;
    }
    function isInstance(obj, type2) {
      return obj instanceof type2 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type2.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = (function() {
      var alphabet = "0123456789abcdef";
      var table = new Array(256);
      for (var i = 0; i < 16; ++i) {
        var i16 = i * 16;
        for (var j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j];
        }
      }
      return table;
    })();
  })(buffer);
  return buffer;
}
function requireShams$1() {
  if (hasRequiredShams$1) return shams$1;
  hasRequiredShams$1 = 1;
  shams$1 = function hasSymbols2() {
    if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
      return false;
    }
    if (typeof Symbol.iterator === "symbol") {
      return true;
    }
    var obj = {};
    var sym = Symbol("test");
    var symObj = Object(sym);
    if (typeof sym === "string") {
      return false;
    }
    if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
      return false;
    }
    if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
      return false;
    }
    var symVal = 42;
    obj[sym] = symVal;
    for (var _ in obj) {
      return false;
    }
    if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
      return false;
    }
    if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
      return false;
    }
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) {
      return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
      return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === "function") {
      var descriptor = (
        /** @type {PropertyDescriptor} */
        Object.getOwnPropertyDescriptor(obj, sym)
      );
      if (descriptor.value !== symVal || descriptor.enumerable !== true) {
        return false;
      }
    }
    return true;
  };
  return shams$1;
}
function requireShams() {
  if (hasRequiredShams) return shams;
  hasRequiredShams = 1;
  var hasSymbols2 = requireShams$1();
  shams = function hasToStringTagShams() {
    return hasSymbols2() && !!Symbol.toStringTag;
  };
  return shams;
}
function requireEsObjectAtoms() {
  if (hasRequiredEsObjectAtoms) return esObjectAtoms;
  hasRequiredEsObjectAtoms = 1;
  esObjectAtoms = Object;
  return esObjectAtoms;
}
function requireEsErrors() {
  if (hasRequiredEsErrors) return esErrors;
  hasRequiredEsErrors = 1;
  esErrors = Error;
  return esErrors;
}
function require_eval() {
  if (hasRequired_eval) return _eval;
  hasRequired_eval = 1;
  _eval = EvalError;
  return _eval;
}
function requireRange() {
  if (hasRequiredRange) return range;
  hasRequiredRange = 1;
  range = RangeError;
  return range;
}
function requireRef() {
  if (hasRequiredRef) return ref;
  hasRequiredRef = 1;
  ref = ReferenceError;
  return ref;
}
function requireSyntax() {
  if (hasRequiredSyntax) return syntax;
  hasRequiredSyntax = 1;
  syntax = SyntaxError;
  return syntax;
}
function requireType() {
  if (hasRequiredType) return type;
  hasRequiredType = 1;
  type = TypeError;
  return type;
}
function requireUri() {
  if (hasRequiredUri) return uri;
  hasRequiredUri = 1;
  uri = URIError;
  return uri;
}
function requireAbs() {
  if (hasRequiredAbs) return abs;
  hasRequiredAbs = 1;
  abs = Math.abs;
  return abs;
}
function requireFloor() {
  if (hasRequiredFloor) return floor;
  hasRequiredFloor = 1;
  floor = Math.floor;
  return floor;
}
function requireMax() {
  if (hasRequiredMax) return max;
  hasRequiredMax = 1;
  max = Math.max;
  return max;
}
function requireMin() {
  if (hasRequiredMin) return min;
  hasRequiredMin = 1;
  min = Math.min;
  return min;
}
function requirePow() {
  if (hasRequiredPow) return pow;
  hasRequiredPow = 1;
  pow = Math.pow;
  return pow;
}
function requireRound() {
  if (hasRequiredRound) return round;
  hasRequiredRound = 1;
  round = Math.round;
  return round;
}
function require_isNaN() {
  if (hasRequired_isNaN) return _isNaN;
  hasRequired_isNaN = 1;
  _isNaN = Number.isNaN || function isNaN2(a) {
    return a !== a;
  };
  return _isNaN;
}
function requireSign() {
  if (hasRequiredSign) return sign;
  hasRequiredSign = 1;
  var $isNaN = /* @__PURE__ */ require_isNaN();
  sign = function sign2(number) {
    if ($isNaN(number) || number === 0) {
      return number;
    }
    return number < 0 ? -1 : 1;
  };
  return sign;
}
function requireGOPD() {
  if (hasRequiredGOPD) return gOPD;
  hasRequiredGOPD = 1;
  gOPD = Object.getOwnPropertyDescriptor;
  return gOPD;
}
function requireGopd() {
  if (hasRequiredGopd) return gopd;
  hasRequiredGopd = 1;
  var $gOPD = /* @__PURE__ */ requireGOPD();
  if ($gOPD) {
    try {
      $gOPD([], "length");
    } catch (e) {
      $gOPD = null;
    }
  }
  gopd = $gOPD;
  return gopd;
}
function requireEsDefineProperty() {
  if (hasRequiredEsDefineProperty) return esDefineProperty;
  hasRequiredEsDefineProperty = 1;
  var $defineProperty = Object.defineProperty || false;
  if ($defineProperty) {
    try {
      $defineProperty({}, "a", { value: 1 });
    } catch (e) {
      $defineProperty = false;
    }
  }
  esDefineProperty = $defineProperty;
  return esDefineProperty;
}
function requireHasSymbols() {
  if (hasRequiredHasSymbols) return hasSymbols;
  hasRequiredHasSymbols = 1;
  var origSymbol = typeof Symbol !== "undefined" && Symbol;
  var hasSymbolSham = requireShams$1();
  hasSymbols = function hasNativeSymbols() {
    if (typeof origSymbol !== "function") {
      return false;
    }
    if (typeof Symbol !== "function") {
      return false;
    }
    if (typeof origSymbol("foo") !== "symbol") {
      return false;
    }
    if (typeof Symbol("bar") !== "symbol") {
      return false;
    }
    return hasSymbolSham();
  };
  return hasSymbols;
}
function requireReflect_getPrototypeOf() {
  if (hasRequiredReflect_getPrototypeOf) return Reflect_getPrototypeOf;
  hasRequiredReflect_getPrototypeOf = 1;
  Reflect_getPrototypeOf = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
  return Reflect_getPrototypeOf;
}
function requireObject_getPrototypeOf() {
  if (hasRequiredObject_getPrototypeOf) return Object_getPrototypeOf;
  hasRequiredObject_getPrototypeOf = 1;
  var $Object = /* @__PURE__ */ requireEsObjectAtoms();
  Object_getPrototypeOf = $Object.getPrototypeOf || null;
  return Object_getPrototypeOf;
}
function requireImplementation() {
  if (hasRequiredImplementation) return implementation;
  hasRequiredImplementation = 1;
  var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
  var toStr = Object.prototype.toString;
  var max2 = Math.max;
  var funcType = "[object Function]";
  var concatty = function concatty2(a, b) {
    var arr = [];
    for (var i = 0; i < a.length; i += 1) {
      arr[i] = a[i];
    }
    for (var j = 0; j < b.length; j += 1) {
      arr[j + a.length] = b[j];
    }
    return arr;
  };
  var slicy = function slicy2(arrLike, offset) {
    var arr = [];
    for (var i = offset, j = 0; i < arrLike.length; i += 1, j += 1) {
      arr[j] = arrLike[i];
    }
    return arr;
  };
  var joiny = function(arr, joiner) {
    var str = "";
    for (var i = 0; i < arr.length; i += 1) {
      str += arr[i];
      if (i + 1 < arr.length) {
        str += joiner;
      }
    }
    return str;
  };
  implementation = function bind(that) {
    var target = this;
    if (typeof target !== "function" || toStr.apply(target) !== funcType) {
      throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);
    var bound;
    var binder = function() {
      if (this instanceof bound) {
        var result = target.apply(
          this,
          concatty(args, arguments)
        );
        if (Object(result) === result) {
          return result;
        }
        return this;
      }
      return target.apply(
        that,
        concatty(args, arguments)
      );
    };
    var boundLength = max2(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
      boundArgs[i] = "$" + i;
    }
    bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
    if (target.prototype) {
      var Empty = function Empty2() {
      };
      Empty.prototype = target.prototype;
      bound.prototype = new Empty();
      Empty.prototype = null;
    }
    return bound;
  };
  return implementation;
}
function requireFunctionBind() {
  if (hasRequiredFunctionBind) return functionBind;
  hasRequiredFunctionBind = 1;
  var implementation2 = requireImplementation();
  functionBind = Function.prototype.bind || implementation2;
  return functionBind;
}
function requireFunctionCall() {
  if (hasRequiredFunctionCall) return functionCall;
  hasRequiredFunctionCall = 1;
  functionCall = Function.prototype.call;
  return functionCall;
}
function requireFunctionApply() {
  if (hasRequiredFunctionApply) return functionApply;
  hasRequiredFunctionApply = 1;
  functionApply = Function.prototype.apply;
  return functionApply;
}
function requireReflectApply() {
  if (hasRequiredReflectApply) return reflectApply;
  hasRequiredReflectApply = 1;
  reflectApply = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
  return reflectApply;
}
function requireActualApply() {
  if (hasRequiredActualApply) return actualApply;
  hasRequiredActualApply = 1;
  var bind = requireFunctionBind();
  var $apply = requireFunctionApply();
  var $call = requireFunctionCall();
  var $reflectApply = requireReflectApply();
  actualApply = $reflectApply || bind.call($call, $apply);
  return actualApply;
}
function requireCallBindApplyHelpers() {
  if (hasRequiredCallBindApplyHelpers) return callBindApplyHelpers;
  hasRequiredCallBindApplyHelpers = 1;
  var bind = requireFunctionBind();
  var $TypeError = /* @__PURE__ */ requireType();
  var $call = requireFunctionCall();
  var $actualApply = requireActualApply();
  callBindApplyHelpers = function callBindBasic(args) {
    if (args.length < 1 || typeof args[0] !== "function") {
      throw new $TypeError("a function is required");
    }
    return $actualApply(bind, $call, args);
  };
  return callBindApplyHelpers;
}
function requireGet() {
  if (hasRequiredGet) return get;
  hasRequiredGet = 1;
  var callBind2 = requireCallBindApplyHelpers();
  var gOPD2 = /* @__PURE__ */ requireGopd();
  var hasProtoAccessor;
  try {
    hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
    [].__proto__ === Array.prototype;
  } catch (e) {
    if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
      throw e;
    }
  }
  var desc = !!hasProtoAccessor && gOPD2 && gOPD2(
    Object.prototype,
    /** @type {keyof typeof Object.prototype} */
    "__proto__"
  );
  var $Object = Object;
  var $getPrototypeOf = $Object.getPrototypeOf;
  get = desc && typeof desc.get === "function" ? callBind2([desc.get]) : typeof $getPrototypeOf === "function" ? (
    /** @type {import('./get')} */
    (function getDunder(value) {
      return $getPrototypeOf(value == null ? value : $Object(value));
    })
  ) : false;
  return get;
}
function requireGetProto() {
  if (hasRequiredGetProto) return getProto;
  hasRequiredGetProto = 1;
  var reflectGetProto = requireReflect_getPrototypeOf();
  var originalGetProto = requireObject_getPrototypeOf();
  var getDunderProto = /* @__PURE__ */ requireGet();
  getProto = reflectGetProto ? function getProto2(O) {
    return reflectGetProto(O);
  } : originalGetProto ? function getProto2(O) {
    if (!O || typeof O !== "object" && typeof O !== "function") {
      throw new TypeError("getProto: not an object");
    }
    return originalGetProto(O);
  } : getDunderProto ? function getProto2(O) {
    return getDunderProto(O);
  } : null;
  return getProto;
}
function requireHasown() {
  if (hasRequiredHasown) return hasown;
  hasRequiredHasown = 1;
  var call = Function.prototype.call;
  var $hasOwn = Object.prototype.hasOwnProperty;
  var bind = requireFunctionBind();
  hasown = bind.call(call, $hasOwn);
  return hasown;
}
function requireGetIntrinsic() {
  if (hasRequiredGetIntrinsic) return getIntrinsic;
  hasRequiredGetIntrinsic = 1;
  var undefined$1;
  var $Object = /* @__PURE__ */ requireEsObjectAtoms();
  var $Error = /* @__PURE__ */ requireEsErrors();
  var $EvalError = /* @__PURE__ */ require_eval();
  var $RangeError = /* @__PURE__ */ requireRange();
  var $ReferenceError = /* @__PURE__ */ requireRef();
  var $SyntaxError = /* @__PURE__ */ requireSyntax();
  var $TypeError = /* @__PURE__ */ requireType();
  var $URIError = /* @__PURE__ */ requireUri();
  var abs2 = /* @__PURE__ */ requireAbs();
  var floor2 = /* @__PURE__ */ requireFloor();
  var max2 = /* @__PURE__ */ requireMax();
  var min2 = /* @__PURE__ */ requireMin();
  var pow2 = /* @__PURE__ */ requirePow();
  var round2 = /* @__PURE__ */ requireRound();
  var sign2 = /* @__PURE__ */ requireSign();
  var $Function = Function;
  var getEvalledConstructor = function(expressionSyntax) {
    try {
      return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
    } catch (e) {
    }
  };
  var $gOPD = /* @__PURE__ */ requireGopd();
  var $defineProperty = /* @__PURE__ */ requireEsDefineProperty();
  var throwTypeError = function() {
    throw new $TypeError();
  };
  var ThrowTypeError = $gOPD ? (function() {
    try {
      arguments.callee;
      return throwTypeError;
    } catch (calleeThrows) {
      try {
        return $gOPD(arguments, "callee").get;
      } catch (gOPDthrows) {
        return throwTypeError;
      }
    }
  })() : throwTypeError;
  var hasSymbols2 = requireHasSymbols()();
  var getProto2 = requireGetProto();
  var $ObjectGPO = requireObject_getPrototypeOf();
  var $ReflectGPO = requireReflect_getPrototypeOf();
  var $apply = requireFunctionApply();
  var $call = requireFunctionCall();
  var needsEval = {};
  var TypedArray = typeof Uint8Array === "undefined" || !getProto2 ? undefined$1 : getProto2(Uint8Array);
  var INTRINSICS = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
    "%ArrayIteratorPrototype%": hasSymbols2 && getProto2 ? getProto2([][Symbol.iterator]()) : undefined$1,
    "%AsyncFromSyncIteratorPrototype%": undefined$1,
    "%AsyncFunction%": needsEval,
    "%AsyncGenerator%": needsEval,
    "%AsyncGeneratorFunction%": needsEval,
    "%AsyncIteratorPrototype%": needsEval,
    "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
    "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
    "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": $Error,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": $EvalError,
    "%Float16Array%": typeof Float16Array === "undefined" ? undefined$1 : Float16Array,
    "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
    "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
    "%Function%": $Function,
    "%GeneratorFunction%": needsEval,
    "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
    "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
    "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": hasSymbols2 && getProto2 ? getProto2(getProto2([][Symbol.iterator]())) : undefined$1,
    "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
    "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
    "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols2 || !getProto2 ? undefined$1 : getProto2((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": $Object,
    "%Object.getOwnPropertyDescriptor%": $gOPD,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
    "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
    "%RangeError%": $RangeError,
    "%ReferenceError%": $ReferenceError,
    "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
    "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols2 || !getProto2 ? undefined$1 : getProto2((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": hasSymbols2 && getProto2 ? getProto2(""[Symbol.iterator]()) : undefined$1,
    "%Symbol%": hasSymbols2 ? Symbol : undefined$1,
    "%SyntaxError%": $SyntaxError,
    "%ThrowTypeError%": ThrowTypeError,
    "%TypedArray%": TypedArray,
    "%TypeError%": $TypeError,
    "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
    "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
    "%URIError%": $URIError,
    "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
    "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
    "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet,
    "%Function.prototype.call%": $call,
    "%Function.prototype.apply%": $apply,
    "%Object.defineProperty%": $defineProperty,
    "%Object.getPrototypeOf%": $ObjectGPO,
    "%Math.abs%": abs2,
    "%Math.floor%": floor2,
    "%Math.max%": max2,
    "%Math.min%": min2,
    "%Math.pow%": pow2,
    "%Math.round%": round2,
    "%Math.sign%": sign2,
    "%Reflect.getPrototypeOf%": $ReflectGPO
  };
  if (getProto2) {
    try {
      null.error;
    } catch (e) {
      var errorProto = getProto2(getProto2(e));
      INTRINSICS["%Error.prototype%"] = errorProto;
    }
  }
  var doEval = function doEval2(name) {
    var value;
    if (name === "%AsyncFunction%") {
      value = getEvalledConstructor("async function () {}");
    } else if (name === "%GeneratorFunction%") {
      value = getEvalledConstructor("function* () {}");
    } else if (name === "%AsyncGeneratorFunction%") {
      value = getEvalledConstructor("async function* () {}");
    } else if (name === "%AsyncGenerator%") {
      var fn = doEval2("%AsyncGeneratorFunction%");
      if (fn) {
        value = fn.prototype;
      }
    } else if (name === "%AsyncIteratorPrototype%") {
      var gen = doEval2("%AsyncGenerator%");
      if (gen && getProto2) {
        value = getProto2(gen.prototype);
      }
    }
    INTRINSICS[name] = value;
    return value;
  };
  var LEGACY_ALIASES = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  };
  var bind = requireFunctionBind();
  var hasOwn = /* @__PURE__ */ requireHasown();
  var $concat = bind.call($call, Array.prototype.concat);
  var $spliceApply = bind.call($apply, Array.prototype.splice);
  var $replace = bind.call($call, String.prototype.replace);
  var $strSlice = bind.call($call, String.prototype.slice);
  var $exec = bind.call($call, RegExp.prototype.exec);
  var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = function stringToPath2(string) {
    var first = $strSlice(string, 0, 1);
    var last = $strSlice(string, -1);
    if (first === "%" && last !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
    } else if (last === "%" && first !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
    }
    var result = [];
    $replace(string, rePropName, function(match, number, quote, subString) {
      result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
    });
    return result;
  };
  var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
    var intrinsicName = name;
    var alias;
    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
      alias = LEGACY_ALIASES[intrinsicName];
      intrinsicName = "%" + alias[0] + "%";
    }
    if (hasOwn(INTRINSICS, intrinsicName)) {
      var value = INTRINSICS[intrinsicName];
      if (value === needsEval) {
        value = doEval(intrinsicName);
      }
      if (typeof value === "undefined" && !allowMissing) {
        throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
      }
      return {
        alias,
        name: intrinsicName,
        value
      };
    }
    throw new $SyntaxError("intrinsic " + name + " does not exist!");
  };
  getIntrinsic = function GetIntrinsic(name, allowMissing) {
    if (typeof name !== "string" || name.length === 0) {
      throw new $TypeError("intrinsic name must be a non-empty string");
    }
    if (arguments.length > 1 && typeof allowMissing !== "boolean") {
      throw new $TypeError('"allowMissing" argument must be a boolean');
    }
    if ($exec(/^%?[^%]*%?$/, name) === null) {
      throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    }
    var parts = stringToPath(name);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
    var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value = intrinsic.value;
    var skipFurtherCaching = false;
    var alias = intrinsic.alias;
    if (alias) {
      intrinsicBaseName = alias[0];
      $spliceApply(parts, $concat([0, 1], alias));
    }
    for (var i = 1, isOwn = true; i < parts.length; i += 1) {
      var part = parts[i];
      var first = $strSlice(part, 0, 1);
      var last = $strSlice(part, -1);
      if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
        throw new $SyntaxError("property names with quotes must have matching quotes");
      }
      if (part === "constructor" || !isOwn) {
        skipFurtherCaching = true;
      }
      intrinsicBaseName += "." + part;
      intrinsicRealName = "%" + intrinsicBaseName + "%";
      if (hasOwn(INTRINSICS, intrinsicRealName)) {
        value = INTRINSICS[intrinsicRealName];
      } else if (value != null) {
        if (!(part in value)) {
          if (!allowMissing) {
            throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
          }
          return void 0;
        }
        if ($gOPD && i + 1 >= parts.length) {
          var desc = $gOPD(value, part);
          isOwn = !!desc;
          if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
            value = desc.get;
          } else {
            value = value[part];
          }
        } else {
          isOwn = hasOwn(value, part);
          value = value[part];
        }
        if (isOwn && !skipFurtherCaching) {
          INTRINSICS[intrinsicRealName] = value;
        }
      }
    }
    return value;
  };
  return getIntrinsic;
}
function requireDefineDataProperty() {
  if (hasRequiredDefineDataProperty) return defineDataProperty;
  hasRequiredDefineDataProperty = 1;
  var $defineProperty = /* @__PURE__ */ requireEsDefineProperty();
  var $SyntaxError = /* @__PURE__ */ requireSyntax();
  var $TypeError = /* @__PURE__ */ requireType();
  var gopd2 = /* @__PURE__ */ requireGopd();
  defineDataProperty = function defineDataProperty2(obj, property, value) {
    if (!obj || typeof obj !== "object" && typeof obj !== "function") {
      throw new $TypeError("`obj` must be an object or a function`");
    }
    if (typeof property !== "string" && typeof property !== "symbol") {
      throw new $TypeError("`property` must be a string or a symbol`");
    }
    if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
      throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
    }
    if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
      throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
    }
    if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
      throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
    }
    if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
      throw new $TypeError("`loose`, if provided, must be a boolean");
    }
    var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
    var nonWritable = arguments.length > 4 ? arguments[4] : null;
    var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
    var loose = arguments.length > 6 ? arguments[6] : false;
    var desc = !!gopd2 && gopd2(obj, property);
    if ($defineProperty) {
      $defineProperty(obj, property, {
        configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
        enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
        value,
        writable: nonWritable === null && desc ? desc.writable : !nonWritable
      });
    } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
      obj[property] = value;
    } else {
      throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
    }
  };
  return defineDataProperty;
}
function requireHasPropertyDescriptors() {
  if (hasRequiredHasPropertyDescriptors) return hasPropertyDescriptors_1;
  hasRequiredHasPropertyDescriptors = 1;
  var $defineProperty = /* @__PURE__ */ requireEsDefineProperty();
  var hasPropertyDescriptors = function hasPropertyDescriptors2() {
    return !!$defineProperty;
  };
  hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
    if (!$defineProperty) {
      return null;
    }
    try {
      return $defineProperty([], "length", { value: 1 }).length !== 1;
    } catch (e) {
      return true;
    }
  };
  hasPropertyDescriptors_1 = hasPropertyDescriptors;
  return hasPropertyDescriptors_1;
}
function requireSetFunctionLength() {
  if (hasRequiredSetFunctionLength) return setFunctionLength;
  hasRequiredSetFunctionLength = 1;
  var GetIntrinsic = /* @__PURE__ */ requireGetIntrinsic();
  var define = /* @__PURE__ */ requireDefineDataProperty();
  var hasDescriptors = /* @__PURE__ */ requireHasPropertyDescriptors()();
  var gOPD2 = /* @__PURE__ */ requireGopd();
  var $TypeError = /* @__PURE__ */ requireType();
  var $floor = GetIntrinsic("%Math.floor%");
  setFunctionLength = function setFunctionLength2(fn, length) {
    if (typeof fn !== "function") {
      throw new $TypeError("`fn` is not a function");
    }
    if (typeof length !== "number" || length < 0 || length > 4294967295 || $floor(length) !== length) {
      throw new $TypeError("`length` must be a positive 32-bit integer");
    }
    var loose = arguments.length > 2 && !!arguments[2];
    var functionLengthIsConfigurable = true;
    var functionLengthIsWritable = true;
    if ("length" in fn && gOPD2) {
      var desc = gOPD2(fn, "length");
      if (desc && !desc.configurable) {
        functionLengthIsConfigurable = false;
      }
      if (desc && !desc.writable) {
        functionLengthIsWritable = false;
      }
    }
    if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
      if (hasDescriptors) {
        define(
          /** @type {Parameters<define>[0]} */
          fn,
          "length",
          length,
          true,
          true
        );
      } else {
        define(
          /** @type {Parameters<define>[0]} */
          fn,
          "length",
          length
        );
      }
    }
    return fn;
  };
  return setFunctionLength;
}
function requireCallBind() {
  if (hasRequiredCallBind) return callBind.exports;
  hasRequiredCallBind = 1;
  (function(module2) {
    var bind = requireFunctionBind();
    var GetIntrinsic = /* @__PURE__ */ requireGetIntrinsic();
    var setFunctionLength2 = /* @__PURE__ */ requireSetFunctionLength();
    var $TypeError = /* @__PURE__ */ requireType();
    var $apply = GetIntrinsic("%Function.prototype.apply%");
    var $call = GetIntrinsic("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
    var $defineProperty = /* @__PURE__ */ requireEsDefineProperty();
    var $max = GetIntrinsic("%Math.max%");
    module2.exports = function callBind2(originalFunction) {
      if (typeof originalFunction !== "function") {
        throw new $TypeError("a function is required");
      }
      var func = $reflectApply(bind, $call, arguments);
      return setFunctionLength2(
        func,
        1 + $max(0, originalFunction.length - (arguments.length - 1)),
        true
      );
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(module2.exports, "apply", { value: applyBind });
    } else {
      module2.exports.apply = applyBind;
    }
  })(callBind);
  return callBind.exports;
}
function requireCallBound() {
  if (hasRequiredCallBound) return callBound;
  hasRequiredCallBound = 1;
  var GetIntrinsic = /* @__PURE__ */ requireGetIntrinsic();
  var callBind2 = requireCallBind();
  var $indexOf = callBind2(GetIntrinsic("String.prototype.indexOf"));
  callBound = function callBoundIntrinsic(name, allowMissing) {
    var intrinsic = GetIntrinsic(name, !!allowMissing);
    if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
      return callBind2(intrinsic);
    }
    return intrinsic;
  };
  return callBound;
}
function requireIsArguments() {
  if (hasRequiredIsArguments) return isArguments;
  hasRequiredIsArguments = 1;
  var hasToStringTag = requireShams()();
  var callBound2 = requireCallBound();
  var $toString = callBound2("Object.prototype.toString");
  var isStandardArguments = function isArguments2(value) {
    if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
      return false;
    }
    return $toString(value) === "[object Arguments]";
  };
  var isLegacyArguments = function isArguments2(value) {
    if (isStandardArguments(value)) {
      return true;
    }
    return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && $toString(value.callee) === "[object Function]";
  };
  var supportsStandardArguments = (function() {
    return isStandardArguments(arguments);
  })();
  isStandardArguments.isLegacyArguments = isLegacyArguments;
  isArguments = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
  return isArguments;
}
function requireIsGeneratorFunction() {
  if (hasRequiredIsGeneratorFunction) return isGeneratorFunction;
  hasRequiredIsGeneratorFunction = 1;
  var toStr = Object.prototype.toString;
  var fnToStr = Function.prototype.toString;
  var isFnRegex = /^\s*(?:function)?\*/;
  var hasToStringTag = requireShams()();
  var getProto2 = Object.getPrototypeOf;
  var getGeneratorFunc = function() {
    if (!hasToStringTag) {
      return false;
    }
    try {
      return Function("return function*() {}")();
    } catch (e) {
    }
  };
  var GeneratorFunction;
  isGeneratorFunction = function isGeneratorFunction2(fn) {
    if (typeof fn !== "function") {
      return false;
    }
    if (isFnRegex.test(fnToStr.call(fn))) {
      return true;
    }
    if (!hasToStringTag) {
      var str = toStr.call(fn);
      return str === "[object GeneratorFunction]";
    }
    if (!getProto2) {
      return false;
    }
    if (typeof GeneratorFunction === "undefined") {
      var generatorFunc = getGeneratorFunc();
      GeneratorFunction = generatorFunc ? getProto2(generatorFunc) : false;
    }
    return getProto2(fn) === GeneratorFunction;
  };
  return isGeneratorFunction;
}
function requireIsCallable() {
  if (hasRequiredIsCallable) return isCallable;
  hasRequiredIsCallable = 1;
  var fnToStr = Function.prototype.toString;
  var reflectApply2 = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
  var badArrayLike;
  var isCallableMarker;
  if (typeof reflectApply2 === "function" && typeof Object.defineProperty === "function") {
    try {
      badArrayLike = Object.defineProperty({}, "length", {
        get: function() {
          throw isCallableMarker;
        }
      });
      isCallableMarker = {};
      reflectApply2(function() {
        throw 42;
      }, null, badArrayLike);
    } catch (_) {
      if (_ !== isCallableMarker) {
        reflectApply2 = null;
      }
    }
  } else {
    reflectApply2 = null;
  }
  var constructorRegex = /^\s*class\b/;
  var isES6ClassFn = function isES6ClassFunction(value) {
    try {
      var fnStr = fnToStr.call(value);
      return constructorRegex.test(fnStr);
    } catch (e) {
      return false;
    }
  };
  var tryFunctionObject = function tryFunctionToStr(value) {
    try {
      if (isES6ClassFn(value)) {
        return false;
      }
      fnToStr.call(value);
      return true;
    } catch (e) {
      return false;
    }
  };
  var toStr = Object.prototype.toString;
  var objectClass = "[object Object]";
  var fnClass = "[object Function]";
  var genClass = "[object GeneratorFunction]";
  var ddaClass = "[object HTMLAllCollection]";
  var ddaClass2 = "[object HTML document.all class]";
  var ddaClass3 = "[object HTMLCollection]";
  var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
  var isIE68 = !(0 in [,]);
  var isDDA = function isDocumentDotAll() {
    return false;
  };
  if (typeof document === "object") {
    var all = document.all;
    if (toStr.call(all) === toStr.call(document.all)) {
      isDDA = function isDocumentDotAll(value) {
        if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
          try {
            var str = toStr.call(value);
            return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
          } catch (e) {
          }
        }
        return false;
      };
    }
  }
  isCallable = reflectApply2 ? function isCallable2(value) {
    if (isDDA(value)) {
      return true;
    }
    if (!value) {
      return false;
    }
    if (typeof value !== "function" && typeof value !== "object") {
      return false;
    }
    try {
      reflectApply2(value, null, badArrayLike);
    } catch (e) {
      if (e !== isCallableMarker) {
        return false;
      }
    }
    return !isES6ClassFn(value) && tryFunctionObject(value);
  } : function isCallable2(value) {
    if (isDDA(value)) {
      return true;
    }
    if (!value) {
      return false;
    }
    if (typeof value !== "function" && typeof value !== "object") {
      return false;
    }
    if (hasToStringTag) {
      return tryFunctionObject(value);
    }
    if (isES6ClassFn(value)) {
      return false;
    }
    var strClass = toStr.call(value);
    if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
      return false;
    }
    return tryFunctionObject(value);
  };
  return isCallable;
}
function requireForEach() {
  if (hasRequiredForEach) return forEach_1;
  hasRequiredForEach = 1;
  var isCallable2 = requireIsCallable();
  var toStr = Object.prototype.toString;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var forEachArray = function forEachArray2(array, iterator, receiver) {
    for (var i = 0, len = array.length; i < len; i++) {
      if (hasOwnProperty.call(array, i)) {
        if (receiver == null) {
          iterator(array[i], i, array);
        } else {
          iterator.call(receiver, array[i], i, array);
        }
      }
    }
  };
  var forEachString = function forEachString2(string, iterator, receiver) {
    for (var i = 0, len = string.length; i < len; i++) {
      if (receiver == null) {
        iterator(string.charAt(i), i, string);
      } else {
        iterator.call(receiver, string.charAt(i), i, string);
      }
    }
  };
  var forEachObject = function forEachObject2(object, iterator, receiver) {
    for (var k in object) {
      if (hasOwnProperty.call(object, k)) {
        if (receiver == null) {
          iterator(object[k], k, object);
        } else {
          iterator.call(receiver, object[k], k, object);
        }
      }
    }
  };
  var forEach = function forEach2(list, iterator, thisArg) {
    if (!isCallable2(iterator)) {
      throw new TypeError("iterator must be a function");
    }
    var receiver;
    if (arguments.length >= 3) {
      receiver = thisArg;
    }
    if (toStr.call(list) === "[object Array]") {
      forEachArray(list, iterator, receiver);
    } else if (typeof list === "string") {
      forEachString(list, iterator, receiver);
    } else {
      forEachObject(list, iterator, receiver);
    }
  };
  forEach_1 = forEach;
  return forEach_1;
}
function requirePossibleTypedArrayNames() {
  if (hasRequiredPossibleTypedArrayNames) return possibleTypedArrayNames;
  hasRequiredPossibleTypedArrayNames = 1;
  possibleTypedArrayNames = [
    "Float32Array",
    "Float64Array",
    "Int8Array",
    "Int16Array",
    "Int32Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Uint16Array",
    "Uint32Array",
    "BigInt64Array",
    "BigUint64Array"
  ];
  return possibleTypedArrayNames;
}
function requireAvailableTypedArrays() {
  if (hasRequiredAvailableTypedArrays) return availableTypedArrays;
  hasRequiredAvailableTypedArrays = 1;
  var possibleNames = /* @__PURE__ */ requirePossibleTypedArrayNames();
  var g = typeof globalThis === "undefined" ? commonjsGlobal : globalThis;
  availableTypedArrays = function availableTypedArrays2() {
    var out = [];
    for (var i = 0; i < possibleNames.length; i++) {
      if (typeof g[possibleNames[i]] === "function") {
        out[out.length] = possibleNames[i];
      }
    }
    return out;
  };
  return availableTypedArrays;
}
function requireWhichTypedArray() {
  if (hasRequiredWhichTypedArray) return whichTypedArray;
  hasRequiredWhichTypedArray = 1;
  var forEach = requireForEach();
  var availableTypedArrays2 = /* @__PURE__ */ requireAvailableTypedArrays();
  var callBind2 = requireCallBind();
  var callBound2 = requireCallBound();
  var gOPD2 = /* @__PURE__ */ requireGopd();
  var $toString = callBound2("Object.prototype.toString");
  var hasToStringTag = requireShams()();
  var g = typeof globalThis === "undefined" ? commonjsGlobal : globalThis;
  var typedArrays = availableTypedArrays2();
  var $slice = callBound2("String.prototype.slice");
  var getPrototypeOf = Object.getPrototypeOf;
  var $indexOf = callBound2("Array.prototype.indexOf", true) || function indexOf(array, value) {
    for (var i = 0; i < array.length; i += 1) {
      if (array[i] === value) {
        return i;
      }
    }
    return -1;
  };
  var cache = { __proto__: null };
  if (hasToStringTag && gOPD2 && getPrototypeOf) {
    forEach(typedArrays, function(typedArray) {
      var arr = new g[typedArray]();
      if (Symbol.toStringTag in arr) {
        var proto = getPrototypeOf(arr);
        var descriptor = gOPD2(proto, Symbol.toStringTag);
        if (!descriptor) {
          var superProto = getPrototypeOf(proto);
          descriptor = gOPD2(superProto, Symbol.toStringTag);
        }
        cache["$" + typedArray] = callBind2(descriptor.get);
      }
    });
  } else {
    forEach(typedArrays, function(typedArray) {
      var arr = new g[typedArray]();
      var fn = arr.slice || arr.set;
      if (fn) {
        cache["$" + typedArray] = callBind2(fn);
      }
    });
  }
  var tryTypedArrays = function tryAllTypedArrays(value) {
    var found = false;
    forEach(
      // eslint-disable-next-line no-extra-parens
      /** @type {Record<`\$${TypedArrayName}`, Getter>} */
      /** @type {any} */
      cache,
      /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
      function(getter, typedArray) {
        if (!found) {
          try {
            if ("$" + getter(value) === typedArray) {
              found = $slice(typedArray, 1);
            }
          } catch (e) {
          }
        }
      }
    );
    return found;
  };
  var trySlices = function tryAllSlices(value) {
    var found = false;
    forEach(
      // eslint-disable-next-line no-extra-parens
      /** @type {Record<`\$${TypedArrayName}`, Getter>} */
      /** @type {any} */
      cache,
      /** @type {(getter: typeof cache, name: `\$${import('.').TypedArrayName}`) => void} */
      function(getter, name) {
        if (!found) {
          try {
            getter(value);
            found = $slice(name, 1);
          } catch (e) {
          }
        }
      }
    );
    return found;
  };
  whichTypedArray = function whichTypedArray2(value) {
    if (!value || typeof value !== "object") {
      return false;
    }
    if (!hasToStringTag) {
      var tag = $slice($toString(value), 8, -1);
      if ($indexOf(typedArrays, tag) > -1) {
        return tag;
      }
      if (tag !== "Object") {
        return false;
      }
      return trySlices(value);
    }
    if (!gOPD2) {
      return null;
    }
    return tryTypedArrays(value);
  };
  return whichTypedArray;
}
function requireIsTypedArray() {
  if (hasRequiredIsTypedArray) return isTypedArray;
  hasRequiredIsTypedArray = 1;
  var whichTypedArray2 = /* @__PURE__ */ requireWhichTypedArray();
  isTypedArray = function isTypedArray2(value) {
    return !!whichTypedArray2(value);
  };
  return isTypedArray;
}
function requireTypes() {
  if (hasRequiredTypes) return types;
  hasRequiredTypes = 1;
  (function(exports2) {
    var isArgumentsObject = requireIsArguments();
    var isGeneratorFunction2 = requireIsGeneratorFunction();
    var whichTypedArray2 = /* @__PURE__ */ requireWhichTypedArray();
    var isTypedArray2 = /* @__PURE__ */ requireIsTypedArray();
    function uncurryThis(f) {
      return f.call.bind(f);
    }
    var BigIntSupported = typeof BigInt !== "undefined";
    var SymbolSupported = typeof Symbol !== "undefined";
    var ObjectToString = uncurryThis(Object.prototype.toString);
    var numberValue = uncurryThis(Number.prototype.valueOf);
    var stringValue = uncurryThis(String.prototype.valueOf);
    var booleanValue = uncurryThis(Boolean.prototype.valueOf);
    if (BigIntSupported) {
      var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
    }
    if (SymbolSupported) {
      var symbolValue = uncurryThis(Symbol.prototype.valueOf);
    }
    function checkBoxedPrimitive(value, prototypeValueOf) {
      if (typeof value !== "object") {
        return false;
      }
      try {
        prototypeValueOf(value);
        return true;
      } catch (e) {
        return false;
      }
    }
    exports2.isArgumentsObject = isArgumentsObject;
    exports2.isGeneratorFunction = isGeneratorFunction2;
    exports2.isTypedArray = isTypedArray2;
    function isPromise(input) {
      return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
    }
    exports2.isPromise = isPromise;
    function isArrayBufferView(value) {
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        return ArrayBuffer.isView(value);
      }
      return isTypedArray2(value) || isDataView(value);
    }
    exports2.isArrayBufferView = isArrayBufferView;
    function isUint8Array(value) {
      return whichTypedArray2(value) === "Uint8Array";
    }
    exports2.isUint8Array = isUint8Array;
    function isUint8ClampedArray(value) {
      return whichTypedArray2(value) === "Uint8ClampedArray";
    }
    exports2.isUint8ClampedArray = isUint8ClampedArray;
    function isUint16Array(value) {
      return whichTypedArray2(value) === "Uint16Array";
    }
    exports2.isUint16Array = isUint16Array;
    function isUint32Array(value) {
      return whichTypedArray2(value) === "Uint32Array";
    }
    exports2.isUint32Array = isUint32Array;
    function isInt8Array(value) {
      return whichTypedArray2(value) === "Int8Array";
    }
    exports2.isInt8Array = isInt8Array;
    function isInt16Array(value) {
      return whichTypedArray2(value) === "Int16Array";
    }
    exports2.isInt16Array = isInt16Array;
    function isInt32Array(value) {
      return whichTypedArray2(value) === "Int32Array";
    }
    exports2.isInt32Array = isInt32Array;
    function isFloat32Array(value) {
      return whichTypedArray2(value) === "Float32Array";
    }
    exports2.isFloat32Array = isFloat32Array;
    function isFloat64Array(value) {
      return whichTypedArray2(value) === "Float64Array";
    }
    exports2.isFloat64Array = isFloat64Array;
    function isBigInt64Array(value) {
      return whichTypedArray2(value) === "BigInt64Array";
    }
    exports2.isBigInt64Array = isBigInt64Array;
    function isBigUint64Array(value) {
      return whichTypedArray2(value) === "BigUint64Array";
    }
    exports2.isBigUint64Array = isBigUint64Array;
    function isMapToString(value) {
      return ObjectToString(value) === "[object Map]";
    }
    isMapToString.working = typeof Map !== "undefined" && isMapToString(/* @__PURE__ */ new Map());
    function isMap(value) {
      if (typeof Map === "undefined") {
        return false;
      }
      return isMapToString.working ? isMapToString(value) : value instanceof Map;
    }
    exports2.isMap = isMap;
    function isSetToString(value) {
      return ObjectToString(value) === "[object Set]";
    }
    isSetToString.working = typeof Set !== "undefined" && isSetToString(/* @__PURE__ */ new Set());
    function isSet(value) {
      if (typeof Set === "undefined") {
        return false;
      }
      return isSetToString.working ? isSetToString(value) : value instanceof Set;
    }
    exports2.isSet = isSet;
    function isWeakMapToString(value) {
      return ObjectToString(value) === "[object WeakMap]";
    }
    isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(/* @__PURE__ */ new WeakMap());
    function isWeakMap(value) {
      if (typeof WeakMap === "undefined") {
        return false;
      }
      return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
    }
    exports2.isWeakMap = isWeakMap;
    function isWeakSetToString(value) {
      return ObjectToString(value) === "[object WeakSet]";
    }
    isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(/* @__PURE__ */ new WeakSet());
    function isWeakSet(value) {
      return isWeakSetToString(value);
    }
    exports2.isWeakSet = isWeakSet;
    function isArrayBufferToString(value) {
      return ObjectToString(value) === "[object ArrayBuffer]";
    }
    isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
    function isArrayBuffer(value) {
      if (typeof ArrayBuffer === "undefined") {
        return false;
      }
      return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
    }
    exports2.isArrayBuffer = isArrayBuffer;
    function isDataViewToString(value) {
      return ObjectToString(value) === "[object DataView]";
    }
    isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
    function isDataView(value) {
      if (typeof DataView === "undefined") {
        return false;
      }
      return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
    }
    exports2.isDataView = isDataView;
    var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : void 0;
    function isSharedArrayBufferToString(value) {
      return ObjectToString(value) === "[object SharedArrayBuffer]";
    }
    function isSharedArrayBuffer(value) {
      if (typeof SharedArrayBufferCopy === "undefined") {
        return false;
      }
      if (typeof isSharedArrayBufferToString.working === "undefined") {
        isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
      }
      return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
    }
    exports2.isSharedArrayBuffer = isSharedArrayBuffer;
    function isAsyncFunction(value) {
      return ObjectToString(value) === "[object AsyncFunction]";
    }
    exports2.isAsyncFunction = isAsyncFunction;
    function isMapIterator(value) {
      return ObjectToString(value) === "[object Map Iterator]";
    }
    exports2.isMapIterator = isMapIterator;
    function isSetIterator(value) {
      return ObjectToString(value) === "[object Set Iterator]";
    }
    exports2.isSetIterator = isSetIterator;
    function isGeneratorObject(value) {
      return ObjectToString(value) === "[object Generator]";
    }
    exports2.isGeneratorObject = isGeneratorObject;
    function isWebAssemblyCompiledModule(value) {
      return ObjectToString(value) === "[object WebAssembly.Module]";
    }
    exports2.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
    function isNumberObject(value) {
      return checkBoxedPrimitive(value, numberValue);
    }
    exports2.isNumberObject = isNumberObject;
    function isStringObject(value) {
      return checkBoxedPrimitive(value, stringValue);
    }
    exports2.isStringObject = isStringObject;
    function isBooleanObject(value) {
      return checkBoxedPrimitive(value, booleanValue);
    }
    exports2.isBooleanObject = isBooleanObject;
    function isBigIntObject(value) {
      return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
    }
    exports2.isBigIntObject = isBigIntObject;
    function isSymbolObject(value) {
      return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
    }
    exports2.isSymbolObject = isSymbolObject;
    function isBoxedPrimitive(value) {
      return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
    }
    exports2.isBoxedPrimitive = isBoxedPrimitive;
    function isAnyArrayBuffer(value) {
      return typeof Uint8Array !== "undefined" && (isArrayBuffer(value) || isSharedArrayBuffer(value));
    }
    exports2.isAnyArrayBuffer = isAnyArrayBuffer;
    ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method) {
      Object.defineProperty(exports2, method, {
        enumerable: false,
        value: function() {
          throw new Error(method + " is not supported in userland");
        }
      });
    });
  })(types);
  return types;
}
function requireIsBufferBrowser() {
  if (hasRequiredIsBufferBrowser) return isBufferBrowser;
  hasRequiredIsBufferBrowser = 1;
  isBufferBrowser = function isBuffer(arg) {
    return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
  };
  return isBufferBrowser;
}
function requireUtil() {
  if (hasRequiredUtil) return util;
  hasRequiredUtil = 1;
  (function(exports2) {
    var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
      var keys = Object.keys(obj);
      var descriptors = {};
      for (var i = 0; i < keys.length; i++) {
        descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
      }
      return descriptors;
    };
    var formatRegExp = /%[sdj%]/g;
    exports2.format = function(f) {
      if (!isString(f)) {
        var objects = [];
        for (var i = 0; i < arguments.length; i++) {
          objects.push(inspect(arguments[i]));
        }
        return objects.join(" ");
      }
      var i = 1;
      var args = arguments;
      var len = args.length;
      var str = String(f).replace(formatRegExp, function(x2) {
        if (x2 === "%%") return "%";
        if (i >= len) return x2;
        switch (x2) {
          case "%s":
            return String(args[i++]);
          case "%d":
            return Number(args[i++]);
          case "%j":
            try {
              return JSON.stringify(args[i++]);
            } catch (_) {
              return "[Circular]";
            }
          default:
            return x2;
        }
      });
      for (var x = args[i]; i < len; x = args[++i]) {
        if (isNull(x) || !isObject(x)) {
          str += " " + x;
        } else {
          str += " " + inspect(x);
        }
      }
      return str;
    };
    exports2.deprecate = function(fn, msg) {
      if (typeof process$1 !== "undefined" && process$1.noDeprecation === true) {
        return fn;
      }
      if (typeof process$1 === "undefined") {
        return function() {
          return exports2.deprecate(fn, msg).apply(this, arguments);
        };
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (process$1.throwDeprecation) {
            throw new Error(msg);
          } else if (process$1.traceDeprecation) {
            console.trace(msg);
          } else {
            console.error(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    };
    var debugs = {};
    var debugEnvRegex = /^$/;
    if (process$1.env.NODE_DEBUG) {
      var debugEnv = process$1.env.NODE_DEBUG;
      debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
      debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
    }
    exports2.debuglog = function(set) {
      set = set.toUpperCase();
      if (!debugs[set]) {
        if (debugEnvRegex.test(set)) {
          var pid = process$1.pid;
          debugs[set] = function() {
            var msg = exports2.format.apply(exports2, arguments);
            console.error("%s %d: %s", set, pid, msg);
          };
        } else {
          debugs[set] = function() {
          };
        }
      }
      return debugs[set];
    };
    function inspect(obj, opts) {
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      };
      if (arguments.length >= 3) ctx.depth = arguments[2];
      if (arguments.length >= 4) ctx.colors = arguments[3];
      if (isBoolean(opts)) {
        ctx.showHidden = opts;
      } else if (opts) {
        exports2._extend(ctx, opts);
      }
      if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
      if (isUndefined(ctx.depth)) ctx.depth = 2;
      if (isUndefined(ctx.colors)) ctx.colors = false;
      if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
      if (ctx.colors) ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj, ctx.depth);
    }
    exports2.inspect = inspect;
    inspect.colors = {
      "bold": [1, 22],
      "italic": [3, 23],
      "underline": [4, 24],
      "inverse": [7, 27],
      "white": [37, 39],
      "grey": [90, 39],
      "black": [30, 39],
      "blue": [34, 39],
      "cyan": [36, 39],
      "green": [32, 39],
      "magenta": [35, 39],
      "red": [31, 39],
      "yellow": [33, 39]
    };
    inspect.styles = {
      "special": "cyan",
      "number": "yellow",
      "boolean": "yellow",
      "undefined": "grey",
      "null": "bold",
      "string": "green",
      "date": "magenta",
      // "name": intentionally not styling
      "regexp": "red"
    };
    function stylizeWithColor(str, styleType) {
      var style = inspect.styles[styleType];
      if (style) {
        return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
      } else {
        return str;
      }
    }
    function stylizeNoColor(str, styleType) {
      return str;
    }
    function arrayToHash(array) {
      var hash2 = {};
      array.forEach(function(val, idx) {
        hash2[val] = true;
      });
      return hash2;
    }
    function formatValue(ctx, value, recurseTimes) {
      if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
      value.inspect !== exports2.inspect && // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (!isString(ret)) {
          ret = formatValue(ctx, ret, recurseTimes);
        }
        return ret;
      }
      var primitive = formatPrimitive(ctx, value);
      if (primitive) {
        return primitive;
      }
      var keys = Object.keys(value);
      var visibleKeys = arrayToHash(keys);
      if (ctx.showHidden) {
        keys = Object.getOwnPropertyNames(value);
      }
      if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
        return formatError(value);
      }
      if (keys.length === 0) {
        if (isFunction(value)) {
          var name = value.name ? ": " + value.name : "";
          return ctx.stylize("[Function" + name + "]", "special");
        }
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        }
        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), "date");
        }
        if (isError(value)) {
          return formatError(value);
        }
      }
      var base = "", array = false, braces = ["{", "}"];
      if (isArray(value)) {
        array = true;
        braces = ["[", "]"];
      }
      if (isFunction(value)) {
        var n = value.name ? ": " + value.name : "";
        base = " [Function" + n + "]";
      }
      if (isRegExp(value)) {
        base = " " + RegExp.prototype.toString.call(value);
      }
      if (isDate(value)) {
        base = " " + Date.prototype.toUTCString.call(value);
      }
      if (isError(value)) {
        base = " " + formatError(value);
      }
      if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
      }
      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        } else {
          return ctx.stylize("[Object]", "special");
        }
      }
      ctx.seen.push(value);
      var output;
      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function(key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }
      ctx.seen.pop();
      return reduceToSingleString(output, base, braces);
    }
    function formatPrimitive(ctx, value) {
      if (isUndefined(value))
        return ctx.stylize("undefined", "undefined");
      if (isString(value)) {
        var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return ctx.stylize(simple, "string");
      }
      if (isNumber(value))
        return ctx.stylize("" + value, "number");
      if (isBoolean(value))
        return ctx.stylize("" + value, "boolean");
      if (isNull(value))
        return ctx.stylize("null", "null");
    }
    function formatError(value) {
      return "[" + Error.prototype.toString.call(value) + "]";
    }
    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
      var output = [];
      for (var i = 0, l = value.length; i < l; ++i) {
        if (hasOwnProperty(value, String(i))) {
          output.push(formatProperty(
            ctx,
            value,
            recurseTimes,
            visibleKeys,
            String(i),
            true
          ));
        } else {
          output.push("");
        }
      }
      keys.forEach(function(key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(
            ctx,
            value,
            recurseTimes,
            visibleKeys,
            key,
            true
          ));
        }
      });
      return output;
    }
    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize("[Getter/Setter]", "special");
        } else {
          str = ctx.stylize("[Getter]", "special");
        }
      } else {
        if (desc.set) {
          str = ctx.stylize("[Setter]", "special");
        }
      }
      if (!hasOwnProperty(visibleKeys, key)) {
        name = "[" + key + "]";
      }
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }
          if (str.indexOf("\n") > -1) {
            if (array) {
              str = str.split("\n").map(function(line) {
                return "  " + line;
              }).join("\n").slice(2);
            } else {
              str = "\n" + str.split("\n").map(function(line) {
                return "   " + line;
              }).join("\n");
            }
          }
        } else {
          str = ctx.stylize("[Circular]", "special");
        }
      }
      if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify("" + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.slice(1, -1);
          name = ctx.stylize(name, "name");
        } else {
          name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, "string");
        }
      }
      return name + ": " + str;
    }
    function reduceToSingleString(output, base, braces) {
      var length = output.reduce(function(prev, cur) {
        if (cur.indexOf("\n") >= 0) ;
        return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      if (length > 60) {
        return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
      }
      return braces[0] + base + " " + output.join(", ") + " " + braces[1];
    }
    exports2.types = requireTypes();
    function isArray(ar) {
      return Array.isArray(ar);
    }
    exports2.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports2.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports2.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports2.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports2.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports2.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports2.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports2.isUndefined = isUndefined;
    function isRegExp(re) {
      return isObject(re) && objectToString(re) === "[object RegExp]";
    }
    exports2.isRegExp = isRegExp;
    exports2.types.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports2.isObject = isObject;
    function isDate(d) {
      return isObject(d) && objectToString(d) === "[object Date]";
    }
    exports2.isDate = isDate;
    exports2.types.isDate = isDate;
    function isError(e) {
      return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
    }
    exports2.isError = isError;
    exports2.types.isNativeError = isError;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    exports2.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
      typeof arg === "undefined";
    }
    exports2.isPrimitive = isPrimitive;
    exports2.isBuffer = requireIsBufferBrowser();
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
    function pad(n) {
      return n < 10 ? "0" + n.toString(10) : n.toString(10);
    }
    var months = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function timestamp() {
      var d = /* @__PURE__ */ new Date();
      var time = [
        pad(d.getHours()),
        pad(d.getMinutes()),
        pad(d.getSeconds())
      ].join(":");
      return [d.getDate(), months[d.getMonth()], time].join(" ");
    }
    exports2.log = function() {
      console.log("%s - %s", timestamp(), exports2.format.apply(exports2, arguments));
    };
    exports2.inherits = requireInherits_browser();
    exports2._extend = function(origin, add) {
      if (!add || !isObject(add)) return origin;
      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    };
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
    exports2.promisify = function promisify(original) {
      if (typeof original !== "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
        var fn = original[kCustomPromisifiedSymbol];
        if (typeof fn !== "function") {
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        }
        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
          value: fn,
          enumerable: false,
          writable: false,
          configurable: true
        });
        return fn;
      }
      function fn() {
        var promiseResolve, promiseReject;
        var promise = new Promise(function(resolve, reject) {
          promiseResolve = resolve;
          promiseReject = reject;
        });
        var args = [];
        for (var i = 0; i < arguments.length; i++) {
          args.push(arguments[i]);
        }
        args.push(function(err, value) {
          if (err) {
            promiseReject(err);
          } else {
            promiseResolve(value);
          }
        });
        try {
          original.apply(this, args);
        } catch (err) {
          promiseReject(err);
        }
        return promise;
      }
      Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
      if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
        value: fn,
        enumerable: false,
        writable: false,
        configurable: true
      });
      return Object.defineProperties(
        fn,
        getOwnPropertyDescriptors(original)
      );
    };
    exports2.promisify.custom = kCustomPromisifiedSymbol;
    function callbackifyOnRejected(reason, cb) {
      if (!reason) {
        var newReason = new Error("Promise was rejected with a falsy value");
        newReason.reason = reason;
        reason = newReason;
      }
      return cb(reason);
    }
    function callbackify(original) {
      if (typeof original !== "function") {
        throw new TypeError('The "original" argument must be of type Function');
      }
      function callbackified() {
        var args = [];
        for (var i = 0; i < arguments.length; i++) {
          args.push(arguments[i]);
        }
        var maybeCb = args.pop();
        if (typeof maybeCb !== "function") {
          throw new TypeError("The last argument must be of type Function");
        }
        var self2 = this;
        var cb = function() {
          return maybeCb.apply(self2, arguments);
        };
        original.apply(this, args).then(
          function(ret) {
            process$1.nextTick(cb.bind(null, null, ret));
          },
          function(rej) {
            process$1.nextTick(callbackifyOnRejected.bind(null, rej, cb));
          }
        );
      }
      Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
      Object.defineProperties(
        callbackified,
        getOwnPropertyDescriptors(original)
      );
      return callbackified;
    }
    exports2.callbackify = callbackify;
  })(util);
  return util;
}
function requireBuffer_list() {
  if (hasRequiredBuffer_list) return buffer_list;
  hasRequiredBuffer_list = 1;
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    return Constructor;
  }
  var _require = requireBuffer(), Buffer2 = _require.Buffer;
  var _require2 = requireUtil(), inspect = _require2.inspect;
  var custom = inspect && inspect.custom || "inspect";
  function copyBuffer(src, target, offset) {
    Buffer2.prototype.copy.call(src, target, offset);
  }
  buffer_list = /* @__PURE__ */ (function() {
    function BufferList() {
      _classCallCheck(this, BufferList);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    _createClass(BufferList, [{
      key: "push",
      value: function push(v) {
        var entry = {
          data: v,
          next: null
        };
        if (this.length > 0) this.tail.next = entry;
        else this.head = entry;
        this.tail = entry;
        ++this.length;
      }
    }, {
      key: "unshift",
      value: function unshift(v) {
        var entry = {
          data: v,
          next: this.head
        };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
      }
    }, {
      key: "shift",
      value: function shift() {
        if (this.length === 0) return;
        var ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        --this.length;
        return ret;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
    }, {
      key: "join",
      value: function join(s) {
        if (this.length === 0) return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) {
          ret += s + p.data;
        }
        return ret;
      }
    }, {
      key: "concat",
      value: function concat(n) {
        if (this.length === 0) return Buffer2.alloc(0);
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function consume(n, hasStrings) {
        var ret;
        if (n < this.head.data.length) {
          ret = this.head.data.slice(0, n);
          this.head.data = this.head.data.slice(n);
        } else if (n === this.head.data.length) {
          ret = this.shift();
        } else {
          ret = hasStrings ? this._getString(n) : this._getBuffer(n);
        }
        return ret;
      }
    }, {
      key: "first",
      value: function first() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function _getString(n) {
        var p = this.head;
        var c = 1;
        var ret = p.data;
        n -= ret.length;
        while (p = p.next) {
          var str = p.data;
          var nb = n > str.length ? str.length : n;
          if (nb === str.length) ret += str;
          else ret += str.slice(0, n);
          n -= nb;
          if (n === 0) {
            if (nb === str.length) {
              ++c;
              if (p.next) this.head = p.next;
              else this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = str.slice(nb);
            }
            break;
          }
          ++c;
        }
        this.length -= c;
        return ret;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function _getBuffer(n) {
        var ret = Buffer2.allocUnsafe(n);
        var p = this.head;
        var c = 1;
        p.data.copy(ret);
        n -= p.data.length;
        while (p = p.next) {
          var buf = p.data;
          var nb = n > buf.length ? buf.length : n;
          buf.copy(ret, ret.length - n, 0, nb);
          n -= nb;
          if (n === 0) {
            if (nb === buf.length) {
              ++c;
              if (p.next) this.head = p.next;
              else this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = buf.slice(nb);
            }
            break;
          }
          ++c;
        }
        this.length -= c;
        return ret;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: custom,
      value: function value(_, options) {
        return inspect(this, _objectSpread({}, options, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: false
        }));
      }
    }]);
    return BufferList;
  })();
  return buffer_list;
}
function requireDestroy() {
  if (hasRequiredDestroy) return destroy_1;
  hasRequiredDestroy = 1;
  function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err) {
        if (!this._writableState) {
          process$1.nextTick(emitErrorNT, this, err);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          process$1.nextTick(emitErrorNT, this, err);
        }
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err2) {
      if (!cb && err2) {
        if (!_this._writableState) {
          process$1.nextTick(emitErrorAndCloseNT, _this, err2);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          process$1.nextTick(emitErrorAndCloseNT, _this, err2);
        } else {
          process$1.nextTick(emitCloseNT, _this);
        }
      } else if (cb) {
        process$1.nextTick(emitCloseNT, _this);
        cb(err2);
      } else {
        process$1.nextTick(emitCloseNT, _this);
      }
    });
    return this;
  }
  function emitErrorAndCloseNT(self2, err) {
    emitErrorNT(self2, err);
    emitCloseNT(self2);
  }
  function emitCloseNT(self2) {
    if (self2._writableState && !self2._writableState.emitClose) return;
    if (self2._readableState && !self2._readableState.emitClose) return;
    self2.emit("close");
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err) {
    self2.emit("error", err);
  }
  function errorOrDestroy(stream, err) {
    var rState = stream._readableState;
    var wState = stream._writableState;
    if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);
    else stream.emit("error", err);
  }
  destroy_1 = {
    destroy,
    undestroy,
    errorOrDestroy
  };
  return destroy_1;
}
function requireErrorsBrowser() {
  if (hasRequiredErrorsBrowser) return errorsBrowser;
  hasRequiredErrorsBrowser = 1;
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }
  var codes = {};
  function createErrorType(code, message, Base) {
    if (!Base) {
      Base = Error;
    }
    function getMessage(arg1, arg2, arg3) {
      if (typeof message === "string") {
        return message;
      } else {
        return message(arg1, arg2, arg3);
      }
    }
    var NodeError = /* @__PURE__ */ (function(_Base) {
      _inheritsLoose(NodeError2, _Base);
      function NodeError2(arg1, arg2, arg3) {
        return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
      }
      return NodeError2;
    })(Base);
    NodeError.prototype.name = Base.name;
    NodeError.prototype.code = code;
    codes[code] = NodeError;
  }
  function oneOf(expected, thing) {
    if (Array.isArray(expected)) {
      var len = expected.length;
      expected = expected.map(function(i) {
        return String(i);
      });
      if (len > 2) {
        return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
      } else if (len === 2) {
        return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
      } else {
        return "of ".concat(thing, " ").concat(expected[0]);
      }
    } else {
      return "of ".concat(thing, " ").concat(String(expected));
    }
  }
  function startsWith(str, search, pos) {
    return str.substr(0, search.length) === search;
  }
  function endsWith(str, search, this_len) {
    if (this_len === void 0 || this_len > str.length) {
      this_len = str.length;
    }
    return str.substring(this_len - search.length, this_len) === search;
  }
  function includes(str, search, start) {
    if (typeof start !== "number") {
      start = 0;
    }
    if (start + search.length > str.length) {
      return false;
    } else {
      return str.indexOf(search, start) !== -1;
    }
  }
  createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
    return 'The value "' + value + '" is invalid for option "' + name + '"';
  }, TypeError);
  createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
    var determiner;
    if (typeof expected === "string" && startsWith(expected, "not ")) {
      determiner = "must not be";
      expected = expected.replace(/^not /, "");
    } else {
      determiner = "must be";
    }
    var msg;
    if (endsWith(name, " argument")) {
      msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
    } else {
      var type2 = includes(name, ".") ? "property" : "argument";
      msg = 'The "'.concat(name, '" ').concat(type2, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
    }
    msg += ". Received type ".concat(typeof actual);
    return msg;
  }, TypeError);
  createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
  createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
    return "The " + name + " method is not implemented";
  });
  createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
  createErrorType("ERR_STREAM_DESTROYED", function(name) {
    return "Cannot call " + name + " after a stream was destroyed";
  });
  createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
  createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
  createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
  createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
  createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
    return "Unknown encoding: " + arg;
  }, TypeError);
  createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
  errorsBrowser.codes = codes;
  return errorsBrowser;
}
function requireState() {
  if (hasRequiredState) return state;
  hasRequiredState = 1;
  var ERR_INVALID_OPT_VALUE = requireErrorsBrowser().codes.ERR_INVALID_OPT_VALUE;
  function highWaterMarkFrom(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
  }
  function getHighWaterMark(state2, options, duplexKey, isDuplex) {
    var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
    if (hwm != null) {
      if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
        var name = isDuplex ? duplexKey : "highWaterMark";
        throw new ERR_INVALID_OPT_VALUE(name, hwm);
      }
      return Math.floor(hwm);
    }
    return state2.objectMode ? 16 : 16 * 1024;
  }
  state = {
    getHighWaterMark
  };
  return state;
}
function requireBrowser() {
  if (hasRequiredBrowser) return browser;
  hasRequiredBrowser = 1;
  browser = deprecate;
  function deprecate(fn, msg) {
    if (config("noDeprecation")) {
      return fn;
    }
    var warned = false;
    function deprecated() {
      if (!warned) {
        if (config("throwDeprecation")) {
          throw new Error(msg);
        } else if (config("traceDeprecation")) {
          console.trace(msg);
        } else {
          console.warn(msg);
        }
        warned = true;
      }
      return fn.apply(this, arguments);
    }
    return deprecated;
  }
  function config(name) {
    try {
      if (!commonjsGlobal.localStorage) return false;
    } catch (_) {
      return false;
    }
    var val = commonjsGlobal.localStorage[name];
    if (null == val) return false;
    return String(val).toLowerCase() === "true";
  }
  return browser;
}
function require_stream_writable() {
  if (hasRequired_stream_writable) return _stream_writable;
  hasRequired_stream_writable = 1;
  _stream_writable = Writable;
  function CorkedRequest(state2) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state2);
    };
  }
  var Duplex;
  Writable.WritableState = WritableState;
  var internalUtil = {
    deprecate: requireBrowser()
  };
  var Stream = requireStreamBrowser();
  var Buffer2 = requireBuffer().Buffer;
  var OurUint8Array = commonjsGlobal.Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = requireDestroy();
  var _require = requireState(), getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = requireErrorsBrowser().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  requireInherits_browser()(Writable, Stream);
  function nop() {
  }
  function WritableState(options, stream, isDuplex) {
    Duplex = Duplex || require_stream_duplex();
    options = options || {};
    if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function writableStateBufferGetter() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch (_) {
    }
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function value(object) {
        if (realHasInstance.call(this, object)) return true;
        if (this !== Writable) return false;
        return object && object._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function realHasInstance2(object) {
      return object instanceof this;
    };
  }
  function Writable(options) {
    Duplex = Duplex || require_stream_duplex();
    var isDuplex = this instanceof Duplex;
    if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
    this._writableState = new WritableState(options, this, isDuplex);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function") this._write = options.write;
      if (typeof options.writev === "function") this._writev = options.writev;
      if (typeof options.destroy === "function") this._destroy = options.destroy;
      if (typeof options.final === "function") this._final = options.final;
    }
    Stream.call(this);
  }
  Writable.prototype.pipe = function() {
    errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
  };
  function writeAfterEnd(stream, cb) {
    var er = new ERR_STREAM_WRITE_AFTER_END();
    errorOrDestroy(stream, er);
    process$1.nextTick(cb, er);
  }
  function validChunk(stream, state2, chunk, cb) {
    var er;
    if (chunk === null) {
      er = new ERR_STREAM_NULL_VALUES();
    } else if (typeof chunk !== "string" && !state2.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
    }
    if (er) {
      errorOrDestroy(stream, er);
      process$1.nextTick(cb, er);
      return false;
    }
    return true;
  }
  Writable.prototype.write = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    var ret = false;
    var isBuf = !state2.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf) encoding = "buffer";
    else if (!encoding) encoding = state2.defaultEncoding;
    if (typeof cb !== "function") cb = nop;
    if (state2.ending) writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state2, chunk, cb)) {
      state2.pendingcb++;
      ret = writeOrBuffer(this, state2, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable.prototype.cork = function() {
    this._writableState.corked++;
  };
  Writable.prototype.uncork = function() {
    var state2 = this._writableState;
    if (state2.corked) {
      state2.corked--;
      if (!state2.writing && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) clearBuffer(this, state2);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string") encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function decodeChunk(state2, chunk, encoding) {
    if (!state2.objectMode && state2.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream, state2, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state2, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len = state2.objectMode ? 1 : chunk.length;
    state2.length += len;
    var ret = state2.length < state2.highWaterMark;
    if (!ret) state2.needDrain = true;
    if (state2.writing || state2.corked) {
      var last = state2.lastBufferedRequest;
      state2.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state2.lastBufferedRequest;
      } else {
        state2.bufferedRequest = state2.lastBufferedRequest;
      }
      state2.bufferedRequestCount += 1;
    } else {
      doWrite(stream, state2, false, len, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream, state2, writev, len, chunk, encoding, cb) {
    state2.writelen = len;
    state2.writecb = cb;
    state2.writing = true;
    state2.sync = true;
    if (state2.destroyed) state2.onwrite(new ERR_STREAM_DESTROYED("write"));
    else if (writev) stream._writev(chunk, state2.onwrite);
    else stream._write(chunk, encoding, state2.onwrite);
    state2.sync = false;
  }
  function onwriteError(stream, state2, sync, er, cb) {
    --state2.pendingcb;
    if (sync) {
      process$1.nextTick(cb, er);
      process$1.nextTick(finishMaybe, stream, state2);
      stream._writableState.errorEmitted = true;
      errorOrDestroy(stream, er);
    } else {
      cb(er);
      stream._writableState.errorEmitted = true;
      errorOrDestroy(stream, er);
      finishMaybe(stream, state2);
    }
  }
  function onwriteStateUpdate(state2) {
    state2.writing = false;
    state2.writecb = null;
    state2.length -= state2.writelen;
    state2.writelen = 0;
  }
  function onwrite(stream, er) {
    var state2 = stream._writableState;
    var sync = state2.sync;
    var cb = state2.writecb;
    if (typeof cb !== "function") throw new ERR_MULTIPLE_CALLBACK();
    onwriteStateUpdate(state2);
    if (er) onwriteError(stream, state2, sync, er, cb);
    else {
      var finished = needFinish(state2) || stream.destroyed;
      if (!finished && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) {
        clearBuffer(stream, state2);
      }
      if (sync) {
        process$1.nextTick(afterWrite, stream, state2, finished, cb);
      } else {
        afterWrite(stream, state2, finished, cb);
      }
    }
  }
  function afterWrite(stream, state2, finished, cb) {
    if (!finished) onwriteDrain(stream, state2);
    state2.pendingcb--;
    cb();
    finishMaybe(stream, state2);
  }
  function onwriteDrain(stream, state2) {
    if (state2.length === 0 && state2.needDrain) {
      state2.needDrain = false;
      stream.emit("drain");
    }
  }
  function clearBuffer(stream, state2) {
    state2.bufferProcessing = true;
    var entry = state2.bufferedRequest;
    if (stream._writev && entry && entry.next) {
      var l = state2.bufferedRequestCount;
      var buffer2 = new Array(l);
      var holder = state2.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer2[count] = entry;
        if (!entry.isBuf) allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer2.allBuffers = allBuffers;
      doWrite(stream, state2, true, state2.length, buffer2, "", holder.finish);
      state2.pendingcb++;
      state2.lastBufferedRequest = null;
      if (holder.next) {
        state2.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state2.corkedRequestsFree = new CorkedRequest(state2);
      }
      state2.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state2.objectMode ? 1 : chunk.length;
        doWrite(stream, state2, false, len, chunk, encoding, cb);
        entry = entry.next;
        state2.bufferedRequestCount--;
        if (state2.writing) {
          break;
        }
      }
      if (entry === null) state2.lastBufferedRequest = null;
    }
    state2.bufferedRequest = entry;
    state2.bufferProcessing = false;
  }
  Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
    if (state2.corked) {
      state2.corked = 1;
      this.uncork();
    }
    if (!state2.ending) endWritable(this, state2, cb);
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState.length;
    }
  });
  function needFinish(state2) {
    return state2.ending && state2.length === 0 && state2.bufferedRequest === null && !state2.finished && !state2.writing;
  }
  function callFinal(stream, state2) {
    stream._final(function(err) {
      state2.pendingcb--;
      if (err) {
        errorOrDestroy(stream, err);
      }
      state2.prefinished = true;
      stream.emit("prefinish");
      finishMaybe(stream, state2);
    });
  }
  function prefinish(stream, state2) {
    if (!state2.prefinished && !state2.finalCalled) {
      if (typeof stream._final === "function" && !state2.destroyed) {
        state2.pendingcb++;
        state2.finalCalled = true;
        process$1.nextTick(callFinal, stream, state2);
      } else {
        state2.prefinished = true;
        stream.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream, state2) {
    var need = needFinish(state2);
    if (need) {
      prefinish(stream, state2);
      if (state2.pendingcb === 0) {
        state2.finished = true;
        stream.emit("finish");
        if (state2.autoDestroy) {
          var rState = stream._readableState;
          if (!rState || rState.autoDestroy && rState.endEmitted) {
            stream.destroy();
          }
        }
      }
    }
    return need;
  }
  function endWritable(stream, state2, cb) {
    state2.ending = true;
    finishMaybe(stream, state2);
    if (cb) {
      if (state2.finished) process$1.nextTick(cb);
      else stream.once("finish", cb);
    }
    state2.ended = true;
    stream.writable = false;
  }
  function onCorkedFinish(corkReq, state2, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state2.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    state2.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      if (this._writableState === void 0) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function set(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable.prototype.destroy = destroyImpl.destroy;
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err, cb) {
    cb(err);
  };
  return _stream_writable;
}
function require_stream_duplex() {
  if (hasRequired_stream_duplex) return _stream_duplex;
  hasRequired_stream_duplex = 1;
  var objectKeys = Object.keys || function(obj) {
    var keys2 = [];
    for (var key in obj) {
      keys2.push(key);
    }
    return keys2;
  };
  _stream_duplex = Duplex;
  var Readable = require_stream_readable();
  var Writable = require_stream_writable();
  requireInherits_browser()(Duplex, Readable);
  {
    var keys = objectKeys(Writable.prototype);
    for (var v = 0; v < keys.length; v++) {
      var method = keys[v];
      if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
    }
  }
  function Duplex(options) {
    if (!(this instanceof Duplex)) return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    this.allowHalfOpen = true;
    if (options) {
      if (options.readable === false) this.readable = false;
      if (options.writable === false) this.writable = false;
      if (options.allowHalfOpen === false) {
        this.allowHalfOpen = false;
        this.once("end", onend);
      }
    }
  }
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState.highWaterMark;
    }
  });
  Object.defineProperty(Duplex.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  Object.defineProperty(Duplex.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState.length;
    }
  });
  function onend() {
    if (this._writableState.ended) return;
    process$1.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function set(value) {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  return _stream_duplex;
}
function requireSafeBuffer() {
  if (hasRequiredSafeBuffer) return safeBuffer.exports;
  hasRequiredSafeBuffer = 1;
  (function(module2, exports2) {
    var buffer2 = requireBuffer();
    var Buffer2 = buffer2.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer2;
    } else {
      copyProps(buffer2, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer2.SlowBuffer(size);
    };
  })(safeBuffer, safeBuffer.exports);
  return safeBuffer.exports;
}
function requireString_decoder() {
  if (hasRequiredString_decoder) return string_decoder;
  hasRequiredString_decoder = 1;
  var Buffer2 = requireSafeBuffer().Buffer;
  var isEncoding = Buffer2.isEncoding || function(encoding) {
    encoding = "" + encoding;
    switch (encoding && encoding.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  function _normalizeEncoding(enc) {
    if (!enc) return "utf8";
    var retried;
    while (true) {
      switch (enc) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return enc;
        default:
          if (retried) return;
          enc = ("" + enc).toLowerCase();
          retried = true;
      }
    }
  }
  function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
  }
  string_decoder.StringDecoder = StringDecoder;
  function StringDecoder(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch (this.encoding) {
      case "utf16le":
        this.text = utf16Text;
        this.end = utf16End;
        nb = 4;
        break;
      case "utf8":
        this.fillLast = utf8FillLast;
        nb = 4;
        break;
      case "base64":
        this.text = base64Text;
        this.end = base64End;
        nb = 3;
        break;
      default:
        this.write = simpleWrite;
        this.end = simpleEnd;
        return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer2.allocUnsafe(nb);
  }
  StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0) return "";
    var r;
    var i;
    if (this.lastNeed) {
      r = this.fillLast(buf);
      if (r === void 0) return "";
      i = this.lastNeed;
      this.lastNeed = 0;
    } else {
      i = 0;
    }
    if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || "";
  };
  StringDecoder.prototype.end = utf8End;
  StringDecoder.prototype.text = utf8Text;
  StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
  };
  function utf8CheckByte(byte) {
    if (byte <= 127) return 0;
    else if (byte >> 5 === 6) return 2;
    else if (byte >> 4 === 14) return 3;
    else if (byte >> 3 === 30) return 4;
    return byte >> 6 === 2 ? -1 : -2;
  }
  function utf8CheckIncomplete(self2, buf, i) {
    var j = buf.length - 1;
    if (j < i) return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) self2.lastNeed = nb - 1;
      return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) self2.lastNeed = nb - 2;
      return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) {
        if (nb === 2) nb = 0;
        else self2.lastNeed = nb - 3;
      }
      return nb;
    }
    return 0;
  }
  function utf8CheckExtraBytes(self2, buf, p) {
    if ((buf[0] & 192) !== 128) {
      self2.lastNeed = 0;
      return "\uFFFD";
    }
    if (self2.lastNeed > 1 && buf.length > 1) {
      if ((buf[1] & 192) !== 128) {
        self2.lastNeed = 1;
        return "\uFFFD";
      }
      if (self2.lastNeed > 2 && buf.length > 2) {
        if ((buf[2] & 192) !== 128) {
          self2.lastNeed = 2;
          return "\uFFFD";
        }
      }
    }
  }
  function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf);
    if (r !== void 0) return r;
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, p, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
  }
  function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed) return buf.toString("utf8", i);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i, end);
  }
  function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + "\uFFFD";
    return r;
  }
  function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
      var r = buf.toString("utf16le", i);
      if (r) {
        var c = r.charCodeAt(r.length - 1);
        if (c >= 55296 && c <= 56319) {
          this.lastNeed = 2;
          this.lastTotal = 4;
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
          return r.slice(0, -1);
        }
      }
      return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i, buf.length - 1);
  }
  function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
      var end = this.lastTotal - this.lastNeed;
      return r + this.lastChar.toString("utf16le", 0, end);
    }
    return r;
  }
  function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0) return buf.toString("base64", i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
      this.lastChar[0] = buf[buf.length - 1];
    } else {
      this.lastChar[0] = buf[buf.length - 2];
      this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n);
  }
  function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r;
  }
  function simpleWrite(buf) {
    return buf.toString(this.encoding);
  }
  function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
  }
  return string_decoder;
}
function requireEndOfStream() {
  if (hasRequiredEndOfStream) return endOfStream;
  hasRequiredEndOfStream = 1;
  var ERR_STREAM_PREMATURE_CLOSE = requireErrorsBrowser().codes.ERR_STREAM_PREMATURE_CLOSE;
  function once(callback) {
    var called = false;
    return function() {
      if (called) return;
      called = true;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      callback.apply(this, args);
    };
  }
  function noop2() {
  }
  function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  }
  function eos(stream, opts, callback) {
    if (typeof opts === "function") return eos(stream, null, opts);
    if (!opts) opts = {};
    callback = once(callback || noop2);
    var readable = opts.readable || opts.readable !== false && stream.readable;
    var writable = opts.writable || opts.writable !== false && stream.writable;
    var onlegacyfinish = function onlegacyfinish2() {
      if (!stream.writable) onfinish();
    };
    var writableEnded = stream._writableState && stream._writableState.finished;
    var onfinish = function onfinish2() {
      writable = false;
      writableEnded = true;
      if (!readable) callback.call(stream);
    };
    var readableEnded = stream._readableState && stream._readableState.endEmitted;
    var onend = function onend2() {
      readable = false;
      readableEnded = true;
      if (!writable) callback.call(stream);
    };
    var onerror = function onerror2(err) {
      callback.call(stream, err);
    };
    var onclose = function onclose2() {
      var err;
      if (readable && !readableEnded) {
        if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
        return callback.call(stream, err);
      }
      if (writable && !writableEnded) {
        if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
        return callback.call(stream, err);
      }
    };
    var onrequest = function onrequest2() {
      stream.req.on("finish", onfinish);
    };
    if (isRequest(stream)) {
      stream.on("complete", onfinish);
      stream.on("abort", onclose);
      if (stream.req) onrequest();
      else stream.on("request", onrequest);
    } else if (writable && !stream._writableState) {
      stream.on("end", onlegacyfinish);
      stream.on("close", onlegacyfinish);
    }
    stream.on("end", onend);
    stream.on("finish", onfinish);
    if (opts.error !== false) stream.on("error", onerror);
    stream.on("close", onclose);
    return function() {
      stream.removeListener("complete", onfinish);
      stream.removeListener("abort", onclose);
      stream.removeListener("request", onrequest);
      if (stream.req) stream.req.removeListener("finish", onfinish);
      stream.removeListener("end", onlegacyfinish);
      stream.removeListener("close", onlegacyfinish);
      stream.removeListener("finish", onfinish);
      stream.removeListener("end", onend);
      stream.removeListener("error", onerror);
      stream.removeListener("close", onclose);
    };
  }
  endOfStream = eos;
  return endOfStream;
}
function requireAsync_iterator() {
  if (hasRequiredAsync_iterator) return async_iterator;
  hasRequiredAsync_iterator = 1;
  var _Object$setPrototypeO;
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var finished = requireEndOfStream();
  var kLastResolve = Symbol("lastResolve");
  var kLastReject = Symbol("lastReject");
  var kError = Symbol("error");
  var kEnded = Symbol("ended");
  var kLastPromise = Symbol("lastPromise");
  var kHandlePromise = Symbol("handlePromise");
  var kStream = Symbol("stream");
  function createIterResult(value, done) {
    return {
      value,
      done
    };
  }
  function readAndResolve(iter) {
    var resolve = iter[kLastResolve];
    if (resolve !== null) {
      var data = iter[kStream].read();
      if (data !== null) {
        iter[kLastPromise] = null;
        iter[kLastResolve] = null;
        iter[kLastReject] = null;
        resolve(createIterResult(data, false));
      }
    }
  }
  function onReadable(iter) {
    process$1.nextTick(readAndResolve, iter);
  }
  function wrapForNext(lastPromise, iter) {
    return function(resolve, reject) {
      lastPromise.then(function() {
        if (iter[kEnded]) {
          resolve(createIterResult(void 0, true));
          return;
        }
        iter[kHandlePromise](resolve, reject);
      }, reject);
    };
  }
  var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
  });
  var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream() {
      return this[kStream];
    },
    next: function next() {
      var _this = this;
      var error = this[kError];
      if (error !== null) {
        return Promise.reject(error);
      }
      if (this[kEnded]) {
        return Promise.resolve(createIterResult(void 0, true));
      }
      if (this[kStream].destroyed) {
        return new Promise(function(resolve, reject) {
          process$1.nextTick(function() {
            if (_this[kError]) {
              reject(_this[kError]);
            } else {
              resolve(createIterResult(void 0, true));
            }
          });
        });
      }
      var lastPromise = this[kLastPromise];
      var promise;
      if (lastPromise) {
        promise = new Promise(wrapForNext(lastPromise, this));
      } else {
        var data = this[kStream].read();
        if (data !== null) {
          return Promise.resolve(createIterResult(data, false));
        }
        promise = new Promise(this[kHandlePromise]);
      }
      this[kLastPromise] = promise;
      return promise;
    }
  }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
    return this;
  }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
    var _this2 = this;
    return new Promise(function(resolve, reject) {
      _this2[kStream].destroy(null, function(err) {
        if (err) {
          reject(err);
          return;
        }
        resolve(createIterResult(void 0, true));
      });
    });
  }), _Object$setPrototypeO), AsyncIteratorPrototype);
  var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
    var _Object$create;
    var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
      value: stream,
      writable: true
    }), _defineProperty(_Object$create, kLastResolve, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kLastReject, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kError, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kEnded, {
      value: stream._readableState.endEmitted,
      writable: true
    }), _defineProperty(_Object$create, kHandlePromise, {
      value: function value(resolve, reject) {
        var data = iterator[kStream].read();
        if (data) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(data, false));
        } else {
          iterator[kLastResolve] = resolve;
          iterator[kLastReject] = reject;
        }
      },
      writable: true
    }), _Object$create));
    iterator[kLastPromise] = null;
    finished(stream, function(err) {
      if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var reject = iterator[kLastReject];
        if (reject !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          reject(err);
        }
        iterator[kError] = err;
        return;
      }
      var resolve = iterator[kLastResolve];
      if (resolve !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(void 0, true));
      }
      iterator[kEnded] = true;
    });
    stream.on("readable", onReadable.bind(null, iterator));
    return iterator;
  };
  async_iterator = createReadableStreamAsyncIterator;
  return async_iterator;
}
function requireFromBrowser() {
  if (hasRequiredFromBrowser) return fromBrowser;
  hasRequiredFromBrowser = 1;
  fromBrowser = function() {
    throw new Error("Readable.from is not available in the browser");
  };
  return fromBrowser;
}
function require_stream_readable() {
  if (hasRequired_stream_readable) return _stream_readable;
  hasRequired_stream_readable = 1;
  _stream_readable = Readable;
  var Duplex;
  Readable.ReadableState = ReadableState;
  requireEvents().EventEmitter;
  var EElistenerCount = function EElistenerCount2(emitter, type2) {
    return emitter.listeners(type2).length;
  };
  var Stream = requireStreamBrowser();
  var Buffer2 = requireBuffer().Buffer;
  var OurUint8Array = commonjsGlobal.Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var debugUtil = requireUtil();
  var debug;
  if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog("stream");
  } else {
    debug = function debug2() {
    };
  }
  var BufferList = requireBuffer_list();
  var destroyImpl = requireDestroy();
  var _require = requireState(), getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = requireErrorsBrowser().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
  var StringDecoder;
  var createReadableStreamAsyncIterator;
  var from;
  requireInherits_browser()(Readable, Stream);
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);
    else emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options, stream, isDuplex) {
    Duplex = Duplex || require_stream_duplex();
    options = options || {};
    if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.paused = true;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder) StringDecoder = requireString_decoder().StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable(options) {
    Duplex = Duplex || require_stream_duplex();
    if (!(this instanceof Readable)) return new Readable(options);
    var isDuplex = this instanceof Duplex;
    this._readableState = new ReadableState(options, this, isDuplex);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function") this._read = options.read;
      if (typeof options.destroy === "function") this._destroy = options.destroy;
    }
    Stream.call(this);
  }
  Object.defineProperty(Readable.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      if (this._readableState === void 0) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function set(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable.prototype.destroy = destroyImpl.destroy;
  Readable.prototype._undestroy = destroyImpl.undestroy;
  Readable.prototype._destroy = function(err, cb) {
    cb(err);
  };
  Readable.prototype.push = function(chunk, encoding) {
    var state2 = this._readableState;
    var skipChunkCheck;
    if (!state2.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state2.defaultEncoding;
        if (encoding !== state2.encoding) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    debug("readableAddChunk", chunk);
    var state2 = stream._readableState;
    if (chunk === null) {
      state2.reading = false;
      onEofChunk(stream, state2);
    } else {
      var er;
      if (!skipChunkCheck) er = chunkInvalid(state2, chunk);
      if (er) {
        errorOrDestroy(stream, er);
      } else if (state2.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state2.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state2.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
          else addChunk(stream, state2, chunk, true);
        } else if (state2.ended) {
          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state2.destroyed) {
          return false;
        } else {
          state2.reading = false;
          if (state2.decoder && !encoding) {
            chunk = state2.decoder.write(chunk);
            if (state2.objectMode || chunk.length !== 0) addChunk(stream, state2, chunk, false);
            else maybeReadMore(stream, state2);
          } else {
            addChunk(stream, state2, chunk, false);
          }
        }
      } else if (!addToFront) {
        state2.reading = false;
        maybeReadMore(stream, state2);
      }
    }
    return !state2.ended && (state2.length < state2.highWaterMark || state2.length === 0);
  }
  function addChunk(stream, state2, chunk, addToFront) {
    if (state2.flowing && state2.length === 0 && !state2.sync) {
      state2.awaitDrain = 0;
      stream.emit("data", chunk);
    } else {
      state2.length += state2.objectMode ? 1 : chunk.length;
      if (addToFront) state2.buffer.unshift(chunk);
      else state2.buffer.push(chunk);
      if (state2.needReadable) emitReadable(stream);
    }
    maybeReadMore(stream, state2);
  }
  function chunkInvalid(state2, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
    }
    return er;
  }
  Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable.prototype.setEncoding = function(enc) {
    if (!StringDecoder) StringDecoder = requireString_decoder().StringDecoder;
    var decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder;
    this._readableState.encoding = this._readableState.decoder.encoding;
    var p = this._readableState.buffer.head;
    var content = "";
    while (p !== null) {
      content += decoder.write(p.data);
      p = p.next;
    }
    this._readableState.buffer.clear();
    if (content !== "") this._readableState.buffer.push(content);
    this._readableState.length = content.length;
    return this;
  };
  var MAX_HWM = 1073741824;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state2) {
    if (n <= 0 || state2.length === 0 && state2.ended) return 0;
    if (state2.objectMode) return 1;
    if (n !== n) {
      if (state2.flowing && state2.length) return state2.buffer.head.data.length;
      else return state2.length;
    }
    if (n > state2.highWaterMark) state2.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state2.length) return n;
    if (!state2.ended) {
      state2.needReadable = true;
      return 0;
    }
    return state2.length;
  }
  Readable.prototype.read = function(n) {
    debug("read", n);
    n = parseInt(n, 10);
    var state2 = this._readableState;
    var nOrig = n;
    if (n !== 0) state2.emittedReadable = false;
    if (n === 0 && state2.needReadable && ((state2.highWaterMark !== 0 ? state2.length >= state2.highWaterMark : state2.length > 0) || state2.ended)) {
      debug("read: emitReadable", state2.length, state2.ended);
      if (state2.length === 0 && state2.ended) endReadable(this);
      else emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state2);
    if (n === 0 && state2.ended) {
      if (state2.length === 0) endReadable(this);
      return null;
    }
    var doRead = state2.needReadable;
    debug("need readable", doRead);
    if (state2.length === 0 || state2.length - n < state2.highWaterMark) {
      doRead = true;
      debug("length less than watermark", doRead);
    }
    if (state2.ended || state2.reading) {
      doRead = false;
      debug("reading or ended", doRead);
    } else if (doRead) {
      debug("do read");
      state2.reading = true;
      state2.sync = true;
      if (state2.length === 0) state2.needReadable = true;
      this._read(state2.highWaterMark);
      state2.sync = false;
      if (!state2.reading) n = howMuchToRead(nOrig, state2);
    }
    var ret;
    if (n > 0) ret = fromList(n, state2);
    else ret = null;
    if (ret === null) {
      state2.needReadable = state2.length <= state2.highWaterMark;
      n = 0;
    } else {
      state2.length -= n;
      state2.awaitDrain = 0;
    }
    if (state2.length === 0) {
      if (!state2.ended) state2.needReadable = true;
      if (nOrig !== n && state2.ended) endReadable(this);
    }
    if (ret !== null) this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream, state2) {
    debug("onEofChunk");
    if (state2.ended) return;
    if (state2.decoder) {
      var chunk = state2.decoder.end();
      if (chunk && chunk.length) {
        state2.buffer.push(chunk);
        state2.length += state2.objectMode ? 1 : chunk.length;
      }
    }
    state2.ended = true;
    if (state2.sync) {
      emitReadable(stream);
    } else {
      state2.needReadable = false;
      if (!state2.emittedReadable) {
        state2.emittedReadable = true;
        emitReadable_(stream);
      }
    }
  }
  function emitReadable(stream) {
    var state2 = stream._readableState;
    debug("emitReadable", state2.needReadable, state2.emittedReadable);
    state2.needReadable = false;
    if (!state2.emittedReadable) {
      debug("emitReadable", state2.flowing);
      state2.emittedReadable = true;
      process$1.nextTick(emitReadable_, stream);
    }
  }
  function emitReadable_(stream) {
    var state2 = stream._readableState;
    debug("emitReadable_", state2.destroyed, state2.length, state2.ended);
    if (!state2.destroyed && (state2.length || state2.ended)) {
      stream.emit("readable");
      state2.emittedReadable = false;
    }
    state2.needReadable = !state2.flowing && !state2.ended && state2.length <= state2.highWaterMark;
    flow(stream);
  }
  function maybeReadMore(stream, state2) {
    if (!state2.readingMore) {
      state2.readingMore = true;
      process$1.nextTick(maybeReadMore_, stream, state2);
    }
  }
  function maybeReadMore_(stream, state2) {
    while (!state2.reading && !state2.ended && (state2.length < state2.highWaterMark || state2.flowing && state2.length === 0)) {
      var len = state2.length;
      debug("maybeReadMore read 0");
      stream.read(0);
      if (len === state2.length)
        break;
    }
    state2.readingMore = false;
  }
  Readable.prototype._read = function(n) {
    errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
  };
  Readable.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state2 = this._readableState;
    switch (state2.pipesCount) {
      case 0:
        state2.pipes = dest;
        break;
      case 1:
        state2.pipes = [state2.pipes, dest];
        break;
      default:
        state2.pipes.push(dest);
        break;
    }
    state2.pipesCount += 1;
    debug("pipe count=%d opts=%j", state2.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process$1.stdout && dest !== process$1.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state2.endEmitted) process$1.nextTick(endFn);
    else src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
      debug("onunpipe");
      if (readable === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src.removeListener("end", onend);
      src.removeListener("end", unpipe);
      src.removeListener("data", ondata);
      cleanedUp = true;
      if (state2.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    }
    src.on("data", ondata);
    function ondata(chunk) {
      debug("ondata");
      var ret = dest.write(chunk);
      debug("dest.write", ret);
      if (ret === false) {
        if ((state2.pipesCount === 1 && state2.pipes === dest || state2.pipesCount > 1 && indexOf(state2.pipes, dest) !== -1) && !cleanedUp) {
          debug("false write response, pause", state2.awaitDrain);
          state2.awaitDrain++;
        }
        src.pause();
      }
    }
    function onerror(er) {
      debug("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0) errorOrDestroy(dest, er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug("unpipe");
      src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (!state2.flowing) {
      debug("pipe resume");
      src.resume();
    }
    return dest;
  };
  function pipeOnDrain(src) {
    return function pipeOnDrainFunctionResult() {
      var state2 = src._readableState;
      debug("pipeOnDrain", state2.awaitDrain);
      if (state2.awaitDrain) state2.awaitDrain--;
      if (state2.awaitDrain === 0 && EElistenerCount(src, "data")) {
        state2.flowing = true;
        flow(src);
      }
    };
  }
  Readable.prototype.unpipe = function(dest) {
    var state2 = this._readableState;
    var unpipeInfo = {
      hasUnpiped: false
    };
    if (state2.pipesCount === 0) return this;
    if (state2.pipesCount === 1) {
      if (dest && dest !== state2.pipes) return this;
      if (!dest) dest = state2.pipes;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      if (dest) dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state2.pipes;
      var len = state2.pipesCount;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      for (var i = 0; i < len; i++) {
        dests[i].emit("unpipe", this, {
          hasUnpiped: false
        });
      }
      return this;
    }
    var index = indexOf(state2.pipes, dest);
    if (index === -1) return this;
    state2.pipes.splice(index, 1);
    state2.pipesCount -= 1;
    if (state2.pipesCount === 1) state2.pipes = state2.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable.prototype.on = function(ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    var state2 = this._readableState;
    if (ev === "data") {
      state2.readableListening = this.listenerCount("readable") > 0;
      if (state2.flowing !== false) this.resume();
    } else if (ev === "readable") {
      if (!state2.endEmitted && !state2.readableListening) {
        state2.readableListening = state2.needReadable = true;
        state2.flowing = false;
        state2.emittedReadable = false;
        debug("on readable", state2.length, state2.reading);
        if (state2.length) {
          emitReadable(this);
        } else if (!state2.reading) {
          process$1.nextTick(nReadingNextTick, this);
        }
      }
    }
    return res;
  };
  Readable.prototype.addListener = Readable.prototype.on;
  Readable.prototype.removeListener = function(ev, fn) {
    var res = Stream.prototype.removeListener.call(this, ev, fn);
    if (ev === "readable") {
      process$1.nextTick(updateReadableListening, this);
    }
    return res;
  };
  Readable.prototype.removeAllListeners = function(ev) {
    var res = Stream.prototype.removeAllListeners.apply(this, arguments);
    if (ev === "readable" || ev === void 0) {
      process$1.nextTick(updateReadableListening, this);
    }
    return res;
  };
  function updateReadableListening(self2) {
    var state2 = self2._readableState;
    state2.readableListening = self2.listenerCount("readable") > 0;
    if (state2.resumeScheduled && !state2.paused) {
      state2.flowing = true;
    } else if (self2.listenerCount("data") > 0) {
      self2.resume();
    }
  }
  function nReadingNextTick(self2) {
    debug("readable nexttick read 0");
    self2.read(0);
  }
  Readable.prototype.resume = function() {
    var state2 = this._readableState;
    if (!state2.flowing) {
      debug("resume");
      state2.flowing = !state2.readableListening;
      resume(this, state2);
    }
    state2.paused = false;
    return this;
  };
  function resume(stream, state2) {
    if (!state2.resumeScheduled) {
      state2.resumeScheduled = true;
      process$1.nextTick(resume_, stream, state2);
    }
  }
  function resume_(stream, state2) {
    debug("resume", state2.reading);
    if (!state2.reading) {
      stream.read(0);
    }
    state2.resumeScheduled = false;
    stream.emit("resume");
    flow(stream);
    if (state2.flowing && !state2.reading) stream.read(0);
  }
  Readable.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    this._readableState.paused = true;
    return this;
  };
  function flow(stream) {
    var state2 = stream._readableState;
    debug("flow", state2.flowing);
    while (state2.flowing && stream.read() !== null) {
    }
  }
  Readable.prototype.wrap = function(stream) {
    var _this = this;
    var state2 = this._readableState;
    var paused = false;
    stream.on("end", function() {
      debug("wrapped end");
      if (state2.decoder && !state2.ended) {
        var chunk = state2.decoder.end();
        if (chunk && chunk.length) _this.push(chunk);
      }
      _this.push(null);
    });
    stream.on("data", function(chunk) {
      debug("wrapped data");
      if (state2.decoder) chunk = state2.decoder.write(chunk);
      if (state2.objectMode && (chunk === null || chunk === void 0)) return;
      else if (!state2.objectMode && (!chunk || !chunk.length)) return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream.pause();
      }
    });
    for (var i in stream) {
      if (this[i] === void 0 && typeof stream[i] === "function") {
        this[i] = /* @__PURE__ */ (function methodWrap(method) {
          return function methodWrapReturnFunction() {
            return stream[method].apply(stream, arguments);
          };
        })(i);
      }
    }
    for (var n = 0; n < kProxyEvents.length; n++) {
      stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    this._read = function(n2) {
      debug("wrapped _read", n2);
      if (paused) {
        paused = false;
        stream.resume();
      }
    };
    return this;
  };
  if (typeof Symbol === "function") {
    Readable.prototype[Symbol.asyncIterator] = function() {
      if (createReadableStreamAsyncIterator === void 0) {
        createReadableStreamAsyncIterator = requireAsync_iterator();
      }
      return createReadableStreamAsyncIterator(this);
    };
  }
  Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._readableState.highWaterMark;
    }
  });
  Object.defineProperty(Readable.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._readableState && this._readableState.buffer;
    }
  });
  Object.defineProperty(Readable.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._readableState.flowing;
    },
    set: function set(state2) {
      if (this._readableState) {
        this._readableState.flowing = state2;
      }
    }
  });
  Readable._fromList = fromList;
  Object.defineProperty(Readable.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._readableState.length;
    }
  });
  function fromList(n, state2) {
    if (state2.length === 0) return null;
    var ret;
    if (state2.objectMode) ret = state2.buffer.shift();
    else if (!n || n >= state2.length) {
      if (state2.decoder) ret = state2.buffer.join("");
      else if (state2.buffer.length === 1) ret = state2.buffer.first();
      else ret = state2.buffer.concat(state2.length);
      state2.buffer.clear();
    } else {
      ret = state2.buffer.consume(n, state2.decoder);
    }
    return ret;
  }
  function endReadable(stream) {
    var state2 = stream._readableState;
    debug("endReadable", state2.endEmitted);
    if (!state2.endEmitted) {
      state2.ended = true;
      process$1.nextTick(endReadableNT, state2, stream);
    }
  }
  function endReadableNT(state2, stream) {
    debug("endReadableNT", state2.endEmitted, state2.length);
    if (!state2.endEmitted && state2.length === 0) {
      state2.endEmitted = true;
      stream.readable = false;
      stream.emit("end");
      if (state2.autoDestroy) {
        var wState = stream._writableState;
        if (!wState || wState.autoDestroy && wState.finished) {
          stream.destroy();
        }
      }
    }
  }
  if (typeof Symbol === "function") {
    Readable.from = function(iterable, opts) {
      if (from === void 0) {
        from = requireFromBrowser();
      }
      return from(Readable, iterable, opts);
    };
  }
  function indexOf(xs, x) {
    for (var i = 0, l = xs.length; i < l; i++) {
      if (xs[i] === x) return i;
    }
    return -1;
  }
  return _stream_readable;
}
function require_stream_transform() {
  if (hasRequired_stream_transform) return _stream_transform;
  hasRequired_stream_transform = 1;
  _stream_transform = Transform;
  var _require$codes = requireErrorsBrowser().codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
  var Duplex = require_stream_duplex();
  requireInherits_browser()(Transform, Duplex);
  function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (cb === null) {
      return this.emit("error", new ERR_MULTIPLE_CALLBACK());
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null)
      this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  function Transform(options) {
    if (!(this instanceof Transform)) return new Transform(options);
    Duplex.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function") this._transform = options.transform;
      if (typeof options.flush === "function") this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function" && !this._readableState.destroyed) {
      this._flush(function(er, data) {
        done(_this, er, data);
      });
    } else {
      done(this, null, null);
    }
  }
  Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };
  Transform.prototype._transform = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
  };
  Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
    }
  };
  Transform.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform.prototype._destroy = function(err, cb) {
    Duplex.prototype._destroy.call(this, err, function(err2) {
      cb(err2);
    });
  };
  function done(stream, er, data) {
    if (er) return stream.emit("error", er);
    if (data != null)
      stream.push(data);
    if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
    if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
    return stream.push(null);
  }
  return _stream_transform;
}
function require_stream_passthrough() {
  if (hasRequired_stream_passthrough) return _stream_passthrough;
  hasRequired_stream_passthrough = 1;
  _stream_passthrough = PassThrough;
  var Transform = require_stream_transform();
  requireInherits_browser()(PassThrough, Transform);
  function PassThrough(options) {
    if (!(this instanceof PassThrough)) return new PassThrough(options);
    Transform.call(this, options);
  }
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
  return _stream_passthrough;
}
function requirePipeline() {
  if (hasRequiredPipeline) return pipeline_1;
  hasRequiredPipeline = 1;
  var eos;
  function once(callback) {
    var called = false;
    return function() {
      if (called) return;
      called = true;
      callback.apply(void 0, arguments);
    };
  }
  var _require$codes = requireErrorsBrowser().codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
  function noop2(err) {
    if (err) throw err;
  }
  function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  }
  function destroyer(stream, reading, writing, callback) {
    callback = once(callback);
    var closed = false;
    stream.on("close", function() {
      closed = true;
    });
    if (eos === void 0) eos = requireEndOfStream();
    eos(stream, {
      readable: reading,
      writable: writing
    }, function(err) {
      if (err) return callback(err);
      closed = true;
      callback();
    });
    var destroyed = false;
    return function(err) {
      if (closed) return;
      if (destroyed) return;
      destroyed = true;
      if (isRequest(stream)) return stream.abort();
      if (typeof stream.destroy === "function") return stream.destroy();
      callback(err || new ERR_STREAM_DESTROYED("pipe"));
    };
  }
  function call(fn) {
    fn();
  }
  function pipe(from, to) {
    return from.pipe(to);
  }
  function popCallback(streams) {
    if (!streams.length) return noop2;
    if (typeof streams[streams.length - 1] !== "function") return noop2;
    return streams.pop();
  }
  function pipeline() {
    for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
      streams[_key] = arguments[_key];
    }
    var callback = popCallback(streams);
    if (Array.isArray(streams[0])) streams = streams[0];
    if (streams.length < 2) {
      throw new ERR_MISSING_ARGS("streams");
    }
    var error;
    var destroys = streams.map(function(stream, i) {
      var reading = i < streams.length - 1;
      var writing = i > 0;
      return destroyer(stream, reading, writing, function(err) {
        if (!error) error = err;
        if (err) destroys.forEach(call);
        if (reading) return;
        destroys.forEach(call);
        callback(error);
      });
    });
    return streams.reduce(pipe);
  }
  pipeline_1 = pipeline;
  return pipeline_1;
}
function requireStreamBrowserify() {
  if (hasRequiredStreamBrowserify) return streamBrowserify;
  hasRequiredStreamBrowserify = 1;
  streamBrowserify = Stream;
  var EE = requireEvents().EventEmitter;
  var inherits = requireInherits_browser();
  inherits(Stream, EE);
  Stream.Readable = require_stream_readable();
  Stream.Writable = require_stream_writable();
  Stream.Duplex = require_stream_duplex();
  Stream.Transform = require_stream_transform();
  Stream.PassThrough = require_stream_passthrough();
  Stream.finished = requireEndOfStream();
  Stream.pipeline = requirePipeline();
  Stream.Stream = Stream;
  function Stream() {
    EE.call(this);
  }
  Stream.prototype.pipe = function(dest, options) {
    var source = this;
    function ondata(chunk) {
      if (dest.writable) {
        if (false === dest.write(chunk) && source.pause) {
          source.pause();
        }
      }
    }
    source.on("data", ondata);
    function ondrain() {
      if (source.readable && source.resume) {
        source.resume();
      }
    }
    dest.on("drain", ondrain);
    if (!dest._isStdio && (!options || options.end !== false)) {
      source.on("end", onend);
      source.on("close", onclose);
    }
    var didOnEnd = false;
    function onend() {
      if (didOnEnd) return;
      didOnEnd = true;
      dest.end();
    }
    function onclose() {
      if (didOnEnd) return;
      didOnEnd = true;
      if (typeof dest.destroy === "function") dest.destroy();
    }
    function onerror(er) {
      cleanup();
      if (EE.listenerCount(this, "error") === 0) {
        throw er;
      }
    }
    source.on("error", onerror);
    dest.on("error", onerror);
    function cleanup() {
      source.removeListener("data", ondata);
      dest.removeListener("drain", ondrain);
      source.removeListener("end", onend);
      source.removeListener("close", onclose);
      source.removeListener("error", onerror);
      dest.removeListener("error", onerror);
      source.removeListener("end", cleanup);
      source.removeListener("close", cleanup);
      dest.removeListener("close", cleanup);
    }
    source.on("end", cleanup);
    source.on("close", cleanup);
    dest.on("close", cleanup);
    dest.emit("pipe", source);
    return dest;
  };
  return streamBrowserify;
}
function requireSax() {
  if (hasRequiredSax) return sax;
  hasRequiredSax = 1;
  (function(exports2) {
    (function(sax2) {
      sax2.parser = function(strict, opt) {
        return new SAXParser(strict, opt);
      };
      sax2.SAXParser = SAXParser;
      sax2.SAXStream = SAXStream;
      sax2.createStream = createStream;
      sax2.MAX_BUFFER_LENGTH = 64 * 1024;
      var buffers = [
        "comment",
        "sgmlDecl",
        "textNode",
        "tagName",
        "doctype",
        "procInstName",
        "procInstBody",
        "entity",
        "attribName",
        "attribValue",
        "cdata",
        "script"
      ];
      sax2.EVENTS = [
        "text",
        "processinginstruction",
        "sgmldeclaration",
        "doctype",
        "comment",
        "opentagstart",
        "attribute",
        "opentag",
        "closetag",
        "opencdata",
        "cdata",
        "closecdata",
        "error",
        "end",
        "ready",
        "script",
        "opennamespace",
        "closenamespace"
      ];
      function SAXParser(strict, opt) {
        if (!(this instanceof SAXParser)) {
          return new SAXParser(strict, opt);
        }
        var parser = this;
        clearBuffers(parser);
        parser.q = parser.c = "";
        parser.bufferCheckPosition = sax2.MAX_BUFFER_LENGTH;
        parser.opt = opt || {};
        parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
        parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
        parser.tags = [];
        parser.closed = parser.closedRoot = parser.sawRoot = false;
        parser.tag = parser.error = null;
        parser.strict = !!strict;
        parser.noscript = !!(strict || parser.opt.noscript);
        parser.state = S.BEGIN;
        parser.strictEntities = parser.opt.strictEntities;
        parser.ENTITIES = parser.strictEntities ? Object.create(sax2.XML_ENTITIES) : Object.create(sax2.ENTITIES);
        parser.attribList = [];
        if (parser.opt.xmlns) {
          parser.ns = Object.create(rootNS);
        }
        parser.trackPosition = parser.opt.position !== false;
        if (parser.trackPosition) {
          parser.position = parser.line = parser.column = 0;
        }
        emit(parser, "onready");
      }
      if (!Object.create) {
        Object.create = function(o) {
          function F() {
          }
          F.prototype = o;
          var newf = new F();
          return newf;
        };
      }
      if (!Object.keys) {
        Object.keys = function(o) {
          var a = [];
          for (var i in o) if (o.hasOwnProperty(i)) a.push(i);
          return a;
        };
      }
      function checkBufferLength(parser) {
        var maxAllowed = Math.max(sax2.MAX_BUFFER_LENGTH, 10);
        var maxActual = 0;
        for (var i = 0, l = buffers.length; i < l; i++) {
          var len = parser[buffers[i]].length;
          if (len > maxAllowed) {
            switch (buffers[i]) {
              case "textNode":
                closeText(parser);
                break;
              case "cdata":
                emitNode(parser, "oncdata", parser.cdata);
                parser.cdata = "";
                break;
              case "script":
                emitNode(parser, "onscript", parser.script);
                parser.script = "";
                break;
              default:
                error(parser, "Max buffer length exceeded: " + buffers[i]);
            }
          }
          maxActual = Math.max(maxActual, len);
        }
        var m = sax2.MAX_BUFFER_LENGTH - maxActual;
        parser.bufferCheckPosition = m + parser.position;
      }
      function clearBuffers(parser) {
        for (var i = 0, l = buffers.length; i < l; i++) {
          parser[buffers[i]] = "";
        }
      }
      function flushBuffers(parser) {
        closeText(parser);
        if (parser.cdata !== "") {
          emitNode(parser, "oncdata", parser.cdata);
          parser.cdata = "";
        }
        if (parser.script !== "") {
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
      }
      SAXParser.prototype = {
        end: function() {
          end(this);
        },
        write,
        resume: function() {
          this.error = null;
          return this;
        },
        close: function() {
          return this.write(null);
        },
        flush: function() {
          flushBuffers(this);
        }
      };
      var Stream;
      try {
        Stream = requireStreamBrowserify().Stream;
      } catch (ex) {
        Stream = function() {
        };
      }
      var streamWraps = sax2.EVENTS.filter(function(ev) {
        return ev !== "error" && ev !== "end";
      });
      function createStream(strict, opt) {
        return new SAXStream(strict, opt);
      }
      function SAXStream(strict, opt) {
        if (!(this instanceof SAXStream)) {
          return new SAXStream(strict, opt);
        }
        Stream.apply(this);
        this._parser = new SAXParser(strict, opt);
        this.writable = true;
        this.readable = true;
        var me = this;
        this._parser.onend = function() {
          me.emit("end");
        };
        this._parser.onerror = function(er) {
          me.emit("error", er);
          me._parser.error = null;
        };
        this._decoder = null;
        streamWraps.forEach(function(ev) {
          Object.defineProperty(me, "on" + ev, {
            get: function() {
              return me._parser["on" + ev];
            },
            set: function(h) {
              if (!h) {
                me.removeAllListeners(ev);
                me._parser["on" + ev] = h;
                return h;
              }
              me.on(ev, h);
            },
            enumerable: true,
            configurable: false
          });
        });
      }
      SAXStream.prototype = Object.create(Stream.prototype, {
        constructor: {
          value: SAXStream
        }
      });
      SAXStream.prototype.write = function(data) {
        if (typeof Buffer === "function" && typeof Buffer.isBuffer === "function" && Buffer.isBuffer(data)) {
          if (!this._decoder) {
            var SD = requireString_decoder().StringDecoder;
            this._decoder = new SD("utf8");
          }
          data = this._decoder.write(data);
        }
        this._parser.write(data.toString());
        this.emit("data", data);
        return true;
      };
      SAXStream.prototype.end = function(chunk) {
        if (chunk && chunk.length) {
          this.write(chunk);
        }
        this._parser.end();
        return true;
      };
      SAXStream.prototype.on = function(ev, handler) {
        var me = this;
        if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) {
          me._parser["on" + ev] = function() {
            var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
            args.splice(0, 0, ev);
            me.emit.apply(me, args);
          };
        }
        return Stream.prototype.on.call(me, ev, handler);
      };
      var CDATA = "[CDATA[";
      var DOCTYPE = "DOCTYPE";
      var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
      var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
      var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
      var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      function isWhitespace(c) {
        return c === " " || c === "\n" || c === "\r" || c === "	";
      }
      function isQuote(c) {
        return c === '"' || c === "'";
      }
      function isAttribEnd(c) {
        return c === ">" || isWhitespace(c);
      }
      function isMatch(regex, c) {
        return regex.test(c);
      }
      function notMatch(regex, c) {
        return !isMatch(regex, c);
      }
      var S = 0;
      sax2.STATE = {
        BEGIN: S++,
        // leading byte order mark or whitespace
        BEGIN_WHITESPACE: S++,
        // leading whitespace
        TEXT: S++,
        // general stuff
        TEXT_ENTITY: S++,
        // &amp and such.
        OPEN_WAKA: S++,
        // <
        SGML_DECL: S++,
        // <!BLARG
        SGML_DECL_QUOTED: S++,
        // <!BLARG foo "bar
        DOCTYPE: S++,
        // <!DOCTYPE
        DOCTYPE_QUOTED: S++,
        // <!DOCTYPE "//blah
        DOCTYPE_DTD: S++,
        // <!DOCTYPE "//blah" [ ...
        DOCTYPE_DTD_QUOTED: S++,
        // <!DOCTYPE "//blah" [ "foo
        COMMENT_STARTING: S++,
        // <!-
        COMMENT: S++,
        // <!--
        COMMENT_ENDING: S++,
        // <!-- blah -
        COMMENT_ENDED: S++,
        // <!-- blah --
        CDATA: S++,
        // <![CDATA[ something
        CDATA_ENDING: S++,
        // ]
        CDATA_ENDING_2: S++,
        // ]]
        PROC_INST: S++,
        // <?hi
        PROC_INST_BODY: S++,
        // <?hi there
        PROC_INST_ENDING: S++,
        // <?hi "there" ?
        OPEN_TAG: S++,
        // <strong
        OPEN_TAG_SLASH: S++,
        // <strong /
        ATTRIB: S++,
        // <a
        ATTRIB_NAME: S++,
        // <a foo
        ATTRIB_NAME_SAW_WHITE: S++,
        // <a foo _
        ATTRIB_VALUE: S++,
        // <a foo=
        ATTRIB_VALUE_QUOTED: S++,
        // <a foo="bar
        ATTRIB_VALUE_CLOSED: S++,
        // <a foo="bar"
        ATTRIB_VALUE_UNQUOTED: S++,
        // <a foo=bar
        ATTRIB_VALUE_ENTITY_Q: S++,
        // <foo bar="&quot;"
        ATTRIB_VALUE_ENTITY_U: S++,
        // <foo bar=&quot
        CLOSE_TAG: S++,
        // </a
        CLOSE_TAG_SAW_WHITE: S++,
        // </a   >
        SCRIPT: S++,
        // <script> ...
        SCRIPT_ENDING: S++
        // <script> ... <
      };
      sax2.XML_ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'"
      };
      sax2.ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'",
        "AElig": 198,
        "Aacute": 193,
        "Acirc": 194,
        "Agrave": 192,
        "Aring": 197,
        "Atilde": 195,
        "Auml": 196,
        "Ccedil": 199,
        "ETH": 208,
        "Eacute": 201,
        "Ecirc": 202,
        "Egrave": 200,
        "Euml": 203,
        "Iacute": 205,
        "Icirc": 206,
        "Igrave": 204,
        "Iuml": 207,
        "Ntilde": 209,
        "Oacute": 211,
        "Ocirc": 212,
        "Ograve": 210,
        "Oslash": 216,
        "Otilde": 213,
        "Ouml": 214,
        "THORN": 222,
        "Uacute": 218,
        "Ucirc": 219,
        "Ugrave": 217,
        "Uuml": 220,
        "Yacute": 221,
        "aacute": 225,
        "acirc": 226,
        "aelig": 230,
        "agrave": 224,
        "aring": 229,
        "atilde": 227,
        "auml": 228,
        "ccedil": 231,
        "eacute": 233,
        "ecirc": 234,
        "egrave": 232,
        "eth": 240,
        "euml": 235,
        "iacute": 237,
        "icirc": 238,
        "igrave": 236,
        "iuml": 239,
        "ntilde": 241,
        "oacute": 243,
        "ocirc": 244,
        "ograve": 242,
        "oslash": 248,
        "otilde": 245,
        "ouml": 246,
        "szlig": 223,
        "thorn": 254,
        "uacute": 250,
        "ucirc": 251,
        "ugrave": 249,
        "uuml": 252,
        "yacute": 253,
        "yuml": 255,
        "copy": 169,
        "reg": 174,
        "nbsp": 160,
        "iexcl": 161,
        "cent": 162,
        "pound": 163,
        "curren": 164,
        "yen": 165,
        "brvbar": 166,
        "sect": 167,
        "uml": 168,
        "ordf": 170,
        "laquo": 171,
        "not": 172,
        "shy": 173,
        "macr": 175,
        "deg": 176,
        "plusmn": 177,
        "sup1": 185,
        "sup2": 178,
        "sup3": 179,
        "acute": 180,
        "micro": 181,
        "para": 182,
        "middot": 183,
        "cedil": 184,
        "ordm": 186,
        "raquo": 187,
        "frac14": 188,
        "frac12": 189,
        "frac34": 190,
        "iquest": 191,
        "times": 215,
        "divide": 247,
        "OElig": 338,
        "oelig": 339,
        "Scaron": 352,
        "scaron": 353,
        "Yuml": 376,
        "fnof": 402,
        "circ": 710,
        "tilde": 732,
        "Alpha": 913,
        "Beta": 914,
        "Gamma": 915,
        "Delta": 916,
        "Epsilon": 917,
        "Zeta": 918,
        "Eta": 919,
        "Theta": 920,
        "Iota": 921,
        "Kappa": 922,
        "Lambda": 923,
        "Mu": 924,
        "Nu": 925,
        "Xi": 926,
        "Omicron": 927,
        "Pi": 928,
        "Rho": 929,
        "Sigma": 931,
        "Tau": 932,
        "Upsilon": 933,
        "Phi": 934,
        "Chi": 935,
        "Psi": 936,
        "Omega": 937,
        "alpha": 945,
        "beta": 946,
        "gamma": 947,
        "delta": 948,
        "epsilon": 949,
        "zeta": 950,
        "eta": 951,
        "theta": 952,
        "iota": 953,
        "kappa": 954,
        "lambda": 955,
        "mu": 956,
        "nu": 957,
        "xi": 958,
        "omicron": 959,
        "pi": 960,
        "rho": 961,
        "sigmaf": 962,
        "sigma": 963,
        "tau": 964,
        "upsilon": 965,
        "phi": 966,
        "chi": 967,
        "psi": 968,
        "omega": 969,
        "thetasym": 977,
        "upsih": 978,
        "piv": 982,
        "ensp": 8194,
        "emsp": 8195,
        "thinsp": 8201,
        "zwnj": 8204,
        "zwj": 8205,
        "lrm": 8206,
        "rlm": 8207,
        "ndash": 8211,
        "mdash": 8212,
        "lsquo": 8216,
        "rsquo": 8217,
        "sbquo": 8218,
        "ldquo": 8220,
        "rdquo": 8221,
        "bdquo": 8222,
        "dagger": 8224,
        "Dagger": 8225,
        "bull": 8226,
        "hellip": 8230,
        "permil": 8240,
        "prime": 8242,
        "Prime": 8243,
        "lsaquo": 8249,
        "rsaquo": 8250,
        "oline": 8254,
        "frasl": 8260,
        "euro": 8364,
        "image": 8465,
        "weierp": 8472,
        "real": 8476,
        "trade": 8482,
        "alefsym": 8501,
        "larr": 8592,
        "uarr": 8593,
        "rarr": 8594,
        "darr": 8595,
        "harr": 8596,
        "crarr": 8629,
        "lArr": 8656,
        "uArr": 8657,
        "rArr": 8658,
        "dArr": 8659,
        "hArr": 8660,
        "forall": 8704,
        "part": 8706,
        "exist": 8707,
        "empty": 8709,
        "nabla": 8711,
        "isin": 8712,
        "notin": 8713,
        "ni": 8715,
        "prod": 8719,
        "sum": 8721,
        "minus": 8722,
        "lowast": 8727,
        "radic": 8730,
        "prop": 8733,
        "infin": 8734,
        "ang": 8736,
        "and": 8743,
        "or": 8744,
        "cap": 8745,
        "cup": 8746,
        "int": 8747,
        "there4": 8756,
        "sim": 8764,
        "cong": 8773,
        "asymp": 8776,
        "ne": 8800,
        "equiv": 8801,
        "le": 8804,
        "ge": 8805,
        "sub": 8834,
        "sup": 8835,
        "nsub": 8836,
        "sube": 8838,
        "supe": 8839,
        "oplus": 8853,
        "otimes": 8855,
        "perp": 8869,
        "sdot": 8901,
        "lceil": 8968,
        "rceil": 8969,
        "lfloor": 8970,
        "rfloor": 8971,
        "lang": 9001,
        "rang": 9002,
        "loz": 9674,
        "spades": 9824,
        "clubs": 9827,
        "hearts": 9829,
        "diams": 9830
      };
      Object.keys(sax2.ENTITIES).forEach(function(key) {
        var e = sax2.ENTITIES[key];
        var s2 = typeof e === "number" ? String.fromCharCode(e) : e;
        sax2.ENTITIES[key] = s2;
      });
      for (var s in sax2.STATE) {
        sax2.STATE[sax2.STATE[s]] = s;
      }
      S = sax2.STATE;
      function emit(parser, event, data) {
        parser[event] && parser[event](data);
      }
      function emitNode(parser, nodeType, data) {
        if (parser.textNode) closeText(parser);
        emit(parser, nodeType, data);
      }
      function closeText(parser) {
        parser.textNode = textopts(parser.opt, parser.textNode);
        if (parser.textNode) emit(parser, "ontext", parser.textNode);
        parser.textNode = "";
      }
      function textopts(opt, text) {
        if (opt.trim) text = text.trim();
        if (opt.normalize) text = text.replace(/\s+/g, " ");
        return text;
      }
      function error(parser, er) {
        closeText(parser);
        if (parser.trackPosition) {
          er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
        }
        er = new Error(er);
        parser.error = er;
        emit(parser, "onerror", er);
        return parser;
      }
      function end(parser) {
        if (parser.sawRoot && !parser.closedRoot) strictFail(parser, "Unclosed root tag");
        if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {
          error(parser, "Unexpected end");
        }
        closeText(parser);
        parser.c = "";
        parser.closed = true;
        emit(parser, "onend");
        SAXParser.call(parser, parser.strict, parser.opt);
        return parser;
      }
      function strictFail(parser, message) {
        if (typeof parser !== "object" || !(parser instanceof SAXParser)) {
          throw new Error("bad call to strictFail");
        }
        if (parser.strict) {
          error(parser, message);
        }
      }
      function newTag(parser) {
        if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();
        var parent = parser.tags[parser.tags.length - 1] || parser;
        var tag = parser.tag = { name: parser.tagName, attributes: {} };
        if (parser.opt.xmlns) {
          tag.ns = parent.ns;
        }
        parser.attribList.length = 0;
        emitNode(parser, "onopentagstart", tag);
      }
      function qname(name, attribute) {
        var i = name.indexOf(":");
        var qualName = i < 0 ? ["", name] : name.split(":");
        var prefix = qualName[0];
        var local = qualName[1];
        if (attribute && name === "xmlns") {
          prefix = "xmlns";
          local = "";
        }
        return { prefix, local };
      }
      function attrib(parser) {
        if (!parser.strict) {
          parser.attribName = parser.attribName[parser.looseCase]();
        }
        if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
          parser.attribName = parser.attribValue = "";
          return;
        }
        if (parser.opt.xmlns) {
          var qn = qname(parser.attribName, true);
          var prefix = qn.prefix;
          var local = qn.local;
          if (prefix === "xmlns") {
            if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
              strictFail(
                parser,
                "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser.attribValue
              );
            } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
              strictFail(
                parser,
                "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\nActual: " + parser.attribValue
              );
            } else {
              var tag = parser.tag;
              var parent = parser.tags[parser.tags.length - 1] || parser;
              if (tag.ns === parent.ns) {
                tag.ns = Object.create(parent.ns);
              }
              tag.ns[local] = parser.attribValue;
            }
          }
          parser.attribList.push([parser.attribName, parser.attribValue]);
        } else {
          parser.tag.attributes[parser.attribName] = parser.attribValue;
          emitNode(parser, "onattribute", {
            name: parser.attribName,
            value: parser.attribValue
          });
        }
        parser.attribName = parser.attribValue = "";
      }
      function openTag(parser, selfClosing) {
        if (parser.opt.xmlns) {
          var tag = parser.tag;
          var qn = qname(parser.tagName);
          tag.prefix = qn.prefix;
          tag.local = qn.local;
          tag.uri = tag.ns[qn.prefix] || "";
          if (tag.prefix && !tag.uri) {
            strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName));
            tag.uri = qn.prefix;
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (tag.ns && parent.ns !== tag.ns) {
            Object.keys(tag.ns).forEach(function(p) {
              emitNode(parser, "onopennamespace", {
                prefix: p,
                uri: tag.ns[p]
              });
            });
          }
          for (var i = 0, l = parser.attribList.length; i < l; i++) {
            var nv = parser.attribList[i];
            var name = nv[0];
            var value = nv[1];
            var qualName = qname(name, true);
            var prefix = qualName.prefix;
            var local = qualName.local;
            var uri2 = prefix === "" ? "" : tag.ns[prefix] || "";
            var a = {
              name,
              value,
              prefix,
              local,
              uri: uri2
            };
            if (prefix && prefix !== "xmlns" && !uri2) {
              strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix));
              a.uri = prefix;
            }
            parser.tag.attributes[name] = a;
            emitNode(parser, "onattribute", a);
          }
          parser.attribList.length = 0;
        }
        parser.tag.isSelfClosing = !!selfClosing;
        parser.sawRoot = true;
        parser.tags.push(parser.tag);
        emitNode(parser, "onopentag", parser.tag);
        if (!selfClosing) {
          if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
            parser.state = S.SCRIPT;
          } else {
            parser.state = S.TEXT;
          }
          parser.tag = null;
          parser.tagName = "";
        }
        parser.attribName = parser.attribValue = "";
        parser.attribList.length = 0;
      }
      function closeTag(parser) {
        if (!parser.tagName) {
          strictFail(parser, "Weird empty close tag.");
          parser.textNode += "</>";
          parser.state = S.TEXT;
          return;
        }
        if (parser.script) {
          if (parser.tagName !== "script") {
            parser.script += "</" + parser.tagName + ">";
            parser.tagName = "";
            parser.state = S.SCRIPT;
            return;
          }
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
        var t = parser.tags.length;
        var tagName = parser.tagName;
        if (!parser.strict) {
          tagName = tagName[parser.looseCase]();
        }
        var closeTo = tagName;
        while (t--) {
          var close = parser.tags[t];
          if (close.name !== closeTo) {
            strictFail(parser, "Unexpected close tag");
          } else {
            break;
          }
        }
        if (t < 0) {
          strictFail(parser, "Unmatched closing tag: " + parser.tagName);
          parser.textNode += "</" + parser.tagName + ">";
          parser.state = S.TEXT;
          return;
        }
        parser.tagName = tagName;
        var s2 = parser.tags.length;
        while (s2-- > t) {
          var tag = parser.tag = parser.tags.pop();
          parser.tagName = parser.tag.name;
          emitNode(parser, "onclosetag", parser.tagName);
          var x = {};
          for (var i in tag.ns) {
            x[i] = tag.ns[i];
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (parser.opt.xmlns && tag.ns !== parent.ns) {
            Object.keys(tag.ns).forEach(function(p) {
              var n = tag.ns[p];
              emitNode(parser, "onclosenamespace", { prefix: p, uri: n });
            });
          }
        }
        if (t === 0) parser.closedRoot = true;
        parser.tagName = parser.attribValue = parser.attribName = "";
        parser.attribList.length = 0;
        parser.state = S.TEXT;
      }
      function parseEntity(parser) {
        var entity = parser.entity;
        var entityLC = entity.toLowerCase();
        var num;
        var numStr = "";
        if (parser.ENTITIES[entity]) {
          return parser.ENTITIES[entity];
        }
        if (parser.ENTITIES[entityLC]) {
          return parser.ENTITIES[entityLC];
        }
        entity = entityLC;
        if (entity.charAt(0) === "#") {
          if (entity.charAt(1) === "x") {
            entity = entity.slice(2);
            num = parseInt(entity, 16);
            numStr = num.toString(16);
          } else {
            entity = entity.slice(1);
            num = parseInt(entity, 10);
            numStr = num.toString(10);
          }
        }
        entity = entity.replace(/^0+/, "");
        if (isNaN(num) || numStr.toLowerCase() !== entity) {
          strictFail(parser, "Invalid character entity");
          return "&" + parser.entity + ";";
        }
        return String.fromCodePoint(num);
      }
      function beginWhiteSpace(parser, c) {
        if (c === "<") {
          parser.state = S.OPEN_WAKA;
          parser.startTagPosition = parser.position;
        } else if (!isWhitespace(c)) {
          strictFail(parser, "Non-whitespace before first tag.");
          parser.textNode = c;
          parser.state = S.TEXT;
        }
      }
      function charAt(chunk, i) {
        var result = "";
        if (i < chunk.length) {
          result = chunk.charAt(i);
        }
        return result;
      }
      function write(chunk) {
        var parser = this;
        if (this.error) {
          throw this.error;
        }
        if (parser.closed) {
          return error(
            parser,
            "Cannot write after close. Assign an onready handler."
          );
        }
        if (chunk === null) {
          return end(parser);
        }
        if (typeof chunk === "object") {
          chunk = chunk.toString();
        }
        var i = 0;
        var c = "";
        while (true) {
          c = charAt(chunk, i++);
          parser.c = c;
          if (!c) {
            break;
          }
          if (parser.trackPosition) {
            parser.position++;
            if (c === "\n") {
              parser.line++;
              parser.column = 0;
            } else {
              parser.column++;
            }
          }
          switch (parser.state) {
            case S.BEGIN:
              parser.state = S.BEGIN_WHITESPACE;
              if (c === "\uFEFF") {
                continue;
              }
              beginWhiteSpace(parser, c);
              continue;
            case S.BEGIN_WHITESPACE:
              beginWhiteSpace(parser, c);
              continue;
            case S.TEXT:
              if (parser.sawRoot && !parser.closedRoot) {
                var starti = i - 1;
                while (c && c !== "<" && c !== "&") {
                  c = charAt(chunk, i++);
                  if (c && parser.trackPosition) {
                    parser.position++;
                    if (c === "\n") {
                      parser.line++;
                      parser.column = 0;
                    } else {
                      parser.column++;
                    }
                  }
                }
                parser.textNode += chunk.substring(starti, i - 1);
              }
              if (c === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
                parser.state = S.OPEN_WAKA;
                parser.startTagPosition = parser.position;
              } else {
                if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
                  strictFail(parser, "Text data outside of root node.");
                }
                if (c === "&") {
                  parser.state = S.TEXT_ENTITY;
                } else {
                  parser.textNode += c;
                }
              }
              continue;
            case S.SCRIPT:
              if (c === "<") {
                parser.state = S.SCRIPT_ENDING;
              } else {
                parser.script += c;
              }
              continue;
            case S.SCRIPT_ENDING:
              if (c === "/") {
                parser.state = S.CLOSE_TAG;
              } else {
                parser.script += "<" + c;
                parser.state = S.SCRIPT;
              }
              continue;
            case S.OPEN_WAKA:
              if (c === "!") {
                parser.state = S.SGML_DECL;
                parser.sgmlDecl = "";
              } else if (isWhitespace(c)) ;
              else if (isMatch(nameStart, c)) {
                parser.state = S.OPEN_TAG;
                parser.tagName = c;
              } else if (c === "/") {
                parser.state = S.CLOSE_TAG;
                parser.tagName = "";
              } else if (c === "?") {
                parser.state = S.PROC_INST;
                parser.procInstName = parser.procInstBody = "";
              } else {
                strictFail(parser, "Unencoded <");
                if (parser.startTagPosition + 1 < parser.position) {
                  var pad = parser.position - parser.startTagPosition;
                  c = new Array(pad).join(" ") + c;
                }
                parser.textNode += "<" + c;
                parser.state = S.TEXT;
              }
              continue;
            case S.SGML_DECL:
              if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
                emitNode(parser, "onopencdata");
                parser.state = S.CDATA;
                parser.sgmlDecl = "";
                parser.cdata = "";
              } else if (parser.sgmlDecl + c === "--") {
                parser.state = S.COMMENT;
                parser.comment = "";
                parser.sgmlDecl = "";
              } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
                parser.state = S.DOCTYPE;
                if (parser.doctype || parser.sawRoot) {
                  strictFail(
                    parser,
                    "Inappropriately located doctype declaration"
                  );
                }
                parser.doctype = "";
                parser.sgmlDecl = "";
              } else if (c === ">") {
                emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
                parser.sgmlDecl = "";
                parser.state = S.TEXT;
              } else if (isQuote(c)) {
                parser.state = S.SGML_DECL_QUOTED;
                parser.sgmlDecl += c;
              } else {
                parser.sgmlDecl += c;
              }
              continue;
            case S.SGML_DECL_QUOTED:
              if (c === parser.q) {
                parser.state = S.SGML_DECL;
                parser.q = "";
              }
              parser.sgmlDecl += c;
              continue;
            case S.DOCTYPE:
              if (c === ">") {
                parser.state = S.TEXT;
                emitNode(parser, "ondoctype", parser.doctype);
                parser.doctype = true;
              } else {
                parser.doctype += c;
                if (c === "[") {
                  parser.state = S.DOCTYPE_DTD;
                } else if (isQuote(c)) {
                  parser.state = S.DOCTYPE_QUOTED;
                  parser.q = c;
                }
              }
              continue;
            case S.DOCTYPE_QUOTED:
              parser.doctype += c;
              if (c === parser.q) {
                parser.q = "";
                parser.state = S.DOCTYPE;
              }
              continue;
            case S.DOCTYPE_DTD:
              parser.doctype += c;
              if (c === "]") {
                parser.state = S.DOCTYPE;
              } else if (isQuote(c)) {
                parser.state = S.DOCTYPE_DTD_QUOTED;
                parser.q = c;
              }
              continue;
            case S.DOCTYPE_DTD_QUOTED:
              parser.doctype += c;
              if (c === parser.q) {
                parser.state = S.DOCTYPE_DTD;
                parser.q = "";
              }
              continue;
            case S.COMMENT:
              if (c === "-") {
                parser.state = S.COMMENT_ENDING;
              } else {
                parser.comment += c;
              }
              continue;
            case S.COMMENT_ENDING:
              if (c === "-") {
                parser.state = S.COMMENT_ENDED;
                parser.comment = textopts(parser.opt, parser.comment);
                if (parser.comment) {
                  emitNode(parser, "oncomment", parser.comment);
                }
                parser.comment = "";
              } else {
                parser.comment += "-" + c;
                parser.state = S.COMMENT;
              }
              continue;
            case S.COMMENT_ENDED:
              if (c !== ">") {
                strictFail(parser, "Malformed comment");
                parser.comment += "--" + c;
                parser.state = S.COMMENT;
              } else {
                parser.state = S.TEXT;
              }
              continue;
            case S.CDATA:
              if (c === "]") {
                parser.state = S.CDATA_ENDING;
              } else {
                parser.cdata += c;
              }
              continue;
            case S.CDATA_ENDING:
              if (c === "]") {
                parser.state = S.CDATA_ENDING_2;
              } else {
                parser.cdata += "]" + c;
                parser.state = S.CDATA;
              }
              continue;
            case S.CDATA_ENDING_2:
              if (c === ">") {
                if (parser.cdata) {
                  emitNode(parser, "oncdata", parser.cdata);
                }
                emitNode(parser, "onclosecdata");
                parser.cdata = "";
                parser.state = S.TEXT;
              } else if (c === "]") {
                parser.cdata += "]";
              } else {
                parser.cdata += "]]" + c;
                parser.state = S.CDATA;
              }
              continue;
            case S.PROC_INST:
              if (c === "?") {
                parser.state = S.PROC_INST_ENDING;
              } else if (isWhitespace(c)) {
                parser.state = S.PROC_INST_BODY;
              } else {
                parser.procInstName += c;
              }
              continue;
            case S.PROC_INST_BODY:
              if (!parser.procInstBody && isWhitespace(c)) {
                continue;
              } else if (c === "?") {
                parser.state = S.PROC_INST_ENDING;
              } else {
                parser.procInstBody += c;
              }
              continue;
            case S.PROC_INST_ENDING:
              if (c === ">") {
                emitNode(parser, "onprocessinginstruction", {
                  name: parser.procInstName,
                  body: parser.procInstBody
                });
                parser.procInstName = parser.procInstBody = "";
                parser.state = S.TEXT;
              } else {
                parser.procInstBody += "?" + c;
                parser.state = S.PROC_INST_BODY;
              }
              continue;
            case S.OPEN_TAG:
              if (isMatch(nameBody, c)) {
                parser.tagName += c;
              } else {
                newTag(parser);
                if (c === ">") {
                  openTag(parser);
                } else if (c === "/") {
                  parser.state = S.OPEN_TAG_SLASH;
                } else {
                  if (!isWhitespace(c)) {
                    strictFail(parser, "Invalid character in tag name");
                  }
                  parser.state = S.ATTRIB;
                }
              }
              continue;
            case S.OPEN_TAG_SLASH:
              if (c === ">") {
                openTag(parser, true);
                closeTag(parser);
              } else {
                strictFail(parser, "Forward-slash in opening tag not followed by >");
                parser.state = S.ATTRIB;
              }
              continue;
            case S.ATTRIB:
              if (isWhitespace(c)) {
                continue;
              } else if (c === ">") {
                openTag(parser);
              } else if (c === "/") {
                parser.state = S.OPEN_TAG_SLASH;
              } else if (isMatch(nameStart, c)) {
                parser.attribName = c;
                parser.attribValue = "";
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_NAME:
              if (c === "=") {
                parser.state = S.ATTRIB_VALUE;
              } else if (c === ">") {
                strictFail(parser, "Attribute without value");
                parser.attribValue = parser.attribName;
                attrib(parser);
                openTag(parser);
              } else if (isWhitespace(c)) {
                parser.state = S.ATTRIB_NAME_SAW_WHITE;
              } else if (isMatch(nameBody, c)) {
                parser.attribName += c;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_NAME_SAW_WHITE:
              if (c === "=") {
                parser.state = S.ATTRIB_VALUE;
              } else if (isWhitespace(c)) {
                continue;
              } else {
                strictFail(parser, "Attribute without value");
                parser.tag.attributes[parser.attribName] = "";
                parser.attribValue = "";
                emitNode(parser, "onattribute", {
                  name: parser.attribName,
                  value: ""
                });
                parser.attribName = "";
                if (c === ">") {
                  openTag(parser);
                } else if (isMatch(nameStart, c)) {
                  parser.attribName = c;
                  parser.state = S.ATTRIB_NAME;
                } else {
                  strictFail(parser, "Invalid attribute name");
                  parser.state = S.ATTRIB;
                }
              }
              continue;
            case S.ATTRIB_VALUE:
              if (isWhitespace(c)) {
                continue;
              } else if (isQuote(c)) {
                parser.q = c;
                parser.state = S.ATTRIB_VALUE_QUOTED;
              } else {
                strictFail(parser, "Unquoted attribute value");
                parser.state = S.ATTRIB_VALUE_UNQUOTED;
                parser.attribValue = c;
              }
              continue;
            case S.ATTRIB_VALUE_QUOTED:
              if (c !== parser.q) {
                if (c === "&") {
                  parser.state = S.ATTRIB_VALUE_ENTITY_Q;
                } else {
                  parser.attribValue += c;
                }
                continue;
              }
              attrib(parser);
              parser.q = "";
              parser.state = S.ATTRIB_VALUE_CLOSED;
              continue;
            case S.ATTRIB_VALUE_CLOSED:
              if (isWhitespace(c)) {
                parser.state = S.ATTRIB;
              } else if (c === ">") {
                openTag(parser);
              } else if (c === "/") {
                parser.state = S.OPEN_TAG_SLASH;
              } else if (isMatch(nameStart, c)) {
                strictFail(parser, "No whitespace between attributes");
                parser.attribName = c;
                parser.attribValue = "";
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_VALUE_UNQUOTED:
              if (!isAttribEnd(c)) {
                if (c === "&") {
                  parser.state = S.ATTRIB_VALUE_ENTITY_U;
                } else {
                  parser.attribValue += c;
                }
                continue;
              }
              attrib(parser);
              if (c === ">") {
                openTag(parser);
              } else {
                parser.state = S.ATTRIB;
              }
              continue;
            case S.CLOSE_TAG:
              if (!parser.tagName) {
                if (isWhitespace(c)) {
                  continue;
                } else if (notMatch(nameStart, c)) {
                  if (parser.script) {
                    parser.script += "</" + c;
                    parser.state = S.SCRIPT;
                  } else {
                    strictFail(parser, "Invalid tagname in closing tag.");
                  }
                } else {
                  parser.tagName = c;
                }
              } else if (c === ">") {
                closeTag(parser);
              } else if (isMatch(nameBody, c)) {
                parser.tagName += c;
              } else if (parser.script) {
                parser.script += "</" + parser.tagName;
                parser.tagName = "";
                parser.state = S.SCRIPT;
              } else {
                if (!isWhitespace(c)) {
                  strictFail(parser, "Invalid tagname in closing tag");
                }
                parser.state = S.CLOSE_TAG_SAW_WHITE;
              }
              continue;
            case S.CLOSE_TAG_SAW_WHITE:
              if (isWhitespace(c)) {
                continue;
              }
              if (c === ">") {
                closeTag(parser);
              } else {
                strictFail(parser, "Invalid characters in closing tag");
              }
              continue;
            case S.TEXT_ENTITY:
            case S.ATTRIB_VALUE_ENTITY_Q:
            case S.ATTRIB_VALUE_ENTITY_U:
              var returnState;
              var buffer2;
              switch (parser.state) {
                case S.TEXT_ENTITY:
                  returnState = S.TEXT;
                  buffer2 = "textNode";
                  break;
                case S.ATTRIB_VALUE_ENTITY_Q:
                  returnState = S.ATTRIB_VALUE_QUOTED;
                  buffer2 = "attribValue";
                  break;
                case S.ATTRIB_VALUE_ENTITY_U:
                  returnState = S.ATTRIB_VALUE_UNQUOTED;
                  buffer2 = "attribValue";
                  break;
              }
              if (c === ";") {
                parser[buffer2] += parseEntity(parser);
                parser.entity = "";
                parser.state = returnState;
              } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
                parser.entity += c;
              } else {
                strictFail(parser, "Invalid character in entity name");
                parser[buffer2] += "&" + parser.entity + c;
                parser.entity = "";
                parser.state = returnState;
              }
              continue;
            default:
              throw new Error(parser, "Unknown state: " + parser.state);
          }
        }
        if (parser.position >= parser.bufferCheckPosition) {
          checkBufferLength(parser);
        }
        return parser;
      }
      if (!String.fromCodePoint) {
        (function() {
          var stringFromCharCode = String.fromCharCode;
          var floor2 = Math.floor;
          var fromCodePoint = function() {
            var MAX_SIZE = 16384;
            var codeUnits = [];
            var highSurrogate;
            var lowSurrogate;
            var index = -1;
            var length = arguments.length;
            if (!length) {
              return "";
            }
            var result = "";
            while (++index < length) {
              var codePoint = Number(arguments[index]);
              if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
              codePoint < 0 || // not a valid Unicode code point
              codePoint > 1114111 || // not a valid Unicode code point
              floor2(codePoint) !== codePoint) {
                throw RangeError("Invalid code point: " + codePoint);
              }
              if (codePoint <= 65535) {
                codeUnits.push(codePoint);
              } else {
                codePoint -= 65536;
                highSurrogate = (codePoint >> 10) + 55296;
                lowSurrogate = codePoint % 1024 + 56320;
                codeUnits.push(highSurrogate, lowSurrogate);
              }
              if (index + 1 === length || codeUnits.length > MAX_SIZE) {
                result += stringFromCharCode.apply(null, codeUnits);
                codeUnits.length = 0;
              }
            }
            return result;
          };
          if (Object.defineProperty) {
            Object.defineProperty(String, "fromCodePoint", {
              value: fromCodePoint,
              configurable: true,
              writable: true
            });
          } else {
            String.fromCodePoint = fromCodePoint;
          }
        })();
      }
    })(exports2);
  })(sax);
  return sax;
}
function requireArrayHelper() {
  if (hasRequiredArrayHelper) return arrayHelper;
  hasRequiredArrayHelper = 1;
  arrayHelper = {
    isArray: function(value) {
      if (Array.isArray) {
        return Array.isArray(value);
      }
      return Object.prototype.toString.call(value) === "[object Array]";
    }
  };
  return arrayHelper;
}
function requireOptionsHelper() {
  if (hasRequiredOptionsHelper) return optionsHelper;
  hasRequiredOptionsHelper = 1;
  var isArray = requireArrayHelper().isArray;
  optionsHelper = {
    copyOptions: function(options) {
      var key, copy = {};
      for (key in options) {
        if (options.hasOwnProperty(key)) {
          copy[key] = options[key];
        }
      }
      return copy;
    },
    ensureFlagExists: function(item, options) {
      if (!(item in options) || typeof options[item] !== "boolean") {
        options[item] = false;
      }
    },
    ensureSpacesExists: function(options) {
      if (!("spaces" in options) || typeof options.spaces !== "number" && typeof options.spaces !== "string") {
        options.spaces = 0;
      }
    },
    ensureAlwaysArrayExists: function(options) {
      if (!("alwaysArray" in options) || typeof options.alwaysArray !== "boolean" && !isArray(options.alwaysArray)) {
        options.alwaysArray = false;
      }
    },
    ensureKeyExists: function(key, options) {
      if (!(key + "Key" in options) || typeof options[key + "Key"] !== "string") {
        options[key + "Key"] = options.compact ? "_" + key : key;
      }
    },
    checkFnExists: function(key, options) {
      return key + "Fn" in options;
    }
  };
  return optionsHelper;
}
function requireXml2js() {
  if (hasRequiredXml2js) return xml2js;
  hasRequiredXml2js = 1;
  var sax2 = requireSax();
  var helper = requireOptionsHelper();
  var isArray = requireArrayHelper().isArray;
  var options;
  var currentElement;
  function validateOptions(userOptions) {
    options = helper.copyOptions(userOptions);
    helper.ensureFlagExists("ignoreDeclaration", options);
    helper.ensureFlagExists("ignoreInstruction", options);
    helper.ensureFlagExists("ignoreAttributes", options);
    helper.ensureFlagExists("ignoreText", options);
    helper.ensureFlagExists("ignoreComment", options);
    helper.ensureFlagExists("ignoreCdata", options);
    helper.ensureFlagExists("ignoreDoctype", options);
    helper.ensureFlagExists("compact", options);
    helper.ensureFlagExists("alwaysChildren", options);
    helper.ensureFlagExists("addParent", options);
    helper.ensureFlagExists("trim", options);
    helper.ensureFlagExists("nativeType", options);
    helper.ensureFlagExists("nativeTypeAttributes", options);
    helper.ensureFlagExists("sanitize", options);
    helper.ensureFlagExists("instructionHasAttributes", options);
    helper.ensureFlagExists("captureSpacesBetweenElements", options);
    helper.ensureAlwaysArrayExists(options);
    helper.ensureKeyExists("declaration", options);
    helper.ensureKeyExists("instruction", options);
    helper.ensureKeyExists("attributes", options);
    helper.ensureKeyExists("text", options);
    helper.ensureKeyExists("comment", options);
    helper.ensureKeyExists("cdata", options);
    helper.ensureKeyExists("doctype", options);
    helper.ensureKeyExists("type", options);
    helper.ensureKeyExists("name", options);
    helper.ensureKeyExists("elements", options);
    helper.ensureKeyExists("parent", options);
    helper.checkFnExists("doctype", options);
    helper.checkFnExists("instruction", options);
    helper.checkFnExists("cdata", options);
    helper.checkFnExists("comment", options);
    helper.checkFnExists("text", options);
    helper.checkFnExists("instructionName", options);
    helper.checkFnExists("elementName", options);
    helper.checkFnExists("attributeName", options);
    helper.checkFnExists("attributeValue", options);
    helper.checkFnExists("attributes", options);
    return options;
  }
  function nativeType(value) {
    var nValue = Number(value);
    if (!isNaN(nValue)) {
      return nValue;
    }
    var bValue = value.toLowerCase();
    if (bValue === "true") {
      return true;
    } else if (bValue === "false") {
      return false;
    }
    return value;
  }
  function addField(type2, value) {
    var key;
    if (options.compact) {
      if (!currentElement[options[type2 + "Key"]] && (isArray(options.alwaysArray) ? options.alwaysArray.indexOf(options[type2 + "Key"]) !== -1 : options.alwaysArray)) {
        currentElement[options[type2 + "Key"]] = [];
      }
      if (currentElement[options[type2 + "Key"]] && !isArray(currentElement[options[type2 + "Key"]])) {
        currentElement[options[type2 + "Key"]] = [currentElement[options[type2 + "Key"]]];
      }
      if (type2 + "Fn" in options && typeof value === "string") {
        value = options[type2 + "Fn"](value, currentElement);
      }
      if (type2 === "instruction" && ("instructionFn" in options || "instructionNameFn" in options)) {
        for (key in value) {
          if (value.hasOwnProperty(key)) {
            if ("instructionFn" in options) {
              value[key] = options.instructionFn(value[key], key, currentElement);
            } else {
              var temp = value[key];
              delete value[key];
              value[options.instructionNameFn(key, temp, currentElement)] = temp;
            }
          }
        }
      }
      if (isArray(currentElement[options[type2 + "Key"]])) {
        currentElement[options[type2 + "Key"]].push(value);
      } else {
        currentElement[options[type2 + "Key"]] = value;
      }
    } else {
      if (!currentElement[options.elementsKey]) {
        currentElement[options.elementsKey] = [];
      }
      var element = {};
      element[options.typeKey] = type2;
      if (type2 === "instruction") {
        for (key in value) {
          if (value.hasOwnProperty(key)) {
            break;
          }
        }
        element[options.nameKey] = "instructionNameFn" in options ? options.instructionNameFn(key, value, currentElement) : key;
        if (options.instructionHasAttributes) {
          element[options.attributesKey] = value[key][options.attributesKey];
          if ("instructionFn" in options) {
            element[options.attributesKey] = options.instructionFn(element[options.attributesKey], key, currentElement);
          }
        } else {
          if ("instructionFn" in options) {
            value[key] = options.instructionFn(value[key], key, currentElement);
          }
          element[options.instructionKey] = value[key];
        }
      } else {
        if (type2 + "Fn" in options) {
          value = options[type2 + "Fn"](value, currentElement);
        }
        element[options[type2 + "Key"]] = value;
      }
      if (options.addParent) {
        element[options.parentKey] = currentElement;
      }
      currentElement[options.elementsKey].push(element);
    }
  }
  function manipulateAttributes(attributes) {
    if ("attributesFn" in options && attributes) {
      attributes = options.attributesFn(attributes, currentElement);
    }
    if ((options.trim || "attributeValueFn" in options || "attributeNameFn" in options || options.nativeTypeAttributes) && attributes) {
      var key;
      for (key in attributes) {
        if (attributes.hasOwnProperty(key)) {
          if (options.trim) attributes[key] = attributes[key].trim();
          if (options.nativeTypeAttributes) {
            attributes[key] = nativeType(attributes[key]);
          }
          if ("attributeValueFn" in options) attributes[key] = options.attributeValueFn(attributes[key], key, currentElement);
          if ("attributeNameFn" in options) {
            var temp = attributes[key];
            delete attributes[key];
            attributes[options.attributeNameFn(key, attributes[key], currentElement)] = temp;
          }
        }
      }
    }
    return attributes;
  }
  function onInstruction(instruction) {
    var attributes = {};
    if (instruction.body && (instruction.name.toLowerCase() === "xml" || options.instructionHasAttributes)) {
      var attrsRegExp = /([\w:-]+)\s*=\s*(?:"([^"]*)"|'([^']*)'|(\w+))\s*/g;
      var match;
      while ((match = attrsRegExp.exec(instruction.body)) !== null) {
        attributes[match[1]] = match[2] || match[3] || match[4];
      }
      attributes = manipulateAttributes(attributes);
    }
    if (instruction.name.toLowerCase() === "xml") {
      if (options.ignoreDeclaration) {
        return;
      }
      currentElement[options.declarationKey] = {};
      if (Object.keys(attributes).length) {
        currentElement[options.declarationKey][options.attributesKey] = attributes;
      }
      if (options.addParent) {
        currentElement[options.declarationKey][options.parentKey] = currentElement;
      }
    } else {
      if (options.ignoreInstruction) {
        return;
      }
      if (options.trim) {
        instruction.body = instruction.body.trim();
      }
      var value = {};
      if (options.instructionHasAttributes && Object.keys(attributes).length) {
        value[instruction.name] = {};
        value[instruction.name][options.attributesKey] = attributes;
      } else {
        value[instruction.name] = instruction.body;
      }
      addField("instruction", value);
    }
  }
  function onStartElement(name, attributes) {
    var element;
    if (typeof name === "object") {
      attributes = name.attributes;
      name = name.name;
    }
    attributes = manipulateAttributes(attributes);
    if ("elementNameFn" in options) {
      name = options.elementNameFn(name, currentElement);
    }
    if (options.compact) {
      element = {};
      if (!options.ignoreAttributes && attributes && Object.keys(attributes).length) {
        element[options.attributesKey] = {};
        var key;
        for (key in attributes) {
          if (attributes.hasOwnProperty(key)) {
            element[options.attributesKey][key] = attributes[key];
          }
        }
      }
      if (!(name in currentElement) && (isArray(options.alwaysArray) ? options.alwaysArray.indexOf(name) !== -1 : options.alwaysArray)) {
        currentElement[name] = [];
      }
      if (currentElement[name] && !isArray(currentElement[name])) {
        currentElement[name] = [currentElement[name]];
      }
      if (isArray(currentElement[name])) {
        currentElement[name].push(element);
      } else {
        currentElement[name] = element;
      }
    } else {
      if (!currentElement[options.elementsKey]) {
        currentElement[options.elementsKey] = [];
      }
      element = {};
      element[options.typeKey] = "element";
      element[options.nameKey] = name;
      if (!options.ignoreAttributes && attributes && Object.keys(attributes).length) {
        element[options.attributesKey] = attributes;
      }
      if (options.alwaysChildren) {
        element[options.elementsKey] = [];
      }
      currentElement[options.elementsKey].push(element);
    }
    element[options.parentKey] = currentElement;
    currentElement = element;
  }
  function onText(text) {
    if (options.ignoreText) {
      return;
    }
    if (!text.trim() && !options.captureSpacesBetweenElements) {
      return;
    }
    if (options.trim) {
      text = text.trim();
    }
    if (options.nativeType) {
      text = nativeType(text);
    }
    if (options.sanitize) {
      text = text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }
    addField("text", text);
  }
  function onComment(comment) {
    if (options.ignoreComment) {
      return;
    }
    if (options.trim) {
      comment = comment.trim();
    }
    addField("comment", comment);
  }
  function onEndElement(name) {
    var parentElement = currentElement[options.parentKey];
    if (!options.addParent) {
      delete currentElement[options.parentKey];
    }
    currentElement = parentElement;
  }
  function onCdata(cdata) {
    if (options.ignoreCdata) {
      return;
    }
    if (options.trim) {
      cdata = cdata.trim();
    }
    addField("cdata", cdata);
  }
  function onDoctype(doctype) {
    if (options.ignoreDoctype) {
      return;
    }
    doctype = doctype.replace(/^ /, "");
    if (options.trim) {
      doctype = doctype.trim();
    }
    addField("doctype", doctype);
  }
  function onError(error) {
    error.note = error;
  }
  xml2js = function(xml2, userOptions) {
    var parser = sax2.parser(true, {});
    var result = {};
    currentElement = result;
    options = validateOptions(userOptions);
    {
      parser.opt = { strictEntities: true };
      parser.onopentag = onStartElement;
      parser.ontext = onText;
      parser.oncomment = onComment;
      parser.onclosetag = onEndElement;
      parser.onerror = onError;
      parser.oncdata = onCdata;
      parser.ondoctype = onDoctype;
      parser.onprocessinginstruction = onInstruction;
    }
    {
      parser.write(xml2).close();
    }
    if (result[options.elementsKey]) {
      var temp = result[options.elementsKey];
      delete result[options.elementsKey];
      result[options.elementsKey] = temp;
      delete result.text;
    }
    return result;
  };
  return xml2js;
}
function requireXml2json() {
  if (hasRequiredXml2json) return xml2json;
  hasRequiredXml2json = 1;
  var helper = requireOptionsHelper();
  var xml2js2 = requireXml2js();
  function validateOptions(userOptions) {
    var options = helper.copyOptions(userOptions);
    helper.ensureSpacesExists(options);
    return options;
  }
  xml2json = function(xml2, userOptions) {
    var options, js, json, parentKey;
    options = validateOptions(userOptions);
    js = xml2js2(xml2, options);
    parentKey = "compact" in options && options.compact ? "_parent" : "parent";
    if ("addParent" in options && options.addParent) {
      json = JSON.stringify(js, function(k, v) {
        return k === parentKey ? "_" : v;
      }, options.spaces);
    } else {
      json = JSON.stringify(js, null, options.spaces);
    }
    return json.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
  };
  return xml2json;
}
function requireJs2xml() {
  if (hasRequiredJs2xml) return js2xml;
  hasRequiredJs2xml = 1;
  var helper = requireOptionsHelper();
  var isArray = requireArrayHelper().isArray;
  var currentElement, currentElementName;
  function validateOptions(userOptions) {
    var options = helper.copyOptions(userOptions);
    helper.ensureFlagExists("ignoreDeclaration", options);
    helper.ensureFlagExists("ignoreInstruction", options);
    helper.ensureFlagExists("ignoreAttributes", options);
    helper.ensureFlagExists("ignoreText", options);
    helper.ensureFlagExists("ignoreComment", options);
    helper.ensureFlagExists("ignoreCdata", options);
    helper.ensureFlagExists("ignoreDoctype", options);
    helper.ensureFlagExists("compact", options);
    helper.ensureFlagExists("indentText", options);
    helper.ensureFlagExists("indentCdata", options);
    helper.ensureFlagExists("indentAttributes", options);
    helper.ensureFlagExists("indentInstruction", options);
    helper.ensureFlagExists("fullTagEmptyElement", options);
    helper.ensureFlagExists("noQuotesForNativeAttributes", options);
    helper.ensureSpacesExists(options);
    if (typeof options.spaces === "number") {
      options.spaces = Array(options.spaces + 1).join(" ");
    }
    helper.ensureKeyExists("declaration", options);
    helper.ensureKeyExists("instruction", options);
    helper.ensureKeyExists("attributes", options);
    helper.ensureKeyExists("text", options);
    helper.ensureKeyExists("comment", options);
    helper.ensureKeyExists("cdata", options);
    helper.ensureKeyExists("doctype", options);
    helper.ensureKeyExists("type", options);
    helper.ensureKeyExists("name", options);
    helper.ensureKeyExists("elements", options);
    helper.checkFnExists("doctype", options);
    helper.checkFnExists("instruction", options);
    helper.checkFnExists("cdata", options);
    helper.checkFnExists("comment", options);
    helper.checkFnExists("text", options);
    helper.checkFnExists("instructionName", options);
    helper.checkFnExists("elementName", options);
    helper.checkFnExists("attributeName", options);
    helper.checkFnExists("attributeValue", options);
    helper.checkFnExists("attributes", options);
    helper.checkFnExists("fullTagEmptyElement", options);
    return options;
  }
  function writeIndentation(options, depth, firstLine) {
    return (!firstLine && options.spaces ? "\n" : "") + Array(depth + 1).join(options.spaces);
  }
  function writeAttributes(attributes, options, depth) {
    if (options.ignoreAttributes) {
      return "";
    }
    if ("attributesFn" in options) {
      attributes = options.attributesFn(attributes, currentElementName, currentElement);
    }
    var key, attr, attrName, quote, result = [];
    for (key in attributes) {
      if (attributes.hasOwnProperty(key) && attributes[key] !== null && attributes[key] !== void 0) {
        quote = options.noQuotesForNativeAttributes && typeof attributes[key] !== "string" ? "" : '"';
        attr = "" + attributes[key];
        attr = attr.replace(/"/g, "&quot;");
        attrName = "attributeNameFn" in options ? options.attributeNameFn(key, attr, currentElementName, currentElement) : key;
        result.push(options.spaces && options.indentAttributes ? writeIndentation(options, depth + 1, false) : " ");
        result.push(attrName + "=" + quote + ("attributeValueFn" in options ? options.attributeValueFn(attr, key, currentElementName, currentElement) : attr) + quote);
      }
    }
    if (attributes && Object.keys(attributes).length && options.spaces && options.indentAttributes) {
      result.push(writeIndentation(options, depth, false));
    }
    return result.join("");
  }
  function writeDeclaration(declaration, options, depth) {
    currentElement = declaration;
    currentElementName = "xml";
    return options.ignoreDeclaration ? "" : "<?xml" + writeAttributes(declaration[options.attributesKey], options, depth) + "?>";
  }
  function writeInstruction(instruction, options, depth) {
    if (options.ignoreInstruction) {
      return "";
    }
    var key;
    for (key in instruction) {
      if (instruction.hasOwnProperty(key)) {
        break;
      }
    }
    var instructionName = "instructionNameFn" in options ? options.instructionNameFn(key, instruction[key], currentElementName, currentElement) : key;
    if (typeof instruction[key] === "object") {
      currentElement = instruction;
      currentElementName = instructionName;
      return "<?" + instructionName + writeAttributes(instruction[key][options.attributesKey], options, depth) + "?>";
    } else {
      var instructionValue = instruction[key] ? instruction[key] : "";
      if ("instructionFn" in options) instructionValue = options.instructionFn(instructionValue, key, currentElementName, currentElement);
      return "<?" + instructionName + (instructionValue ? " " + instructionValue : "") + "?>";
    }
  }
  function writeComment(comment, options) {
    return options.ignoreComment ? "" : "<!--" + ("commentFn" in options ? options.commentFn(comment, currentElementName, currentElement) : comment) + "-->";
  }
  function writeCdata(cdata, options) {
    return options.ignoreCdata ? "" : "<![CDATA[" + ("cdataFn" in options ? options.cdataFn(cdata, currentElementName, currentElement) : cdata.replace("]]>", "]]]]><![CDATA[>")) + "]]>";
  }
  function writeDoctype(doctype, options) {
    return options.ignoreDoctype ? "" : "<!DOCTYPE " + ("doctypeFn" in options ? options.doctypeFn(doctype, currentElementName, currentElement) : doctype) + ">";
  }
  function writeText(text, options) {
    if (options.ignoreText) return "";
    text = "" + text;
    text = text.replace(/&amp;/g, "&");
    text = text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    return "textFn" in options ? options.textFn(text, currentElementName, currentElement) : text;
  }
  function hasContent(element, options) {
    var i;
    if (element.elements && element.elements.length) {
      for (i = 0; i < element.elements.length; ++i) {
        switch (element.elements[i][options.typeKey]) {
          case "text":
            if (options.indentText) {
              return true;
            }
            break;
          // skip to next key
          case "cdata":
            if (options.indentCdata) {
              return true;
            }
            break;
          // skip to next key
          case "instruction":
            if (options.indentInstruction) {
              return true;
            }
            break;
          // skip to next key
          case "doctype":
          case "comment":
          case "element":
            return true;
          default:
            return true;
        }
      }
    }
    return false;
  }
  function writeElement(element, options, depth) {
    currentElement = element;
    currentElementName = element.name;
    var xml2 = [], elementName = "elementNameFn" in options ? options.elementNameFn(element.name, element) : element.name;
    xml2.push("<" + elementName);
    if (element[options.attributesKey]) {
      xml2.push(writeAttributes(element[options.attributesKey], options, depth));
    }
    var withClosingTag = element[options.elementsKey] && element[options.elementsKey].length || element[options.attributesKey] && element[options.attributesKey]["xml:space"] === "preserve";
    if (!withClosingTag) {
      if ("fullTagEmptyElementFn" in options) {
        withClosingTag = options.fullTagEmptyElementFn(element.name, element);
      } else {
        withClosingTag = options.fullTagEmptyElement;
      }
    }
    if (withClosingTag) {
      xml2.push(">");
      if (element[options.elementsKey] && element[options.elementsKey].length) {
        xml2.push(writeElements(element[options.elementsKey], options, depth + 1));
        currentElement = element;
        currentElementName = element.name;
      }
      xml2.push(options.spaces && hasContent(element, options) ? "\n" + Array(depth + 1).join(options.spaces) : "");
      xml2.push("</" + elementName + ">");
    } else {
      xml2.push("/>");
    }
    return xml2.join("");
  }
  function writeElements(elements, options, depth, firstLine) {
    return elements.reduce(function(xml2, element) {
      var indent = writeIndentation(options, depth, firstLine && !xml2);
      switch (element.type) {
        case "element":
          return xml2 + indent + writeElement(element, options, depth);
        case "comment":
          return xml2 + indent + writeComment(element[options.commentKey], options);
        case "doctype":
          return xml2 + indent + writeDoctype(element[options.doctypeKey], options);
        case "cdata":
          return xml2 + (options.indentCdata ? indent : "") + writeCdata(element[options.cdataKey], options);
        case "text":
          return xml2 + (options.indentText ? indent : "") + writeText(element[options.textKey], options);
        case "instruction":
          var instruction = {};
          instruction[element[options.nameKey]] = element[options.attributesKey] ? element : element[options.instructionKey];
          return xml2 + (options.indentInstruction ? indent : "") + writeInstruction(instruction, options, depth);
      }
    }, "");
  }
  function hasContentCompact(element, options, anyContent) {
    var key;
    for (key in element) {
      if (element.hasOwnProperty(key)) {
        switch (key) {
          case options.parentKey:
          case options.attributesKey:
            break;
          // skip to next key
          case options.textKey:
            if (options.indentText || anyContent) {
              return true;
            }
            break;
          // skip to next key
          case options.cdataKey:
            if (options.indentCdata || anyContent) {
              return true;
            }
            break;
          // skip to next key
          case options.instructionKey:
            if (options.indentInstruction || anyContent) {
              return true;
            }
            break;
          // skip to next key
          case options.doctypeKey:
          case options.commentKey:
            return true;
          default:
            return true;
        }
      }
    }
    return false;
  }
  function writeElementCompact(element, name, options, depth, indent) {
    currentElement = element;
    currentElementName = name;
    var elementName = "elementNameFn" in options ? options.elementNameFn(name, element) : name;
    if (typeof element === "undefined" || element === null || element === "") {
      return "fullTagEmptyElementFn" in options && options.fullTagEmptyElementFn(name, element) || options.fullTagEmptyElement ? "<" + elementName + "></" + elementName + ">" : "<" + elementName + "/>";
    }
    var xml2 = [];
    if (name) {
      xml2.push("<" + elementName);
      if (typeof element !== "object") {
        xml2.push(">" + writeText(element, options) + "</" + elementName + ">");
        return xml2.join("");
      }
      if (element[options.attributesKey]) {
        xml2.push(writeAttributes(element[options.attributesKey], options, depth));
      }
      var withClosingTag = hasContentCompact(element, options, true) || element[options.attributesKey] && element[options.attributesKey]["xml:space"] === "preserve";
      if (!withClosingTag) {
        if ("fullTagEmptyElementFn" in options) {
          withClosingTag = options.fullTagEmptyElementFn(name, element);
        } else {
          withClosingTag = options.fullTagEmptyElement;
        }
      }
      if (withClosingTag) {
        xml2.push(">");
      } else {
        xml2.push("/>");
        return xml2.join("");
      }
    }
    xml2.push(writeElementsCompact(element, options, depth + 1, false));
    currentElement = element;
    currentElementName = name;
    if (name) {
      xml2.push((indent ? writeIndentation(options, depth, false) : "") + "</" + elementName + ">");
    }
    return xml2.join("");
  }
  function writeElementsCompact(element, options, depth, firstLine) {
    var i, key, nodes, xml2 = [];
    for (key in element) {
      if (element.hasOwnProperty(key)) {
        nodes = isArray(element[key]) ? element[key] : [element[key]];
        for (i = 0; i < nodes.length; ++i) {
          switch (key) {
            case options.declarationKey:
              xml2.push(writeDeclaration(nodes[i], options, depth));
              break;
            case options.instructionKey:
              xml2.push((options.indentInstruction ? writeIndentation(options, depth, firstLine) : "") + writeInstruction(nodes[i], options, depth));
              break;
            case options.attributesKey:
            case options.parentKey:
              break;
            // skip
            case options.textKey:
              xml2.push((options.indentText ? writeIndentation(options, depth, firstLine) : "") + writeText(nodes[i], options));
              break;
            case options.cdataKey:
              xml2.push((options.indentCdata ? writeIndentation(options, depth, firstLine) : "") + writeCdata(nodes[i], options));
              break;
            case options.doctypeKey:
              xml2.push(writeIndentation(options, depth, firstLine) + writeDoctype(nodes[i], options));
              break;
            case options.commentKey:
              xml2.push(writeIndentation(options, depth, firstLine) + writeComment(nodes[i], options));
              break;
            default:
              xml2.push(writeIndentation(options, depth, firstLine) + writeElementCompact(nodes[i], key, options, depth, hasContentCompact(nodes[i], options)));
          }
          firstLine = firstLine && !xml2.length;
        }
      }
    }
    return xml2.join("");
  }
  js2xml = function(js, options) {
    options = validateOptions(options);
    var xml2 = [];
    currentElement = js;
    currentElementName = "_root_";
    if (options.compact) {
      xml2.push(writeElementsCompact(js, options, 0, true));
    } else {
      if (js[options.declarationKey]) {
        xml2.push(writeDeclaration(js[options.declarationKey], options, 0));
      }
      if (js[options.elementsKey] && js[options.elementsKey].length) {
        xml2.push(writeElements(js[options.elementsKey], options, 0, !xml2.length));
      }
    }
    return xml2.join("");
  };
  return js2xml;
}
function requireJson2xml() {
  if (hasRequiredJson2xml) return json2xml;
  hasRequiredJson2xml = 1;
  var js2xml2 = requireJs2xml();
  json2xml = function(json, options) {
    if (json instanceof Buffer) {
      json = json.toString();
    }
    var js = null;
    if (typeof json === "string") {
      try {
        js = JSON.parse(json);
      } catch (e) {
        throw new Error("The JSON structure is invalid");
      }
    } else {
      js = json;
    }
    return js2xml2(js, options);
  };
  return json2xml;
}
function requireLib() {
  if (hasRequiredLib) return lib;
  hasRequiredLib = 1;
  var xml2js2 = requireXml2js();
  var xml2json2 = requireXml2json();
  var js2xml2 = requireJs2xml();
  var json2xml2 = requireJson2xml();
  lib = {
    xml2js: xml2js2,
    xml2json: xml2json2,
    js2xml: js2xml2,
    json2xml: json2xml2
  };
  return lib;
}
function requireMinimalisticAssert() {
  if (hasRequiredMinimalisticAssert) return minimalisticAssert;
  hasRequiredMinimalisticAssert = 1;
  minimalisticAssert = assert;
  function assert(val, msg) {
    if (!val)
      throw new Error(msg || "Assertion failed");
  }
  assert.equal = function assertEqual(l, r, msg) {
    if (l != r)
      throw new Error(msg || "Assertion failed: " + l + " != " + r);
  };
  return minimalisticAssert;
}
function requireUtils() {
  if (hasRequiredUtils) return utils;
  hasRequiredUtils = 1;
  var assert = requireMinimalisticAssert();
  var inherits = requireInherits_browser();
  utils.inherits = inherits;
  function isSurrogatePair(msg, i) {
    if ((msg.charCodeAt(i) & 64512) !== 55296) {
      return false;
    }
    if (i < 0 || i + 1 >= msg.length) {
      return false;
    }
    return (msg.charCodeAt(i + 1) & 64512) === 56320;
  }
  function toArray(msg, enc) {
    if (Array.isArray(msg))
      return msg.slice();
    if (!msg)
      return [];
    var res = [];
    if (typeof msg === "string") {
      if (!enc) {
        var p = 0;
        for (var i = 0; i < msg.length; i++) {
          var c = msg.charCodeAt(i);
          if (c < 128) {
            res[p++] = c;
          } else if (c < 2048) {
            res[p++] = c >> 6 | 192;
            res[p++] = c & 63 | 128;
          } else if (isSurrogatePair(msg, i)) {
            c = 65536 + ((c & 1023) << 10) + (msg.charCodeAt(++i) & 1023);
            res[p++] = c >> 18 | 240;
            res[p++] = c >> 12 & 63 | 128;
            res[p++] = c >> 6 & 63 | 128;
            res[p++] = c & 63 | 128;
          } else {
            res[p++] = c >> 12 | 224;
            res[p++] = c >> 6 & 63 | 128;
            res[p++] = c & 63 | 128;
          }
        }
      } else if (enc === "hex") {
        msg = msg.replace(/[^a-z0-9]+/ig, "");
        if (msg.length % 2 !== 0)
          msg = "0" + msg;
        for (i = 0; i < msg.length; i += 2)
          res.push(parseInt(msg[i] + msg[i + 1], 16));
      }
    } else {
      for (i = 0; i < msg.length; i++)
        res[i] = msg[i] | 0;
    }
    return res;
  }
  utils.toArray = toArray;
  function toHex(msg) {
    var res = "";
    for (var i = 0; i < msg.length; i++)
      res += zero2(msg[i].toString(16));
    return res;
  }
  utils.toHex = toHex;
  function htonl(w) {
    var res = w >>> 24 | w >>> 8 & 65280 | w << 8 & 16711680 | (w & 255) << 24;
    return res >>> 0;
  }
  utils.htonl = htonl;
  function toHex32(msg, endian) {
    var res = "";
    for (var i = 0; i < msg.length; i++) {
      var w = msg[i];
      if (endian === "little")
        w = htonl(w);
      res += zero8(w.toString(16));
    }
    return res;
  }
  utils.toHex32 = toHex32;
  function zero2(word) {
    if (word.length === 1)
      return "0" + word;
    else
      return word;
  }
  utils.zero2 = zero2;
  function zero8(word) {
    if (word.length === 7)
      return "0" + word;
    else if (word.length === 6)
      return "00" + word;
    else if (word.length === 5)
      return "000" + word;
    else if (word.length === 4)
      return "0000" + word;
    else if (word.length === 3)
      return "00000" + word;
    else if (word.length === 2)
      return "000000" + word;
    else if (word.length === 1)
      return "0000000" + word;
    else
      return word;
  }
  utils.zero8 = zero8;
  function join32(msg, start, end, endian) {
    var len = end - start;
    assert(len % 4 === 0);
    var res = new Array(len / 4);
    for (var i = 0, k = start; i < res.length; i++, k += 4) {
      var w;
      if (endian === "big")
        w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3];
      else
        w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];
      res[i] = w >>> 0;
    }
    return res;
  }
  utils.join32 = join32;
  function split32(msg, endian) {
    var res = new Array(msg.length * 4);
    for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
      var m = msg[i];
      if (endian === "big") {
        res[k] = m >>> 24;
        res[k + 1] = m >>> 16 & 255;
        res[k + 2] = m >>> 8 & 255;
        res[k + 3] = m & 255;
      } else {
        res[k + 3] = m >>> 24;
        res[k + 2] = m >>> 16 & 255;
        res[k + 1] = m >>> 8 & 255;
        res[k] = m & 255;
      }
    }
    return res;
  }
  utils.split32 = split32;
  function rotr32(w, b) {
    return w >>> b | w << 32 - b;
  }
  utils.rotr32 = rotr32;
  function rotl32(w, b) {
    return w << b | w >>> 32 - b;
  }
  utils.rotl32 = rotl32;
  function sum32(a, b) {
    return a + b >>> 0;
  }
  utils.sum32 = sum32;
  function sum32_3(a, b, c) {
    return a + b + c >>> 0;
  }
  utils.sum32_3 = sum32_3;
  function sum32_4(a, b, c, d) {
    return a + b + c + d >>> 0;
  }
  utils.sum32_4 = sum32_4;
  function sum32_5(a, b, c, d, e) {
    return a + b + c + d + e >>> 0;
  }
  utils.sum32_5 = sum32_5;
  function sum64(buf, pos, ah, al) {
    var bh = buf[pos];
    var bl = buf[pos + 1];
    var lo = al + bl >>> 0;
    var hi = (lo < al ? 1 : 0) + ah + bh;
    buf[pos] = hi >>> 0;
    buf[pos + 1] = lo;
  }
  utils.sum64 = sum64;
  function sum64_hi(ah, al, bh, bl) {
    var lo = al + bl >>> 0;
    var hi = (lo < al ? 1 : 0) + ah + bh;
    return hi >>> 0;
  }
  utils.sum64_hi = sum64_hi;
  function sum64_lo(ah, al, bh, bl) {
    var lo = al + bl;
    return lo >>> 0;
  }
  utils.sum64_lo = sum64_lo;
  function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
    var carry = 0;
    var lo = al;
    lo = lo + bl >>> 0;
    carry += lo < al ? 1 : 0;
    lo = lo + cl >>> 0;
    carry += lo < cl ? 1 : 0;
    lo = lo + dl >>> 0;
    carry += lo < dl ? 1 : 0;
    var hi = ah + bh + ch + dh + carry;
    return hi >>> 0;
  }
  utils.sum64_4_hi = sum64_4_hi;
  function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
    var lo = al + bl + cl + dl;
    return lo >>> 0;
  }
  utils.sum64_4_lo = sum64_4_lo;
  function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
    var carry = 0;
    var lo = al;
    lo = lo + bl >>> 0;
    carry += lo < al ? 1 : 0;
    lo = lo + cl >>> 0;
    carry += lo < cl ? 1 : 0;
    lo = lo + dl >>> 0;
    carry += lo < dl ? 1 : 0;
    lo = lo + el >>> 0;
    carry += lo < el ? 1 : 0;
    var hi = ah + bh + ch + dh + eh + carry;
    return hi >>> 0;
  }
  utils.sum64_5_hi = sum64_5_hi;
  function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
    var lo = al + bl + cl + dl + el;
    return lo >>> 0;
  }
  utils.sum64_5_lo = sum64_5_lo;
  function rotr64_hi(ah, al, num) {
    var r = al << 32 - num | ah >>> num;
    return r >>> 0;
  }
  utils.rotr64_hi = rotr64_hi;
  function rotr64_lo(ah, al, num) {
    var r = ah << 32 - num | al >>> num;
    return r >>> 0;
  }
  utils.rotr64_lo = rotr64_lo;
  function shr64_hi(ah, al, num) {
    return ah >>> num;
  }
  utils.shr64_hi = shr64_hi;
  function shr64_lo(ah, al, num) {
    var r = ah << 32 - num | al >>> num;
    return r >>> 0;
  }
  utils.shr64_lo = shr64_lo;
  return utils;
}
function requireCommon$1() {
  if (hasRequiredCommon$1) return common$1;
  hasRequiredCommon$1 = 1;
  var utils2 = requireUtils();
  var assert = requireMinimalisticAssert();
  function BlockHash() {
    this.pending = null;
    this.pendingTotal = 0;
    this.blockSize = this.constructor.blockSize;
    this.outSize = this.constructor.outSize;
    this.hmacStrength = this.constructor.hmacStrength;
    this.padLength = this.constructor.padLength / 8;
    this.endian = "big";
    this._delta8 = this.blockSize / 8;
    this._delta32 = this.blockSize / 32;
  }
  common$1.BlockHash = BlockHash;
  BlockHash.prototype.update = function update(msg, enc) {
    msg = utils2.toArray(msg, enc);
    if (!this.pending)
      this.pending = msg;
    else
      this.pending = this.pending.concat(msg);
    this.pendingTotal += msg.length;
    if (this.pending.length >= this._delta8) {
      msg = this.pending;
      var r = msg.length % this._delta8;
      this.pending = msg.slice(msg.length - r, msg.length);
      if (this.pending.length === 0)
        this.pending = null;
      msg = utils2.join32(msg, 0, msg.length - r, this.endian);
      for (var i = 0; i < msg.length; i += this._delta32)
        this._update(msg, i, i + this._delta32);
    }
    return this;
  };
  BlockHash.prototype.digest = function digest(enc) {
    this.update(this._pad());
    assert(this.pending === null);
    return this._digest(enc);
  };
  BlockHash.prototype._pad = function pad() {
    var len = this.pendingTotal;
    var bytes = this._delta8;
    var k = bytes - (len + this.padLength) % bytes;
    var res = new Array(k + this.padLength);
    res[0] = 128;
    for (var i = 1; i < k; i++)
      res[i] = 0;
    len <<= 3;
    if (this.endian === "big") {
      for (var t = 8; t < this.padLength; t++)
        res[i++] = 0;
      res[i++] = 0;
      res[i++] = 0;
      res[i++] = 0;
      res[i++] = 0;
      res[i++] = len >>> 24 & 255;
      res[i++] = len >>> 16 & 255;
      res[i++] = len >>> 8 & 255;
      res[i++] = len & 255;
    } else {
      res[i++] = len & 255;
      res[i++] = len >>> 8 & 255;
      res[i++] = len >>> 16 & 255;
      res[i++] = len >>> 24 & 255;
      res[i++] = 0;
      res[i++] = 0;
      res[i++] = 0;
      res[i++] = 0;
      for (t = 8; t < this.padLength; t++)
        res[i++] = 0;
    }
    return res;
  };
  return common$1;
}
function requireCommon() {
  if (hasRequiredCommon) return common;
  hasRequiredCommon = 1;
  var utils2 = requireUtils();
  var rotr32 = utils2.rotr32;
  function ft_1(s, x, y, z) {
    if (s === 0)
      return ch32(x, y, z);
    if (s === 1 || s === 3)
      return p32(x, y, z);
    if (s === 2)
      return maj32(x, y, z);
  }
  common.ft_1 = ft_1;
  function ch32(x, y, z) {
    return x & y ^ ~x & z;
  }
  common.ch32 = ch32;
  function maj32(x, y, z) {
    return x & y ^ x & z ^ y & z;
  }
  common.maj32 = maj32;
  function p32(x, y, z) {
    return x ^ y ^ z;
  }
  common.p32 = p32;
  function s0_256(x) {
    return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
  }
  common.s0_256 = s0_256;
  function s1_256(x) {
    return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
  }
  common.s1_256 = s1_256;
  function g0_256(x) {
    return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;
  }
  common.g0_256 = g0_256;
  function g1_256(x) {
    return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;
  }
  common.g1_256 = g1_256;
  return common;
}
function require_1() {
  if (hasRequired_1) return _1;
  hasRequired_1 = 1;
  var utils2 = requireUtils();
  var common2 = requireCommon$1();
  var shaCommon = requireCommon();
  var rotl32 = utils2.rotl32;
  var sum32 = utils2.sum32;
  var sum32_5 = utils2.sum32_5;
  var ft_1 = shaCommon.ft_1;
  var BlockHash = common2.BlockHash;
  var sha1_K = [
    1518500249,
    1859775393,
    2400959708,
    3395469782
  ];
  function SHA1() {
    if (!(this instanceof SHA1))
      return new SHA1();
    BlockHash.call(this);
    this.h = [
      1732584193,
      4023233417,
      2562383102,
      271733878,
      3285377520
    ];
    this.W = new Array(80);
  }
  utils2.inherits(SHA1, BlockHash);
  _1 = SHA1;
  SHA1.blockSize = 512;
  SHA1.outSize = 160;
  SHA1.hmacStrength = 80;
  SHA1.padLength = 64;
  SHA1.prototype._update = function _update(msg, start) {
    var W = this.W;
    for (var i = 0; i < 16; i++)
      W[i] = msg[start + i];
    for (; i < W.length; i++)
      W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
    var a = this.h[0];
    var b = this.h[1];
    var c = this.h[2];
    var d = this.h[3];
    var e = this.h[4];
    for (i = 0; i < W.length; i++) {
      var s = ~~(i / 20);
      var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
      e = d;
      d = c;
      c = rotl32(b, 30);
      b = a;
      a = t;
    }
    this.h[0] = sum32(this.h[0], a);
    this.h[1] = sum32(this.h[1], b);
    this.h[2] = sum32(this.h[2], c);
    this.h[3] = sum32(this.h[3], d);
    this.h[4] = sum32(this.h[4], e);
  };
  SHA1.prototype._digest = function digest(enc) {
    if (enc === "hex")
      return utils2.toHex32(this.h, "big");
    else
      return utils2.split32(this.h, "big");
  };
  return _1;
}
function require_256() {
  if (hasRequired_256) return _256;
  hasRequired_256 = 1;
  var utils2 = requireUtils();
  var common2 = requireCommon$1();
  var shaCommon = requireCommon();
  var assert = requireMinimalisticAssert();
  var sum32 = utils2.sum32;
  var sum32_4 = utils2.sum32_4;
  var sum32_5 = utils2.sum32_5;
  var ch32 = shaCommon.ch32;
  var maj32 = shaCommon.maj32;
  var s0_256 = shaCommon.s0_256;
  var s1_256 = shaCommon.s1_256;
  var g0_256 = shaCommon.g0_256;
  var g1_256 = shaCommon.g1_256;
  var BlockHash = common2.BlockHash;
  var sha256_K = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ];
  function SHA256() {
    if (!(this instanceof SHA256))
      return new SHA256();
    BlockHash.call(this);
    this.h = [
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ];
    this.k = sha256_K;
    this.W = new Array(64);
  }
  utils2.inherits(SHA256, BlockHash);
  _256 = SHA256;
  SHA256.blockSize = 512;
  SHA256.outSize = 256;
  SHA256.hmacStrength = 192;
  SHA256.padLength = 64;
  SHA256.prototype._update = function _update(msg, start) {
    var W = this.W;
    for (var i = 0; i < 16; i++)
      W[i] = msg[start + i];
    for (; i < W.length; i++)
      W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);
    var a = this.h[0];
    var b = this.h[1];
    var c = this.h[2];
    var d = this.h[3];
    var e = this.h[4];
    var f = this.h[5];
    var g = this.h[6];
    var h = this.h[7];
    assert(this.k.length === W.length);
    for (i = 0; i < W.length; i++) {
      var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
      var T2 = sum32(s0_256(a), maj32(a, b, c));
      h = g;
      g = f;
      f = e;
      e = sum32(d, T1);
      d = c;
      c = b;
      b = a;
      a = sum32(T1, T2);
    }
    this.h[0] = sum32(this.h[0], a);
    this.h[1] = sum32(this.h[1], b);
    this.h[2] = sum32(this.h[2], c);
    this.h[3] = sum32(this.h[3], d);
    this.h[4] = sum32(this.h[4], e);
    this.h[5] = sum32(this.h[5], f);
    this.h[6] = sum32(this.h[6], g);
    this.h[7] = sum32(this.h[7], h);
  };
  SHA256.prototype._digest = function digest(enc) {
    if (enc === "hex")
      return utils2.toHex32(this.h, "big");
    else
      return utils2.split32(this.h, "big");
  };
  return _256;
}
function require_224() {
  if (hasRequired_224) return _224;
  hasRequired_224 = 1;
  var utils2 = requireUtils();
  var SHA256 = require_256();
  function SHA224() {
    if (!(this instanceof SHA224))
      return new SHA224();
    SHA256.call(this);
    this.h = [
      3238371032,
      914150663,
      812702999,
      4144912697,
      4290775857,
      1750603025,
      1694076839,
      3204075428
    ];
  }
  utils2.inherits(SHA224, SHA256);
  _224 = SHA224;
  SHA224.blockSize = 512;
  SHA224.outSize = 224;
  SHA224.hmacStrength = 192;
  SHA224.padLength = 64;
  SHA224.prototype._digest = function digest(enc) {
    if (enc === "hex")
      return utils2.toHex32(this.h.slice(0, 7), "big");
    else
      return utils2.split32(this.h.slice(0, 7), "big");
  };
  return _224;
}
function require_512() {
  if (hasRequired_512) return _512;
  hasRequired_512 = 1;
  var utils2 = requireUtils();
  var common2 = requireCommon$1();
  var assert = requireMinimalisticAssert();
  var rotr64_hi = utils2.rotr64_hi;
  var rotr64_lo = utils2.rotr64_lo;
  var shr64_hi = utils2.shr64_hi;
  var shr64_lo = utils2.shr64_lo;
  var sum64 = utils2.sum64;
  var sum64_hi = utils2.sum64_hi;
  var sum64_lo = utils2.sum64_lo;
  var sum64_4_hi = utils2.sum64_4_hi;
  var sum64_4_lo = utils2.sum64_4_lo;
  var sum64_5_hi = utils2.sum64_5_hi;
  var sum64_5_lo = utils2.sum64_5_lo;
  var BlockHash = common2.BlockHash;
  var sha512_K = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ];
  function SHA512() {
    if (!(this instanceof SHA512))
      return new SHA512();
    BlockHash.call(this);
    this.h = [
      1779033703,
      4089235720,
      3144134277,
      2227873595,
      1013904242,
      4271175723,
      2773480762,
      1595750129,
      1359893119,
      2917565137,
      2600822924,
      725511199,
      528734635,
      4215389547,
      1541459225,
      327033209
    ];
    this.k = sha512_K;
    this.W = new Array(160);
  }
  utils2.inherits(SHA512, BlockHash);
  _512 = SHA512;
  SHA512.blockSize = 1024;
  SHA512.outSize = 512;
  SHA512.hmacStrength = 192;
  SHA512.padLength = 128;
  SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
    var W = this.W;
    for (var i = 0; i < 32; i++)
      W[i] = msg[start + i];
    for (; i < W.length; i += 2) {
      var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);
      var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
      var c1_hi = W[i - 14];
      var c1_lo = W[i - 13];
      var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);
      var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
      var c3_hi = W[i - 32];
      var c3_lo = W[i - 31];
      W[i] = sum64_4_hi(
        c0_hi,
        c0_lo,
        c1_hi,
        c1_lo,
        c2_hi,
        c2_lo,
        c3_hi,
        c3_lo
      );
      W[i + 1] = sum64_4_lo(
        c0_hi,
        c0_lo,
        c1_hi,
        c1_lo,
        c2_hi,
        c2_lo,
        c3_hi,
        c3_lo
      );
    }
  };
  SHA512.prototype._update = function _update(msg, start) {
    this._prepareBlock(msg, start);
    var W = this.W;
    var ah = this.h[0];
    var al = this.h[1];
    var bh = this.h[2];
    var bl = this.h[3];
    var ch = this.h[4];
    var cl = this.h[5];
    var dh = this.h[6];
    var dl = this.h[7];
    var eh = this.h[8];
    var el = this.h[9];
    var fh = this.h[10];
    var fl = this.h[11];
    var gh = this.h[12];
    var gl = this.h[13];
    var hh = this.h[14];
    var hl = this.h[15];
    assert(this.k.length === W.length);
    for (var i = 0; i < W.length; i += 2) {
      var c0_hi = hh;
      var c0_lo = hl;
      var c1_hi = s1_512_hi(eh, el);
      var c1_lo = s1_512_lo(eh, el);
      var c2_hi = ch64_hi(eh, el, fh, fl, gh);
      var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
      var c3_hi = this.k[i];
      var c3_lo = this.k[i + 1];
      var c4_hi = W[i];
      var c4_lo = W[i + 1];
      var T1_hi = sum64_5_hi(
        c0_hi,
        c0_lo,
        c1_hi,
        c1_lo,
        c2_hi,
        c2_lo,
        c3_hi,
        c3_lo,
        c4_hi,
        c4_lo
      );
      var T1_lo = sum64_5_lo(
        c0_hi,
        c0_lo,
        c1_hi,
        c1_lo,
        c2_hi,
        c2_lo,
        c3_hi,
        c3_lo,
        c4_hi,
        c4_lo
      );
      c0_hi = s0_512_hi(ah, al);
      c0_lo = s0_512_lo(ah, al);
      c1_hi = maj64_hi(ah, al, bh, bl, ch);
      c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
      var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
      var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
      hh = gh;
      hl = gl;
      gh = fh;
      gl = fl;
      fh = eh;
      fl = el;
      eh = sum64_hi(dh, dl, T1_hi, T1_lo);
      el = sum64_lo(dl, dl, T1_hi, T1_lo);
      dh = ch;
      dl = cl;
      ch = bh;
      cl = bl;
      bh = ah;
      bl = al;
      ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
      al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
    }
    sum64(this.h, 0, ah, al);
    sum64(this.h, 2, bh, bl);
    sum64(this.h, 4, ch, cl);
    sum64(this.h, 6, dh, dl);
    sum64(this.h, 8, eh, el);
    sum64(this.h, 10, fh, fl);
    sum64(this.h, 12, gh, gl);
    sum64(this.h, 14, hh, hl);
  };
  SHA512.prototype._digest = function digest(enc) {
    if (enc === "hex")
      return utils2.toHex32(this.h, "big");
    else
      return utils2.split32(this.h, "big");
  };
  function ch64_hi(xh, xl, yh, yl, zh) {
    var r = xh & yh ^ ~xh & zh;
    if (r < 0)
      r += 4294967296;
    return r;
  }
  function ch64_lo(xh, xl, yh, yl, zh, zl) {
    var r = xl & yl ^ ~xl & zl;
    if (r < 0)
      r += 4294967296;
    return r;
  }
  function maj64_hi(xh, xl, yh, yl, zh) {
    var r = xh & yh ^ xh & zh ^ yh & zh;
    if (r < 0)
      r += 4294967296;
    return r;
  }
  function maj64_lo(xh, xl, yh, yl, zh, zl) {
    var r = xl & yl ^ xl & zl ^ yl & zl;
    if (r < 0)
      r += 4294967296;
    return r;
  }
  function s0_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 28);
    var c1_hi = rotr64_hi(xl, xh, 2);
    var c2_hi = rotr64_hi(xl, xh, 7);
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0)
      r += 4294967296;
    return r;
  }
  function s0_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 28);
    var c1_lo = rotr64_lo(xl, xh, 2);
    var c2_lo = rotr64_lo(xl, xh, 7);
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0)
      r += 4294967296;
    return r;
  }
  function s1_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 14);
    var c1_hi = rotr64_hi(xh, xl, 18);
    var c2_hi = rotr64_hi(xl, xh, 9);
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0)
      r += 4294967296;
    return r;
  }
  function s1_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 14);
    var c1_lo = rotr64_lo(xh, xl, 18);
    var c2_lo = rotr64_lo(xl, xh, 9);
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0)
      r += 4294967296;
    return r;
  }
  function g0_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 1);
    var c1_hi = rotr64_hi(xh, xl, 8);
    var c2_hi = shr64_hi(xh, xl, 7);
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0)
      r += 4294967296;
    return r;
  }
  function g0_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 1);
    var c1_lo = rotr64_lo(xh, xl, 8);
    var c2_lo = shr64_lo(xh, xl, 7);
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0)
      r += 4294967296;
    return r;
  }
  function g1_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 19);
    var c1_hi = rotr64_hi(xl, xh, 29);
    var c2_hi = shr64_hi(xh, xl, 6);
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0)
      r += 4294967296;
    return r;
  }
  function g1_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 19);
    var c1_lo = rotr64_lo(xl, xh, 29);
    var c2_lo = shr64_lo(xh, xl, 6);
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0)
      r += 4294967296;
    return r;
  }
  return _512;
}
function require_384() {
  if (hasRequired_384) return _384;
  hasRequired_384 = 1;
  var utils2 = requireUtils();
  var SHA512 = require_512();
  function SHA384() {
    if (!(this instanceof SHA384))
      return new SHA384();
    SHA512.call(this);
    this.h = [
      3418070365,
      3238371032,
      1654270250,
      914150663,
      2438529370,
      812702999,
      355462360,
      4144912697,
      1731405415,
      4290775857,
      2394180231,
      1750603025,
      3675008525,
      1694076839,
      1203062813,
      3204075428
    ];
  }
  utils2.inherits(SHA384, SHA512);
  _384 = SHA384;
  SHA384.blockSize = 1024;
  SHA384.outSize = 384;
  SHA384.hmacStrength = 192;
  SHA384.padLength = 128;
  SHA384.prototype._digest = function digest(enc) {
    if (enc === "hex")
      return utils2.toHex32(this.h.slice(0, 12), "big");
    else
      return utils2.split32(this.h.slice(0, 12), "big");
  };
  return _384;
}
function requireSha() {
  if (hasRequiredSha) return sha;
  hasRequiredSha = 1;
  sha.sha1 = require_1();
  sha.sha224 = require_224();
  sha.sha256 = require_256();
  sha.sha384 = require_384();
  sha.sha512 = require_512();
  return sha;
}
function requireRipemd() {
  if (hasRequiredRipemd) return ripemd;
  hasRequiredRipemd = 1;
  var utils2 = requireUtils();
  var common2 = requireCommon$1();
  var rotl32 = utils2.rotl32;
  var sum32 = utils2.sum32;
  var sum32_3 = utils2.sum32_3;
  var sum32_4 = utils2.sum32_4;
  var BlockHash = common2.BlockHash;
  function RIPEMD160() {
    if (!(this instanceof RIPEMD160))
      return new RIPEMD160();
    BlockHash.call(this);
    this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    this.endian = "little";
  }
  utils2.inherits(RIPEMD160, BlockHash);
  ripemd.ripemd160 = RIPEMD160;
  RIPEMD160.blockSize = 512;
  RIPEMD160.outSize = 160;
  RIPEMD160.hmacStrength = 192;
  RIPEMD160.padLength = 64;
  RIPEMD160.prototype._update = function update(msg, start) {
    var A = this.h[0];
    var B = this.h[1];
    var C = this.h[2];
    var D = this.h[3];
    var E = this.h[4];
    var Ah = A;
    var Bh = B;
    var Ch = C;
    var Dh = D;
    var Eh = E;
    for (var j = 0; j < 80; j++) {
      var T = sum32(
        rotl32(
          sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
          s[j]
        ),
        E
      );
      A = E;
      E = D;
      D = rotl32(C, 10);
      C = B;
      B = T;
      T = sum32(
        rotl32(
          sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
          sh[j]
        ),
        Eh
      );
      Ah = Eh;
      Eh = Dh;
      Dh = rotl32(Ch, 10);
      Ch = Bh;
      Bh = T;
    }
    T = sum32_3(this.h[1], C, Dh);
    this.h[1] = sum32_3(this.h[2], D, Eh);
    this.h[2] = sum32_3(this.h[3], E, Ah);
    this.h[3] = sum32_3(this.h[4], A, Bh);
    this.h[4] = sum32_3(this.h[0], B, Ch);
    this.h[0] = T;
  };
  RIPEMD160.prototype._digest = function digest(enc) {
    if (enc === "hex")
      return utils2.toHex32(this.h, "little");
    else
      return utils2.split32(this.h, "little");
  };
  function f(j, x, y, z) {
    if (j <= 15)
      return x ^ y ^ z;
    else if (j <= 31)
      return x & y | ~x & z;
    else if (j <= 47)
      return (x | ~y) ^ z;
    else if (j <= 63)
      return x & z | y & ~z;
    else
      return x ^ (y | ~z);
  }
  function K(j) {
    if (j <= 15)
      return 0;
    else if (j <= 31)
      return 1518500249;
    else if (j <= 47)
      return 1859775393;
    else if (j <= 63)
      return 2400959708;
    else
      return 2840853838;
  }
  function Kh(j) {
    if (j <= 15)
      return 1352829926;
    else if (j <= 31)
      return 1548603684;
    else if (j <= 47)
      return 1836072691;
    else if (j <= 63)
      return 2053994217;
    else
      return 0;
  }
  var r = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ];
  var rh = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ];
  var s = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ];
  var sh = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ];
  return ripemd;
}
function requireHmac() {
  if (hasRequiredHmac) return hmac;
  hasRequiredHmac = 1;
  var utils2 = requireUtils();
  var assert = requireMinimalisticAssert();
  function Hmac(hash2, key, enc) {
    if (!(this instanceof Hmac))
      return new Hmac(hash2, key, enc);
    this.Hash = hash2;
    this.blockSize = hash2.blockSize / 8;
    this.outSize = hash2.outSize / 8;
    this.inner = null;
    this.outer = null;
    this._init(utils2.toArray(key, enc));
  }
  hmac = Hmac;
  Hmac.prototype._init = function init(key) {
    if (key.length > this.blockSize)
      key = new this.Hash().update(key).digest();
    assert(key.length <= this.blockSize);
    for (var i = key.length; i < this.blockSize; i++)
      key.push(0);
    for (i = 0; i < key.length; i++)
      key[i] ^= 54;
    this.inner = new this.Hash().update(key);
    for (i = 0; i < key.length; i++)
      key[i] ^= 106;
    this.outer = new this.Hash().update(key);
  };
  Hmac.prototype.update = function update(msg, enc) {
    this.inner.update(msg, enc);
    return this;
  };
  Hmac.prototype.digest = function digest(enc) {
    this.outer.update(this.inner.digest());
    return this.outer.digest(enc);
  };
  return hmac;
}
function requireHash() {
  if (hasRequiredHash) return hash$1;
  hasRequiredHash = 1;
  (function(exports2) {
    var hash2 = exports2;
    hash2.utils = requireUtils();
    hash2.common = requireCommon$1();
    hash2.sha = requireSha();
    hash2.ripemd = requireRipemd();
    hash2.hmac = requireHmac();
    hash2.sha1 = hash2.sha.sha1;
    hash2.sha256 = hash2.sha.sha256;
    hash2.sha224 = hash2.sha.sha224;
    hash2.sha384 = hash2.sha.sha384;
    hash2.sha512 = hash2.sha.sha512;
    hash2.ripemd160 = hash2.ripemd.ripemd160;
  })(hash$1);
  return hash$1;
}
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
function requireJszip_min() {
  if (hasRequiredJszip_min) return jszip_min.exports;
  hasRequiredJszip_min = 1;
  (function(module2, exports2) {
    !(function(e) {
      module2.exports = e();
    })(function() {
      return (function s(a, o, h) {
        function u(r, e2) {
          if (!o[r]) {
            if (!a[r]) {
              var t = "function" == typeof commonjsRequire && commonjsRequire;
              if (!e2 && t) return t(r, true);
              if (l) return l(r, true);
              var n = new Error("Cannot find module '" + r + "'");
              throw n.code = "MODULE_NOT_FOUND", n;
            }
            var i = o[r] = { exports: {} };
            a[r][0].call(i.exports, function(e3) {
              var t2 = a[r][1][e3];
              return u(t2 || e3);
            }, i, i.exports, s, a, o, h);
          }
          return o[r].exports;
        }
        for (var l = "function" == typeof commonjsRequire && commonjsRequire, e = 0; e < h.length; e++) u(h[e]);
        return u;
      })({ 1: [function(e, t, r) {
        var d = e("./utils"), c = e("./support"), p = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        r.encode = function(e2) {
          for (var t2, r2, n, i, s, a, o, h = [], u = 0, l = e2.length, f = l, c2 = "string" !== d.getTypeOf(e2); u < e2.length; ) f = l - u, n = c2 ? (t2 = e2[u++], r2 = u < l ? e2[u++] : 0, u < l ? e2[u++] : 0) : (t2 = e2.charCodeAt(u++), r2 = u < l ? e2.charCodeAt(u++) : 0, u < l ? e2.charCodeAt(u++) : 0), i = t2 >> 2, s = (3 & t2) << 4 | r2 >> 4, a = 1 < f ? (15 & r2) << 2 | n >> 6 : 64, o = 2 < f ? 63 & n : 64, h.push(p.charAt(i) + p.charAt(s) + p.charAt(a) + p.charAt(o));
          return h.join("");
        }, r.decode = function(e2) {
          var t2, r2, n, i, s, a, o = 0, h = 0, u = "data:";
          if (e2.substr(0, u.length) === u) throw new Error("Invalid base64 input, it looks like a data url.");
          var l, f = 3 * (e2 = e2.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
          if (e2.charAt(e2.length - 1) === p.charAt(64) && f--, e2.charAt(e2.length - 2) === p.charAt(64) && f--, f % 1 != 0) throw new Error("Invalid base64 input, bad content length.");
          for (l = c.uint8array ? new Uint8Array(0 | f) : new Array(0 | f); o < e2.length; ) t2 = p.indexOf(e2.charAt(o++)) << 2 | (i = p.indexOf(e2.charAt(o++))) >> 4, r2 = (15 & i) << 4 | (s = p.indexOf(e2.charAt(o++))) >> 2, n = (3 & s) << 6 | (a = p.indexOf(e2.charAt(o++))), l[h++] = t2, 64 !== s && (l[h++] = r2), 64 !== a && (l[h++] = n);
          return l;
        };
      }, { "./support": 30, "./utils": 32 }], 2: [function(e, t, r) {
        var n = e("./external"), i = e("./stream/DataWorker"), s = e("./stream/Crc32Probe"), a = e("./stream/DataLengthProbe");
        function o(e2, t2, r2, n2, i2) {
          this.compressedSize = e2, this.uncompressedSize = t2, this.crc32 = r2, this.compression = n2, this.compressedContent = i2;
        }
        o.prototype = { getContentWorker: function() {
          var e2 = new i(n.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a("data_length")), t2 = this;
          return e2.on("end", function() {
            if (this.streamInfo.data_length !== t2.uncompressedSize) throw new Error("Bug : uncompressed data size mismatch");
          }), e2;
        }, getCompressedWorker: function() {
          return new i(n.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
        } }, o.createWorkerFrom = function(e2, t2, r2) {
          return e2.pipe(new s()).pipe(new a("uncompressedSize")).pipe(t2.compressWorker(r2)).pipe(new a("compressedSize")).withStreamInfo("compression", t2);
        }, t.exports = o;
      }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(e, t, r) {
        var n = e("./stream/GenericWorker");
        r.STORE = { magic: "\0\0", compressWorker: function() {
          return new n("STORE compression");
        }, uncompressWorker: function() {
          return new n("STORE decompression");
        } }, r.DEFLATE = e("./flate");
      }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(e, t, r) {
        var n = e("./utils");
        var o = (function() {
          for (var e2, t2 = [], r2 = 0; r2 < 256; r2++) {
            e2 = r2;
            for (var n2 = 0; n2 < 8; n2++) e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
            t2[r2] = e2;
          }
          return t2;
        })();
        t.exports = function(e2, t2) {
          return void 0 !== e2 && e2.length ? "string" !== n.getTypeOf(e2) ? (function(e3, t3, r2, n2) {
            var i = o, s = n2 + r2;
            e3 ^= -1;
            for (var a = n2; a < s; a++) e3 = e3 >>> 8 ^ i[255 & (e3 ^ t3[a])];
            return -1 ^ e3;
          })(0 | t2, e2, e2.length, 0) : (function(e3, t3, r2, n2) {
            var i = o, s = n2 + r2;
            e3 ^= -1;
            for (var a = n2; a < s; a++) e3 = e3 >>> 8 ^ i[255 & (e3 ^ t3.charCodeAt(a))];
            return -1 ^ e3;
          })(0 | t2, e2, e2.length, 0) : 0;
        };
      }, { "./utils": 32 }], 5: [function(e, t, r) {
        r.base64 = false, r.binary = false, r.dir = false, r.createFolders = true, r.date = null, r.compression = null, r.compressionOptions = null, r.comment = null, r.unixPermissions = null, r.dosPermissions = null;
      }, {}], 6: [function(e, t, r) {
        var n = null;
        n = "undefined" != typeof Promise ? Promise : e("lie"), t.exports = { Promise: n };
      }, { lie: 37 }], 7: [function(e, t, r) {
        var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Uint32Array, i = e("pako"), s = e("./utils"), a = e("./stream/GenericWorker"), o = n ? "uint8array" : "array";
        function h(e2, t2) {
          a.call(this, "FlateWorker/" + e2), this._pako = null, this._pakoAction = e2, this._pakoOptions = t2, this.meta = {};
        }
        r.magic = "\b\0", s.inherits(h, a), h.prototype.processChunk = function(e2) {
          this.meta = e2.meta, null === this._pako && this._createPako(), this._pako.push(s.transformTo(o, e2.data), false);
        }, h.prototype.flush = function() {
          a.prototype.flush.call(this), null === this._pako && this._createPako(), this._pako.push([], true);
        }, h.prototype.cleanUp = function() {
          a.prototype.cleanUp.call(this), this._pako = null;
        }, h.prototype._createPako = function() {
          this._pako = new i[this._pakoAction]({ raw: true, level: this._pakoOptions.level || -1 });
          var t2 = this;
          this._pako.onData = function(e2) {
            t2.push({ data: e2, meta: t2.meta });
          };
        }, r.compressWorker = function(e2) {
          return new h("Deflate", e2);
        }, r.uncompressWorker = function() {
          return new h("Inflate", {});
        };
      }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(e, t, r) {
        function A(e2, t2) {
          var r2, n2 = "";
          for (r2 = 0; r2 < t2; r2++) n2 += String.fromCharCode(255 & e2), e2 >>>= 8;
          return n2;
        }
        function n(e2, t2, r2, n2, i2, s2) {
          var a, o, h = e2.file, u = e2.compression, l = s2 !== O.utf8encode, f = I.transformTo("string", s2(h.name)), c = I.transformTo("string", O.utf8encode(h.name)), d = h.comment, p = I.transformTo("string", s2(d)), m = I.transformTo("string", O.utf8encode(d)), _ = c.length !== h.name.length, g = m.length !== d.length, b = "", v = "", y = "", w = h.dir, k = h.date, x = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
          t2 && !r2 || (x.crc32 = e2.crc32, x.compressedSize = e2.compressedSize, x.uncompressedSize = e2.uncompressedSize);
          var S = 0;
          t2 && (S |= 8), l || !_ && !g || (S |= 2048);
          var z = 0, C = 0;
          w && (z |= 16), "UNIX" === i2 ? (C = 798, z |= (function(e3, t3) {
            var r3 = e3;
            return e3 || (r3 = t3 ? 16893 : 33204), (65535 & r3) << 16;
          })(h.unixPermissions, w)) : (C = 20, z |= (function(e3) {
            return 63 & (e3 || 0);
          })(h.dosPermissions)), a = k.getUTCHours(), a <<= 6, a |= k.getUTCMinutes(), a <<= 5, a |= k.getUTCSeconds() / 2, o = k.getUTCFullYear() - 1980, o <<= 4, o |= k.getUTCMonth() + 1, o <<= 5, o |= k.getUTCDate(), _ && (v = A(1, 1) + A(B(f), 4) + c, b += "up" + A(v.length, 2) + v), g && (y = A(1, 1) + A(B(p), 4) + m, b += "uc" + A(y.length, 2) + y);
          var E = "";
          return E += "\n\0", E += A(S, 2), E += u.magic, E += A(a, 2), E += A(o, 2), E += A(x.crc32, 4), E += A(x.compressedSize, 4), E += A(x.uncompressedSize, 4), E += A(f.length, 2), E += A(b.length, 2), { fileRecord: R.LOCAL_FILE_HEADER + E + f + b, dirRecord: R.CENTRAL_FILE_HEADER + A(C, 2) + E + A(p.length, 2) + "\0\0\0\0" + A(z, 4) + A(n2, 4) + f + b + p };
        }
        var I = e("../utils"), i = e("../stream/GenericWorker"), O = e("../utf8"), B = e("../crc32"), R = e("../signature");
        function s(e2, t2, r2, n2) {
          i.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = t2, this.zipPlatform = r2, this.encodeFileName = n2, this.streamFiles = e2, this.accumulate = false, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
        }
        I.inherits(s, i), s.prototype.push = function(e2) {
          var t2 = e2.meta.percent || 0, r2 = this.entriesCount, n2 = this._sources.length;
          this.accumulate ? this.contentBuffer.push(e2) : (this.bytesWritten += e2.data.length, i.prototype.push.call(this, { data: e2.data, meta: { currentFile: this.currentFile, percent: r2 ? (t2 + 100 * (r2 - n2 - 1)) / r2 : 100 } }));
        }, s.prototype.openedSource = function(e2) {
          this.currentSourceOffset = this.bytesWritten, this.currentFile = e2.file.name;
          var t2 = this.streamFiles && !e2.file.dir;
          if (t2) {
            var r2 = n(e2, t2, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
            this.push({ data: r2.fileRecord, meta: { percent: 0 } });
          } else this.accumulate = true;
        }, s.prototype.closedSource = function(e2) {
          this.accumulate = false;
          var t2 = this.streamFiles && !e2.file.dir, r2 = n(e2, t2, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          if (this.dirRecords.push(r2.dirRecord), t2) this.push({ data: (function(e3) {
            return R.DATA_DESCRIPTOR + A(e3.crc32, 4) + A(e3.compressedSize, 4) + A(e3.uncompressedSize, 4);
          })(e2), meta: { percent: 100 } });
          else for (this.push({ data: r2.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; ) this.push(this.contentBuffer.shift());
          this.currentFile = null;
        }, s.prototype.flush = function() {
          for (var e2 = this.bytesWritten, t2 = 0; t2 < this.dirRecords.length; t2++) this.push({ data: this.dirRecords[t2], meta: { percent: 100 } });
          var r2 = this.bytesWritten - e2, n2 = (function(e3, t3, r3, n3, i2) {
            var s2 = I.transformTo("string", i2(n3));
            return R.CENTRAL_DIRECTORY_END + "\0\0\0\0" + A(e3, 2) + A(e3, 2) + A(t3, 4) + A(r3, 4) + A(s2.length, 2) + s2;
          })(this.dirRecords.length, r2, e2, this.zipComment, this.encodeFileName);
          this.push({ data: n2, meta: { percent: 100 } });
        }, s.prototype.prepareNextSource = function() {
          this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
        }, s.prototype.registerPrevious = function(e2) {
          this._sources.push(e2);
          var t2 = this;
          return e2.on("data", function(e3) {
            t2.processChunk(e3);
          }), e2.on("end", function() {
            t2.closedSource(t2.previous.streamInfo), t2._sources.length ? t2.prepareNextSource() : t2.end();
          }), e2.on("error", function(e3) {
            t2.error(e3);
          }), this;
        }, s.prototype.resume = function() {
          return !!i.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), true) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), true));
        }, s.prototype.error = function(e2) {
          var t2 = this._sources;
          if (!i.prototype.error.call(this, e2)) return false;
          for (var r2 = 0; r2 < t2.length; r2++) try {
            t2[r2].error(e2);
          } catch (e3) {
          }
          return true;
        }, s.prototype.lock = function() {
          i.prototype.lock.call(this);
          for (var e2 = this._sources, t2 = 0; t2 < e2.length; t2++) e2[t2].lock();
        }, t.exports = s;
      }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(e, t, r) {
        var u = e("../compressions"), n = e("./ZipFileWorker");
        r.generateWorker = function(e2, a, t2) {
          var o = new n(a.streamFiles, t2, a.platform, a.encodeFileName), h = 0;
          try {
            e2.forEach(function(e3, t3) {
              h++;
              var r2 = (function(e4, t4) {
                var r3 = e4 || t4, n3 = u[r3];
                if (!n3) throw new Error(r3 + " is not a valid compression method !");
                return n3;
              })(t3.options.compression, a.compression), n2 = t3.options.compressionOptions || a.compressionOptions || {}, i = t3.dir, s = t3.date;
              t3._compressWorker(r2, n2).withStreamInfo("file", { name: e3, dir: i, date: s, comment: t3.comment || "", unixPermissions: t3.unixPermissions, dosPermissions: t3.dosPermissions }).pipe(o);
            }), o.entriesCount = h;
          } catch (e3) {
            o.error(e3);
          }
          return o;
        };
      }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(e, t, r) {
        function n() {
          if (!(this instanceof n)) return new n();
          if (arguments.length) throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
          this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
            var e2 = new n();
            for (var t2 in this) "function" != typeof this[t2] && (e2[t2] = this[t2]);
            return e2;
          };
        }
        (n.prototype = e("./object")).loadAsync = e("./load"), n.support = e("./support"), n.defaults = e("./defaults"), n.version = "3.10.1", n.loadAsync = function(e2, t2) {
          return new n().loadAsync(e2, t2);
        }, n.external = e("./external"), t.exports = n;
      }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(e, t, r) {
        var u = e("./utils"), i = e("./external"), n = e("./utf8"), s = e("./zipEntries"), a = e("./stream/Crc32Probe"), l = e("./nodejsUtils");
        function f(n2) {
          return new i.Promise(function(e2, t2) {
            var r2 = n2.decompressed.getContentWorker().pipe(new a());
            r2.on("error", function(e3) {
              t2(e3);
            }).on("end", function() {
              r2.streamInfo.crc32 !== n2.decompressed.crc32 ? t2(new Error("Corrupted zip : CRC32 mismatch")) : e2();
            }).resume();
          });
        }
        t.exports = function(e2, o) {
          var h = this;
          return o = u.extend(o || {}, { base64: false, checkCRC32: false, optimizedBinaryString: false, createFolders: false, decodeFileName: n.utf8decode }), l.isNode && l.isStream(e2) ? i.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : u.prepareContent("the loaded zip file", e2, true, o.optimizedBinaryString, o.base64).then(function(e3) {
            var t2 = new s(o);
            return t2.load(e3), t2;
          }).then(function(e3) {
            var t2 = [i.Promise.resolve(e3)], r2 = e3.files;
            if (o.checkCRC32) for (var n2 = 0; n2 < r2.length; n2++) t2.push(f(r2[n2]));
            return i.Promise.all(t2);
          }).then(function(e3) {
            for (var t2 = e3.shift(), r2 = t2.files, n2 = 0; n2 < r2.length; n2++) {
              var i2 = r2[n2], s2 = i2.fileNameStr, a2 = u.resolve(i2.fileNameStr);
              h.file(a2, i2.decompressed, { binary: true, optimizedBinaryString: true, date: i2.date, dir: i2.dir, comment: i2.fileCommentStr.length ? i2.fileCommentStr : null, unixPermissions: i2.unixPermissions, dosPermissions: i2.dosPermissions, createFolders: o.createFolders }), i2.dir || (h.file(a2).unsafeOriginalName = s2);
            }
            return t2.zipComment.length && (h.comment = t2.zipComment), h;
          });
        };
      }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(e, t, r) {
        var n = e("../utils"), i = e("../stream/GenericWorker");
        function s(e2, t2) {
          i.call(this, "Nodejs stream input adapter for " + e2), this._upstreamEnded = false, this._bindStream(t2);
        }
        n.inherits(s, i), s.prototype._bindStream = function(e2) {
          var t2 = this;
          (this._stream = e2).pause(), e2.on("data", function(e3) {
            t2.push({ data: e3, meta: { percent: 0 } });
          }).on("error", function(e3) {
            t2.isPaused ? this.generatedError = e3 : t2.error(e3);
          }).on("end", function() {
            t2.isPaused ? t2._upstreamEnded = true : t2.end();
          });
        }, s.prototype.pause = function() {
          return !!i.prototype.pause.call(this) && (this._stream.pause(), true);
        }, s.prototype.resume = function() {
          return !!i.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), true);
        }, t.exports = s;
      }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(e, t, r) {
        var i = e("readable-stream").Readable;
        function n(e2, t2, r2) {
          i.call(this, t2), this._helper = e2;
          var n2 = this;
          e2.on("data", function(e3, t3) {
            n2.push(e3) || n2._helper.pause(), r2 && r2(t3);
          }).on("error", function(e3) {
            n2.emit("error", e3);
          }).on("end", function() {
            n2.push(null);
          });
        }
        e("../utils").inherits(n, i), n.prototype._read = function() {
          this._helper.resume();
        }, t.exports = n;
      }, { "../utils": 32, "readable-stream": 16 }], 14: [function(e, t, r) {
        t.exports = { isNode: "undefined" != typeof Buffer, newBufferFrom: function(e2, t2) {
          if (Buffer.from && Buffer.from !== Uint8Array.from) return Buffer.from(e2, t2);
          if ("number" == typeof e2) throw new Error('The "data" argument must not be a number');
          return new Buffer(e2, t2);
        }, allocBuffer: function(e2) {
          if (Buffer.alloc) return Buffer.alloc(e2);
          var t2 = new Buffer(e2);
          return t2.fill(0), t2;
        }, isBuffer: function(e2) {
          return Buffer.isBuffer(e2);
        }, isStream: function(e2) {
          return e2 && "function" == typeof e2.on && "function" == typeof e2.pause && "function" == typeof e2.resume;
        } };
      }, {}], 15: [function(e, t, r) {
        function s(e2, t2, r2) {
          var n2, i2 = u.getTypeOf(t2), s2 = u.extend(r2 || {}, f);
          s2.date = s2.date || /* @__PURE__ */ new Date(), null !== s2.compression && (s2.compression = s2.compression.toUpperCase()), "string" == typeof s2.unixPermissions && (s2.unixPermissions = parseInt(s2.unixPermissions, 8)), s2.unixPermissions && 16384 & s2.unixPermissions && (s2.dir = true), s2.dosPermissions && 16 & s2.dosPermissions && (s2.dir = true), s2.dir && (e2 = g(e2)), s2.createFolders && (n2 = _(e2)) && b.call(this, n2, true);
          var a2 = "string" === i2 && false === s2.binary && false === s2.base64;
          r2 && void 0 !== r2.binary || (s2.binary = !a2), (t2 instanceof c && 0 === t2.uncompressedSize || s2.dir || !t2 || 0 === t2.length) && (s2.base64 = false, s2.binary = true, t2 = "", s2.compression = "STORE", i2 = "string");
          var o2 = null;
          o2 = t2 instanceof c || t2 instanceof l ? t2 : p.isNode && p.isStream(t2) ? new m(e2, t2) : u.prepareContent(e2, t2, s2.binary, s2.optimizedBinaryString, s2.base64);
          var h2 = new d(e2, o2, s2);
          this.files[e2] = h2;
        }
        var i = e("./utf8"), u = e("./utils"), l = e("./stream/GenericWorker"), a = e("./stream/StreamHelper"), f = e("./defaults"), c = e("./compressedObject"), d = e("./zipObject"), o = e("./generate"), p = e("./nodejsUtils"), m = e("./nodejs/NodejsStreamInputAdapter"), _ = function(e2) {
          "/" === e2.slice(-1) && (e2 = e2.substring(0, e2.length - 1));
          var t2 = e2.lastIndexOf("/");
          return 0 < t2 ? e2.substring(0, t2) : "";
        }, g = function(e2) {
          return "/" !== e2.slice(-1) && (e2 += "/"), e2;
        }, b = function(e2, t2) {
          return t2 = void 0 !== t2 ? t2 : f.createFolders, e2 = g(e2), this.files[e2] || s.call(this, e2, null, { dir: true, createFolders: t2 }), this.files[e2];
        };
        function h(e2) {
          return "[object RegExp]" === Object.prototype.toString.call(e2);
        }
        var n = { load: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, forEach: function(e2) {
          var t2, r2, n2;
          for (t2 in this.files) n2 = this.files[t2], (r2 = t2.slice(this.root.length, t2.length)) && t2.slice(0, this.root.length) === this.root && e2(r2, n2);
        }, filter: function(r2) {
          var n2 = [];
          return this.forEach(function(e2, t2) {
            r2(e2, t2) && n2.push(t2);
          }), n2;
        }, file: function(e2, t2, r2) {
          if (1 !== arguments.length) return e2 = this.root + e2, s.call(this, e2, t2, r2), this;
          if (h(e2)) {
            var n2 = e2;
            return this.filter(function(e3, t3) {
              return !t3.dir && n2.test(e3);
            });
          }
          var i2 = this.files[this.root + e2];
          return i2 && !i2.dir ? i2 : null;
        }, folder: function(r2) {
          if (!r2) return this;
          if (h(r2)) return this.filter(function(e3, t3) {
            return t3.dir && r2.test(e3);
          });
          var e2 = this.root + r2, t2 = b.call(this, e2), n2 = this.clone();
          return n2.root = t2.name, n2;
        }, remove: function(r2) {
          r2 = this.root + r2;
          var e2 = this.files[r2];
          if (e2 || ("/" !== r2.slice(-1) && (r2 += "/"), e2 = this.files[r2]), e2 && !e2.dir) delete this.files[r2];
          else for (var t2 = this.filter(function(e3, t3) {
            return t3.name.slice(0, r2.length) === r2;
          }), n2 = 0; n2 < t2.length; n2++) delete this.files[t2[n2].name];
          return this;
        }, generate: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, generateInternalStream: function(e2) {
          var t2, r2 = {};
          try {
            if ((r2 = u.extend(e2 || {}, { streamFiles: false, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: i.utf8encode })).type = r2.type.toLowerCase(), r2.compression = r2.compression.toUpperCase(), "binarystring" === r2.type && (r2.type = "string"), !r2.type) throw new Error("No output type specified.");
            u.checkSupport(r2.type), "darwin" !== r2.platform && "freebsd" !== r2.platform && "linux" !== r2.platform && "sunos" !== r2.platform || (r2.platform = "UNIX"), "win32" === r2.platform && (r2.platform = "DOS");
            var n2 = r2.comment || this.comment || "";
            t2 = o.generateWorker(this, r2, n2);
          } catch (e3) {
            (t2 = new l("error")).error(e3);
          }
          return new a(t2, r2.type || "string", r2.mimeType);
        }, generateAsync: function(e2, t2) {
          return this.generateInternalStream(e2).accumulate(t2);
        }, generateNodeStream: function(e2, t2) {
          return (e2 = e2 || {}).type || (e2.type = "nodebuffer"), this.generateInternalStream(e2).toNodejsStream(t2);
        } };
        t.exports = n;
      }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(e, t, r) {
        t.exports = e("stream");
      }, { stream: void 0 }], 17: [function(e, t, r) {
        var n = e("./DataReader");
        function i(e2) {
          n.call(this, e2);
          for (var t2 = 0; t2 < this.data.length; t2++) e2[t2] = 255 & e2[t2];
        }
        e("../utils").inherits(i, n), i.prototype.byteAt = function(e2) {
          return this.data[this.zero + e2];
        }, i.prototype.lastIndexOfSignature = function(e2) {
          for (var t2 = e2.charCodeAt(0), r2 = e2.charCodeAt(1), n2 = e2.charCodeAt(2), i2 = e2.charCodeAt(3), s = this.length - 4; 0 <= s; --s) if (this.data[s] === t2 && this.data[s + 1] === r2 && this.data[s + 2] === n2 && this.data[s + 3] === i2) return s - this.zero;
          return -1;
        }, i.prototype.readAndCheckSignature = function(e2) {
          var t2 = e2.charCodeAt(0), r2 = e2.charCodeAt(1), n2 = e2.charCodeAt(2), i2 = e2.charCodeAt(3), s = this.readData(4);
          return t2 === s[0] && r2 === s[1] && n2 === s[2] && i2 === s[3];
        }, i.prototype.readData = function(e2) {
          if (this.checkOffset(e2), 0 === e2) return [];
          var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t2;
        }, t.exports = i;
      }, { "../utils": 32, "./DataReader": 18 }], 18: [function(e, t, r) {
        var n = e("../utils");
        function i(e2) {
          this.data = e2, this.length = e2.length, this.index = 0, this.zero = 0;
        }
        i.prototype = { checkOffset: function(e2) {
          this.checkIndex(this.index + e2);
        }, checkIndex: function(e2) {
          if (this.length < this.zero + e2 || e2 < 0) throw new Error("End of data reached (data length = " + this.length + ", asked index = " + e2 + "). Corrupted zip ?");
        }, setIndex: function(e2) {
          this.checkIndex(e2), this.index = e2;
        }, skip: function(e2) {
          this.setIndex(this.index + e2);
        }, byteAt: function() {
        }, readInt: function(e2) {
          var t2, r2 = 0;
          for (this.checkOffset(e2), t2 = this.index + e2 - 1; t2 >= this.index; t2--) r2 = (r2 << 8) + this.byteAt(t2);
          return this.index += e2, r2;
        }, readString: function(e2) {
          return n.transformTo("string", this.readData(e2));
        }, readData: function() {
        }, lastIndexOfSignature: function() {
        }, readAndCheckSignature: function() {
        }, readDate: function() {
          var e2 = this.readInt(4);
          return new Date(Date.UTC(1980 + (e2 >> 25 & 127), (e2 >> 21 & 15) - 1, e2 >> 16 & 31, e2 >> 11 & 31, e2 >> 5 & 63, (31 & e2) << 1));
        } }, t.exports = i;
      }, { "../utils": 32 }], 19: [function(e, t, r) {
        var n = e("./Uint8ArrayReader");
        function i(e2) {
          n.call(this, e2);
        }
        e("../utils").inherits(i, n), i.prototype.readData = function(e2) {
          this.checkOffset(e2);
          var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t2;
        }, t.exports = i;
      }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(e, t, r) {
        var n = e("./DataReader");
        function i(e2) {
          n.call(this, e2);
        }
        e("../utils").inherits(i, n), i.prototype.byteAt = function(e2) {
          return this.data.charCodeAt(this.zero + e2);
        }, i.prototype.lastIndexOfSignature = function(e2) {
          return this.data.lastIndexOf(e2) - this.zero;
        }, i.prototype.readAndCheckSignature = function(e2) {
          return e2 === this.readData(4);
        }, i.prototype.readData = function(e2) {
          this.checkOffset(e2);
          var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t2;
        }, t.exports = i;
      }, { "../utils": 32, "./DataReader": 18 }], 21: [function(e, t, r) {
        var n = e("./ArrayReader");
        function i(e2) {
          n.call(this, e2);
        }
        e("../utils").inherits(i, n), i.prototype.readData = function(e2) {
          if (this.checkOffset(e2), 0 === e2) return new Uint8Array(0);
          var t2 = this.data.subarray(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t2;
        }, t.exports = i;
      }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(e, t, r) {
        var n = e("../utils"), i = e("../support"), s = e("./ArrayReader"), a = e("./StringReader"), o = e("./NodeBufferReader"), h = e("./Uint8ArrayReader");
        t.exports = function(e2) {
          var t2 = n.getTypeOf(e2);
          return n.checkSupport(t2), "string" !== t2 || i.uint8array ? "nodebuffer" === t2 ? new o(e2) : i.uint8array ? new h(n.transformTo("uint8array", e2)) : new s(n.transformTo("array", e2)) : new a(e2);
        };
      }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(e, t, r) {
        r.LOCAL_FILE_HEADER = "PK", r.CENTRAL_FILE_HEADER = "PK", r.CENTRAL_DIRECTORY_END = "PK", r.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", r.ZIP64_CENTRAL_DIRECTORY_END = "PK", r.DATA_DESCRIPTOR = "PK\x07\b";
      }, {}], 24: [function(e, t, r) {
        var n = e("./GenericWorker"), i = e("../utils");
        function s(e2) {
          n.call(this, "ConvertWorker to " + e2), this.destType = e2;
        }
        i.inherits(s, n), s.prototype.processChunk = function(e2) {
          this.push({ data: i.transformTo(this.destType, e2.data), meta: e2.meta });
        }, t.exports = s;
      }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(e, t, r) {
        var n = e("./GenericWorker"), i = e("../crc32");
        function s() {
          n.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
        }
        e("../utils").inherits(s, n), s.prototype.processChunk = function(e2) {
          this.streamInfo.crc32 = i(e2.data, this.streamInfo.crc32 || 0), this.push(e2);
        }, t.exports = s;
      }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(e, t, r) {
        var n = e("../utils"), i = e("./GenericWorker");
        function s(e2) {
          i.call(this, "DataLengthProbe for " + e2), this.propName = e2, this.withStreamInfo(e2, 0);
        }
        n.inherits(s, i), s.prototype.processChunk = function(e2) {
          if (e2) {
            var t2 = this.streamInfo[this.propName] || 0;
            this.streamInfo[this.propName] = t2 + e2.data.length;
          }
          i.prototype.processChunk.call(this, e2);
        }, t.exports = s;
      }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(e, t, r) {
        var n = e("../utils"), i = e("./GenericWorker");
        function s(e2) {
          i.call(this, "DataWorker");
          var t2 = this;
          this.dataIsReady = false, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = false, e2.then(function(e3) {
            t2.dataIsReady = true, t2.data = e3, t2.max = e3 && e3.length || 0, t2.type = n.getTypeOf(e3), t2.isPaused || t2._tickAndRepeat();
          }, function(e3) {
            t2.error(e3);
          });
        }
        n.inherits(s, i), s.prototype.cleanUp = function() {
          i.prototype.cleanUp.call(this), this.data = null;
        }, s.prototype.resume = function() {
          return !!i.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = true, n.delay(this._tickAndRepeat, [], this)), true);
        }, s.prototype._tickAndRepeat = function() {
          this._tickScheduled = false, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (n.delay(this._tickAndRepeat, [], this), this._tickScheduled = true));
        }, s.prototype._tick = function() {
          if (this.isPaused || this.isFinished) return false;
          var e2 = null, t2 = Math.min(this.max, this.index + 16384);
          if (this.index >= this.max) return this.end();
          switch (this.type) {
            case "string":
              e2 = this.data.substring(this.index, t2);
              break;
            case "uint8array":
              e2 = this.data.subarray(this.index, t2);
              break;
            case "array":
            case "nodebuffer":
              e2 = this.data.slice(this.index, t2);
          }
          return this.index = t2, this.push({ data: e2, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
        }, t.exports = s;
      }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(e, t, r) {
        function n(e2) {
          this.name = e2 || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = true, this.isFinished = false, this.isLocked = false, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
        }
        n.prototype = { push: function(e2) {
          this.emit("data", e2);
        }, end: function() {
          if (this.isFinished) return false;
          this.flush();
          try {
            this.emit("end"), this.cleanUp(), this.isFinished = true;
          } catch (e2) {
            this.emit("error", e2);
          }
          return true;
        }, error: function(e2) {
          return !this.isFinished && (this.isPaused ? this.generatedError = e2 : (this.isFinished = true, this.emit("error", e2), this.previous && this.previous.error(e2), this.cleanUp()), true);
        }, on: function(e2, t2) {
          return this._listeners[e2].push(t2), this;
        }, cleanUp: function() {
          this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
        }, emit: function(e2, t2) {
          if (this._listeners[e2]) for (var r2 = 0; r2 < this._listeners[e2].length; r2++) this._listeners[e2][r2].call(this, t2);
        }, pipe: function(e2) {
          return e2.registerPrevious(this);
        }, registerPrevious: function(e2) {
          if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
          this.streamInfo = e2.streamInfo, this.mergeStreamInfo(), this.previous = e2;
          var t2 = this;
          return e2.on("data", function(e3) {
            t2.processChunk(e3);
          }), e2.on("end", function() {
            t2.end();
          }), e2.on("error", function(e3) {
            t2.error(e3);
          }), this;
        }, pause: function() {
          return !this.isPaused && !this.isFinished && (this.isPaused = true, this.previous && this.previous.pause(), true);
        }, resume: function() {
          if (!this.isPaused || this.isFinished) return false;
          var e2 = this.isPaused = false;
          return this.generatedError && (this.error(this.generatedError), e2 = true), this.previous && this.previous.resume(), !e2;
        }, flush: function() {
        }, processChunk: function(e2) {
          this.push(e2);
        }, withStreamInfo: function(e2, t2) {
          return this.extraStreamInfo[e2] = t2, this.mergeStreamInfo(), this;
        }, mergeStreamInfo: function() {
          for (var e2 in this.extraStreamInfo) Object.prototype.hasOwnProperty.call(this.extraStreamInfo, e2) && (this.streamInfo[e2] = this.extraStreamInfo[e2]);
        }, lock: function() {
          if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
          this.isLocked = true, this.previous && this.previous.lock();
        }, toString: function() {
          var e2 = "Worker " + this.name;
          return this.previous ? this.previous + " -> " + e2 : e2;
        } }, t.exports = n;
      }, {}], 29: [function(e, t, r) {
        var h = e("../utils"), i = e("./ConvertWorker"), s = e("./GenericWorker"), u = e("../base64"), n = e("../support"), a = e("../external"), o = null;
        if (n.nodestream) try {
          o = e("../nodejs/NodejsStreamOutputAdapter");
        } catch (e2) {
        }
        function l(e2, o2) {
          return new a.Promise(function(t2, r2) {
            var n2 = [], i2 = e2._internalType, s2 = e2._outputType, a2 = e2._mimeType;
            e2.on("data", function(e3, t3) {
              n2.push(e3), o2 && o2(t3);
            }).on("error", function(e3) {
              n2 = [], r2(e3);
            }).on("end", function() {
              try {
                var e3 = (function(e4, t3, r3) {
                  switch (e4) {
                    case "blob":
                      return h.newBlob(h.transformTo("arraybuffer", t3), r3);
                    case "base64":
                      return u.encode(t3);
                    default:
                      return h.transformTo(e4, t3);
                  }
                })(s2, (function(e4, t3) {
                  var r3, n3 = 0, i3 = null, s3 = 0;
                  for (r3 = 0; r3 < t3.length; r3++) s3 += t3[r3].length;
                  switch (e4) {
                    case "string":
                      return t3.join("");
                    case "array":
                      return Array.prototype.concat.apply([], t3);
                    case "uint8array":
                      for (i3 = new Uint8Array(s3), r3 = 0; r3 < t3.length; r3++) i3.set(t3[r3], n3), n3 += t3[r3].length;
                      return i3;
                    case "nodebuffer":
                      return Buffer.concat(t3);
                    default:
                      throw new Error("concat : unsupported type '" + e4 + "'");
                  }
                })(i2, n2), a2);
                t2(e3);
              } catch (e4) {
                r2(e4);
              }
              n2 = [];
            }).resume();
          });
        }
        function f(e2, t2, r2) {
          var n2 = t2;
          switch (t2) {
            case "blob":
            case "arraybuffer":
              n2 = "uint8array";
              break;
            case "base64":
              n2 = "string";
          }
          try {
            this._internalType = n2, this._outputType = t2, this._mimeType = r2, h.checkSupport(n2), this._worker = e2.pipe(new i(n2)), e2.lock();
          } catch (e3) {
            this._worker = new s("error"), this._worker.error(e3);
          }
        }
        f.prototype = { accumulate: function(e2) {
          return l(this, e2);
        }, on: function(e2, t2) {
          var r2 = this;
          return "data" === e2 ? this._worker.on(e2, function(e3) {
            t2.call(r2, e3.data, e3.meta);
          }) : this._worker.on(e2, function() {
            h.delay(t2, arguments, r2);
          }), this;
        }, resume: function() {
          return h.delay(this._worker.resume, [], this._worker), this;
        }, pause: function() {
          return this._worker.pause(), this;
        }, toNodejsStream: function(e2) {
          if (h.checkSupport("nodestream"), "nodebuffer" !== this._outputType) throw new Error(this._outputType + " is not supported by this method");
          return new o(this, { objectMode: "nodebuffer" !== this._outputType }, e2);
        } }, t.exports = f;
      }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(e, t, r) {
        if (r.base64 = true, r.array = true, r.string = true, r.arraybuffer = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array, r.nodebuffer = "undefined" != typeof Buffer, r.uint8array = "undefined" != typeof Uint8Array, "undefined" == typeof ArrayBuffer) r.blob = false;
        else {
          var n = new ArrayBuffer(0);
          try {
            r.blob = 0 === new Blob([n], { type: "application/zip" }).size;
          } catch (e2) {
            try {
              var i = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
              i.append(n), r.blob = 0 === i.getBlob("application/zip").size;
            } catch (e3) {
              r.blob = false;
            }
          }
        }
        try {
          r.nodestream = !!e("readable-stream").Readable;
        } catch (e2) {
          r.nodestream = false;
        }
      }, { "readable-stream": 16 }], 31: [function(e, t, s) {
        for (var o = e("./utils"), h = e("./support"), r = e("./nodejsUtils"), n = e("./stream/GenericWorker"), u = new Array(256), i = 0; i < 256; i++) u[i] = 252 <= i ? 6 : 248 <= i ? 5 : 240 <= i ? 4 : 224 <= i ? 3 : 192 <= i ? 2 : 1;
        u[254] = u[254] = 1;
        function a() {
          n.call(this, "utf-8 decode"), this.leftOver = null;
        }
        function l() {
          n.call(this, "utf-8 encode");
        }
        s.utf8encode = function(e2) {
          return h.nodebuffer ? r.newBufferFrom(e2, "utf-8") : (function(e3) {
            var t2, r2, n2, i2, s2, a2 = e3.length, o2 = 0;
            for (i2 = 0; i2 < a2; i2++) 55296 == (64512 & (r2 = e3.charCodeAt(i2))) && i2 + 1 < a2 && 56320 == (64512 & (n2 = e3.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), o2 += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
            for (t2 = h.uint8array ? new Uint8Array(o2) : new Array(o2), i2 = s2 = 0; s2 < o2; i2++) 55296 == (64512 & (r2 = e3.charCodeAt(i2))) && i2 + 1 < a2 && 56320 == (64512 & (n2 = e3.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), r2 < 128 ? t2[s2++] = r2 : (r2 < 2048 ? t2[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? t2[s2++] = 224 | r2 >>> 12 : (t2[s2++] = 240 | r2 >>> 18, t2[s2++] = 128 | r2 >>> 12 & 63), t2[s2++] = 128 | r2 >>> 6 & 63), t2[s2++] = 128 | 63 & r2);
            return t2;
          })(e2);
        }, s.utf8decode = function(e2) {
          return h.nodebuffer ? o.transformTo("nodebuffer", e2).toString("utf-8") : (function(e3) {
            var t2, r2, n2, i2, s2 = e3.length, a2 = new Array(2 * s2);
            for (t2 = r2 = 0; t2 < s2; ) if ((n2 = e3[t2++]) < 128) a2[r2++] = n2;
            else if (4 < (i2 = u[n2])) a2[r2++] = 65533, t2 += i2 - 1;
            else {
              for (n2 &= 2 === i2 ? 31 : 3 === i2 ? 15 : 7; 1 < i2 && t2 < s2; ) n2 = n2 << 6 | 63 & e3[t2++], i2--;
              1 < i2 ? a2[r2++] = 65533 : n2 < 65536 ? a2[r2++] = n2 : (n2 -= 65536, a2[r2++] = 55296 | n2 >> 10 & 1023, a2[r2++] = 56320 | 1023 & n2);
            }
            return a2.length !== r2 && (a2.subarray ? a2 = a2.subarray(0, r2) : a2.length = r2), o.applyFromCharCode(a2);
          })(e2 = o.transformTo(h.uint8array ? "uint8array" : "array", e2));
        }, o.inherits(a, n), a.prototype.processChunk = function(e2) {
          var t2 = o.transformTo(h.uint8array ? "uint8array" : "array", e2.data);
          if (this.leftOver && this.leftOver.length) {
            if (h.uint8array) {
              var r2 = t2;
              (t2 = new Uint8Array(r2.length + this.leftOver.length)).set(this.leftOver, 0), t2.set(r2, this.leftOver.length);
            } else t2 = this.leftOver.concat(t2);
            this.leftOver = null;
          }
          var n2 = (function(e3, t3) {
            var r3;
            for ((t3 = t3 || e3.length) > e3.length && (t3 = e3.length), r3 = t3 - 1; 0 <= r3 && 128 == (192 & e3[r3]); ) r3--;
            return r3 < 0 ? t3 : 0 === r3 ? t3 : r3 + u[e3[r3]] > t3 ? r3 : t3;
          })(t2), i2 = t2;
          n2 !== t2.length && (h.uint8array ? (i2 = t2.subarray(0, n2), this.leftOver = t2.subarray(n2, t2.length)) : (i2 = t2.slice(0, n2), this.leftOver = t2.slice(n2, t2.length))), this.push({ data: s.utf8decode(i2), meta: e2.meta });
        }, a.prototype.flush = function() {
          this.leftOver && this.leftOver.length && (this.push({ data: s.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
        }, s.Utf8DecodeWorker = a, o.inherits(l, n), l.prototype.processChunk = function(e2) {
          this.push({ data: s.utf8encode(e2.data), meta: e2.meta });
        }, s.Utf8EncodeWorker = l;
      }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(e, t, a) {
        var o = e("./support"), h = e("./base64"), r = e("./nodejsUtils"), u = e("./external");
        function n(e2) {
          return e2;
        }
        function l(e2, t2) {
          for (var r2 = 0; r2 < e2.length; ++r2) t2[r2] = 255 & e2.charCodeAt(r2);
          return t2;
        }
        e("setimmediate"), a.newBlob = function(t2, r2) {
          a.checkSupport("blob");
          try {
            return new Blob([t2], { type: r2 });
          } catch (e2) {
            try {
              var n2 = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
              return n2.append(t2), n2.getBlob(r2);
            } catch (e3) {
              throw new Error("Bug : can't construct the Blob.");
            }
          }
        };
        var i = { stringifyByChunk: function(e2, t2, r2) {
          var n2 = [], i2 = 0, s2 = e2.length;
          if (s2 <= r2) return String.fromCharCode.apply(null, e2);
          for (; i2 < s2; ) "array" === t2 || "nodebuffer" === t2 ? n2.push(String.fromCharCode.apply(null, e2.slice(i2, Math.min(i2 + r2, s2)))) : n2.push(String.fromCharCode.apply(null, e2.subarray(i2, Math.min(i2 + r2, s2)))), i2 += r2;
          return n2.join("");
        }, stringifyByChar: function(e2) {
          for (var t2 = "", r2 = 0; r2 < e2.length; r2++) t2 += String.fromCharCode(e2[r2]);
          return t2;
        }, applyCanBeUsed: { uint8array: (function() {
          try {
            return o.uint8array && 1 === String.fromCharCode.apply(null, new Uint8Array(1)).length;
          } catch (e2) {
            return false;
          }
        })(), nodebuffer: (function() {
          try {
            return o.nodebuffer && 1 === String.fromCharCode.apply(null, r.allocBuffer(1)).length;
          } catch (e2) {
            return false;
          }
        })() } };
        function s(e2) {
          var t2 = 65536, r2 = a.getTypeOf(e2), n2 = true;
          if ("uint8array" === r2 ? n2 = i.applyCanBeUsed.uint8array : "nodebuffer" === r2 && (n2 = i.applyCanBeUsed.nodebuffer), n2) for (; 1 < t2; ) try {
            return i.stringifyByChunk(e2, r2, t2);
          } catch (e3) {
            t2 = Math.floor(t2 / 2);
          }
          return i.stringifyByChar(e2);
        }
        function f(e2, t2) {
          for (var r2 = 0; r2 < e2.length; r2++) t2[r2] = e2[r2];
          return t2;
        }
        a.applyFromCharCode = s;
        var c = {};
        c.string = { string: n, array: function(e2) {
          return l(e2, new Array(e2.length));
        }, arraybuffer: function(e2) {
          return c.string.uint8array(e2).buffer;
        }, uint8array: function(e2) {
          return l(e2, new Uint8Array(e2.length));
        }, nodebuffer: function(e2) {
          return l(e2, r.allocBuffer(e2.length));
        } }, c.array = { string: s, array: n, arraybuffer: function(e2) {
          return new Uint8Array(e2).buffer;
        }, uint8array: function(e2) {
          return new Uint8Array(e2);
        }, nodebuffer: function(e2) {
          return r.newBufferFrom(e2);
        } }, c.arraybuffer = { string: function(e2) {
          return s(new Uint8Array(e2));
        }, array: function(e2) {
          return f(new Uint8Array(e2), new Array(e2.byteLength));
        }, arraybuffer: n, uint8array: function(e2) {
          return new Uint8Array(e2);
        }, nodebuffer: function(e2) {
          return r.newBufferFrom(new Uint8Array(e2));
        } }, c.uint8array = { string: s, array: function(e2) {
          return f(e2, new Array(e2.length));
        }, arraybuffer: function(e2) {
          return e2.buffer;
        }, uint8array: n, nodebuffer: function(e2) {
          return r.newBufferFrom(e2);
        } }, c.nodebuffer = { string: s, array: function(e2) {
          return f(e2, new Array(e2.length));
        }, arraybuffer: function(e2) {
          return c.nodebuffer.uint8array(e2).buffer;
        }, uint8array: function(e2) {
          return f(e2, new Uint8Array(e2.length));
        }, nodebuffer: n }, a.transformTo = function(e2, t2) {
          if (t2 = t2 || "", !e2) return t2;
          a.checkSupport(e2);
          var r2 = a.getTypeOf(t2);
          return c[r2][e2](t2);
        }, a.resolve = function(e2) {
          for (var t2 = e2.split("/"), r2 = [], n2 = 0; n2 < t2.length; n2++) {
            var i2 = t2[n2];
            "." === i2 || "" === i2 && 0 !== n2 && n2 !== t2.length - 1 || (".." === i2 ? r2.pop() : r2.push(i2));
          }
          return r2.join("/");
        }, a.getTypeOf = function(e2) {
          return "string" == typeof e2 ? "string" : "[object Array]" === Object.prototype.toString.call(e2) ? "array" : o.nodebuffer && r.isBuffer(e2) ? "nodebuffer" : o.uint8array && e2 instanceof Uint8Array ? "uint8array" : o.arraybuffer && e2 instanceof ArrayBuffer ? "arraybuffer" : void 0;
        }, a.checkSupport = function(e2) {
          if (!o[e2.toLowerCase()]) throw new Error(e2 + " is not supported by this platform");
        }, a.MAX_VALUE_16BITS = 65535, a.MAX_VALUE_32BITS = -1, a.pretty = function(e2) {
          var t2, r2, n2 = "";
          for (r2 = 0; r2 < (e2 || "").length; r2++) n2 += "\\x" + ((t2 = e2.charCodeAt(r2)) < 16 ? "0" : "") + t2.toString(16).toUpperCase();
          return n2;
        }, a.delay = function(e2, t2, r2) {
          setImmediate(function() {
            e2.apply(r2 || null, t2 || []);
          });
        }, a.inherits = function(e2, t2) {
          function r2() {
          }
          r2.prototype = t2.prototype, e2.prototype = new r2();
        }, a.extend = function() {
          var e2, t2, r2 = {};
          for (e2 = 0; e2 < arguments.length; e2++) for (t2 in arguments[e2]) Object.prototype.hasOwnProperty.call(arguments[e2], t2) && void 0 === r2[t2] && (r2[t2] = arguments[e2][t2]);
          return r2;
        }, a.prepareContent = function(r2, e2, n2, i2, s2) {
          return u.Promise.resolve(e2).then(function(n3) {
            return o.blob && (n3 instanceof Blob || -1 !== ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(n3))) && "undefined" != typeof FileReader ? new u.Promise(function(t2, r3) {
              var e3 = new FileReader();
              e3.onload = function(e4) {
                t2(e4.target.result);
              }, e3.onerror = function(e4) {
                r3(e4.target.error);
              }, e3.readAsArrayBuffer(n3);
            }) : n3;
          }).then(function(e3) {
            var t2 = a.getTypeOf(e3);
            return t2 ? ("arraybuffer" === t2 ? e3 = a.transformTo("uint8array", e3) : "string" === t2 && (s2 ? e3 = h.decode(e3) : n2 && true !== i2 && (e3 = (function(e4) {
              return l(e4, o.uint8array ? new Uint8Array(e4.length) : new Array(e4.length));
            })(e3))), e3) : u.Promise.reject(new Error("Can't read the data of '" + r2 + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
          });
        };
      }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(e, t, r) {
        var n = e("./reader/readerFor"), i = e("./utils"), s = e("./signature"), a = e("./zipEntry"), o = e("./support");
        function h(e2) {
          this.files = [], this.loadOptions = e2;
        }
        h.prototype = { checkSignature: function(e2) {
          if (!this.reader.readAndCheckSignature(e2)) {
            this.reader.index -= 4;
            var t2 = this.reader.readString(4);
            throw new Error("Corrupted zip or bug: unexpected signature (" + i.pretty(t2) + ", expected " + i.pretty(e2) + ")");
          }
        }, isSignature: function(e2, t2) {
          var r2 = this.reader.index;
          this.reader.setIndex(e2);
          var n2 = this.reader.readString(4) === t2;
          return this.reader.setIndex(r2), n2;
        }, readBlockEndOfCentral: function() {
          this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
          var e2 = this.reader.readData(this.zipCommentLength), t2 = o.uint8array ? "uint8array" : "array", r2 = i.transformTo(t2, e2);
          this.zipComment = this.loadOptions.decodeFileName(r2);
        }, readBlockZip64EndOfCentral: function() {
          this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
          for (var e2, t2, r2, n2 = this.zip64EndOfCentralSize - 44; 0 < n2; ) e2 = this.reader.readInt(2), t2 = this.reader.readInt(4), r2 = this.reader.readData(t2), this.zip64ExtensibleData[e2] = { id: e2, length: t2, value: r2 };
        }, readBlockZip64EndOfCentralLocator: function() {
          if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount) throw new Error("Multi-volumes zip are not supported");
        }, readLocalFiles: function() {
          var e2, t2;
          for (e2 = 0; e2 < this.files.length; e2++) t2 = this.files[e2], this.reader.setIndex(t2.localHeaderOffset), this.checkSignature(s.LOCAL_FILE_HEADER), t2.readLocalPart(this.reader), t2.handleUTF8(), t2.processAttributes();
        }, readCentralDir: function() {
          var e2;
          for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER); ) (e2 = new a({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(e2);
          if (this.centralDirRecords !== this.files.length && 0 !== this.centralDirRecords && 0 === this.files.length) throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
        }, readEndOfCentral: function() {
          var e2 = this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END);
          if (e2 < 0) throw !this.isSignature(0, s.LOCAL_FILE_HEADER) ? new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html") : new Error("Corrupted zip: can't find end of central directory");
          this.reader.setIndex(e2);
          var t2 = e2;
          if (this.checkSignature(s.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === i.MAX_VALUE_16BITS || this.diskWithCentralDirStart === i.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === i.MAX_VALUE_16BITS || this.centralDirRecords === i.MAX_VALUE_16BITS || this.centralDirSize === i.MAX_VALUE_32BITS || this.centralDirOffset === i.MAX_VALUE_32BITS) {
            if (this.zip64 = true, (e2 = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
            if (this.reader.setIndex(e2), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, s.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0)) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
          }
          var r2 = this.centralDirOffset + this.centralDirSize;
          this.zip64 && (r2 += 20, r2 += 12 + this.zip64EndOfCentralSize);
          var n2 = t2 - r2;
          if (0 < n2) this.isSignature(t2, s.CENTRAL_FILE_HEADER) || (this.reader.zero = n2);
          else if (n2 < 0) throw new Error("Corrupted zip: missing " + Math.abs(n2) + " bytes.");
        }, prepareReader: function(e2) {
          this.reader = n(e2);
        }, load: function(e2) {
          this.prepareReader(e2), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
        } }, t.exports = h;
      }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(e, t, r) {
        var n = e("./reader/readerFor"), s = e("./utils"), i = e("./compressedObject"), a = e("./crc32"), o = e("./utf8"), h = e("./compressions"), u = e("./support");
        function l(e2, t2) {
          this.options = e2, this.loadOptions = t2;
        }
        l.prototype = { isEncrypted: function() {
          return 1 == (1 & this.bitFlag);
        }, useUTF8: function() {
          return 2048 == (2048 & this.bitFlag);
        }, readLocalPart: function(e2) {
          var t2, r2;
          if (e2.skip(22), this.fileNameLength = e2.readInt(2), r2 = e2.readInt(2), this.fileName = e2.readData(this.fileNameLength), e2.skip(r2), -1 === this.compressedSize || -1 === this.uncompressedSize) throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
          if (null === (t2 = (function(e3) {
            for (var t3 in h) if (Object.prototype.hasOwnProperty.call(h, t3) && h[t3].magic === e3) return h[t3];
            return null;
          })(this.compressionMethod))) throw new Error("Corrupted zip : compression " + s.pretty(this.compressionMethod) + " unknown (inner file : " + s.transformTo("string", this.fileName) + ")");
          this.decompressed = new i(this.compressedSize, this.uncompressedSize, this.crc32, t2, e2.readData(this.compressedSize));
        }, readCentralPart: function(e2) {
          this.versionMadeBy = e2.readInt(2), e2.skip(2), this.bitFlag = e2.readInt(2), this.compressionMethod = e2.readString(2), this.date = e2.readDate(), this.crc32 = e2.readInt(4), this.compressedSize = e2.readInt(4), this.uncompressedSize = e2.readInt(4);
          var t2 = e2.readInt(2);
          if (this.extraFieldsLength = e2.readInt(2), this.fileCommentLength = e2.readInt(2), this.diskNumberStart = e2.readInt(2), this.internalFileAttributes = e2.readInt(2), this.externalFileAttributes = e2.readInt(4), this.localHeaderOffset = e2.readInt(4), this.isEncrypted()) throw new Error("Encrypted zip are not supported");
          e2.skip(t2), this.readExtraFields(e2), this.parseZIP64ExtraField(e2), this.fileComment = e2.readData(this.fileCommentLength);
        }, processAttributes: function() {
          this.unixPermissions = null, this.dosPermissions = null;
          var e2 = this.versionMadeBy >> 8;
          this.dir = !!(16 & this.externalFileAttributes), 0 == e2 && (this.dosPermissions = 63 & this.externalFileAttributes), 3 == e2 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || "/" !== this.fileNameStr.slice(-1) || (this.dir = true);
        }, parseZIP64ExtraField: function() {
          if (this.extraFields[1]) {
            var e2 = n(this.extraFields[1].value);
            this.uncompressedSize === s.MAX_VALUE_32BITS && (this.uncompressedSize = e2.readInt(8)), this.compressedSize === s.MAX_VALUE_32BITS && (this.compressedSize = e2.readInt(8)), this.localHeaderOffset === s.MAX_VALUE_32BITS && (this.localHeaderOffset = e2.readInt(8)), this.diskNumberStart === s.MAX_VALUE_32BITS && (this.diskNumberStart = e2.readInt(4));
          }
        }, readExtraFields: function(e2) {
          var t2, r2, n2, i2 = e2.index + this.extraFieldsLength;
          for (this.extraFields || (this.extraFields = {}); e2.index + 4 < i2; ) t2 = e2.readInt(2), r2 = e2.readInt(2), n2 = e2.readData(r2), this.extraFields[t2] = { id: t2, length: r2, value: n2 };
          e2.setIndex(i2);
        }, handleUTF8: function() {
          var e2 = u.uint8array ? "uint8array" : "array";
          if (this.useUTF8()) this.fileNameStr = o.utf8decode(this.fileName), this.fileCommentStr = o.utf8decode(this.fileComment);
          else {
            var t2 = this.findExtraFieldUnicodePath();
            if (null !== t2) this.fileNameStr = t2;
            else {
              var r2 = s.transformTo(e2, this.fileName);
              this.fileNameStr = this.loadOptions.decodeFileName(r2);
            }
            var n2 = this.findExtraFieldUnicodeComment();
            if (null !== n2) this.fileCommentStr = n2;
            else {
              var i2 = s.transformTo(e2, this.fileComment);
              this.fileCommentStr = this.loadOptions.decodeFileName(i2);
            }
          }
        }, findExtraFieldUnicodePath: function() {
          var e2 = this.extraFields[28789];
          if (e2) {
            var t2 = n(e2.value);
            return 1 !== t2.readInt(1) ? null : a(this.fileName) !== t2.readInt(4) ? null : o.utf8decode(t2.readData(e2.length - 5));
          }
          return null;
        }, findExtraFieldUnicodeComment: function() {
          var e2 = this.extraFields[25461];
          if (e2) {
            var t2 = n(e2.value);
            return 1 !== t2.readInt(1) ? null : a(this.fileComment) !== t2.readInt(4) ? null : o.utf8decode(t2.readData(e2.length - 5));
          }
          return null;
        } }, t.exports = l;
      }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(e, t, r) {
        function n(e2, t2, r2) {
          this.name = e2, this.dir = r2.dir, this.date = r2.date, this.comment = r2.comment, this.unixPermissions = r2.unixPermissions, this.dosPermissions = r2.dosPermissions, this._data = t2, this._dataBinary = r2.binary, this.options = { compression: r2.compression, compressionOptions: r2.compressionOptions };
        }
        var s = e("./stream/StreamHelper"), i = e("./stream/DataWorker"), a = e("./utf8"), o = e("./compressedObject"), h = e("./stream/GenericWorker");
        n.prototype = { internalStream: function(e2) {
          var t2 = null, r2 = "string";
          try {
            if (!e2) throw new Error("No output type specified.");
            var n2 = "string" === (r2 = e2.toLowerCase()) || "text" === r2;
            "binarystring" !== r2 && "text" !== r2 || (r2 = "string"), t2 = this._decompressWorker();
            var i2 = !this._dataBinary;
            i2 && !n2 && (t2 = t2.pipe(new a.Utf8EncodeWorker())), !i2 && n2 && (t2 = t2.pipe(new a.Utf8DecodeWorker()));
          } catch (e3) {
            (t2 = new h("error")).error(e3);
          }
          return new s(t2, r2, "");
        }, async: function(e2, t2) {
          return this.internalStream(e2).accumulate(t2);
        }, nodeStream: function(e2, t2) {
          return this.internalStream(e2 || "nodebuffer").toNodejsStream(t2);
        }, _compressWorker: function(e2, t2) {
          if (this._data instanceof o && this._data.compression.magic === e2.magic) return this._data.getCompressedWorker();
          var r2 = this._decompressWorker();
          return this._dataBinary || (r2 = r2.pipe(new a.Utf8EncodeWorker())), o.createWorkerFrom(r2, e2, t2);
        }, _decompressWorker: function() {
          return this._data instanceof o ? this._data.getContentWorker() : this._data instanceof h ? this._data : new i(this._data);
        } };
        for (var u = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], l = function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, f = 0; f < u.length; f++) n.prototype[u[f]] = l;
        t.exports = n;
      }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(e, l, t) {
        (function(t2) {
          var r, n, e2 = t2.MutationObserver || t2.WebKitMutationObserver;
          if (e2) {
            var i = 0, s = new e2(u), a = t2.document.createTextNode("");
            s.observe(a, { characterData: true }), r = function() {
              a.data = i = ++i % 2;
            };
          } else if (t2.setImmediate || void 0 === t2.MessageChannel) r = "document" in t2 && "onreadystatechange" in t2.document.createElement("script") ? function() {
            var e3 = t2.document.createElement("script");
            e3.onreadystatechange = function() {
              u(), e3.onreadystatechange = null, e3.parentNode.removeChild(e3), e3 = null;
            }, t2.document.documentElement.appendChild(e3);
          } : function() {
            setTimeout(u, 0);
          };
          else {
            var o = new t2.MessageChannel();
            o.port1.onmessage = u, r = function() {
              o.port2.postMessage(0);
            };
          }
          var h = [];
          function u() {
            var e3, t3;
            n = true;
            for (var r2 = h.length; r2; ) {
              for (t3 = h, h = [], e3 = -1; ++e3 < r2; ) t3[e3]();
              r2 = h.length;
            }
            n = false;
          }
          l.exports = function(e3) {
            1 !== h.push(e3) || n || r();
          };
        }).call(this, "undefined" != typeof commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, {}], 37: [function(e, t, r) {
        var i = e("immediate");
        function u() {
        }
        var l = {}, s = ["REJECTED"], a = ["FULFILLED"], n = ["PENDING"];
        function o(e2) {
          if ("function" != typeof e2) throw new TypeError("resolver must be a function");
          this.state = n, this.queue = [], this.outcome = void 0, e2 !== u && d(this, e2);
        }
        function h(e2, t2, r2) {
          this.promise = e2, "function" == typeof t2 && (this.onFulfilled = t2, this.callFulfilled = this.otherCallFulfilled), "function" == typeof r2 && (this.onRejected = r2, this.callRejected = this.otherCallRejected);
        }
        function f(t2, r2, n2) {
          i(function() {
            var e2;
            try {
              e2 = r2(n2);
            } catch (e3) {
              return l.reject(t2, e3);
            }
            e2 === t2 ? l.reject(t2, new TypeError("Cannot resolve promise with itself")) : l.resolve(t2, e2);
          });
        }
        function c(e2) {
          var t2 = e2 && e2.then;
          if (e2 && ("object" == typeof e2 || "function" == typeof e2) && "function" == typeof t2) return function() {
            t2.apply(e2, arguments);
          };
        }
        function d(t2, e2) {
          var r2 = false;
          function n2(e3) {
            r2 || (r2 = true, l.reject(t2, e3));
          }
          function i2(e3) {
            r2 || (r2 = true, l.resolve(t2, e3));
          }
          var s2 = p(function() {
            e2(i2, n2);
          });
          "error" === s2.status && n2(s2.value);
        }
        function p(e2, t2) {
          var r2 = {};
          try {
            r2.value = e2(t2), r2.status = "success";
          } catch (e3) {
            r2.status = "error", r2.value = e3;
          }
          return r2;
        }
        (t.exports = o).prototype.finally = function(t2) {
          if ("function" != typeof t2) return this;
          var r2 = this.constructor;
          return this.then(function(e2) {
            return r2.resolve(t2()).then(function() {
              return e2;
            });
          }, function(e2) {
            return r2.resolve(t2()).then(function() {
              throw e2;
            });
          });
        }, o.prototype.catch = function(e2) {
          return this.then(null, e2);
        }, o.prototype.then = function(e2, t2) {
          if ("function" != typeof e2 && this.state === a || "function" != typeof t2 && this.state === s) return this;
          var r2 = new this.constructor(u);
          this.state !== n ? f(r2, this.state === a ? e2 : t2, this.outcome) : this.queue.push(new h(r2, e2, t2));
          return r2;
        }, h.prototype.callFulfilled = function(e2) {
          l.resolve(this.promise, e2);
        }, h.prototype.otherCallFulfilled = function(e2) {
          f(this.promise, this.onFulfilled, e2);
        }, h.prototype.callRejected = function(e2) {
          l.reject(this.promise, e2);
        }, h.prototype.otherCallRejected = function(e2) {
          f(this.promise, this.onRejected, e2);
        }, l.resolve = function(e2, t2) {
          var r2 = p(c, t2);
          if ("error" === r2.status) return l.reject(e2, r2.value);
          var n2 = r2.value;
          if (n2) d(e2, n2);
          else {
            e2.state = a, e2.outcome = t2;
            for (var i2 = -1, s2 = e2.queue.length; ++i2 < s2; ) e2.queue[i2].callFulfilled(t2);
          }
          return e2;
        }, l.reject = function(e2, t2) {
          e2.state = s, e2.outcome = t2;
          for (var r2 = -1, n2 = e2.queue.length; ++r2 < n2; ) e2.queue[r2].callRejected(t2);
          return e2;
        }, o.resolve = function(e2) {
          if (e2 instanceof this) return e2;
          return l.resolve(new this(u), e2);
        }, o.reject = function(e2) {
          var t2 = new this(u);
          return l.reject(t2, e2);
        }, o.all = function(e2) {
          var r2 = this;
          if ("[object Array]" !== Object.prototype.toString.call(e2)) return this.reject(new TypeError("must be an array"));
          var n2 = e2.length, i2 = false;
          if (!n2) return this.resolve([]);
          var s2 = new Array(n2), a2 = 0, t2 = -1, o2 = new this(u);
          for (; ++t2 < n2; ) h2(e2[t2], t2);
          return o2;
          function h2(e3, t3) {
            r2.resolve(e3).then(function(e4) {
              s2[t3] = e4, ++a2 !== n2 || i2 || (i2 = true, l.resolve(o2, s2));
            }, function(e4) {
              i2 || (i2 = true, l.reject(o2, e4));
            });
          }
        }, o.race = function(e2) {
          var t2 = this;
          if ("[object Array]" !== Object.prototype.toString.call(e2)) return this.reject(new TypeError("must be an array"));
          var r2 = e2.length, n2 = false;
          if (!r2) return this.resolve([]);
          var i2 = -1, s2 = new this(u);
          for (; ++i2 < r2; ) a2 = e2[i2], t2.resolve(a2).then(function(e3) {
            n2 || (n2 = true, l.resolve(s2, e3));
          }, function(e3) {
            n2 || (n2 = true, l.reject(s2, e3));
          });
          var a2;
          return s2;
        };
      }, { immediate: 36 }], 38: [function(e, t, r) {
        var n = {};
        (0, e("./lib/utils/common").assign)(n, e("./lib/deflate"), e("./lib/inflate"), e("./lib/zlib/constants")), t.exports = n;
      }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(e, t, r) {
        var a = e("./zlib/deflate"), o = e("./utils/common"), h = e("./utils/strings"), i = e("./zlib/messages"), s = e("./zlib/zstream"), u = Object.prototype.toString, l = 0, f = -1, c = 0, d = 8;
        function p(e2) {
          if (!(this instanceof p)) return new p(e2);
          this.options = o.assign({ level: f, method: d, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: c, to: "" }, e2 || {});
          var t2 = this.options;
          t2.raw && 0 < t2.windowBits ? t2.windowBits = -t2.windowBits : t2.gzip && 0 < t2.windowBits && t2.windowBits < 16 && (t2.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new s(), this.strm.avail_out = 0;
          var r2 = a.deflateInit2(this.strm, t2.level, t2.method, t2.windowBits, t2.memLevel, t2.strategy);
          if (r2 !== l) throw new Error(i[r2]);
          if (t2.header && a.deflateSetHeader(this.strm, t2.header), t2.dictionary) {
            var n2;
            if (n2 = "string" == typeof t2.dictionary ? h.string2buf(t2.dictionary) : "[object ArrayBuffer]" === u.call(t2.dictionary) ? new Uint8Array(t2.dictionary) : t2.dictionary, (r2 = a.deflateSetDictionary(this.strm, n2)) !== l) throw new Error(i[r2]);
            this._dict_set = true;
          }
        }
        function n(e2, t2) {
          var r2 = new p(t2);
          if (r2.push(e2, true), r2.err) throw r2.msg || i[r2.err];
          return r2.result;
        }
        p.prototype.push = function(e2, t2) {
          var r2, n2, i2 = this.strm, s2 = this.options.chunkSize;
          if (this.ended) return false;
          n2 = t2 === ~~t2 ? t2 : true === t2 ? 4 : 0, "string" == typeof e2 ? i2.input = h.string2buf(e2) : "[object ArrayBuffer]" === u.call(e2) ? i2.input = new Uint8Array(e2) : i2.input = e2, i2.next_in = 0, i2.avail_in = i2.input.length;
          do {
            if (0 === i2.avail_out && (i2.output = new o.Buf8(s2), i2.next_out = 0, i2.avail_out = s2), 1 !== (r2 = a.deflate(i2, n2)) && r2 !== l) return this.onEnd(r2), !(this.ended = true);
            0 !== i2.avail_out && (0 !== i2.avail_in || 4 !== n2 && 2 !== n2) || ("string" === this.options.to ? this.onData(h.buf2binstring(o.shrinkBuf(i2.output, i2.next_out))) : this.onData(o.shrinkBuf(i2.output, i2.next_out)));
          } while ((0 < i2.avail_in || 0 === i2.avail_out) && 1 !== r2);
          return 4 === n2 ? (r2 = a.deflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === l) : 2 !== n2 || (this.onEnd(l), !(i2.avail_out = 0));
        }, p.prototype.onData = function(e2) {
          this.chunks.push(e2);
        }, p.prototype.onEnd = function(e2) {
          e2 === l && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
        }, r.Deflate = p, r.deflate = n, r.deflateRaw = function(e2, t2) {
          return (t2 = t2 || {}).raw = true, n(e2, t2);
        }, r.gzip = function(e2, t2) {
          return (t2 = t2 || {}).gzip = true, n(e2, t2);
        };
      }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(e, t, r) {
        var c = e("./zlib/inflate"), d = e("./utils/common"), p = e("./utils/strings"), m = e("./zlib/constants"), n = e("./zlib/messages"), i = e("./zlib/zstream"), s = e("./zlib/gzheader"), _ = Object.prototype.toString;
        function a(e2) {
          if (!(this instanceof a)) return new a(e2);
          this.options = d.assign({ chunkSize: 16384, windowBits: 0, to: "" }, e2 || {});
          var t2 = this.options;
          t2.raw && 0 <= t2.windowBits && t2.windowBits < 16 && (t2.windowBits = -t2.windowBits, 0 === t2.windowBits && (t2.windowBits = -15)), !(0 <= t2.windowBits && t2.windowBits < 16) || e2 && e2.windowBits || (t2.windowBits += 32), 15 < t2.windowBits && t2.windowBits < 48 && 0 == (15 & t2.windowBits) && (t2.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new i(), this.strm.avail_out = 0;
          var r2 = c.inflateInit2(this.strm, t2.windowBits);
          if (r2 !== m.Z_OK) throw new Error(n[r2]);
          this.header = new s(), c.inflateGetHeader(this.strm, this.header);
        }
        function o(e2, t2) {
          var r2 = new a(t2);
          if (r2.push(e2, true), r2.err) throw r2.msg || n[r2.err];
          return r2.result;
        }
        a.prototype.push = function(e2, t2) {
          var r2, n2, i2, s2, a2, o2, h = this.strm, u = this.options.chunkSize, l = this.options.dictionary, f = false;
          if (this.ended) return false;
          n2 = t2 === ~~t2 ? t2 : true === t2 ? m.Z_FINISH : m.Z_NO_FLUSH, "string" == typeof e2 ? h.input = p.binstring2buf(e2) : "[object ArrayBuffer]" === _.call(e2) ? h.input = new Uint8Array(e2) : h.input = e2, h.next_in = 0, h.avail_in = h.input.length;
          do {
            if (0 === h.avail_out && (h.output = new d.Buf8(u), h.next_out = 0, h.avail_out = u), (r2 = c.inflate(h, m.Z_NO_FLUSH)) === m.Z_NEED_DICT && l && (o2 = "string" == typeof l ? p.string2buf(l) : "[object ArrayBuffer]" === _.call(l) ? new Uint8Array(l) : l, r2 = c.inflateSetDictionary(this.strm, o2)), r2 === m.Z_BUF_ERROR && true === f && (r2 = m.Z_OK, f = false), r2 !== m.Z_STREAM_END && r2 !== m.Z_OK) return this.onEnd(r2), !(this.ended = true);
            h.next_out && (0 !== h.avail_out && r2 !== m.Z_STREAM_END && (0 !== h.avail_in || n2 !== m.Z_FINISH && n2 !== m.Z_SYNC_FLUSH) || ("string" === this.options.to ? (i2 = p.utf8border(h.output, h.next_out), s2 = h.next_out - i2, a2 = p.buf2string(h.output, i2), h.next_out = s2, h.avail_out = u - s2, s2 && d.arraySet(h.output, h.output, i2, s2, 0), this.onData(a2)) : this.onData(d.shrinkBuf(h.output, h.next_out)))), 0 === h.avail_in && 0 === h.avail_out && (f = true);
          } while ((0 < h.avail_in || 0 === h.avail_out) && r2 !== m.Z_STREAM_END);
          return r2 === m.Z_STREAM_END && (n2 = m.Z_FINISH), n2 === m.Z_FINISH ? (r2 = c.inflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === m.Z_OK) : n2 !== m.Z_SYNC_FLUSH || (this.onEnd(m.Z_OK), !(h.avail_out = 0));
        }, a.prototype.onData = function(e2) {
          this.chunks.push(e2);
        }, a.prototype.onEnd = function(e2) {
          e2 === m.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = d.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
        }, r.Inflate = a, r.inflate = o, r.inflateRaw = function(e2, t2) {
          return (t2 = t2 || {}).raw = true, o(e2, t2);
        }, r.ungzip = o;
      }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(e, t, r) {
        var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
        r.assign = function(e2) {
          for (var t2 = Array.prototype.slice.call(arguments, 1); t2.length; ) {
            var r2 = t2.shift();
            if (r2) {
              if ("object" != typeof r2) throw new TypeError(r2 + "must be non-object");
              for (var n2 in r2) r2.hasOwnProperty(n2) && (e2[n2] = r2[n2]);
            }
          }
          return e2;
        }, r.shrinkBuf = function(e2, t2) {
          return e2.length === t2 ? e2 : e2.subarray ? e2.subarray(0, t2) : (e2.length = t2, e2);
        };
        var i = { arraySet: function(e2, t2, r2, n2, i2) {
          if (t2.subarray && e2.subarray) e2.set(t2.subarray(r2, r2 + n2), i2);
          else for (var s2 = 0; s2 < n2; s2++) e2[i2 + s2] = t2[r2 + s2];
        }, flattenChunks: function(e2) {
          var t2, r2, n2, i2, s2, a;
          for (t2 = n2 = 0, r2 = e2.length; t2 < r2; t2++) n2 += e2[t2].length;
          for (a = new Uint8Array(n2), t2 = i2 = 0, r2 = e2.length; t2 < r2; t2++) s2 = e2[t2], a.set(s2, i2), i2 += s2.length;
          return a;
        } }, s = { arraySet: function(e2, t2, r2, n2, i2) {
          for (var s2 = 0; s2 < n2; s2++) e2[i2 + s2] = t2[r2 + s2];
        }, flattenChunks: function(e2) {
          return [].concat.apply([], e2);
        } };
        r.setTyped = function(e2) {
          e2 ? (r.Buf8 = Uint8Array, r.Buf16 = Uint16Array, r.Buf32 = Int32Array, r.assign(r, i)) : (r.Buf8 = Array, r.Buf16 = Array, r.Buf32 = Array, r.assign(r, s));
        }, r.setTyped(n);
      }, {}], 42: [function(e, t, r) {
        var h = e("./common"), i = true, s = true;
        try {
          String.fromCharCode.apply(null, [0]);
        } catch (e2) {
          i = false;
        }
        try {
          String.fromCharCode.apply(null, new Uint8Array(1));
        } catch (e2) {
          s = false;
        }
        for (var u = new h.Buf8(256), n = 0; n < 256; n++) u[n] = 252 <= n ? 6 : 248 <= n ? 5 : 240 <= n ? 4 : 224 <= n ? 3 : 192 <= n ? 2 : 1;
        function l(e2, t2) {
          if (t2 < 65537 && (e2.subarray && s || !e2.subarray && i)) return String.fromCharCode.apply(null, h.shrinkBuf(e2, t2));
          for (var r2 = "", n2 = 0; n2 < t2; n2++) r2 += String.fromCharCode(e2[n2]);
          return r2;
        }
        u[254] = u[254] = 1, r.string2buf = function(e2) {
          var t2, r2, n2, i2, s2, a = e2.length, o = 0;
          for (i2 = 0; i2 < a; i2++) 55296 == (64512 & (r2 = e2.charCodeAt(i2))) && i2 + 1 < a && 56320 == (64512 & (n2 = e2.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), o += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
          for (t2 = new h.Buf8(o), i2 = s2 = 0; s2 < o; i2++) 55296 == (64512 & (r2 = e2.charCodeAt(i2))) && i2 + 1 < a && 56320 == (64512 & (n2 = e2.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), r2 < 128 ? t2[s2++] = r2 : (r2 < 2048 ? t2[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? t2[s2++] = 224 | r2 >>> 12 : (t2[s2++] = 240 | r2 >>> 18, t2[s2++] = 128 | r2 >>> 12 & 63), t2[s2++] = 128 | r2 >>> 6 & 63), t2[s2++] = 128 | 63 & r2);
          return t2;
        }, r.buf2binstring = function(e2) {
          return l(e2, e2.length);
        }, r.binstring2buf = function(e2) {
          for (var t2 = new h.Buf8(e2.length), r2 = 0, n2 = t2.length; r2 < n2; r2++) t2[r2] = e2.charCodeAt(r2);
          return t2;
        }, r.buf2string = function(e2, t2) {
          var r2, n2, i2, s2, a = t2 || e2.length, o = new Array(2 * a);
          for (r2 = n2 = 0; r2 < a; ) if ((i2 = e2[r2++]) < 128) o[n2++] = i2;
          else if (4 < (s2 = u[i2])) o[n2++] = 65533, r2 += s2 - 1;
          else {
            for (i2 &= 2 === s2 ? 31 : 3 === s2 ? 15 : 7; 1 < s2 && r2 < a; ) i2 = i2 << 6 | 63 & e2[r2++], s2--;
            1 < s2 ? o[n2++] = 65533 : i2 < 65536 ? o[n2++] = i2 : (i2 -= 65536, o[n2++] = 55296 | i2 >> 10 & 1023, o[n2++] = 56320 | 1023 & i2);
          }
          return l(o, n2);
        }, r.utf8border = function(e2, t2) {
          var r2;
          for ((t2 = t2 || e2.length) > e2.length && (t2 = e2.length), r2 = t2 - 1; 0 <= r2 && 128 == (192 & e2[r2]); ) r2--;
          return r2 < 0 ? t2 : 0 === r2 ? t2 : r2 + u[e2[r2]] > t2 ? r2 : t2;
        };
      }, { "./common": 41 }], 43: [function(e, t, r) {
        t.exports = function(e2, t2, r2, n) {
          for (var i = 65535 & e2 | 0, s = e2 >>> 16 & 65535 | 0, a = 0; 0 !== r2; ) {
            for (r2 -= a = 2e3 < r2 ? 2e3 : r2; s = s + (i = i + t2[n++] | 0) | 0, --a; ) ;
            i %= 65521, s %= 65521;
          }
          return i | s << 16 | 0;
        };
      }, {}], 44: [function(e, t, r) {
        t.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
      }, {}], 45: [function(e, t, r) {
        var o = (function() {
          for (var e2, t2 = [], r2 = 0; r2 < 256; r2++) {
            e2 = r2;
            for (var n = 0; n < 8; n++) e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
            t2[r2] = e2;
          }
          return t2;
        })();
        t.exports = function(e2, t2, r2, n) {
          var i = o, s = n + r2;
          e2 ^= -1;
          for (var a = n; a < s; a++) e2 = e2 >>> 8 ^ i[255 & (e2 ^ t2[a])];
          return -1 ^ e2;
        };
      }, {}], 46: [function(e, t, r) {
        var h, c = e("../utils/common"), u = e("./trees"), d = e("./adler32"), p = e("./crc32"), n = e("./messages"), l = 0, f = 4, m = 0, _ = -2, g = -1, b = 4, i = 2, v = 8, y = 9, s = 286, a = 30, o = 19, w = 2 * s + 1, k = 15, x = 3, S = 258, z = S + x + 1, C = 42, E = 113, A = 1, I = 2, O = 3, B = 4;
        function R(e2, t2) {
          return e2.msg = n[t2], t2;
        }
        function T(e2) {
          return (e2 << 1) - (4 < e2 ? 9 : 0);
        }
        function D(e2) {
          for (var t2 = e2.length; 0 <= --t2; ) e2[t2] = 0;
        }
        function F(e2) {
          var t2 = e2.state, r2 = t2.pending;
          r2 > e2.avail_out && (r2 = e2.avail_out), 0 !== r2 && (c.arraySet(e2.output, t2.pending_buf, t2.pending_out, r2, e2.next_out), e2.next_out += r2, t2.pending_out += r2, e2.total_out += r2, e2.avail_out -= r2, t2.pending -= r2, 0 === t2.pending && (t2.pending_out = 0));
        }
        function N(e2, t2) {
          u._tr_flush_block(e2, 0 <= e2.block_start ? e2.block_start : -1, e2.strstart - e2.block_start, t2), e2.block_start = e2.strstart, F(e2.strm);
        }
        function U(e2, t2) {
          e2.pending_buf[e2.pending++] = t2;
        }
        function P(e2, t2) {
          e2.pending_buf[e2.pending++] = t2 >>> 8 & 255, e2.pending_buf[e2.pending++] = 255 & t2;
        }
        function L(e2, t2) {
          var r2, n2, i2 = e2.max_chain_length, s2 = e2.strstart, a2 = e2.prev_length, o2 = e2.nice_match, h2 = e2.strstart > e2.w_size - z ? e2.strstart - (e2.w_size - z) : 0, u2 = e2.window, l2 = e2.w_mask, f2 = e2.prev, c2 = e2.strstart + S, d2 = u2[s2 + a2 - 1], p2 = u2[s2 + a2];
          e2.prev_length >= e2.good_match && (i2 >>= 2), o2 > e2.lookahead && (o2 = e2.lookahead);
          do {
            if (u2[(r2 = t2) + a2] === p2 && u2[r2 + a2 - 1] === d2 && u2[r2] === u2[s2] && u2[++r2] === u2[s2 + 1]) {
              s2 += 2, r2++;
              do {
              } while (u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && s2 < c2);
              if (n2 = S - (c2 - s2), s2 = c2 - S, a2 < n2) {
                if (e2.match_start = t2, o2 <= (a2 = n2)) break;
                d2 = u2[s2 + a2 - 1], p2 = u2[s2 + a2];
              }
            }
          } while ((t2 = f2[t2 & l2]) > h2 && 0 != --i2);
          return a2 <= e2.lookahead ? a2 : e2.lookahead;
        }
        function j(e2) {
          var t2, r2, n2, i2, s2, a2, o2, h2, u2, l2, f2 = e2.w_size;
          do {
            if (i2 = e2.window_size - e2.lookahead - e2.strstart, e2.strstart >= f2 + (f2 - z)) {
              for (c.arraySet(e2.window, e2.window, f2, f2, 0), e2.match_start -= f2, e2.strstart -= f2, e2.block_start -= f2, t2 = r2 = e2.hash_size; n2 = e2.head[--t2], e2.head[t2] = f2 <= n2 ? n2 - f2 : 0, --r2; ) ;
              for (t2 = r2 = f2; n2 = e2.prev[--t2], e2.prev[t2] = f2 <= n2 ? n2 - f2 : 0, --r2; ) ;
              i2 += f2;
            }
            if (0 === e2.strm.avail_in) break;
            if (a2 = e2.strm, o2 = e2.window, h2 = e2.strstart + e2.lookahead, u2 = i2, l2 = void 0, l2 = a2.avail_in, u2 < l2 && (l2 = u2), r2 = 0 === l2 ? 0 : (a2.avail_in -= l2, c.arraySet(o2, a2.input, a2.next_in, l2, h2), 1 === a2.state.wrap ? a2.adler = d(a2.adler, o2, l2, h2) : 2 === a2.state.wrap && (a2.adler = p(a2.adler, o2, l2, h2)), a2.next_in += l2, a2.total_in += l2, l2), e2.lookahead += r2, e2.lookahead + e2.insert >= x) for (s2 = e2.strstart - e2.insert, e2.ins_h = e2.window[s2], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s2 + 1]) & e2.hash_mask; e2.insert && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s2 + x - 1]) & e2.hash_mask, e2.prev[s2 & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = s2, s2++, e2.insert--, !(e2.lookahead + e2.insert < x)); ) ;
          } while (e2.lookahead < z && 0 !== e2.strm.avail_in);
        }
        function Z(e2, t2) {
          for (var r2, n2; ; ) {
            if (e2.lookahead < z) {
              if (j(e2), e2.lookahead < z && t2 === l) return A;
              if (0 === e2.lookahead) break;
            }
            if (r2 = 0, e2.lookahead >= x && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), 0 !== r2 && e2.strstart - r2 <= e2.w_size - z && (e2.match_length = L(e2, r2)), e2.match_length >= x) if (n2 = u._tr_tally(e2, e2.strstart - e2.match_start, e2.match_length - x), e2.lookahead -= e2.match_length, e2.match_length <= e2.max_lazy_match && e2.lookahead >= x) {
              for (e2.match_length--; e2.strstart++, e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart, 0 != --e2.match_length; ) ;
              e2.strstart++;
            } else e2.strstart += e2.match_length, e2.match_length = 0, e2.ins_h = e2.window[e2.strstart], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + 1]) & e2.hash_mask;
            else n2 = u._tr_tally(e2, 0, e2.window[e2.strstart]), e2.lookahead--, e2.strstart++;
            if (n2 && (N(e2, false), 0 === e2.strm.avail_out)) return A;
          }
          return e2.insert = e2.strstart < x - 1 ? e2.strstart : x - 1, t2 === f ? (N(e2, true), 0 === e2.strm.avail_out ? O : B) : e2.last_lit && (N(e2, false), 0 === e2.strm.avail_out) ? A : I;
        }
        function W(e2, t2) {
          for (var r2, n2, i2; ; ) {
            if (e2.lookahead < z) {
              if (j(e2), e2.lookahead < z && t2 === l) return A;
              if (0 === e2.lookahead) break;
            }
            if (r2 = 0, e2.lookahead >= x && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), e2.prev_length = e2.match_length, e2.prev_match = e2.match_start, e2.match_length = x - 1, 0 !== r2 && e2.prev_length < e2.max_lazy_match && e2.strstart - r2 <= e2.w_size - z && (e2.match_length = L(e2, r2), e2.match_length <= 5 && (1 === e2.strategy || e2.match_length === x && 4096 < e2.strstart - e2.match_start) && (e2.match_length = x - 1)), e2.prev_length >= x && e2.match_length <= e2.prev_length) {
              for (i2 = e2.strstart + e2.lookahead - x, n2 = u._tr_tally(e2, e2.strstart - 1 - e2.prev_match, e2.prev_length - x), e2.lookahead -= e2.prev_length - 1, e2.prev_length -= 2; ++e2.strstart <= i2 && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), 0 != --e2.prev_length; ) ;
              if (e2.match_available = 0, e2.match_length = x - 1, e2.strstart++, n2 && (N(e2, false), 0 === e2.strm.avail_out)) return A;
            } else if (e2.match_available) {
              if ((n2 = u._tr_tally(e2, 0, e2.window[e2.strstart - 1])) && N(e2, false), e2.strstart++, e2.lookahead--, 0 === e2.strm.avail_out) return A;
            } else e2.match_available = 1, e2.strstart++, e2.lookahead--;
          }
          return e2.match_available && (n2 = u._tr_tally(e2, 0, e2.window[e2.strstart - 1]), e2.match_available = 0), e2.insert = e2.strstart < x - 1 ? e2.strstart : x - 1, t2 === f ? (N(e2, true), 0 === e2.strm.avail_out ? O : B) : e2.last_lit && (N(e2, false), 0 === e2.strm.avail_out) ? A : I;
        }
        function M(e2, t2, r2, n2, i2) {
          this.good_length = e2, this.max_lazy = t2, this.nice_length = r2, this.max_chain = n2, this.func = i2;
        }
        function H() {
          this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = v, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new c.Buf16(2 * w), this.dyn_dtree = new c.Buf16(2 * (2 * a + 1)), this.bl_tree = new c.Buf16(2 * (2 * o + 1)), D(this.dyn_ltree), D(this.dyn_dtree), D(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new c.Buf16(k + 1), this.heap = new c.Buf16(2 * s + 1), D(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new c.Buf16(2 * s + 1), D(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
        }
        function G(e2) {
          var t2;
          return e2 && e2.state ? (e2.total_in = e2.total_out = 0, e2.data_type = i, (t2 = e2.state).pending = 0, t2.pending_out = 0, t2.wrap < 0 && (t2.wrap = -t2.wrap), t2.status = t2.wrap ? C : E, e2.adler = 2 === t2.wrap ? 0 : 1, t2.last_flush = l, u._tr_init(t2), m) : R(e2, _);
        }
        function K(e2) {
          var t2 = G(e2);
          return t2 === m && (function(e3) {
            e3.window_size = 2 * e3.w_size, D(e3.head), e3.max_lazy_match = h[e3.level].max_lazy, e3.good_match = h[e3.level].good_length, e3.nice_match = h[e3.level].nice_length, e3.max_chain_length = h[e3.level].max_chain, e3.strstart = 0, e3.block_start = 0, e3.lookahead = 0, e3.insert = 0, e3.match_length = e3.prev_length = x - 1, e3.match_available = 0, e3.ins_h = 0;
          })(e2.state), t2;
        }
        function Y(e2, t2, r2, n2, i2, s2) {
          if (!e2) return _;
          var a2 = 1;
          if (t2 === g && (t2 = 6), n2 < 0 ? (a2 = 0, n2 = -n2) : 15 < n2 && (a2 = 2, n2 -= 16), i2 < 1 || y < i2 || r2 !== v || n2 < 8 || 15 < n2 || t2 < 0 || 9 < t2 || s2 < 0 || b < s2) return R(e2, _);
          8 === n2 && (n2 = 9);
          var o2 = new H();
          return (e2.state = o2).strm = e2, o2.wrap = a2, o2.gzhead = null, o2.w_bits = n2, o2.w_size = 1 << o2.w_bits, o2.w_mask = o2.w_size - 1, o2.hash_bits = i2 + 7, o2.hash_size = 1 << o2.hash_bits, o2.hash_mask = o2.hash_size - 1, o2.hash_shift = ~~((o2.hash_bits + x - 1) / x), o2.window = new c.Buf8(2 * o2.w_size), o2.head = new c.Buf16(o2.hash_size), o2.prev = new c.Buf16(o2.w_size), o2.lit_bufsize = 1 << i2 + 6, o2.pending_buf_size = 4 * o2.lit_bufsize, o2.pending_buf = new c.Buf8(o2.pending_buf_size), o2.d_buf = 1 * o2.lit_bufsize, o2.l_buf = 3 * o2.lit_bufsize, o2.level = t2, o2.strategy = s2, o2.method = r2, K(e2);
        }
        h = [new M(0, 0, 0, 0, function(e2, t2) {
          var r2 = 65535;
          for (r2 > e2.pending_buf_size - 5 && (r2 = e2.pending_buf_size - 5); ; ) {
            if (e2.lookahead <= 1) {
              if (j(e2), 0 === e2.lookahead && t2 === l) return A;
              if (0 === e2.lookahead) break;
            }
            e2.strstart += e2.lookahead, e2.lookahead = 0;
            var n2 = e2.block_start + r2;
            if ((0 === e2.strstart || e2.strstart >= n2) && (e2.lookahead = e2.strstart - n2, e2.strstart = n2, N(e2, false), 0 === e2.strm.avail_out)) return A;
            if (e2.strstart - e2.block_start >= e2.w_size - z && (N(e2, false), 0 === e2.strm.avail_out)) return A;
          }
          return e2.insert = 0, t2 === f ? (N(e2, true), 0 === e2.strm.avail_out ? O : B) : (e2.strstart > e2.block_start && (N(e2, false), e2.strm.avail_out), A);
        }), new M(4, 4, 8, 4, Z), new M(4, 5, 16, 8, Z), new M(4, 6, 32, 32, Z), new M(4, 4, 16, 16, W), new M(8, 16, 32, 32, W), new M(8, 16, 128, 128, W), new M(8, 32, 128, 256, W), new M(32, 128, 258, 1024, W), new M(32, 258, 258, 4096, W)], r.deflateInit = function(e2, t2) {
          return Y(e2, t2, v, 15, 8, 0);
        }, r.deflateInit2 = Y, r.deflateReset = K, r.deflateResetKeep = G, r.deflateSetHeader = function(e2, t2) {
          return e2 && e2.state ? 2 !== e2.state.wrap ? _ : (e2.state.gzhead = t2, m) : _;
        }, r.deflate = function(e2, t2) {
          var r2, n2, i2, s2;
          if (!e2 || !e2.state || 5 < t2 || t2 < 0) return e2 ? R(e2, _) : _;
          if (n2 = e2.state, !e2.output || !e2.input && 0 !== e2.avail_in || 666 === n2.status && t2 !== f) return R(e2, 0 === e2.avail_out ? -5 : _);
          if (n2.strm = e2, r2 = n2.last_flush, n2.last_flush = t2, n2.status === C) if (2 === n2.wrap) e2.adler = 0, U(n2, 31), U(n2, 139), U(n2, 8), n2.gzhead ? (U(n2, (n2.gzhead.text ? 1 : 0) + (n2.gzhead.hcrc ? 2 : 0) + (n2.gzhead.extra ? 4 : 0) + (n2.gzhead.name ? 8 : 0) + (n2.gzhead.comment ? 16 : 0)), U(n2, 255 & n2.gzhead.time), U(n2, n2.gzhead.time >> 8 & 255), U(n2, n2.gzhead.time >> 16 & 255), U(n2, n2.gzhead.time >> 24 & 255), U(n2, 9 === n2.level ? 2 : 2 <= n2.strategy || n2.level < 2 ? 4 : 0), U(n2, 255 & n2.gzhead.os), n2.gzhead.extra && n2.gzhead.extra.length && (U(n2, 255 & n2.gzhead.extra.length), U(n2, n2.gzhead.extra.length >> 8 & 255)), n2.gzhead.hcrc && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending, 0)), n2.gzindex = 0, n2.status = 69) : (U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 9 === n2.level ? 2 : 2 <= n2.strategy || n2.level < 2 ? 4 : 0), U(n2, 3), n2.status = E);
          else {
            var a2 = v + (n2.w_bits - 8 << 4) << 8;
            a2 |= (2 <= n2.strategy || n2.level < 2 ? 0 : n2.level < 6 ? 1 : 6 === n2.level ? 2 : 3) << 6, 0 !== n2.strstart && (a2 |= 32), a2 += 31 - a2 % 31, n2.status = E, P(n2, a2), 0 !== n2.strstart && (P(n2, e2.adler >>> 16), P(n2, 65535 & e2.adler)), e2.adler = 1;
          }
          if (69 === n2.status) if (n2.gzhead.extra) {
            for (i2 = n2.pending; n2.gzindex < (65535 & n2.gzhead.extra.length) && (n2.pending !== n2.pending_buf_size || (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending !== n2.pending_buf_size)); ) U(n2, 255 & n2.gzhead.extra[n2.gzindex]), n2.gzindex++;
            n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), n2.gzindex === n2.gzhead.extra.length && (n2.gzindex = 0, n2.status = 73);
          } else n2.status = 73;
          if (73 === n2.status) if (n2.gzhead.name) {
            i2 = n2.pending;
            do {
              if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending === n2.pending_buf_size)) {
                s2 = 1;
                break;
              }
              s2 = n2.gzindex < n2.gzhead.name.length ? 255 & n2.gzhead.name.charCodeAt(n2.gzindex++) : 0, U(n2, s2);
            } while (0 !== s2);
            n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), 0 === s2 && (n2.gzindex = 0, n2.status = 91);
          } else n2.status = 91;
          if (91 === n2.status) if (n2.gzhead.comment) {
            i2 = n2.pending;
            do {
              if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending === n2.pending_buf_size)) {
                s2 = 1;
                break;
              }
              s2 = n2.gzindex < n2.gzhead.comment.length ? 255 & n2.gzhead.comment.charCodeAt(n2.gzindex++) : 0, U(n2, s2);
            } while (0 !== s2);
            n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), 0 === s2 && (n2.status = 103);
          } else n2.status = 103;
          if (103 === n2.status && (n2.gzhead.hcrc ? (n2.pending + 2 > n2.pending_buf_size && F(e2), n2.pending + 2 <= n2.pending_buf_size && (U(n2, 255 & e2.adler), U(n2, e2.adler >> 8 & 255), e2.adler = 0, n2.status = E)) : n2.status = E), 0 !== n2.pending) {
            if (F(e2), 0 === e2.avail_out) return n2.last_flush = -1, m;
          } else if (0 === e2.avail_in && T(t2) <= T(r2) && t2 !== f) return R(e2, -5);
          if (666 === n2.status && 0 !== e2.avail_in) return R(e2, -5);
          if (0 !== e2.avail_in || 0 !== n2.lookahead || t2 !== l && 666 !== n2.status) {
            var o2 = 2 === n2.strategy ? (function(e3, t3) {
              for (var r3; ; ) {
                if (0 === e3.lookahead && (j(e3), 0 === e3.lookahead)) {
                  if (t3 === l) return A;
                  break;
                }
                if (e3.match_length = 0, r3 = u._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++, r3 && (N(e3, false), 0 === e3.strm.avail_out)) return A;
              }
              return e3.insert = 0, t3 === f ? (N(e3, true), 0 === e3.strm.avail_out ? O : B) : e3.last_lit && (N(e3, false), 0 === e3.strm.avail_out) ? A : I;
            })(n2, t2) : 3 === n2.strategy ? (function(e3, t3) {
              for (var r3, n3, i3, s3, a3 = e3.window; ; ) {
                if (e3.lookahead <= S) {
                  if (j(e3), e3.lookahead <= S && t3 === l) return A;
                  if (0 === e3.lookahead) break;
                }
                if (e3.match_length = 0, e3.lookahead >= x && 0 < e3.strstart && (n3 = a3[i3 = e3.strstart - 1]) === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3]) {
                  s3 = e3.strstart + S;
                  do {
                  } while (n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && i3 < s3);
                  e3.match_length = S - (s3 - i3), e3.match_length > e3.lookahead && (e3.match_length = e3.lookahead);
                }
                if (e3.match_length >= x ? (r3 = u._tr_tally(e3, 1, e3.match_length - x), e3.lookahead -= e3.match_length, e3.strstart += e3.match_length, e3.match_length = 0) : (r3 = u._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++), r3 && (N(e3, false), 0 === e3.strm.avail_out)) return A;
              }
              return e3.insert = 0, t3 === f ? (N(e3, true), 0 === e3.strm.avail_out ? O : B) : e3.last_lit && (N(e3, false), 0 === e3.strm.avail_out) ? A : I;
            })(n2, t2) : h[n2.level].func(n2, t2);
            if (o2 !== O && o2 !== B || (n2.status = 666), o2 === A || o2 === O) return 0 === e2.avail_out && (n2.last_flush = -1), m;
            if (o2 === I && (1 === t2 ? u._tr_align(n2) : 5 !== t2 && (u._tr_stored_block(n2, 0, 0, false), 3 === t2 && (D(n2.head), 0 === n2.lookahead && (n2.strstart = 0, n2.block_start = 0, n2.insert = 0))), F(e2), 0 === e2.avail_out)) return n2.last_flush = -1, m;
          }
          return t2 !== f ? m : n2.wrap <= 0 ? 1 : (2 === n2.wrap ? (U(n2, 255 & e2.adler), U(n2, e2.adler >> 8 & 255), U(n2, e2.adler >> 16 & 255), U(n2, e2.adler >> 24 & 255), U(n2, 255 & e2.total_in), U(n2, e2.total_in >> 8 & 255), U(n2, e2.total_in >> 16 & 255), U(n2, e2.total_in >> 24 & 255)) : (P(n2, e2.adler >>> 16), P(n2, 65535 & e2.adler)), F(e2), 0 < n2.wrap && (n2.wrap = -n2.wrap), 0 !== n2.pending ? m : 1);
        }, r.deflateEnd = function(e2) {
          var t2;
          return e2 && e2.state ? (t2 = e2.state.status) !== C && 69 !== t2 && 73 !== t2 && 91 !== t2 && 103 !== t2 && t2 !== E && 666 !== t2 ? R(e2, _) : (e2.state = null, t2 === E ? R(e2, -3) : m) : _;
        }, r.deflateSetDictionary = function(e2, t2) {
          var r2, n2, i2, s2, a2, o2, h2, u2, l2 = t2.length;
          if (!e2 || !e2.state) return _;
          if (2 === (s2 = (r2 = e2.state).wrap) || 1 === s2 && r2.status !== C || r2.lookahead) return _;
          for (1 === s2 && (e2.adler = d(e2.adler, t2, l2, 0)), r2.wrap = 0, l2 >= r2.w_size && (0 === s2 && (D(r2.head), r2.strstart = 0, r2.block_start = 0, r2.insert = 0), u2 = new c.Buf8(r2.w_size), c.arraySet(u2, t2, l2 - r2.w_size, r2.w_size, 0), t2 = u2, l2 = r2.w_size), a2 = e2.avail_in, o2 = e2.next_in, h2 = e2.input, e2.avail_in = l2, e2.next_in = 0, e2.input = t2, j(r2); r2.lookahead >= x; ) {
            for (n2 = r2.strstart, i2 = r2.lookahead - (x - 1); r2.ins_h = (r2.ins_h << r2.hash_shift ^ r2.window[n2 + x - 1]) & r2.hash_mask, r2.prev[n2 & r2.w_mask] = r2.head[r2.ins_h], r2.head[r2.ins_h] = n2, n2++, --i2; ) ;
            r2.strstart = n2, r2.lookahead = x - 1, j(r2);
          }
          return r2.strstart += r2.lookahead, r2.block_start = r2.strstart, r2.insert = r2.lookahead, r2.lookahead = 0, r2.match_length = r2.prev_length = x - 1, r2.match_available = 0, e2.next_in = o2, e2.input = h2, e2.avail_in = a2, r2.wrap = s2, m;
        }, r.deflateInfo = "pako deflate (from Nodeca project)";
      }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(e, t, r) {
        t.exports = function() {
          this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
        };
      }, {}], 48: [function(e, t, r) {
        t.exports = function(e2, t2) {
          var r2, n, i, s, a, o, h, u, l, f, c, d, p, m, _, g, b, v, y, w, k, x, S, z, C;
          r2 = e2.state, n = e2.next_in, z = e2.input, i = n + (e2.avail_in - 5), s = e2.next_out, C = e2.output, a = s - (t2 - e2.avail_out), o = s + (e2.avail_out - 257), h = r2.dmax, u = r2.wsize, l = r2.whave, f = r2.wnext, c = r2.window, d = r2.hold, p = r2.bits, m = r2.lencode, _ = r2.distcode, g = (1 << r2.lenbits) - 1, b = (1 << r2.distbits) - 1;
          e: do {
            p < 15 && (d += z[n++] << p, p += 8, d += z[n++] << p, p += 8), v = m[d & g];
            t: for (; ; ) {
              if (d >>>= y = v >>> 24, p -= y, 0 === (y = v >>> 16 & 255)) C[s++] = 65535 & v;
              else {
                if (!(16 & y)) {
                  if (0 == (64 & y)) {
                    v = m[(65535 & v) + (d & (1 << y) - 1)];
                    continue t;
                  }
                  if (32 & y) {
                    r2.mode = 12;
                    break e;
                  }
                  e2.msg = "invalid literal/length code", r2.mode = 30;
                  break e;
                }
                w = 65535 & v, (y &= 15) && (p < y && (d += z[n++] << p, p += 8), w += d & (1 << y) - 1, d >>>= y, p -= y), p < 15 && (d += z[n++] << p, p += 8, d += z[n++] << p, p += 8), v = _[d & b];
                r: for (; ; ) {
                  if (d >>>= y = v >>> 24, p -= y, !(16 & (y = v >>> 16 & 255))) {
                    if (0 == (64 & y)) {
                      v = _[(65535 & v) + (d & (1 << y) - 1)];
                      continue r;
                    }
                    e2.msg = "invalid distance code", r2.mode = 30;
                    break e;
                  }
                  if (k = 65535 & v, p < (y &= 15) && (d += z[n++] << p, (p += 8) < y && (d += z[n++] << p, p += 8)), h < (k += d & (1 << y) - 1)) {
                    e2.msg = "invalid distance too far back", r2.mode = 30;
                    break e;
                  }
                  if (d >>>= y, p -= y, (y = s - a) < k) {
                    if (l < (y = k - y) && r2.sane) {
                      e2.msg = "invalid distance too far back", r2.mode = 30;
                      break e;
                    }
                    if (S = c, (x = 0) === f) {
                      if (x += u - y, y < w) {
                        for (w -= y; C[s++] = c[x++], --y; ) ;
                        x = s - k, S = C;
                      }
                    } else if (f < y) {
                      if (x += u + f - y, (y -= f) < w) {
                        for (w -= y; C[s++] = c[x++], --y; ) ;
                        if (x = 0, f < w) {
                          for (w -= y = f; C[s++] = c[x++], --y; ) ;
                          x = s - k, S = C;
                        }
                      }
                    } else if (x += f - y, y < w) {
                      for (w -= y; C[s++] = c[x++], --y; ) ;
                      x = s - k, S = C;
                    }
                    for (; 2 < w; ) C[s++] = S[x++], C[s++] = S[x++], C[s++] = S[x++], w -= 3;
                    w && (C[s++] = S[x++], 1 < w && (C[s++] = S[x++]));
                  } else {
                    for (x = s - k; C[s++] = C[x++], C[s++] = C[x++], C[s++] = C[x++], 2 < (w -= 3); ) ;
                    w && (C[s++] = C[x++], 1 < w && (C[s++] = C[x++]));
                  }
                  break;
                }
              }
              break;
            }
          } while (n < i && s < o);
          n -= w = p >> 3, d &= (1 << (p -= w << 3)) - 1, e2.next_in = n, e2.next_out = s, e2.avail_in = n < i ? i - n + 5 : 5 - (n - i), e2.avail_out = s < o ? o - s + 257 : 257 - (s - o), r2.hold = d, r2.bits = p;
        };
      }, {}], 49: [function(e, t, r) {
        var I = e("../utils/common"), O = e("./adler32"), B = e("./crc32"), R = e("./inffast"), T = e("./inftrees"), D = 1, F = 2, N = 0, U = -2, P = 1, n = 852, i = 592;
        function L(e2) {
          return (e2 >>> 24 & 255) + (e2 >>> 8 & 65280) + ((65280 & e2) << 8) + ((255 & e2) << 24);
        }
        function s() {
          this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new I.Buf16(320), this.work = new I.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
        }
        function a(e2) {
          var t2;
          return e2 && e2.state ? (t2 = e2.state, e2.total_in = e2.total_out = t2.total = 0, e2.msg = "", t2.wrap && (e2.adler = 1 & t2.wrap), t2.mode = P, t2.last = 0, t2.havedict = 0, t2.dmax = 32768, t2.head = null, t2.hold = 0, t2.bits = 0, t2.lencode = t2.lendyn = new I.Buf32(n), t2.distcode = t2.distdyn = new I.Buf32(i), t2.sane = 1, t2.back = -1, N) : U;
        }
        function o(e2) {
          var t2;
          return e2 && e2.state ? ((t2 = e2.state).wsize = 0, t2.whave = 0, t2.wnext = 0, a(e2)) : U;
        }
        function h(e2, t2) {
          var r2, n2;
          return e2 && e2.state ? (n2 = e2.state, t2 < 0 ? (r2 = 0, t2 = -t2) : (r2 = 1 + (t2 >> 4), t2 < 48 && (t2 &= 15)), t2 && (t2 < 8 || 15 < t2) ? U : (null !== n2.window && n2.wbits !== t2 && (n2.window = null), n2.wrap = r2, n2.wbits = t2, o(e2))) : U;
        }
        function u(e2, t2) {
          var r2, n2;
          return e2 ? (n2 = new s(), (e2.state = n2).window = null, (r2 = h(e2, t2)) !== N && (e2.state = null), r2) : U;
        }
        var l, f, c = true;
        function j(e2) {
          if (c) {
            var t2;
            for (l = new I.Buf32(512), f = new I.Buf32(32), t2 = 0; t2 < 144; ) e2.lens[t2++] = 8;
            for (; t2 < 256; ) e2.lens[t2++] = 9;
            for (; t2 < 280; ) e2.lens[t2++] = 7;
            for (; t2 < 288; ) e2.lens[t2++] = 8;
            for (T(D, e2.lens, 0, 288, l, 0, e2.work, { bits: 9 }), t2 = 0; t2 < 32; ) e2.lens[t2++] = 5;
            T(F, e2.lens, 0, 32, f, 0, e2.work, { bits: 5 }), c = false;
          }
          e2.lencode = l, e2.lenbits = 9, e2.distcode = f, e2.distbits = 5;
        }
        function Z(e2, t2, r2, n2) {
          var i2, s2 = e2.state;
          return null === s2.window && (s2.wsize = 1 << s2.wbits, s2.wnext = 0, s2.whave = 0, s2.window = new I.Buf8(s2.wsize)), n2 >= s2.wsize ? (I.arraySet(s2.window, t2, r2 - s2.wsize, s2.wsize, 0), s2.wnext = 0, s2.whave = s2.wsize) : (n2 < (i2 = s2.wsize - s2.wnext) && (i2 = n2), I.arraySet(s2.window, t2, r2 - n2, i2, s2.wnext), (n2 -= i2) ? (I.arraySet(s2.window, t2, r2 - n2, n2, 0), s2.wnext = n2, s2.whave = s2.wsize) : (s2.wnext += i2, s2.wnext === s2.wsize && (s2.wnext = 0), s2.whave < s2.wsize && (s2.whave += i2))), 0;
        }
        r.inflateReset = o, r.inflateReset2 = h, r.inflateResetKeep = a, r.inflateInit = function(e2) {
          return u(e2, 15);
        }, r.inflateInit2 = u, r.inflate = function(e2, t2) {
          var r2, n2, i2, s2, a2, o2, h2, u2, l2, f2, c2, d, p, m, _, g, b, v, y, w, k, x, S, z, C = 0, E = new I.Buf8(4), A = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
          if (!e2 || !e2.state || !e2.output || !e2.input && 0 !== e2.avail_in) return U;
          12 === (r2 = e2.state).mode && (r2.mode = 13), a2 = e2.next_out, i2 = e2.output, h2 = e2.avail_out, s2 = e2.next_in, n2 = e2.input, o2 = e2.avail_in, u2 = r2.hold, l2 = r2.bits, f2 = o2, c2 = h2, x = N;
          e: for (; ; ) switch (r2.mode) {
            case P:
              if (0 === r2.wrap) {
                r2.mode = 13;
                break;
              }
              for (; l2 < 16; ) {
                if (0 === o2) break e;
                o2--, u2 += n2[s2++] << l2, l2 += 8;
              }
              if (2 & r2.wrap && 35615 === u2) {
                E[r2.check = 0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0), l2 = u2 = 0, r2.mode = 2;
                break;
              }
              if (r2.flags = 0, r2.head && (r2.head.done = false), !(1 & r2.wrap) || (((255 & u2) << 8) + (u2 >> 8)) % 31) {
                e2.msg = "incorrect header check", r2.mode = 30;
                break;
              }
              if (8 != (15 & u2)) {
                e2.msg = "unknown compression method", r2.mode = 30;
                break;
              }
              if (l2 -= 4, k = 8 + (15 & (u2 >>>= 4)), 0 === r2.wbits) r2.wbits = k;
              else if (k > r2.wbits) {
                e2.msg = "invalid window size", r2.mode = 30;
                break;
              }
              r2.dmax = 1 << k, e2.adler = r2.check = 1, r2.mode = 512 & u2 ? 10 : 12, l2 = u2 = 0;
              break;
            case 2:
              for (; l2 < 16; ) {
                if (0 === o2) break e;
                o2--, u2 += n2[s2++] << l2, l2 += 8;
              }
              if (r2.flags = u2, 8 != (255 & r2.flags)) {
                e2.msg = "unknown compression method", r2.mode = 30;
                break;
              }
              if (57344 & r2.flags) {
                e2.msg = "unknown header flags set", r2.mode = 30;
                break;
              }
              r2.head && (r2.head.text = u2 >> 8 & 1), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0, r2.mode = 3;
            case 3:
              for (; l2 < 32; ) {
                if (0 === o2) break e;
                o2--, u2 += n2[s2++] << l2, l2 += 8;
              }
              r2.head && (r2.head.time = u2), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, E[2] = u2 >>> 16 & 255, E[3] = u2 >>> 24 & 255, r2.check = B(r2.check, E, 4, 0)), l2 = u2 = 0, r2.mode = 4;
            case 4:
              for (; l2 < 16; ) {
                if (0 === o2) break e;
                o2--, u2 += n2[s2++] << l2, l2 += 8;
              }
              r2.head && (r2.head.xflags = 255 & u2, r2.head.os = u2 >> 8), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0, r2.mode = 5;
            case 5:
              if (1024 & r2.flags) {
                for (; l2 < 16; ) {
                  if (0 === o2) break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                r2.length = u2, r2.head && (r2.head.extra_len = u2), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0;
              } else r2.head && (r2.head.extra = null);
              r2.mode = 6;
            case 6:
              if (1024 & r2.flags && (o2 < (d = r2.length) && (d = o2), d && (r2.head && (k = r2.head.extra_len - r2.length, r2.head.extra || (r2.head.extra = new Array(r2.head.extra_len)), I.arraySet(r2.head.extra, n2, s2, d, k)), 512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, r2.length -= d), r2.length)) break e;
              r2.length = 0, r2.mode = 7;
            case 7:
              if (2048 & r2.flags) {
                if (0 === o2) break e;
                for (d = 0; k = n2[s2 + d++], r2.head && k && r2.length < 65536 && (r2.head.name += String.fromCharCode(k)), k && d < o2; ) ;
                if (512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, k) break e;
              } else r2.head && (r2.head.name = null);
              r2.length = 0, r2.mode = 8;
            case 8:
              if (4096 & r2.flags) {
                if (0 === o2) break e;
                for (d = 0; k = n2[s2 + d++], r2.head && k && r2.length < 65536 && (r2.head.comment += String.fromCharCode(k)), k && d < o2; ) ;
                if (512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, k) break e;
              } else r2.head && (r2.head.comment = null);
              r2.mode = 9;
            case 9:
              if (512 & r2.flags) {
                for (; l2 < 16; ) {
                  if (0 === o2) break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                if (u2 !== (65535 & r2.check)) {
                  e2.msg = "header crc mismatch", r2.mode = 30;
                  break;
                }
                l2 = u2 = 0;
              }
              r2.head && (r2.head.hcrc = r2.flags >> 9 & 1, r2.head.done = true), e2.adler = r2.check = 0, r2.mode = 12;
              break;
            case 10:
              for (; l2 < 32; ) {
                if (0 === o2) break e;
                o2--, u2 += n2[s2++] << l2, l2 += 8;
              }
              e2.adler = r2.check = L(u2), l2 = u2 = 0, r2.mode = 11;
            case 11:
              if (0 === r2.havedict) return e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, 2;
              e2.adler = r2.check = 1, r2.mode = 12;
            case 12:
              if (5 === t2 || 6 === t2) break e;
            case 13:
              if (r2.last) {
                u2 >>>= 7 & l2, l2 -= 7 & l2, r2.mode = 27;
                break;
              }
              for (; l2 < 3; ) {
                if (0 === o2) break e;
                o2--, u2 += n2[s2++] << l2, l2 += 8;
              }
              switch (r2.last = 1 & u2, l2 -= 1, 3 & (u2 >>>= 1)) {
                case 0:
                  r2.mode = 14;
                  break;
                case 1:
                  if (j(r2), r2.mode = 20, 6 !== t2) break;
                  u2 >>>= 2, l2 -= 2;
                  break e;
                case 2:
                  r2.mode = 17;
                  break;
                case 3:
                  e2.msg = "invalid block type", r2.mode = 30;
              }
              u2 >>>= 2, l2 -= 2;
              break;
            case 14:
              for (u2 >>>= 7 & l2, l2 -= 7 & l2; l2 < 32; ) {
                if (0 === o2) break e;
                o2--, u2 += n2[s2++] << l2, l2 += 8;
              }
              if ((65535 & u2) != (u2 >>> 16 ^ 65535)) {
                e2.msg = "invalid stored block lengths", r2.mode = 30;
                break;
              }
              if (r2.length = 65535 & u2, l2 = u2 = 0, r2.mode = 15, 6 === t2) break e;
            case 15:
              r2.mode = 16;
            case 16:
              if (d = r2.length) {
                if (o2 < d && (d = o2), h2 < d && (d = h2), 0 === d) break e;
                I.arraySet(i2, n2, s2, d, a2), o2 -= d, s2 += d, h2 -= d, a2 += d, r2.length -= d;
                break;
              }
              r2.mode = 12;
              break;
            case 17:
              for (; l2 < 14; ) {
                if (0 === o2) break e;
                o2--, u2 += n2[s2++] << l2, l2 += 8;
              }
              if (r2.nlen = 257 + (31 & u2), u2 >>>= 5, l2 -= 5, r2.ndist = 1 + (31 & u2), u2 >>>= 5, l2 -= 5, r2.ncode = 4 + (15 & u2), u2 >>>= 4, l2 -= 4, 286 < r2.nlen || 30 < r2.ndist) {
                e2.msg = "too many length or distance symbols", r2.mode = 30;
                break;
              }
              r2.have = 0, r2.mode = 18;
            case 18:
              for (; r2.have < r2.ncode; ) {
                for (; l2 < 3; ) {
                  if (0 === o2) break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                r2.lens[A[r2.have++]] = 7 & u2, u2 >>>= 3, l2 -= 3;
              }
              for (; r2.have < 19; ) r2.lens[A[r2.have++]] = 0;
              if (r2.lencode = r2.lendyn, r2.lenbits = 7, S = { bits: r2.lenbits }, x = T(0, r2.lens, 0, 19, r2.lencode, 0, r2.work, S), r2.lenbits = S.bits, x) {
                e2.msg = "invalid code lengths set", r2.mode = 30;
                break;
              }
              r2.have = 0, r2.mode = 19;
            case 19:
              for (; r2.have < r2.nlen + r2.ndist; ) {
                for (; g = (C = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                  if (0 === o2) break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                if (b < 16) u2 >>>= _, l2 -= _, r2.lens[r2.have++] = b;
                else {
                  if (16 === b) {
                    for (z = _ + 2; l2 < z; ) {
                      if (0 === o2) break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    if (u2 >>>= _, l2 -= _, 0 === r2.have) {
                      e2.msg = "invalid bit length repeat", r2.mode = 30;
                      break;
                    }
                    k = r2.lens[r2.have - 1], d = 3 + (3 & u2), u2 >>>= 2, l2 -= 2;
                  } else if (17 === b) {
                    for (z = _ + 3; l2 < z; ) {
                      if (0 === o2) break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    l2 -= _, k = 0, d = 3 + (7 & (u2 >>>= _)), u2 >>>= 3, l2 -= 3;
                  } else {
                    for (z = _ + 7; l2 < z; ) {
                      if (0 === o2) break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    l2 -= _, k = 0, d = 11 + (127 & (u2 >>>= _)), u2 >>>= 7, l2 -= 7;
                  }
                  if (r2.have + d > r2.nlen + r2.ndist) {
                    e2.msg = "invalid bit length repeat", r2.mode = 30;
                    break;
                  }
                  for (; d--; ) r2.lens[r2.have++] = k;
                }
              }
              if (30 === r2.mode) break;
              if (0 === r2.lens[256]) {
                e2.msg = "invalid code -- missing end-of-block", r2.mode = 30;
                break;
              }
              if (r2.lenbits = 9, S = { bits: r2.lenbits }, x = T(D, r2.lens, 0, r2.nlen, r2.lencode, 0, r2.work, S), r2.lenbits = S.bits, x) {
                e2.msg = "invalid literal/lengths set", r2.mode = 30;
                break;
              }
              if (r2.distbits = 6, r2.distcode = r2.distdyn, S = { bits: r2.distbits }, x = T(F, r2.lens, r2.nlen, r2.ndist, r2.distcode, 0, r2.work, S), r2.distbits = S.bits, x) {
                e2.msg = "invalid distances set", r2.mode = 30;
                break;
              }
              if (r2.mode = 20, 6 === t2) break e;
            case 20:
              r2.mode = 21;
            case 21:
              if (6 <= o2 && 258 <= h2) {
                e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, R(e2, c2), a2 = e2.next_out, i2 = e2.output, h2 = e2.avail_out, s2 = e2.next_in, n2 = e2.input, o2 = e2.avail_in, u2 = r2.hold, l2 = r2.bits, 12 === r2.mode && (r2.back = -1);
                break;
              }
              for (r2.back = 0; g = (C = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                if (0 === o2) break e;
                o2--, u2 += n2[s2++] << l2, l2 += 8;
              }
              if (g && 0 == (240 & g)) {
                for (v = _, y = g, w = b; g = (C = r2.lencode[w + ((u2 & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l2); ) {
                  if (0 === o2) break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                u2 >>>= v, l2 -= v, r2.back += v;
              }
              if (u2 >>>= _, l2 -= _, r2.back += _, r2.length = b, 0 === g) {
                r2.mode = 26;
                break;
              }
              if (32 & g) {
                r2.back = -1, r2.mode = 12;
                break;
              }
              if (64 & g) {
                e2.msg = "invalid literal/length code", r2.mode = 30;
                break;
              }
              r2.extra = 15 & g, r2.mode = 22;
            case 22:
              if (r2.extra) {
                for (z = r2.extra; l2 < z; ) {
                  if (0 === o2) break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                r2.length += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l2 -= r2.extra, r2.back += r2.extra;
              }
              r2.was = r2.length, r2.mode = 23;
            case 23:
              for (; g = (C = r2.distcode[u2 & (1 << r2.distbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                if (0 === o2) break e;
                o2--, u2 += n2[s2++] << l2, l2 += 8;
              }
              if (0 == (240 & g)) {
                for (v = _, y = g, w = b; g = (C = r2.distcode[w + ((u2 & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l2); ) {
                  if (0 === o2) break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                u2 >>>= v, l2 -= v, r2.back += v;
              }
              if (u2 >>>= _, l2 -= _, r2.back += _, 64 & g) {
                e2.msg = "invalid distance code", r2.mode = 30;
                break;
              }
              r2.offset = b, r2.extra = 15 & g, r2.mode = 24;
            case 24:
              if (r2.extra) {
                for (z = r2.extra; l2 < z; ) {
                  if (0 === o2) break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                r2.offset += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l2 -= r2.extra, r2.back += r2.extra;
              }
              if (r2.offset > r2.dmax) {
                e2.msg = "invalid distance too far back", r2.mode = 30;
                break;
              }
              r2.mode = 25;
            case 25:
              if (0 === h2) break e;
              if (d = c2 - h2, r2.offset > d) {
                if ((d = r2.offset - d) > r2.whave && r2.sane) {
                  e2.msg = "invalid distance too far back", r2.mode = 30;
                  break;
                }
                p = d > r2.wnext ? (d -= r2.wnext, r2.wsize - d) : r2.wnext - d, d > r2.length && (d = r2.length), m = r2.window;
              } else m = i2, p = a2 - r2.offset, d = r2.length;
              for (h2 < d && (d = h2), h2 -= d, r2.length -= d; i2[a2++] = m[p++], --d; ) ;
              0 === r2.length && (r2.mode = 21);
              break;
            case 26:
              if (0 === h2) break e;
              i2[a2++] = r2.length, h2--, r2.mode = 21;
              break;
            case 27:
              if (r2.wrap) {
                for (; l2 < 32; ) {
                  if (0 === o2) break e;
                  o2--, u2 |= n2[s2++] << l2, l2 += 8;
                }
                if (c2 -= h2, e2.total_out += c2, r2.total += c2, c2 && (e2.adler = r2.check = r2.flags ? B(r2.check, i2, c2, a2 - c2) : O(r2.check, i2, c2, a2 - c2)), c2 = h2, (r2.flags ? u2 : L(u2)) !== r2.check) {
                  e2.msg = "incorrect data check", r2.mode = 30;
                  break;
                }
                l2 = u2 = 0;
              }
              r2.mode = 28;
            case 28:
              if (r2.wrap && r2.flags) {
                for (; l2 < 32; ) {
                  if (0 === o2) break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                if (u2 !== (4294967295 & r2.total)) {
                  e2.msg = "incorrect length check", r2.mode = 30;
                  break;
                }
                l2 = u2 = 0;
              }
              r2.mode = 29;
            case 29:
              x = 1;
              break e;
            case 30:
              x = -3;
              break e;
            case 31:
              return -4;
            case 32:
            default:
              return U;
          }
          return e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, (r2.wsize || c2 !== e2.avail_out && r2.mode < 30 && (r2.mode < 27 || 4 !== t2)) && Z(e2, e2.output, e2.next_out, c2 - e2.avail_out) ? (r2.mode = 31, -4) : (f2 -= e2.avail_in, c2 -= e2.avail_out, e2.total_in += f2, e2.total_out += c2, r2.total += c2, r2.wrap && c2 && (e2.adler = r2.check = r2.flags ? B(r2.check, i2, c2, e2.next_out - c2) : O(r2.check, i2, c2, e2.next_out - c2)), e2.data_type = r2.bits + (r2.last ? 64 : 0) + (12 === r2.mode ? 128 : 0) + (20 === r2.mode || 15 === r2.mode ? 256 : 0), (0 == f2 && 0 === c2 || 4 === t2) && x === N && (x = -5), x);
        }, r.inflateEnd = function(e2) {
          if (!e2 || !e2.state) return U;
          var t2 = e2.state;
          return t2.window && (t2.window = null), e2.state = null, N;
        }, r.inflateGetHeader = function(e2, t2) {
          var r2;
          return e2 && e2.state ? 0 == (2 & (r2 = e2.state).wrap) ? U : ((r2.head = t2).done = false, N) : U;
        }, r.inflateSetDictionary = function(e2, t2) {
          var r2, n2 = t2.length;
          return e2 && e2.state ? 0 !== (r2 = e2.state).wrap && 11 !== r2.mode ? U : 11 === r2.mode && O(1, t2, n2, 0) !== r2.check ? -3 : Z(e2, t2, n2, n2) ? (r2.mode = 31, -4) : (r2.havedict = 1, N) : U;
        }, r.inflateInfo = "pako inflate (from Nodeca project)";
      }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(e, t, r) {
        var D = e("../utils/common"), F = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], N = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], U = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], P = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
        t.exports = function(e2, t2, r2, n, i, s, a, o) {
          var h, u, l, f, c, d, p, m, _, g = o.bits, b = 0, v = 0, y = 0, w = 0, k = 0, x = 0, S = 0, z = 0, C = 0, E = 0, A = null, I = 0, O = new D.Buf16(16), B = new D.Buf16(16), R = null, T = 0;
          for (b = 0; b <= 15; b++) O[b] = 0;
          for (v = 0; v < n; v++) O[t2[r2 + v]]++;
          for (k = g, w = 15; 1 <= w && 0 === O[w]; w--) ;
          if (w < k && (k = w), 0 === w) return i[s++] = 20971520, i[s++] = 20971520, o.bits = 1, 0;
          for (y = 1; y < w && 0 === O[y]; y++) ;
          for (k < y && (k = y), b = z = 1; b <= 15; b++) if (z <<= 1, (z -= O[b]) < 0) return -1;
          if (0 < z && (0 === e2 || 1 !== w)) return -1;
          for (B[1] = 0, b = 1; b < 15; b++) B[b + 1] = B[b] + O[b];
          for (v = 0; v < n; v++) 0 !== t2[r2 + v] && (a[B[t2[r2 + v]]++] = v);
          if (d = 0 === e2 ? (A = R = a, 19) : 1 === e2 ? (A = F, I -= 257, R = N, T -= 257, 256) : (A = U, R = P, -1), b = y, c = s, S = v = E = 0, l = -1, f = (C = 1 << (x = k)) - 1, 1 === e2 && 852 < C || 2 === e2 && 592 < C) return 1;
          for (; ; ) {
            for (p = b - S, _ = a[v] < d ? (m = 0, a[v]) : a[v] > d ? (m = R[T + a[v]], A[I + a[v]]) : (m = 96, 0), h = 1 << b - S, y = u = 1 << x; i[c + (E >> S) + (u -= h)] = p << 24 | m << 16 | _ | 0, 0 !== u; ) ;
            for (h = 1 << b - 1; E & h; ) h >>= 1;
            if (0 !== h ? (E &= h - 1, E += h) : E = 0, v++, 0 == --O[b]) {
              if (b === w) break;
              b = t2[r2 + a[v]];
            }
            if (k < b && (E & f) !== l) {
              for (0 === S && (S = k), c += y, z = 1 << (x = b - S); x + S < w && !((z -= O[x + S]) <= 0); ) x++, z <<= 1;
              if (C += 1 << x, 1 === e2 && 852 < C || 2 === e2 && 592 < C) return 1;
              i[l = E & f] = k << 24 | x << 16 | c - s | 0;
            }
          }
          return 0 !== E && (i[c + E] = b - S << 24 | 64 << 16 | 0), o.bits = k, 0;
        };
      }, { "../utils/common": 41 }], 51: [function(e, t, r) {
        t.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
      }, {}], 52: [function(e, t, r) {
        var i = e("../utils/common"), o = 0, h = 1;
        function n(e2) {
          for (var t2 = e2.length; 0 <= --t2; ) e2[t2] = 0;
        }
        var s = 0, a = 29, u = 256, l = u + 1 + a, f = 30, c = 19, _ = 2 * l + 1, g = 15, d = 16, p = 7, m = 256, b = 16, v = 17, y = 18, w = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], k = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], x = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], S = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], z = new Array(2 * (l + 2));
        n(z);
        var C = new Array(2 * f);
        n(C);
        var E = new Array(512);
        n(E);
        var A = new Array(256);
        n(A);
        var I = new Array(a);
        n(I);
        var O, B, R, T = new Array(f);
        function D(e2, t2, r2, n2, i2) {
          this.static_tree = e2, this.extra_bits = t2, this.extra_base = r2, this.elems = n2, this.max_length = i2, this.has_stree = e2 && e2.length;
        }
        function F(e2, t2) {
          this.dyn_tree = e2, this.max_code = 0, this.stat_desc = t2;
        }
        function N(e2) {
          return e2 < 256 ? E[e2] : E[256 + (e2 >>> 7)];
        }
        function U(e2, t2) {
          e2.pending_buf[e2.pending++] = 255 & t2, e2.pending_buf[e2.pending++] = t2 >>> 8 & 255;
        }
        function P(e2, t2, r2) {
          e2.bi_valid > d - r2 ? (e2.bi_buf |= t2 << e2.bi_valid & 65535, U(e2, e2.bi_buf), e2.bi_buf = t2 >> d - e2.bi_valid, e2.bi_valid += r2 - d) : (e2.bi_buf |= t2 << e2.bi_valid & 65535, e2.bi_valid += r2);
        }
        function L(e2, t2, r2) {
          P(e2, r2[2 * t2], r2[2 * t2 + 1]);
        }
        function j(e2, t2) {
          for (var r2 = 0; r2 |= 1 & e2, e2 >>>= 1, r2 <<= 1, 0 < --t2; ) ;
          return r2 >>> 1;
        }
        function Z(e2, t2, r2) {
          var n2, i2, s2 = new Array(g + 1), a2 = 0;
          for (n2 = 1; n2 <= g; n2++) s2[n2] = a2 = a2 + r2[n2 - 1] << 1;
          for (i2 = 0; i2 <= t2; i2++) {
            var o2 = e2[2 * i2 + 1];
            0 !== o2 && (e2[2 * i2] = j(s2[o2]++, o2));
          }
        }
        function W(e2) {
          var t2;
          for (t2 = 0; t2 < l; t2++) e2.dyn_ltree[2 * t2] = 0;
          for (t2 = 0; t2 < f; t2++) e2.dyn_dtree[2 * t2] = 0;
          for (t2 = 0; t2 < c; t2++) e2.bl_tree[2 * t2] = 0;
          e2.dyn_ltree[2 * m] = 1, e2.opt_len = e2.static_len = 0, e2.last_lit = e2.matches = 0;
        }
        function M(e2) {
          8 < e2.bi_valid ? U(e2, e2.bi_buf) : 0 < e2.bi_valid && (e2.pending_buf[e2.pending++] = e2.bi_buf), e2.bi_buf = 0, e2.bi_valid = 0;
        }
        function H(e2, t2, r2, n2) {
          var i2 = 2 * t2, s2 = 2 * r2;
          return e2[i2] < e2[s2] || e2[i2] === e2[s2] && n2[t2] <= n2[r2];
        }
        function G(e2, t2, r2) {
          for (var n2 = e2.heap[r2], i2 = r2 << 1; i2 <= e2.heap_len && (i2 < e2.heap_len && H(t2, e2.heap[i2 + 1], e2.heap[i2], e2.depth) && i2++, !H(t2, n2, e2.heap[i2], e2.depth)); ) e2.heap[r2] = e2.heap[i2], r2 = i2, i2 <<= 1;
          e2.heap[r2] = n2;
        }
        function K(e2, t2, r2) {
          var n2, i2, s2, a2, o2 = 0;
          if (0 !== e2.last_lit) for (; n2 = e2.pending_buf[e2.d_buf + 2 * o2] << 8 | e2.pending_buf[e2.d_buf + 2 * o2 + 1], i2 = e2.pending_buf[e2.l_buf + o2], o2++, 0 === n2 ? L(e2, i2, t2) : (L(e2, (s2 = A[i2]) + u + 1, t2), 0 !== (a2 = w[s2]) && P(e2, i2 -= I[s2], a2), L(e2, s2 = N(--n2), r2), 0 !== (a2 = k[s2]) && P(e2, n2 -= T[s2], a2)), o2 < e2.last_lit; ) ;
          L(e2, m, t2);
        }
        function Y(e2, t2) {
          var r2, n2, i2, s2 = t2.dyn_tree, a2 = t2.stat_desc.static_tree, o2 = t2.stat_desc.has_stree, h2 = t2.stat_desc.elems, u2 = -1;
          for (e2.heap_len = 0, e2.heap_max = _, r2 = 0; r2 < h2; r2++) 0 !== s2[2 * r2] ? (e2.heap[++e2.heap_len] = u2 = r2, e2.depth[r2] = 0) : s2[2 * r2 + 1] = 0;
          for (; e2.heap_len < 2; ) s2[2 * (i2 = e2.heap[++e2.heap_len] = u2 < 2 ? ++u2 : 0)] = 1, e2.depth[i2] = 0, e2.opt_len--, o2 && (e2.static_len -= a2[2 * i2 + 1]);
          for (t2.max_code = u2, r2 = e2.heap_len >> 1; 1 <= r2; r2--) G(e2, s2, r2);
          for (i2 = h2; r2 = e2.heap[1], e2.heap[1] = e2.heap[e2.heap_len--], G(e2, s2, 1), n2 = e2.heap[1], e2.heap[--e2.heap_max] = r2, e2.heap[--e2.heap_max] = n2, s2[2 * i2] = s2[2 * r2] + s2[2 * n2], e2.depth[i2] = (e2.depth[r2] >= e2.depth[n2] ? e2.depth[r2] : e2.depth[n2]) + 1, s2[2 * r2 + 1] = s2[2 * n2 + 1] = i2, e2.heap[1] = i2++, G(e2, s2, 1), 2 <= e2.heap_len; ) ;
          e2.heap[--e2.heap_max] = e2.heap[1], (function(e3, t3) {
            var r3, n3, i3, s3, a3, o3, h3 = t3.dyn_tree, u3 = t3.max_code, l2 = t3.stat_desc.static_tree, f2 = t3.stat_desc.has_stree, c2 = t3.stat_desc.extra_bits, d2 = t3.stat_desc.extra_base, p2 = t3.stat_desc.max_length, m2 = 0;
            for (s3 = 0; s3 <= g; s3++) e3.bl_count[s3] = 0;
            for (h3[2 * e3.heap[e3.heap_max] + 1] = 0, r3 = e3.heap_max + 1; r3 < _; r3++) p2 < (s3 = h3[2 * h3[2 * (n3 = e3.heap[r3]) + 1] + 1] + 1) && (s3 = p2, m2++), h3[2 * n3 + 1] = s3, u3 < n3 || (e3.bl_count[s3]++, a3 = 0, d2 <= n3 && (a3 = c2[n3 - d2]), o3 = h3[2 * n3], e3.opt_len += o3 * (s3 + a3), f2 && (e3.static_len += o3 * (l2[2 * n3 + 1] + a3)));
            if (0 !== m2) {
              do {
                for (s3 = p2 - 1; 0 === e3.bl_count[s3]; ) s3--;
                e3.bl_count[s3]--, e3.bl_count[s3 + 1] += 2, e3.bl_count[p2]--, m2 -= 2;
              } while (0 < m2);
              for (s3 = p2; 0 !== s3; s3--) for (n3 = e3.bl_count[s3]; 0 !== n3; ) u3 < (i3 = e3.heap[--r3]) || (h3[2 * i3 + 1] !== s3 && (e3.opt_len += (s3 - h3[2 * i3 + 1]) * h3[2 * i3], h3[2 * i3 + 1] = s3), n3--);
            }
          })(e2, t2), Z(s2, u2, e2.bl_count);
        }
        function X(e2, t2, r2) {
          var n2, i2, s2 = -1, a2 = t2[1], o2 = 0, h2 = 7, u2 = 4;
          for (0 === a2 && (h2 = 138, u2 = 3), t2[2 * (r2 + 1) + 1] = 65535, n2 = 0; n2 <= r2; n2++) i2 = a2, a2 = t2[2 * (n2 + 1) + 1], ++o2 < h2 && i2 === a2 || (o2 < u2 ? e2.bl_tree[2 * i2] += o2 : 0 !== i2 ? (i2 !== s2 && e2.bl_tree[2 * i2]++, e2.bl_tree[2 * b]++) : o2 <= 10 ? e2.bl_tree[2 * v]++ : e2.bl_tree[2 * y]++, s2 = i2, u2 = (o2 = 0) === a2 ? (h2 = 138, 3) : i2 === a2 ? (h2 = 6, 3) : (h2 = 7, 4));
        }
        function V(e2, t2, r2) {
          var n2, i2, s2 = -1, a2 = t2[1], o2 = 0, h2 = 7, u2 = 4;
          for (0 === a2 && (h2 = 138, u2 = 3), n2 = 0; n2 <= r2; n2++) if (i2 = a2, a2 = t2[2 * (n2 + 1) + 1], !(++o2 < h2 && i2 === a2)) {
            if (o2 < u2) for (; L(e2, i2, e2.bl_tree), 0 != --o2; ) ;
            else 0 !== i2 ? (i2 !== s2 && (L(e2, i2, e2.bl_tree), o2--), L(e2, b, e2.bl_tree), P(e2, o2 - 3, 2)) : o2 <= 10 ? (L(e2, v, e2.bl_tree), P(e2, o2 - 3, 3)) : (L(e2, y, e2.bl_tree), P(e2, o2 - 11, 7));
            s2 = i2, u2 = (o2 = 0) === a2 ? (h2 = 138, 3) : i2 === a2 ? (h2 = 6, 3) : (h2 = 7, 4);
          }
        }
        n(T);
        var q = false;
        function J(e2, t2, r2, n2) {
          P(e2, (s << 1) + (n2 ? 1 : 0), 3), (function(e3, t3, r3, n3) {
            M(e3), U(e3, r3), U(e3, ~r3), i.arraySet(e3.pending_buf, e3.window, t3, r3, e3.pending), e3.pending += r3;
          })(e2, t2, r2);
        }
        r._tr_init = function(e2) {
          q || ((function() {
            var e3, t2, r2, n2, i2, s2 = new Array(g + 1);
            for (n2 = r2 = 0; n2 < a - 1; n2++) for (I[n2] = r2, e3 = 0; e3 < 1 << w[n2]; e3++) A[r2++] = n2;
            for (A[r2 - 1] = n2, n2 = i2 = 0; n2 < 16; n2++) for (T[n2] = i2, e3 = 0; e3 < 1 << k[n2]; e3++) E[i2++] = n2;
            for (i2 >>= 7; n2 < f; n2++) for (T[n2] = i2 << 7, e3 = 0; e3 < 1 << k[n2] - 7; e3++) E[256 + i2++] = n2;
            for (t2 = 0; t2 <= g; t2++) s2[t2] = 0;
            for (e3 = 0; e3 <= 143; ) z[2 * e3 + 1] = 8, e3++, s2[8]++;
            for (; e3 <= 255; ) z[2 * e3 + 1] = 9, e3++, s2[9]++;
            for (; e3 <= 279; ) z[2 * e3 + 1] = 7, e3++, s2[7]++;
            for (; e3 <= 287; ) z[2 * e3 + 1] = 8, e3++, s2[8]++;
            for (Z(z, l + 1, s2), e3 = 0; e3 < f; e3++) C[2 * e3 + 1] = 5, C[2 * e3] = j(e3, 5);
            O = new D(z, w, u + 1, l, g), B = new D(C, k, 0, f, g), R = new D(new Array(0), x, 0, c, p);
          })(), q = true), e2.l_desc = new F(e2.dyn_ltree, O), e2.d_desc = new F(e2.dyn_dtree, B), e2.bl_desc = new F(e2.bl_tree, R), e2.bi_buf = 0, e2.bi_valid = 0, W(e2);
        }, r._tr_stored_block = J, r._tr_flush_block = function(e2, t2, r2, n2) {
          var i2, s2, a2 = 0;
          0 < e2.level ? (2 === e2.strm.data_type && (e2.strm.data_type = (function(e3) {
            var t3, r3 = 4093624447;
            for (t3 = 0; t3 <= 31; t3++, r3 >>>= 1) if (1 & r3 && 0 !== e3.dyn_ltree[2 * t3]) return o;
            if (0 !== e3.dyn_ltree[18] || 0 !== e3.dyn_ltree[20] || 0 !== e3.dyn_ltree[26]) return h;
            for (t3 = 32; t3 < u; t3++) if (0 !== e3.dyn_ltree[2 * t3]) return h;
            return o;
          })(e2)), Y(e2, e2.l_desc), Y(e2, e2.d_desc), a2 = (function(e3) {
            var t3;
            for (X(e3, e3.dyn_ltree, e3.l_desc.max_code), X(e3, e3.dyn_dtree, e3.d_desc.max_code), Y(e3, e3.bl_desc), t3 = c - 1; 3 <= t3 && 0 === e3.bl_tree[2 * S[t3] + 1]; t3--) ;
            return e3.opt_len += 3 * (t3 + 1) + 5 + 5 + 4, t3;
          })(e2), i2 = e2.opt_len + 3 + 7 >>> 3, (s2 = e2.static_len + 3 + 7 >>> 3) <= i2 && (i2 = s2)) : i2 = s2 = r2 + 5, r2 + 4 <= i2 && -1 !== t2 ? J(e2, t2, r2, n2) : 4 === e2.strategy || s2 === i2 ? (P(e2, 2 + (n2 ? 1 : 0), 3), K(e2, z, C)) : (P(e2, 4 + (n2 ? 1 : 0), 3), (function(e3, t3, r3, n3) {
            var i3;
            for (P(e3, t3 - 257, 5), P(e3, r3 - 1, 5), P(e3, n3 - 4, 4), i3 = 0; i3 < n3; i3++) P(e3, e3.bl_tree[2 * S[i3] + 1], 3);
            V(e3, e3.dyn_ltree, t3 - 1), V(e3, e3.dyn_dtree, r3 - 1);
          })(e2, e2.l_desc.max_code + 1, e2.d_desc.max_code + 1, a2 + 1), K(e2, e2.dyn_ltree, e2.dyn_dtree)), W(e2), n2 && M(e2);
        }, r._tr_tally = function(e2, t2, r2) {
          return e2.pending_buf[e2.d_buf + 2 * e2.last_lit] = t2 >>> 8 & 255, e2.pending_buf[e2.d_buf + 2 * e2.last_lit + 1] = 255 & t2, e2.pending_buf[e2.l_buf + e2.last_lit] = 255 & r2, e2.last_lit++, 0 === t2 ? e2.dyn_ltree[2 * r2]++ : (e2.matches++, t2--, e2.dyn_ltree[2 * (A[r2] + u + 1)]++, e2.dyn_dtree[2 * N(t2)]++), e2.last_lit === e2.lit_bufsize - 1;
        }, r._tr_align = function(e2) {
          P(e2, 2, 3), L(e2, m, z), (function(e3) {
            16 === e3.bi_valid ? (U(e3, e3.bi_buf), e3.bi_buf = 0, e3.bi_valid = 0) : 8 <= e3.bi_valid && (e3.pending_buf[e3.pending++] = 255 & e3.bi_buf, e3.bi_buf >>= 8, e3.bi_valid -= 8);
          })(e2);
        };
      }, { "../utils/common": 41 }], 53: [function(e, t, r) {
        t.exports = function() {
          this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
        };
      }, {}], 54: [function(e, t, r) {
        (function(e2) {
          !(function(r2, n) {
            if (!r2.setImmediate) {
              var i, s, t2, a, o = 1, h = {}, u = false, l = r2.document, e3 = Object.getPrototypeOf && Object.getPrototypeOf(r2);
              e3 = e3 && e3.setTimeout ? e3 : r2, i = "[object process]" === {}.toString.call(r2.process) ? function(e4) {
                process$1.nextTick(function() {
                  c(e4);
                });
              } : (function() {
                if (r2.postMessage && !r2.importScripts) {
                  var e4 = true, t3 = r2.onmessage;
                  return r2.onmessage = function() {
                    e4 = false;
                  }, r2.postMessage("", "*"), r2.onmessage = t3, e4;
                }
              })() ? (a = "setImmediate$" + Math.random() + "$", r2.addEventListener ? r2.addEventListener("message", d, false) : r2.attachEvent("onmessage", d), function(e4) {
                r2.postMessage(a + e4, "*");
              }) : r2.MessageChannel ? ((t2 = new MessageChannel()).port1.onmessage = function(e4) {
                c(e4.data);
              }, function(e4) {
                t2.port2.postMessage(e4);
              }) : l && "onreadystatechange" in l.createElement("script") ? (s = l.documentElement, function(e4) {
                var t3 = l.createElement("script");
                t3.onreadystatechange = function() {
                  c(e4), t3.onreadystatechange = null, s.removeChild(t3), t3 = null;
                }, s.appendChild(t3);
              }) : function(e4) {
                setTimeout(c, 0, e4);
              }, e3.setImmediate = function(e4) {
                "function" != typeof e4 && (e4 = new Function("" + e4));
                for (var t3 = new Array(arguments.length - 1), r3 = 0; r3 < t3.length; r3++) t3[r3] = arguments[r3 + 1];
                var n2 = { callback: e4, args: t3 };
                return h[o] = n2, i(o), o++;
              }, e3.clearImmediate = f;
            }
            function f(e4) {
              delete h[e4];
            }
            function c(e4) {
              if (u) setTimeout(c, 0, e4);
              else {
                var t3 = h[e4];
                if (t3) {
                  u = true;
                  try {
                    !(function(e5) {
                      var t4 = e5.callback, r3 = e5.args;
                      switch (r3.length) {
                        case 0:
                          t4();
                          break;
                        case 1:
                          t4(r3[0]);
                          break;
                        case 2:
                          t4(r3[0], r3[1]);
                          break;
                        case 3:
                          t4(r3[0], r3[1], r3[2]);
                          break;
                        default:
                          t4.apply(n, r3);
                      }
                    })(t3);
                  } finally {
                    f(e4), u = false;
                  }
                }
              }
            }
            function d(e4) {
              e4.source === r2 && "string" == typeof e4.data && 0 === e4.data.indexOf(a) && c(+e4.data.slice(a.length));
            }
          })("undefined" == typeof self ? void 0 === e2 ? this : e2 : self);
        }).call(this, "undefined" != typeof commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, {}] }, {}, [10])(10);
    });
  })(jszip_min);
  return jszip_min.exports;
}
function requireEscapeForXML() {
  if (hasRequiredEscapeForXML) return escapeForXML_1;
  hasRequiredEscapeForXML = 1;
  var XML_CHARACTER_MAP = {
    "&": "&amp;",
    '"': "&quot;",
    "'": "&apos;",
    "<": "&lt;",
    ">": "&gt;"
  };
  function escapeForXML(string) {
    return string && string.replace ? string.replace(/([&"<>'])/g, function(str, item) {
      return XML_CHARACTER_MAP[item];
    }) : string;
  }
  escapeForXML_1 = escapeForXML;
  return escapeForXML_1;
}
function requireXml() {
  if (hasRequiredXml) return xml$1.exports;
  hasRequiredXml = 1;
  var escapeForXML = requireEscapeForXML();
  var Stream = requireStreamBrowserify().Stream;
  var DEFAULT_INDENT = "    ";
  function xml2(input, options) {
    if (typeof options !== "object") {
      options = {
        indent: options
      };
    }
    var stream = options.stream ? new Stream() : null, output = "", interrupted = false, indent = !options.indent ? "" : options.indent === true ? DEFAULT_INDENT : options.indent, instant = true;
    function delay(func) {
      if (!instant) {
        func();
      } else {
        process$1.nextTick(func);
      }
    }
    function append(interrupt, out) {
      if (out !== void 0) {
        output += out;
      }
      if (interrupt && !interrupted) {
        stream = stream || new Stream();
        interrupted = true;
      }
      if (interrupt && interrupted) {
        var data = output;
        delay(function() {
          stream.emit("data", data);
        });
        output = "";
      }
    }
    function add(value, last) {
      format(append, resolve(value, indent, indent ? 1 : 0), last);
    }
    function end() {
      if (stream) {
        var data = output;
        delay(function() {
          stream.emit("data", data);
          stream.emit("end");
          stream.readable = false;
          stream.emit("close");
        });
      }
    }
    function addXmlDeclaration(declaration) {
      var encoding = declaration.encoding || "UTF-8", attr = { version: "1.0", encoding };
      if (declaration.standalone) {
        attr.standalone = declaration.standalone;
      }
      add({ "?xml": { _attr: attr } });
      output = output.replace("/>", "?>");
    }
    delay(function() {
      instant = false;
    });
    if (options.declaration) {
      addXmlDeclaration(options.declaration);
    }
    if (input && input.forEach) {
      input.forEach(function(value, i) {
        var last;
        if (i + 1 === input.length)
          last = end;
        add(value, last);
      });
    } else {
      add(input, end);
    }
    if (stream) {
      stream.readable = true;
      return stream;
    }
    return output;
  }
  function element() {
    var input = Array.prototype.slice.call(arguments), self2 = {
      _elem: resolve(input)
    };
    self2.push = function(input2) {
      if (!this.append) {
        throw new Error("not assigned to a parent!");
      }
      var that = this;
      var indent = this._elem.indent;
      format(
        this.append,
        resolve(
          input2,
          indent,
          this._elem.icount + (indent ? 1 : 0)
        ),
        function() {
          that.append(true);
        }
      );
    };
    self2.close = function(input2) {
      if (input2 !== void 0) {
        this.push(input2);
      }
      if (this.end) {
        this.end();
      }
    };
    return self2;
  }
  function create_indent(character, count) {
    return new Array(count || 0).join(character || "");
  }
  function resolve(data, indent, indent_count) {
    indent_count = indent_count || 0;
    var indent_spaces = create_indent(indent, indent_count);
    var name;
    var values = data;
    var interrupt = false;
    if (typeof data === "object") {
      var keys = Object.keys(data);
      name = keys[0];
      values = data[name];
      if (values && values._elem) {
        values._elem.name = name;
        values._elem.icount = indent_count;
        values._elem.indent = indent;
        values._elem.indents = indent_spaces;
        values._elem.interrupt = values;
        return values._elem;
      }
    }
    var attributes = [], content = [];
    var isStringContent;
    function get_attributes(obj) {
      var keys2 = Object.keys(obj);
      keys2.forEach(function(key) {
        attributes.push(attribute(key, obj[key]));
      });
    }
    switch (typeof values) {
      case "object":
        if (values === null) break;
        if (values._attr) {
          get_attributes(values._attr);
        }
        if (values._cdata) {
          content.push(
            ("<![CDATA[" + values._cdata).replace(/\]\]>/g, "]]]]><![CDATA[>") + "]]>"
          );
        }
        if (values.forEach) {
          isStringContent = false;
          content.push("");
          values.forEach(function(value) {
            if (typeof value == "object") {
              var _name = Object.keys(value)[0];
              if (_name == "_attr") {
                get_attributes(value._attr);
              } else {
                content.push(resolve(
                  value,
                  indent,
                  indent_count + 1
                ));
              }
            } else {
              content.pop();
              isStringContent = true;
              content.push(escapeForXML(value));
            }
          });
          if (!isStringContent) {
            content.push("");
          }
        }
        break;
      default:
        content.push(escapeForXML(values));
    }
    return {
      name,
      interrupt,
      attributes,
      content,
      icount: indent_count,
      indents: indent_spaces,
      indent
    };
  }
  function format(append, elem, end) {
    if (typeof elem != "object") {
      return append(false, elem);
    }
    var len = elem.interrupt ? 1 : elem.content.length;
    function proceed() {
      while (elem.content.length) {
        var value = elem.content.shift();
        if (value === void 0) continue;
        if (interrupt(value)) return;
        format(append, value);
      }
      append(false, (len > 1 ? elem.indents : "") + (elem.name ? "</" + elem.name + ">" : "") + (elem.indent && !end ? "\n" : ""));
      if (end) {
        end();
      }
    }
    function interrupt(value) {
      if (value.interrupt) {
        value.interrupt.append = append;
        value.interrupt.end = proceed;
        value.interrupt = false;
        append(true);
        return true;
      }
      return false;
    }
    append(false, elem.indents + (elem.name ? "<" + elem.name : "") + (elem.attributes.length ? " " + elem.attributes.join(" ") : "") + (len ? elem.name ? ">" : "" : elem.name ? "/>" : "") + (elem.indent && len > 1 ? "\n" : ""));
    if (!len) {
      return append(false, elem.indent ? "\n" : "");
    }
    if (!interrupt(elem)) {
      proceed();
    }
  }
  function attribute(key, value) {
    return key + '="' + escapeForXML(value) + '"';
  }
  xml$1.exports = xml2;
  xml$1.exports.element = xml$1.exports.Element = element;
  return xml$1.exports;
}
var __defProp2, __defProps, __getOwnPropDescs, __getOwnPropSymbols, __hasOwnProp2, __propIsEnum, __defNormalProp, __spreadValues, __spreadProps, __publicField, __async, BaseXmlComponent, EMPTY_OBJECT, XmlComponent, IgnoreIfEmptyXmlComponent, XmlAttributeComponent, NextAttributeComponent, Attributes, commonjsGlobal, sax, events, hasRequiredEvents, inherits_browser, hasRequiredInherits_browser, browser$1, process, cachedSetTimeout, cachedClearTimeout, queue, draining, currentQueue, queueIndex, browserExports, process$1, streamBrowser, hasRequiredStreamBrowser, buffer, base64Js, hasRequiredBase64Js, ieee754, hasRequiredIeee754, hasRequiredBuffer, util, types, shams$1, hasRequiredShams$1, shams, hasRequiredShams, esObjectAtoms, hasRequiredEsObjectAtoms, esErrors, hasRequiredEsErrors, _eval, hasRequired_eval, range, hasRequiredRange, ref, hasRequiredRef, syntax, hasRequiredSyntax, type, hasRequiredType, uri, hasRequiredUri, abs, hasRequiredAbs, floor, hasRequiredFloor, max, hasRequiredMax, min, hasRequiredMin, pow, hasRequiredPow, round, hasRequiredRound, _isNaN, hasRequired_isNaN, sign, hasRequiredSign, gOPD, hasRequiredGOPD, gopd, hasRequiredGopd, esDefineProperty, hasRequiredEsDefineProperty, hasSymbols, hasRequiredHasSymbols, Reflect_getPrototypeOf, hasRequiredReflect_getPrototypeOf, Object_getPrototypeOf, hasRequiredObject_getPrototypeOf, implementation, hasRequiredImplementation, functionBind, hasRequiredFunctionBind, functionCall, hasRequiredFunctionCall, functionApply, hasRequiredFunctionApply, reflectApply, hasRequiredReflectApply, actualApply, hasRequiredActualApply, callBindApplyHelpers, hasRequiredCallBindApplyHelpers, get, hasRequiredGet, getProto, hasRequiredGetProto, hasown, hasRequiredHasown, getIntrinsic, hasRequiredGetIntrinsic, callBind, defineDataProperty, hasRequiredDefineDataProperty, hasPropertyDescriptors_1, hasRequiredHasPropertyDescriptors, setFunctionLength, hasRequiredSetFunctionLength, hasRequiredCallBind, callBound, hasRequiredCallBound, isArguments, hasRequiredIsArguments, isGeneratorFunction, hasRequiredIsGeneratorFunction, isCallable, hasRequiredIsCallable, forEach_1, hasRequiredForEach, possibleTypedArrayNames, hasRequiredPossibleTypedArrayNames, availableTypedArrays, hasRequiredAvailableTypedArrays, whichTypedArray, hasRequiredWhichTypedArray, isTypedArray, hasRequiredIsTypedArray, hasRequiredTypes, isBufferBrowser, hasRequiredIsBufferBrowser, hasRequiredUtil, buffer_list, hasRequiredBuffer_list, destroy_1, hasRequiredDestroy, errorsBrowser, hasRequiredErrorsBrowser, state, hasRequiredState, browser, hasRequiredBrowser, _stream_writable, hasRequired_stream_writable, _stream_duplex, hasRequired_stream_duplex, string_decoder, safeBuffer, hasRequiredSafeBuffer, hasRequiredString_decoder, endOfStream, hasRequiredEndOfStream, async_iterator, hasRequiredAsync_iterator, fromBrowser, hasRequiredFromBrowser, _stream_readable, hasRequired_stream_readable, _stream_transform, hasRequired_stream_transform, _stream_passthrough, hasRequired_stream_passthrough, pipeline_1, hasRequiredPipeline, streamBrowserify, hasRequiredStreamBrowserify, hasRequiredSax, arrayHelper, hasRequiredArrayHelper, optionsHelper, hasRequiredOptionsHelper, xml2js, hasRequiredXml2js, xml2json, hasRequiredXml2json, js2xml, hasRequiredJs2xml, json2xml, hasRequiredJson2xml, lib, hasRequiredLib, libExports, convertToXmlComponent, ImportedXmlComponentAttributes, ImportedXmlComponent, ImportedRootElementAttributes, InitializableXmlComponent, decimalNumber, unsignedDecimalNumber, hexBinary, uCharHexNumber, universalMeasureValue, positiveUniversalMeasureValue, hexColorValue, signedTwipsMeasureValue, hpsMeasureValue, twipsMeasureValue, percentageValue, measurementOrPercentValue, eighthPointMeasureValue, pointMeasureValue, dateTimeValue, OnOffElement, HpsMeasureElement, StringValueElement, createStringElement, NumberValueElement, StringEnumValueElement, StringContainer, BuilderElement, AlignmentType, AlignmentAttributes, Alignment, BorderElement, BordersAttributes, BorderStyle, Border, ThematicBreak, Indent, Break$1, FieldCharacterType, FidCharAttrs, Begin, Separate, End, SpaceType, TextAttributes, Page, NumberOfPages, NumberOfPagesSection, CurrentSection, ShadingAttributes, Shading, ShadingType, ChangeAttributes, EmphasisMarkType, BaseEmphasisMark, EmphasisMark, CharacterSpacing, Color, Highlight, HighlightComplexScript, createLanguageComponent, RunFontAttributes, RunFonts, VerticalAlign$1, SuperScript, SubScript, UnderlineType, Underline, RunProperties, RunPropertiesChange, Text, PageNumber, Run, TextRun, hash$1, utils, minimalisticAssert, hasRequiredMinimalisticAssert, hasRequiredUtils, common$1, hasRequiredCommon$1, sha, common, hasRequiredCommon, _1, hasRequired_1, _256, hasRequired_256, _224, hasRequired_224, _512, hasRequired_512, _384, hasRequired_384, hasRequiredSha, ripemd, hasRequiredRipemd, hmac, hasRequiredHmac, hasRequiredHash, hashExports, hash, urlAlphabet, customAlphabet, nanoid, convertInchesToTwip, uniqueNumericIdCreator, abstractNumUniqueNumericIdGen, concreteNumUniqueNumericIdGen, docPropertiesUniqueNumericIdGen, bookmarkUniqueNumericIdGen, uniqueId, hashedId, generateUuidPart, uniqueUuid, HorizontalPositionRelativeFrom, VerticalPositionRelativeFrom, createSimplePos, createAlign, createPositionOffset, createHorizontalPosition, createVerticalPosition, GraphicDataAttributes, createSvgBlip, createExtention, createExtentionList, createBlip, SourceRectangle, FillRectangle, Stretch, BlipFill, PicLocksAttributes, PicLocks, ChildNonVisualProperties, createHyperlinkClick, NonVisualPropertiesAttributes, NonVisualProperties, NonVisualPicProperties, PicAttributes, ExtentsAttributes, Extents, OffsetAttributes, Offset, FormAttributes, Form, createNoFill, createSolidRgbColor, createSchemeColor, createSolidFill, createOutline, AdjustmentValues, PresetGeometryAttributes, PresetGeometry, ShapePropertiesAttributes, ShapeProperties, Pic, GraphicData, GraphicAttributes, Graphic, TextWrappingType, TextWrappingSide, WrapNone, WrapSquareAttributes, WrapSquare, WrapTightAttributes, WrapTight, WrapTopAndBottomAttributes, WrapTopAndBottom, DocProperties, createEffectExtent, createExtent, GraphicFrameLockAttributes, GraphicFrameLocks, createGraphicFrameProperties, AnchorAttributes, Anchor, createInline, Drawing, convertDataURIToBinary, standardizeData, createImageData, ImageRun, SequentialIdentifierInstruction, SequentialIdentifier, FldSimpleAttrs, SimpleField, RelationshipsAttributes, RelationshipAttributes, TargetModeType, Relationship, Relationships, CommentAttributes, RootCommentsAttributes, Comment, Comments, PageBreakBefore, LineRuleType, SpacingAttributes, Spacing, HeadingLevel, Style$1, TabStop, TabStopType, TabStopPosition, TabAttributes, TabStopItem, NumberProperties, IndentLevel, NumberId, FileChild, HyperlinkAttributes, ConcreteHyperlink, InternalHyperlink, ExternalHyperlink, BookmarkStartAttributes, BookmarkEndAttributes, Bookmark, BookmarkStart, BookmarkEnd, OutlineLevel, VerticalAlignTable, VerticalAlignSection, VerticalAlignAttributes, VerticalAlignElement, Columns, createDocumentGrid, HeaderFooterReferenceType, FooterReferenceAttributes, HeaderFooterType, HeaderFooterReference, createLineNumberType, PageBordersAttributes, PageBorders, PageMargin, PageNumberTypeAttributes, PageNumberType, PageOrientation, createPageSize, PageTextDirectionAttributes, PageTextDirection, SectionType, SectionTypeAttributes, Type, sectionMarginDefaults, sectionPageSizeDefaults, SectionProperties, Body, DocumentAttributeNamespaces, DocumentAttributes, DocumentBackgroundAttributes, DocumentBackground, Document, DocumentWrapper, WordWrapAttributes, WordWrap, createFrameProperties, ParagraphProperties, Paragraph, Math$1, MathText, MathRun, TableGrid, GridCol, TableCellMarginElementType, TableCellMargin, WidthType, TableWidthElement, TableCellBorders, GridSpanAttributes, GridSpan, VerticalMergeType, VerticalMergeAttributes, VerticalMerge, TDirectionAttributes, TDirection, TableCellProperties, TableCell, NONE_BORDER, DEFAULT_BORDER, TableBorders, TableFloatProperties, TableLayoutAttributes, TableLayout, CellSpacingType, TableCellSpacingElement, TableProperties, Table, TableRowHeightAttributes, TableRowHeight, TableRowProperties, TableRow, AppPropertiesAttributes, AppProperties, ContentTypeAttributes, DefaultAttributes, Default, OverrideAttributes, Override, ContentTypes, CoreProperties, TimestampElementProperties, TimestampElement, CustomPropertiesAttributes, CustomPropertyAttributes, CustomProperty, CustomPropertyValue, CustomProperties, createFontRelationship, createFont, createRegularFont, createFontTable, FontWrapper, FooterAttributes, Footer$1, FooterWrapper, FootnoteAttributes, FootnoteRef, FootnoteRefRun, FootnoteType, Footnote, ContinuationSeperator, ContinuationSeperatorRun, Seperator, SeperatorRun, FootnotesAttributes, FootNotes, FootnotesWrapper, HeaderAttributes, Header$1, HeaderWrapper, Media, LevelFormat, LevelAttributes, NumberFormat, LevelText, LevelJc, Suffix, IsLegalNumberingStyle, LevelBase, Level, MultiLevelType, AbstractNumberingAttributes, AbstractNumbering, AbstractNumId, NumAttributes, ConcreteNumbering, LevelOverrideAttributes, LevelOverride, StartOverrideAttributes, StartOverride, Numbering, CompatibilitySettingAttributes, CompatibilitySetting, Compatibility, SettingsAttributes, Settings, ComponentAttributes, Name, UiPriority, StyleAttributes, Style2, StyleForParagraph, StyleForCharacter, HeadingStyle, TitleStyle, Heading1Style, Heading2Style, Heading3Style, Heading4Style, Heading5Style, Heading6Style, StrongStyle, ListParagraph, FootnoteText, FootnoteReferenceStyle, FootnoteTextChar, HyperlinkStyle, Styles, ParagraphPropertiesDefaults, RunPropertiesDefaults, DocumentDefaults, ExternalStylesFactory, DefaultStylesFactory, File, FootNoteReferenceRunAttributes, FootnoteReference, FootnoteReferenceRun, streamBrowserifyExports, jszip_min, hasRequiredJszip_min, jszip_minExports, JSZip, xml$1, escapeForXML_1, hasRequiredEscapeForXML, hasRequiredXml, xmlExports, xml, obfuscatedStartOffset, obfuscatedEndOffset, guidSize, obfuscate, Formatter, ImageReplacer, NumberingReplacer, Compiler, PrettifyType, convertPrettifyType, _Packer, Packer, formatter$1, formatter, imageReplacer, UTF16LE, UTF16BE;
var init_dist = __esm({
  "node_modules/.pnpm/docx@9.5.1/node_modules/docx/dist/index.mjs"() {
    __defProp2 = Object.defineProperty;
    __defProps = Object.defineProperties;
    __getOwnPropDescs = Object.getOwnPropertyDescriptors;
    __getOwnPropSymbols = Object.getOwnPropertySymbols;
    __hasOwnProp2 = Object.prototype.hasOwnProperty;
    __propIsEnum = Object.prototype.propertyIsEnumerable;
    __defNormalProp = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    __spreadValues = (a, b) => {
      for (var prop in b || (b = {}))
        if (__hasOwnProp2.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      if (__getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(b)) {
          if (__propIsEnum.call(b, prop))
            __defNormalProp(a, prop, b[prop]);
        }
      return a;
    };
    __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
    __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    __async = (__this, __arguments, generator) => {
      return new Promise((resolve, reject) => {
        var fulfilled = (value) => {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        };
        var rejected = (value) => {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        };
        var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
        step((generator = generator.apply(__this, __arguments)).next());
      });
    };
    BaseXmlComponent = class {
      constructor(rootKey) {
        __publicField(this, "rootKey");
        this.rootKey = rootKey;
      }
    };
    EMPTY_OBJECT = Object.seal({});
    XmlComponent = class extends BaseXmlComponent {
      constructor(rootKey) {
        super(rootKey);
        __publicField(this, "root");
        this.root = new Array();
      }
      // This method is called by the formatter to get the XML representation of this component.
      // It is called recursively for all child components.
      // It is a serializer to be used in the xml library.
      // https://www.npmjs.com/package/xml
      // Child components can override this method to customize the XML representation, or execute side effects.
      prepForXml(context) {
        var _a;
        context.stack.push(this);
        const children = this.root.map((comp) => {
          if (comp instanceof BaseXmlComponent) {
            return comp.prepForXml(context);
          }
          return comp;
        }).filter((comp) => comp !== void 0);
        context.stack.pop();
        return {
          [this.rootKey]: children.length ? children.length === 1 && ((_a = children[0]) == null ? void 0 : _a._attr) ? children[0] : children : EMPTY_OBJECT
        };
      }
      /**
       * @deprecated Do not use this method. It is only used internally by the library. It will be removed in a future version.
       */
      addChildElement(child) {
        this.root.push(child);
        return this;
      }
    };
    IgnoreIfEmptyXmlComponent = class extends XmlComponent {
      prepForXml(context) {
        const result = super.prepForXml(context);
        if (result && (typeof result[this.rootKey] !== "object" || Object.keys(result[this.rootKey]).length)) {
          return result;
        }
        return void 0;
      }
    };
    XmlAttributeComponent = class extends BaseXmlComponent {
      constructor(root) {
        super("_attr");
        __publicField(this, "xmlKeys");
        this.root = root;
      }
      prepForXml(_) {
        const attrs = {};
        Object.entries(this.root).forEach(([key, value]) => {
          if (value !== void 0) {
            const newKey = this.xmlKeys && this.xmlKeys[key] || key;
            attrs[newKey] = value;
          }
        });
        return { _attr: attrs };
      }
    };
    NextAttributeComponent = class extends BaseXmlComponent {
      constructor(root) {
        super("_attr");
        this.root = root;
      }
      prepForXml(_) {
        const attrs = Object.values(this.root).filter(({ value }) => value !== void 0).reduce((acc, { key, value }) => __spreadProps(__spreadValues({}, acc), { [key]: value }), {});
        return { _attr: attrs };
      }
    };
    Attributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", {
          val: "w:val",
          color: "w:color",
          fill: "w:fill",
          space: "w:space",
          sz: "w:sz",
          type: "w:type",
          rsidR: "w:rsidR",
          rsidRPr: "w:rsidRPr",
          rsidSect: "w:rsidSect",
          w: "w:w",
          h: "w:h",
          top: "w:top",
          right: "w:right",
          bottom: "w:bottom",
          left: "w:left",
          header: "w:header",
          footer: "w:footer",
          gutter: "w:gutter",
          linePitch: "w:linePitch",
          pos: "w:pos"
        });
      }
    };
    commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    sax = {};
    events = { exports: {} };
    inherits_browser = { exports: {} };
    browser$1 = { exports: {} };
    process = browser$1.exports = {};
    (function() {
      try {
        if (typeof setTimeout === "function") {
          cachedSetTimeout = setTimeout;
        } else {
          cachedSetTimeout = defaultSetTimout;
        }
      } catch (e) {
        cachedSetTimeout = defaultSetTimout;
      }
      try {
        if (typeof clearTimeout === "function") {
          cachedClearTimeout = clearTimeout;
        } else {
          cachedClearTimeout = defaultClearTimeout;
        }
      } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
      }
    })();
    queue = [];
    draining = false;
    queueIndex = -1;
    process.nextTick = function(fun) {
      var args = new Array(arguments.length - 1);
      if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
          args[i - 1] = arguments[i];
        }
      }
      queue.push(new Item(fun, args));
      if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
      }
    };
    Item.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    process.title = "browser";
    process.browser = true;
    process.env = {};
    process.argv = [];
    process.version = "";
    process.versions = {};
    process.on = noop;
    process.addListener = noop;
    process.once = noop;
    process.off = noop;
    process.removeListener = noop;
    process.removeAllListeners = noop;
    process.emit = noop;
    process.prependListener = noop;
    process.prependOnceListener = noop;
    process.listeners = function(name) {
      return [];
    };
    process.binding = function(name) {
      throw new Error("process.binding is not supported");
    };
    process.cwd = function() {
      return "/";
    };
    process.chdir = function(dir) {
      throw new Error("process.chdir is not supported");
    };
    process.umask = function() {
      return 0;
    };
    browserExports = browser$1.exports;
    process$1 = /* @__PURE__ */ getDefaultExportFromCjs(browserExports);
    buffer = {};
    base64Js = {};
    ieee754 = {};
    util = {};
    types = {};
    callBind = { exports: {} };
    errorsBrowser = {};
    string_decoder = {};
    safeBuffer = { exports: {} };
    libExports = requireLib();
    convertToXmlComponent = (element) => {
      switch (element.type) {
        case void 0:
        case "element":
          const xmlComponent = new ImportedXmlComponent(element.name, element.attributes);
          const childElements = element.elements || [];
          for (const childElm of childElements) {
            const child = convertToXmlComponent(childElm);
            if (child !== void 0) {
              xmlComponent.push(child);
            }
          }
          return xmlComponent;
        case "text":
          return element.text;
        default:
          return void 0;
      }
    };
    ImportedXmlComponentAttributes = class extends XmlAttributeComponent {
      // noop
    };
    ImportedXmlComponent = class extends XmlComponent {
      /**
       * Converts the xml string to a XmlComponent tree.
       *
       * @param importedContent xml content of the imported component
       */
      static fromXmlString(importedContent) {
        const xmlObj = libExports.xml2js(importedContent, { compact: false });
        return convertToXmlComponent(xmlObj);
      }
      /**
       * Converts the xml string to a XmlComponent tree.
       *
       * @param importedContent xml content of the imported component
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      constructor(rootKey, _attr) {
        super(rootKey);
        if (_attr) {
          this.root.push(new ImportedXmlComponentAttributes(_attr));
        }
      }
      push(xmlComponent) {
        this.root.push(xmlComponent);
      }
    };
    ImportedRootElementAttributes = class extends XmlComponent {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      constructor(_attr) {
        super("");
        this._attr = _attr;
      }
      prepForXml(_) {
        return {
          _attr: this._attr
        };
      }
    };
    InitializableXmlComponent = class extends XmlComponent {
      constructor(rootKey, initComponent) {
        super(rootKey);
        if (initComponent) {
          this.root = initComponent.root;
        }
      }
    };
    decimalNumber = (val) => {
      if (isNaN(val)) {
        throw new Error(`Invalid value '${val}' specified. Must be an integer.`);
      }
      return Math.floor(val);
    };
    unsignedDecimalNumber = (val) => {
      const value = decimalNumber(val);
      if (value < 0) {
        throw new Error(`Invalid value '${val}' specified. Must be a positive integer.`);
      }
      return value;
    };
    hexBinary = (val, length) => {
      const expectedLength = length * 2;
      if (val.length !== expectedLength || isNaN(Number(`0x${val}`))) {
        throw new Error(`Invalid hex value '${val}'. Expected ${expectedLength} digit hex value`);
      }
      return val;
    };
    uCharHexNumber = (val) => hexBinary(val, 1);
    universalMeasureValue = (val) => {
      const unit = val.slice(-2);
      const amount = val.substring(0, val.length - 2);
      return `${Number(amount)}${unit}`;
    };
    positiveUniversalMeasureValue = (val) => {
      const value = universalMeasureValue(val);
      if (parseFloat(value) < 0) {
        throw new Error(`Invalid value '${value}' specified. Expected a positive number.`);
      }
      return value;
    };
    hexColorValue = (val) => {
      if (val === "auto") {
        return val;
      }
      const color = val.charAt(0) === "#" ? val.substring(1) : val;
      return hexBinary(color, 3);
    };
    signedTwipsMeasureValue = (val) => typeof val === "string" ? universalMeasureValue(val) : decimalNumber(val);
    hpsMeasureValue = (val) => typeof val === "string" ? positiveUniversalMeasureValue(val) : unsignedDecimalNumber(val);
    twipsMeasureValue = (val) => typeof val === "string" ? positiveUniversalMeasureValue(val) : unsignedDecimalNumber(val);
    percentageValue = (val) => {
      const percent = val.substring(0, val.length - 1);
      return `${Number(percent)}%`;
    };
    measurementOrPercentValue = (val) => {
      if (typeof val === "number") {
        return decimalNumber(val);
      }
      if (val.slice(-1) === "%") {
        return percentageValue(val);
      }
      return universalMeasureValue(val);
    };
    eighthPointMeasureValue = unsignedDecimalNumber;
    pointMeasureValue = unsignedDecimalNumber;
    dateTimeValue = (val) => val.toISOString();
    OnOffElement = class extends XmlComponent {
      constructor(name, val = true) {
        super(name);
        if (val !== true) {
          this.root.push(new Attributes({ val }));
        }
      }
    };
    HpsMeasureElement = class extends XmlComponent {
      constructor(name, val) {
        super(name);
        this.root.push(new Attributes({ val: hpsMeasureValue(val) }));
      }
    };
    StringValueElement = class extends XmlComponent {
      constructor(name, val) {
        super(name);
        this.root.push(new Attributes({ val }));
      }
    };
    createStringElement = (name, value) => new BuilderElement({
      name,
      attributes: {
        value: { key: "w:val", value }
      }
    });
    NumberValueElement = class extends XmlComponent {
      constructor(name, val) {
        super(name);
        this.root.push(new Attributes({ val }));
      }
    };
    StringEnumValueElement = class extends XmlComponent {
      constructor(name, val) {
        super(name);
        this.root.push(new Attributes({ val }));
      }
    };
    StringContainer = class extends XmlComponent {
      constructor(name, val) {
        super(name);
        this.root.push(val);
      }
    };
    BuilderElement = class extends XmlComponent {
      constructor({
        name,
        attributes,
        children
      }) {
        super(name);
        if (attributes) {
          this.root.push(new NextAttributeComponent(attributes));
        }
        if (children) {
          this.root.push(...children);
        }
      }
    };
    AlignmentType = {
      /** Align Start */
      START: "start",
      /** Align Center */
      CENTER: "center",
      /** End */
      END: "end",
      /** Justified */
      BOTH: "both",
      /** Medium Kashida Length */
      MEDIUM_KASHIDA: "mediumKashida",
      /** Distribute All Characters Equally */
      DISTRIBUTE: "distribute",
      /** Align to List Tab */
      NUM_TAB: "numTab",
      /** Widest Kashida Length */
      HIGH_KASHIDA: "highKashida",
      /** Low Kashida Length */
      LOW_KASHIDA: "lowKashida",
      /** Thai Language Justification */
      THAI_DISTRIBUTE: "thaiDistribute",
      /** Align Left */
      LEFT: "left",
      /** Align Right */
      RIGHT: "right",
      /** Justified */
      JUSTIFIED: "both"
    };
    AlignmentAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", { val: "w:val" });
      }
    };
    Alignment = class extends XmlComponent {
      constructor(type2) {
        super("w:jc");
        this.root.push(new AlignmentAttributes({ val: type2 }));
      }
    };
    BorderElement = class extends XmlComponent {
      constructor(elementName, { color, size, space, style }) {
        super(elementName);
        this.root.push(
          new BordersAttributes({
            style,
            color: color === void 0 ? void 0 : hexColorValue(color),
            size: size === void 0 ? void 0 : eighthPointMeasureValue(size),
            space: space === void 0 ? void 0 : pointMeasureValue(space)
          })
        );
      }
    };
    BordersAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", {
          style: "w:val",
          color: "w:color",
          size: "w:sz",
          space: "w:space"
        });
      }
    };
    BorderStyle = {
      /** a single line */
      SINGLE: "single",
      /** a line with a series of alternating thin and thick strokes */
      DASH_DOT_STROKED: "dashDotStroked",
      /** a dashed line */
      DASHED: "dashed",
      /** a dashed line with small gaps */
      DASH_SMALL_GAP: "dashSmallGap",
      /** a line with alternating dots and dashes */
      DOT_DASH: "dotDash",
      /** a line with a repeating dot - dot - dash sequence */
      DOT_DOT_DASH: "dotDotDash",
      /** a dotted line */
      DOTTED: "dotted",
      /** a double line */
      DOUBLE: "double",
      /** a double wavy line */
      DOUBLE_WAVE: "doubleWave",
      /** an inset set of lines */
      INSET: "inset",
      /** no border */
      NIL: "nil",
      /** no border */
      NONE: "none",
      /** an outset set of lines */
      OUTSET: "outset",
      /** a single line */
      THICK: "thick",
      /** a thick line contained within a thin line with a large-sized intermediate gap */
      THICK_THIN_LARGE_GAP: "thickThinLargeGap",
      /** a thick line contained within a thin line with a medium-sized intermediate gap */
      THICK_THIN_MEDIUM_GAP: "thickThinMediumGap",
      /** a thick line contained within a thin line with a small intermediate gap */
      THICK_THIN_SMALL_GAP: "thickThinSmallGap",
      /** a thin line contained within a thick line with a large-sized intermediate gap */
      THIN_THICK_LARGE_GAP: "thinThickLargeGap",
      /** a thick line contained within a thin line with a medium-sized intermediate gap */
      THIN_THICK_MEDIUM_GAP: "thinThickMediumGap",
      /** a thick line contained within a thin line with a small intermediate gap */
      THIN_THICK_SMALL_GAP: "thinThickSmallGap",
      /** a thin-thick-thin line with a large gap */
      THIN_THICK_THIN_LARGE_GAP: "thinThickThinLargeGap",
      /** a thin-thick-thin line with a medium gap */
      THIN_THICK_THIN_MEDIUM_GAP: "thinThickThinMediumGap",
      /** a thin-thick-thin line with a small gap */
      THIN_THICK_THIN_SMALL_GAP: "thinThickThinSmallGap",
      /** a three-staged gradient line, getting darker towards the paragraph */
      THREE_D_EMBOSS: "threeDEmboss",
      /** a three-staged gradient like, getting darker away from the paragraph */
      THREE_D_ENGRAVE: "threeDEngrave",
      /** a triple line */
      TRIPLE: "triple",
      /** a wavy line */
      WAVE: "wave"
    };
    Border = class extends IgnoreIfEmptyXmlComponent {
      constructor(options) {
        super("w:pBdr");
        if (options.top) {
          this.root.push(new BorderElement("w:top", options.top));
        }
        if (options.bottom) {
          this.root.push(new BorderElement("w:bottom", options.bottom));
        }
        if (options.left) {
          this.root.push(new BorderElement("w:left", options.left));
        }
        if (options.right) {
          this.root.push(new BorderElement("w:right", options.right));
        }
      }
    };
    ThematicBreak = class extends XmlComponent {
      constructor() {
        super("w:pBdr");
        const bottom = new BorderElement("w:bottom", {
          color: "auto",
          space: 1,
          style: BorderStyle.SINGLE,
          size: 6
        });
        this.root.push(bottom);
      }
    };
    Indent = class extends XmlComponent {
      constructor({ start, end, left, right, hanging, firstLine }) {
        super("w:ind");
        this.root.push(
          new NextAttributeComponent({
            start: {
              key: "w:start",
              value: start === void 0 ? void 0 : signedTwipsMeasureValue(start)
            },
            end: {
              key: "w:end",
              value: end === void 0 ? void 0 : signedTwipsMeasureValue(end)
            },
            left: {
              key: "w:left",
              value: left === void 0 ? void 0 : signedTwipsMeasureValue(left)
            },
            right: {
              key: "w:right",
              value: right === void 0 ? void 0 : signedTwipsMeasureValue(right)
            },
            hanging: {
              key: "w:hanging",
              value: hanging === void 0 ? void 0 : twipsMeasureValue(hanging)
            },
            firstLine: {
              key: "w:firstLine",
              value: firstLine === void 0 ? void 0 : twipsMeasureValue(firstLine)
            }
          })
        );
      }
    };
    Break$1 = class Break extends XmlComponent {
      constructor() {
        super("w:br");
      }
    };
    FieldCharacterType = {
      BEGIN: "begin",
      END: "end",
      SEPARATE: "separate"
    };
    FidCharAttrs = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", { type: "w:fldCharType", dirty: "w:dirty" });
      }
    };
    Begin = class extends XmlComponent {
      constructor(dirty) {
        super("w:fldChar");
        this.root.push(new FidCharAttrs({ type: FieldCharacterType.BEGIN, dirty }));
      }
    };
    Separate = class extends XmlComponent {
      constructor(dirty) {
        super("w:fldChar");
        this.root.push(new FidCharAttrs({ type: FieldCharacterType.SEPARATE, dirty }));
      }
    };
    End = class extends XmlComponent {
      constructor(dirty) {
        super("w:fldChar");
        this.root.push(new FidCharAttrs({ type: FieldCharacterType.END, dirty }));
      }
    };
    SpaceType = {
      DEFAULT: "default",
      PRESERVE: "preserve"
    };
    TextAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", { space: "xml:space" });
      }
    };
    Page = class extends XmlComponent {
      constructor() {
        super("w:instrText");
        this.root.push(new TextAttributes({ space: SpaceType.PRESERVE }));
        this.root.push("PAGE");
      }
    };
    NumberOfPages = class extends XmlComponent {
      constructor() {
        super("w:instrText");
        this.root.push(new TextAttributes({ space: SpaceType.PRESERVE }));
        this.root.push("NUMPAGES");
      }
    };
    NumberOfPagesSection = class extends XmlComponent {
      constructor() {
        super("w:instrText");
        this.root.push(new TextAttributes({ space: SpaceType.PRESERVE }));
        this.root.push("SECTIONPAGES");
      }
    };
    CurrentSection = class extends XmlComponent {
      constructor() {
        super("w:instrText");
        this.root.push(new TextAttributes({ space: SpaceType.PRESERVE }));
        this.root.push("SECTION");
      }
    };
    ShadingAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", {
          fill: "w:fill",
          color: "w:color",
          type: "w:val"
        });
      }
    };
    Shading = class extends XmlComponent {
      constructor({ fill, color, type: type2 }) {
        super("w:shd");
        this.root.push(
          new ShadingAttributes({
            fill: fill === void 0 ? void 0 : hexColorValue(fill),
            color: color === void 0 ? void 0 : hexColorValue(color),
            type: type2
          })
        );
      }
    };
    ShadingType = {
      CLEAR: "clear",
      DIAGONAL_CROSS: "diagCross",
      DIAGONAL_STRIPE: "diagStripe",
      HORIZONTAL_CROSS: "horzCross",
      HORIZONTAL_STRIPE: "horzStripe",
      NIL: "nil",
      PERCENT_5: "pct5",
      PERCENT_10: "pct10",
      PERCENT_12: "pct12",
      PERCENT_15: "pct15",
      PERCENT_20: "pct20",
      PERCENT_25: "pct25",
      PERCENT_30: "pct30",
      PERCENT_35: "pct35",
      PERCENT_37: "pct37",
      PERCENT_40: "pct40",
      PERCENT_45: "pct45",
      PERCENT_50: "pct50",
      PERCENT_55: "pct55",
      PERCENT_60: "pct60",
      PERCENT_62: "pct62",
      PERCENT_65: "pct65",
      PERCENT_70: "pct70",
      PERCENT_75: "pct75",
      PERCENT_80: "pct80",
      PERCENT_85: "pct85",
      PERCENT_87: "pct87",
      PERCENT_90: "pct90",
      PERCENT_95: "pct95",
      REVERSE_DIAGONAL_STRIPE: "reverseDiagStripe",
      SOLID: "solid",
      THIN_DIAGONAL_CROSS: "thinDiagCross",
      THIN_DIAGONAL_STRIPE: "thinDiagStripe",
      THIN_HORIZONTAL_CROSS: "thinHorzCross",
      THIN_REVERSE_DIAGONAL_STRIPE: "thinReverseDiagStripe",
      THIN_VERTICAL_STRIPE: "thinVertStripe",
      VERTICAL_STRIPE: "vertStripe"
    };
    ChangeAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", {
          id: "w:id",
          author: "w:author",
          date: "w:date"
        });
      }
    };
    EmphasisMarkType = {
      DOT: "dot"
    };
    BaseEmphasisMark = class extends XmlComponent {
      constructor(emphasisMarkType) {
        super("w:em");
        this.root.push(
          new Attributes({
            val: emphasisMarkType
          })
        );
      }
    };
    EmphasisMark = class extends BaseEmphasisMark {
      constructor(emphasisMarkType = EmphasisMarkType.DOT) {
        super(emphasisMarkType);
      }
    };
    CharacterSpacing = class extends XmlComponent {
      constructor(value) {
        super("w:spacing");
        this.root.push(
          new Attributes({
            val: signedTwipsMeasureValue(value)
          })
        );
      }
    };
    Color = class extends XmlComponent {
      constructor(color) {
        super("w:color");
        this.root.push(
          new Attributes({
            val: hexColorValue(color)
          })
        );
      }
    };
    Highlight = class extends XmlComponent {
      constructor(color) {
        super("w:highlight");
        this.root.push(
          new Attributes({
            val: color
          })
        );
      }
    };
    HighlightComplexScript = class extends XmlComponent {
      constructor(color) {
        super("w:highlightCs");
        this.root.push(
          new Attributes({
            val: color
          })
        );
      }
    };
    createLanguageComponent = (options) => new BuilderElement({
      name: "w:lang",
      attributes: {
        value: {
          key: "w:val",
          value: options.value
        },
        eastAsia: {
          key: "w:eastAsia",
          value: options.eastAsia
        },
        bidirectional: {
          key: "w:bidi",
          value: options.bidirectional
        }
      }
    });
    RunFontAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", {
          ascii: "w:ascii",
          cs: "w:cs",
          eastAsia: "w:eastAsia",
          hAnsi: "w:hAnsi",
          hint: "w:hint"
        });
      }
    };
    RunFonts = class extends XmlComponent {
      constructor(nameOrAttrs, hint) {
        super("w:rFonts");
        if (typeof nameOrAttrs === "string") {
          const name = nameOrAttrs;
          this.root.push(
            new RunFontAttributes({
              ascii: name,
              cs: name,
              eastAsia: name,
              hAnsi: name,
              hint
            })
          );
        } else {
          const attrs = nameOrAttrs;
          this.root.push(new RunFontAttributes(attrs));
        }
      }
    };
    VerticalAlign$1 = class VerticalAlign extends XmlComponent {
      constructor(type2) {
        super("w:vertAlign");
        this.root.push(
          new Attributes({
            val: type2
          })
        );
      }
    };
    SuperScript = class extends VerticalAlign$1 {
      constructor() {
        super("superscript");
      }
    };
    SubScript = class extends VerticalAlign$1 {
      constructor() {
        super("subscript");
      }
    };
    UnderlineType = {
      SINGLE: "single",
      WORDS: "words",
      DOUBLE: "double",
      THICK: "thick",
      DOTTED: "dotted",
      DOTTEDHEAVY: "dottedHeavy",
      DASH: "dash",
      DASHEDHEAVY: "dashedHeavy",
      DASHLONG: "dashLong",
      DASHLONGHEAVY: "dashLongHeavy",
      DOTDASH: "dotDash",
      DASHDOTHEAVY: "dashDotHeavy",
      DOTDOTDASH: "dotDotDash",
      DASHDOTDOTHEAVY: "dashDotDotHeavy",
      WAVE: "wave",
      WAVYHEAVY: "wavyHeavy",
      WAVYDOUBLE: "wavyDouble",
      NONE: "none"
    };
    Underline = class extends XmlComponent {
      constructor(underlineType = UnderlineType.SINGLE, color) {
        super("w:u");
        this.root.push(
          new Attributes({
            val: underlineType,
            color: color === void 0 ? void 0 : hexColorValue(color)
          })
        );
      }
    };
    RunProperties = class extends IgnoreIfEmptyXmlComponent {
      constructor(options) {
        var _a, _b;
        super("w:rPr");
        if (!options) {
          return;
        }
        if (options.style) {
          this.push(new StringValueElement("w:rStyle", options.style));
        }
        if (options.font) {
          if (typeof options.font === "string") {
            this.push(new RunFonts(options.font));
          } else if ("name" in options.font) {
            this.push(new RunFonts(options.font.name, options.font.hint));
          } else {
            this.push(new RunFonts(options.font));
          }
        }
        if (options.bold !== void 0) {
          this.push(new OnOffElement("w:b", options.bold));
        }
        if (options.boldComplexScript === void 0 && options.bold !== void 0 || options.boldComplexScript) {
          this.push(new OnOffElement("w:bCs", (_a = options.boldComplexScript) != null ? _a : options.bold));
        }
        if (options.italics !== void 0) {
          this.push(new OnOffElement("w:i", options.italics));
        }
        if (options.italicsComplexScript === void 0 && options.italics !== void 0 || options.italicsComplexScript) {
          this.push(new OnOffElement("w:iCs", (_b = options.italicsComplexScript) != null ? _b : options.italics));
        }
        if (options.smallCaps !== void 0) {
          this.push(new OnOffElement("w:smallCaps", options.smallCaps));
        } else if (options.allCaps !== void 0) {
          this.push(new OnOffElement("w:caps", options.allCaps));
        }
        if (options.strike !== void 0) {
          this.push(new OnOffElement("w:strike", options.strike));
        }
        if (options.doubleStrike !== void 0) {
          this.push(new OnOffElement("w:dstrike", options.doubleStrike));
        }
        if (options.emboss !== void 0) {
          this.push(new OnOffElement("w:emboss", options.emboss));
        }
        if (options.imprint !== void 0) {
          this.push(new OnOffElement("w:imprint", options.imprint));
        }
        if (options.noProof !== void 0) {
          this.push(new OnOffElement("w:noProof", options.noProof));
        }
        if (options.snapToGrid !== void 0) {
          this.push(new OnOffElement("w:snapToGrid", options.snapToGrid));
        }
        if (options.vanish) {
          this.push(new OnOffElement("w:vanish", options.vanish));
        }
        if (options.color) {
          this.push(new Color(options.color));
        }
        if (options.characterSpacing) {
          this.push(new CharacterSpacing(options.characterSpacing));
        }
        if (options.scale !== void 0) {
          this.push(new NumberValueElement("w:w", options.scale));
        }
        if (options.kern) {
          this.push(new HpsMeasureElement("w:kern", options.kern));
        }
        if (options.position) {
          this.push(new StringValueElement("w:position", options.position));
        }
        if (options.size !== void 0) {
          this.push(new HpsMeasureElement("w:sz", options.size));
        }
        const szCs = options.sizeComplexScript === void 0 || options.sizeComplexScript === true ? options.size : options.sizeComplexScript;
        if (szCs) {
          this.push(new HpsMeasureElement("w:szCs", szCs));
        }
        if (options.highlight) {
          this.push(new Highlight(options.highlight));
        }
        const highlightCs = options.highlightComplexScript === void 0 || options.highlightComplexScript === true ? options.highlight : options.highlightComplexScript;
        if (highlightCs) {
          this.push(new HighlightComplexScript(highlightCs));
        }
        if (options.underline) {
          this.push(new Underline(options.underline.type, options.underline.color));
        }
        if (options.effect) {
          this.push(new StringValueElement("w:effect", options.effect));
        }
        if (options.border) {
          this.push(new BorderElement("w:bdr", options.border));
        }
        if (options.shading) {
          this.push(new Shading(options.shading));
        }
        if (options.subScript) {
          this.push(new SubScript());
        }
        if (options.superScript) {
          this.push(new SuperScript());
        }
        if (options.rightToLeft !== void 0) {
          this.push(new OnOffElement("w:rtl", options.rightToLeft));
        }
        if (options.emphasisMark) {
          this.push(new EmphasisMark(options.emphasisMark.type));
        }
        if (options.language) {
          this.push(createLanguageComponent(options.language));
        }
        if (options.specVanish) {
          this.push(new OnOffElement("w:specVanish", options.vanish));
        }
        if (options.math) {
          this.push(new OnOffElement("w:oMath", options.math));
        }
        if (options.revision) {
          this.push(new RunPropertiesChange(options.revision));
        }
      }
      push(item) {
        this.root.push(item);
      }
    };
    RunPropertiesChange = class extends XmlComponent {
      constructor(options) {
        super("w:rPrChange");
        this.root.push(
          new ChangeAttributes({
            id: options.id,
            author: options.author,
            date: options.date
          })
        );
        this.addChildElement(new RunProperties(options));
      }
    };
    Text = class extends XmlComponent {
      constructor(options) {
        var _a;
        super("w:t");
        if (typeof options === "string") {
          this.root.push(new TextAttributes({ space: SpaceType.PRESERVE }));
          this.root.push(options);
        } else {
          this.root.push(new TextAttributes({ space: (_a = options.space) != null ? _a : SpaceType.DEFAULT }));
          this.root.push(options.text);
        }
      }
    };
    PageNumber = {
      CURRENT: "CURRENT",
      TOTAL_PAGES: "TOTAL_PAGES",
      TOTAL_PAGES_IN_SECTION: "TOTAL_PAGES_IN_SECTION",
      CURRENT_SECTION: "SECTION"
    };
    Run = class extends XmlComponent {
      constructor(options) {
        super("w:r");
        __publicField(this, "properties");
        this.properties = new RunProperties(options);
        this.root.push(this.properties);
        if (options.break) {
          for (let i = 0; i < options.break; i++) {
            this.root.push(new Break$1());
          }
        }
        if (options.children) {
          for (const child of options.children) {
            if (typeof child === "string") {
              switch (child) {
                case PageNumber.CURRENT:
                  this.root.push(new Begin());
                  this.root.push(new Page());
                  this.root.push(new Separate());
                  this.root.push(new End());
                  break;
                case PageNumber.TOTAL_PAGES:
                  this.root.push(new Begin());
                  this.root.push(new NumberOfPages());
                  this.root.push(new Separate());
                  this.root.push(new End());
                  break;
                case PageNumber.TOTAL_PAGES_IN_SECTION:
                  this.root.push(new Begin());
                  this.root.push(new NumberOfPagesSection());
                  this.root.push(new Separate());
                  this.root.push(new End());
                  break;
                case PageNumber.CURRENT_SECTION:
                  this.root.push(new Begin());
                  this.root.push(new CurrentSection());
                  this.root.push(new Separate());
                  this.root.push(new End());
                  break;
                default:
                  this.root.push(new Text(child));
                  break;
              }
              continue;
            }
            this.root.push(child);
          }
        } else if (options.text !== void 0) {
          this.root.push(new Text(options.text));
        }
      }
    };
    TextRun = class extends Run {
      constructor(options) {
        super(typeof options === "string" ? { text: options } : options);
      }
    };
    hash$1 = {};
    utils = {};
    common$1 = {};
    sha = {};
    common = {};
    ripemd = {};
    hashExports = requireHash();
    hash = /* @__PURE__ */ getDefaultExportFromCjs$1(hashExports);
    urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
    customAlphabet = (alphabet, defaultSize = 21) => {
      return (size = defaultSize) => {
        let id = "";
        let i = size | 0;
        while (i--) {
          id += alphabet[Math.random() * alphabet.length | 0];
        }
        return id;
      };
    };
    nanoid = (size = 21) => {
      let id = "";
      let i = size | 0;
      while (i--) {
        id += urlAlphabet[Math.random() * 64 | 0];
      }
      return id;
    };
    convertInchesToTwip = (inches) => Math.floor(inches * 72 * 20);
    uniqueNumericIdCreator = (initial = 0) => {
      let currentCount = initial;
      return () => ++currentCount;
    };
    abstractNumUniqueNumericIdGen = () => uniqueNumericIdCreator();
    concreteNumUniqueNumericIdGen = () => uniqueNumericIdCreator(1);
    docPropertiesUniqueNumericIdGen = () => uniqueNumericIdCreator();
    bookmarkUniqueNumericIdGen = () => uniqueNumericIdCreator();
    uniqueId = () => nanoid().toLowerCase();
    hashedId = (data) => hash.sha1().update(data instanceof ArrayBuffer ? new Uint8Array(data) : data).digest("hex");
    generateUuidPart = (count) => customAlphabet("1234567890abcdef", count)();
    uniqueUuid = () => `${generateUuidPart(8)}-${generateUuidPart(4)}-${generateUuidPart(4)}-${generateUuidPart(4)}-${generateUuidPart(12)}`;
    HorizontalPositionRelativeFrom = {
      /**
       * ## Character
       *
       * Specifies that the horizontal positioning shall be relative to the position of the anchor within its run content.
       */
      CHARACTER: "character",
      /**
       * ## Column
       *
       * Specifies that the horizontal positioning shall be relative to the extents of the column which contains its anchor.
       */
      COLUMN: "column",
      /**
       * ## Inside Margin
       *
       * Specifies that the horizontal positioning shall be relative to the inside margin of the current page (the left margin on odd pages, right on even pages).
       */
      INSIDE_MARGIN: "insideMargin",
      /**
       * ## Left Margin
       *
       * Specifies that the horizontal positioning shall be relative to the left margin of the page.
       */
      LEFT_MARGIN: "leftMargin",
      /**
       * ## Page Margin
       *
       * Specifies that the horizontal positioning shall be relative to the page margins.
       */
      MARGIN: "margin",
      /**
       * ## Outside Margin
       *
       * Specifies that the horizontal positioning shall be relative to the outside margin of the current page (the right margin on odd pages, left on even pages).
       */
      OUTSIDE_MARGIN: "outsideMargin",
      /**
       * ## Page Edge
       *
       * Specifies that the horizontal positioning shall be relative to the edge of the page.
       */
      PAGE: "page",
      /**
       * ## Right Margin
       *
       * Specifies that the horizontal positioning shall be relative to the right margin of the page.
       */
      RIGHT_MARGIN: "rightMargin"
    };
    VerticalPositionRelativeFrom = {
      /**
       * ## Bottom Margin
       *
       * Specifies that the vertical positioning shall be relative to the bottom margin of the current page.
       */
      BOTTOM_MARGIN: "bottomMargin",
      /**
       * ## Inside Margin
       *
       * Specifies that the vertical positioning shall be relative to the inside margin of the current page.
       */
      INSIDE_MARGIN: "insideMargin",
      /**
       * ## Line
       *
       * Specifies that the vertical positioning shall be relative to the line containing the anchor character.
       */
      LINE: "line",
      /**
       * ## Page Margin
       *
       * Specifies that the vertical positioning shall be relative to the page margins.
       */
      MARGIN: "margin",
      /**
       * ## Outside Margin
       *
       * Specifies that the vertical positioning shall be relative to the outside margin of the current page.
       */
      OUTSIDE_MARGIN: "outsideMargin",
      /**
       * ## Page Edge
       *
       * Specifies that the vertical positioning shall be relative to the edge of the page.
       */
      PAGE: "page",
      /**
       * ## Paragraph
       *
       * Specifies that the vertical positioning shall be relative to the paragraph which contains the drawing anchor.
       */
      PARAGRAPH: "paragraph",
      /**
       * ## Top Margin
       *
       * Specifies that the vertical positioning shall be relative to the top margin of the current page.
       */
      TOP_MARGIN: "topMargin"
    };
    createSimplePos = () => new BuilderElement({
      name: "wp:simplePos",
      // NOTE: It's not fully supported in Microsoft Word, but this element is needed anyway
      attributes: {
        x: { key: "x", value: 0 },
        y: { key: "y", value: 0 }
      }
    });
    createAlign = (value) => new BuilderElement({
      name: "wp:align",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      children: [value]
    });
    createPositionOffset = (offsetValue) => new BuilderElement({
      name: "wp:posOffset",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      children: [offsetValue.toString()]
    });
    createHorizontalPosition = ({ relative, align, offset }) => new BuilderElement({
      name: "wp:positionH",
      attributes: {
        relativeFrom: { key: "relativeFrom", value: relative != null ? relative : HorizontalPositionRelativeFrom.PAGE }
      },
      children: [
        (() => {
          if (align) {
            return createAlign(align);
          } else if (offset !== void 0) {
            return createPositionOffset(offset);
          } else {
            throw new Error("There is no configuration provided for floating position (Align or offset)");
          }
        })()
      ]
    });
    createVerticalPosition = ({ relative, align, offset }) => new BuilderElement({
      name: "wp:positionV",
      attributes: {
        relativeFrom: { key: "relativeFrom", value: relative != null ? relative : VerticalPositionRelativeFrom.PAGE }
      },
      children: [
        (() => {
          if (align) {
            return createAlign(align);
          } else if (offset !== void 0) {
            return createPositionOffset(offset);
          } else {
            throw new Error("There is no configuration provided for floating position (Align or offset)");
          }
        })()
      ]
    });
    GraphicDataAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", {
          uri: "uri"
        });
      }
    };
    createSvgBlip = (mediaData) => new BuilderElement({
      name: "asvg:svgBlip",
      attributes: {
        asvg: {
          key: "xmlns:asvg",
          value: "http://schemas.microsoft.com/office/drawing/2016/SVG/main"
        },
        embed: {
          key: "r:embed",
          value: `rId{${mediaData.fileName}}`
        }
      }
    });
    createExtention = (mediaData) => new BuilderElement({
      name: "a:ext",
      attributes: {
        uri: {
          key: "uri",
          value: "{96DAC541-7B7A-43D3-8B79-37D633B846F1}"
        }
      },
      children: [createSvgBlip(mediaData)]
    });
    createExtentionList = (mediaData) => new BuilderElement({
      name: "a:extLst",
      children: [createExtention(mediaData)]
    });
    createBlip = (mediaData) => new BuilderElement({
      name: "a:blip",
      attributes: {
        embed: {
          key: "r:embed",
          value: `rId{${mediaData.type === "svg" ? mediaData.fallback.fileName : mediaData.fileName}}`
        },
        cstate: {
          key: "cstate",
          value: "none"
        }
      },
      children: mediaData.type === "svg" ? [createExtentionList(mediaData)] : []
    });
    SourceRectangle = class extends XmlComponent {
      constructor() {
        super("a:srcRect");
      }
    };
    FillRectangle = class extends XmlComponent {
      constructor() {
        super("a:fillRect");
      }
    };
    Stretch = class extends XmlComponent {
      constructor() {
        super("a:stretch");
        this.root.push(new FillRectangle());
      }
    };
    BlipFill = class extends XmlComponent {
      constructor(mediaData) {
        super("pic:blipFill");
        this.root.push(createBlip(mediaData));
        this.root.push(new SourceRectangle());
        this.root.push(new Stretch());
      }
    };
    PicLocksAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", {
          noChangeAspect: "noChangeAspect",
          noChangeArrowheads: "noChangeArrowheads"
        });
      }
    };
    PicLocks = class extends XmlComponent {
      constructor() {
        super("a:picLocks");
        this.root.push(
          new PicLocksAttributes({
            noChangeAspect: 1,
            noChangeArrowheads: 1
          })
        );
      }
    };
    ChildNonVisualProperties = class extends XmlComponent {
      constructor() {
        super("pic:cNvPicPr");
        this.root.push(new PicLocks());
      }
    };
    createHyperlinkClick = (linkId, hasXmlNs) => new BuilderElement({
      name: "a:hlinkClick",
      attributes: __spreadProps(__spreadValues({}, hasXmlNs ? {
        xmlns: {
          key: "xmlns:a",
          value: "http://schemas.openxmlformats.org/drawingml/2006/main"
        }
      } : {}), {
        id: {
          key: "r:id",
          value: `rId${linkId}`
        }
      })
    });
    NonVisualPropertiesAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", {
          id: "id",
          name: "name",
          descr: "descr"
        });
      }
    };
    NonVisualProperties = class extends XmlComponent {
      constructor() {
        super("pic:cNvPr");
        this.root.push(
          new NonVisualPropertiesAttributes({
            id: 0,
            name: "",
            descr: ""
          })
        );
      }
      prepForXml(context) {
        for (let i = context.stack.length - 1; i >= 0; i--) {
          const element = context.stack[i];
          if (!(element instanceof ConcreteHyperlink)) {
            continue;
          }
          this.root.push(createHyperlinkClick(element.linkId, false));
          break;
        }
        return super.prepForXml(context);
      }
    };
    NonVisualPicProperties = class extends XmlComponent {
      constructor() {
        super("pic:nvPicPr");
        this.root.push(new NonVisualProperties());
        this.root.push(new ChildNonVisualProperties());
      }
    };
    PicAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", {
          xmlns: "xmlns:pic"
        });
      }
    };
    ExtentsAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", {
          cx: "cx",
          cy: "cy"
        });
      }
    };
    Extents = class extends XmlComponent {
      constructor(x, y) {
        super("a:ext");
        __publicField(this, "attributes");
        this.attributes = new ExtentsAttributes({
          cx: x,
          cy: y
        });
        this.root.push(this.attributes);
      }
    };
    OffsetAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", {
          x: "x",
          y: "y"
        });
      }
    };
    Offset = class extends XmlComponent {
      constructor() {
        super("a:off");
        this.root.push(
          new OffsetAttributes({
            x: 0,
            y: 0
          })
        );
      }
    };
    FormAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", {
          flipVertical: "flipV",
          flipHorizontal: "flipH",
          rotation: "rot"
        });
      }
    };
    Form = class extends XmlComponent {
      constructor(options) {
        var _a, _b;
        super("a:xfrm");
        __publicField(this, "extents");
        this.root.push(
          new FormAttributes({
            flipVertical: (_a = options.flip) == null ? void 0 : _a.vertical,
            flipHorizontal: (_b = options.flip) == null ? void 0 : _b.horizontal,
            rotation: options.rotation
          })
        );
        this.extents = new Extents(options.emus.x, options.emus.y);
        this.root.push(new Offset());
        this.root.push(this.extents);
      }
    };
    createNoFill = () => new BuilderElement({ name: "a:noFill" });
    createSolidRgbColor = (options) => new BuilderElement({
      name: "a:srgbClr",
      attributes: {
        value: {
          key: "val",
          value: options.value
        }
      }
    });
    createSchemeColor = (options) => new BuilderElement({
      name: "a:schemeClr",
      attributes: {
        value: {
          key: "val",
          value: options.value
        }
      }
    });
    createSolidFill = (options) => new BuilderElement({
      name: "a:solidFill",
      children: [options.type === "rgb" ? createSolidRgbColor(options) : createSchemeColor(options)]
    });
    createOutline = (options) => new BuilderElement({
      name: "a:ln",
      attributes: {
        width: {
          key: "w",
          value: options.width
        },
        cap: {
          key: "cap",
          value: options.cap
        },
        compoundLine: {
          key: "cmpd",
          value: options.compoundLine
        },
        align: {
          key: "algn",
          value: options.align
        }
      },
      children: [
        options.type === "noFill" ? createNoFill() : options.solidFillType === "rgb" ? createSolidFill({
          type: "rgb",
          value: options.value
        }) : createSolidFill({
          type: "scheme",
          value: options.value
        })
      ]
    });
    AdjustmentValues = class extends XmlComponent {
      constructor() {
        super("a:avLst");
      }
    };
    PresetGeometryAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", {
          prst: "prst"
        });
      }
    };
    PresetGeometry = class extends XmlComponent {
      constructor() {
        super("a:prstGeom");
        this.root.push(
          new PresetGeometryAttributes({
            prst: "rect"
          })
        );
        this.root.push(new AdjustmentValues());
      }
    };
    ShapePropertiesAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", {
          bwMode: "bwMode"
        });
      }
    };
    ShapeProperties = class extends XmlComponent {
      constructor({ outline, transform }) {
        super("pic:spPr");
        __publicField(this, "form");
        this.root.push(
          new ShapePropertiesAttributes({
            bwMode: "auto"
          })
        );
        this.form = new Form(transform);
        this.root.push(this.form);
        this.root.push(new PresetGeometry());
        if (outline) {
          this.root.push(createNoFill());
          this.root.push(createOutline(outline));
        }
      }
    };
    Pic = class extends XmlComponent {
      constructor({
        mediaData,
        transform,
        outline
      }) {
        super("pic:pic");
        this.root.push(
          new PicAttributes({
            xmlns: "http://schemas.openxmlformats.org/drawingml/2006/picture"
          })
        );
        this.root.push(new NonVisualPicProperties());
        this.root.push(new BlipFill(mediaData));
        this.root.push(new ShapeProperties({ transform, outline }));
      }
    };
    GraphicData = class extends XmlComponent {
      constructor({
        mediaData,
        transform,
        outline
      }) {
        super("a:graphicData");
        __publicField(this, "pic");
        this.root.push(
          new GraphicDataAttributes({
            uri: "http://schemas.openxmlformats.org/drawingml/2006/picture"
          })
        );
        this.pic = new Pic({ mediaData, transform, outline });
        this.root.push(this.pic);
      }
    };
    GraphicAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", {
          a: "xmlns:a"
        });
      }
    };
    Graphic = class extends XmlComponent {
      constructor({
        mediaData,
        transform,
        outline
      }) {
        super("a:graphic");
        __publicField(this, "data");
        this.root.push(
          new GraphicAttributes({
            a: "http://schemas.openxmlformats.org/drawingml/2006/main"
          })
        );
        this.data = new GraphicData({ mediaData, transform, outline });
        this.root.push(this.data);
      }
    };
    TextWrappingType = {
      NONE: 0,
      SQUARE: 1,
      TIGHT: 2,
      TOP_AND_BOTTOM: 3
    };
    TextWrappingSide = {
      BOTH_SIDES: "bothSides",
      LEFT: "left",
      RIGHT: "right",
      LARGEST: "largest"
    };
    WrapNone = class extends XmlComponent {
      constructor() {
        super("wp:wrapNone");
      }
    };
    WrapSquareAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", {
          distT: "distT",
          distB: "distB",
          distL: "distL",
          distR: "distR",
          wrapText: "wrapText"
        });
      }
    };
    WrapSquare = class extends XmlComponent {
      constructor(textWrapping, margins = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      }) {
        super("wp:wrapSquare");
        this.root.push(
          new WrapSquareAttributes({
            wrapText: textWrapping.side || TextWrappingSide.BOTH_SIDES,
            distT: margins.top,
            distB: margins.bottom,
            distL: margins.left,
            distR: margins.right
          })
        );
      }
    };
    WrapTightAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", {
          distT: "distT",
          distB: "distB"
        });
      }
    };
    WrapTight = class extends XmlComponent {
      constructor(margins = {
        top: 0,
        bottom: 0
      }) {
        super("wp:wrapTight");
        this.root.push(
          new WrapTightAttributes({
            distT: margins.top,
            distB: margins.bottom
          })
        );
      }
    };
    WrapTopAndBottomAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", {
          distT: "distT",
          distB: "distB"
        });
      }
    };
    WrapTopAndBottom = class extends XmlComponent {
      constructor(margins = {
        top: 0,
        bottom: 0
      }) {
        super("wp:wrapTopAndBottom");
        this.root.push(
          new WrapTopAndBottomAttributes({
            distT: margins.top,
            distB: margins.bottom
          })
        );
      }
    };
    DocProperties = class extends XmlComponent {
      constructor({ name, description, title } = { name: "", description: "", title: "" }) {
        super("wp:docPr");
        __publicField(this, "docPropertiesUniqueNumericId", docPropertiesUniqueNumericIdGen());
        const attributes = {
          id: {
            key: "id",
            value: this.docPropertiesUniqueNumericId()
          },
          name: {
            key: "name",
            value: name
          }
        };
        if (description !== null && description !== void 0) {
          attributes.description = {
            key: "descr",
            value: description
          };
        }
        if (title !== null && title !== void 0) {
          attributes.title = {
            key: "title",
            value: title
          };
        }
        this.root.push(new NextAttributeComponent(attributes));
      }
      prepForXml(context) {
        for (let i = context.stack.length - 1; i >= 0; i--) {
          const element = context.stack[i];
          if (!(element instanceof ConcreteHyperlink)) {
            continue;
          }
          this.root.push(createHyperlinkClick(element.linkId, true));
          break;
        }
        return super.prepForXml(context);
      }
    };
    createEffectExtent = ({ top, right, bottom, left }) => new BuilderElement({
      name: "wp:effectExtent",
      attributes: {
        top: {
          key: "t",
          value: top
        },
        right: {
          key: "r",
          value: right
        },
        bottom: {
          key: "b",
          value: bottom
        },
        left: {
          key: "l",
          value: left
        }
      }
    });
    createExtent = ({ x, y }) => new BuilderElement({
      name: "wp:extent",
      attributes: {
        x: { key: "cx", value: x },
        y: { key: "cy", value: y }
      }
    });
    GraphicFrameLockAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", {
          xmlns: "xmlns:a",
          noChangeAspect: "noChangeAspect"
        });
      }
    };
    GraphicFrameLocks = class extends XmlComponent {
      constructor() {
        super("a:graphicFrameLocks");
        this.root.push(
          new GraphicFrameLockAttributes({
            xmlns: "http://schemas.openxmlformats.org/drawingml/2006/main",
            noChangeAspect: 1
          })
        );
      }
    };
    createGraphicFrameProperties = () => new BuilderElement({
      name: "wp:cNvGraphicFramePr",
      children: [new GraphicFrameLocks()]
    });
    AnchorAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", {
          distT: "distT",
          distB: "distB",
          distL: "distL",
          distR: "distR",
          allowOverlap: "allowOverlap",
          behindDoc: "behindDoc",
          layoutInCell: "layoutInCell",
          locked: "locked",
          relativeHeight: "relativeHeight",
          simplePos: "simplePos"
        });
      }
    };
    Anchor = class extends XmlComponent {
      constructor({
        mediaData,
        transform,
        drawingOptions
      }) {
        super("wp:anchor");
        const floating = __spreadValues({
          allowOverlap: true,
          behindDocument: false,
          lockAnchor: false,
          layoutInCell: true,
          verticalPosition: {},
          horizontalPosition: {}
        }, drawingOptions.floating);
        this.root.push(
          new AnchorAttributes({
            distT: floating.margins ? floating.margins.top || 0 : 0,
            distB: floating.margins ? floating.margins.bottom || 0 : 0,
            distL: floating.margins ? floating.margins.left || 0 : 0,
            distR: floating.margins ? floating.margins.right || 0 : 0,
            simplePos: "0",
            // note: word doesn't fully support - so we use 0
            allowOverlap: floating.allowOverlap === true ? "1" : "0",
            behindDoc: floating.behindDocument === true ? "1" : "0",
            locked: floating.lockAnchor === true ? "1" : "0",
            layoutInCell: floating.layoutInCell === true ? "1" : "0",
            relativeHeight: floating.zIndex ? floating.zIndex : transform.emus.y
          })
        );
        this.root.push(createSimplePos());
        this.root.push(createHorizontalPosition(floating.horizontalPosition));
        this.root.push(createVerticalPosition(floating.verticalPosition));
        this.root.push(createExtent({ x: transform.emus.x, y: transform.emus.y }));
        this.root.push(createEffectExtent({ top: 0, right: 0, bottom: 0, left: 0 }));
        if (drawingOptions.floating !== void 0 && drawingOptions.floating.wrap !== void 0) {
          switch (drawingOptions.floating.wrap.type) {
            case TextWrappingType.SQUARE:
              this.root.push(new WrapSquare(drawingOptions.floating.wrap, drawingOptions.floating.margins));
              break;
            case TextWrappingType.TIGHT:
              this.root.push(new WrapTight(drawingOptions.floating.margins));
              break;
            case TextWrappingType.TOP_AND_BOTTOM:
              this.root.push(new WrapTopAndBottom(drawingOptions.floating.margins));
              break;
            case TextWrappingType.NONE:
            default:
              this.root.push(new WrapNone());
          }
        } else {
          this.root.push(new WrapNone());
        }
        this.root.push(new DocProperties(drawingOptions.docProperties));
        this.root.push(createGraphicFrameProperties());
        this.root.push(new Graphic({ mediaData, transform, outline: drawingOptions.outline }));
      }
    };
    createInline = ({ mediaData, transform, docProperties, outline }) => {
      var _a, _b, _c, _d;
      return new BuilderElement({
        name: "wp:inline",
        attributes: {
          distanceTop: {
            key: "distT",
            value: 0
          },
          distanceBottom: {
            key: "distB",
            value: 0
          },
          distanceLeft: {
            key: "distL",
            value: 0
          },
          distanceRight: {
            key: "distR",
            value: 0
          }
        },
        children: [
          createExtent({ x: transform.emus.x, y: transform.emus.y }),
          createEffectExtent(
            outline ? {
              top: ((_a = outline.width) != null ? _a : 9525) * 2,
              right: ((_b = outline.width) != null ? _b : 9525) * 2,
              bottom: ((_c = outline.width) != null ? _c : 9525) * 2,
              left: ((_d = outline.width) != null ? _d : 9525) * 2
            } : { top: 0, right: 0, bottom: 0, left: 0 }
          ),
          new DocProperties(docProperties),
          createGraphicFrameProperties(),
          new Graphic({ mediaData, transform, outline })
        ]
      });
    };
    Drawing = class extends XmlComponent {
      constructor(imageData, drawingOptions = {}) {
        super("w:drawing");
        if (!drawingOptions.floating) {
          this.root.push(
            createInline({
              mediaData: imageData,
              transform: imageData.transformation,
              docProperties: drawingOptions.docProperties,
              outline: drawingOptions.outline
            })
          );
        } else {
          this.root.push(new Anchor({ mediaData: imageData, transform: imageData.transformation, drawingOptions }));
        }
      }
    };
    convertDataURIToBinary = (dataURI) => {
      if (typeof atob === "function") {
        const BASE64_MARKER = ";base64,";
        const base64Index = dataURI.indexOf(BASE64_MARKER);
        const base64IndexWithOffset = base64Index === -1 ? 0 : base64Index + BASE64_MARKER.length;
        return new Uint8Array(
          atob(dataURI.substring(base64IndexWithOffset)).split("").map((c) => c.charCodeAt(0))
        );
      } else {
        const b = require("buffer");
        return new b.Buffer(dataURI, "base64");
      }
    };
    standardizeData = (data) => typeof data === "string" ? convertDataURIToBinary(data) : data;
    createImageData = (options, key) => ({
      data: standardizeData(options.data),
      fileName: key,
      transformation: {
        pixels: {
          x: Math.round(options.transformation.width),
          y: Math.round(options.transformation.height)
        },
        emus: {
          x: Math.round(options.transformation.width * 9525),
          y: Math.round(options.transformation.height * 9525)
        },
        flip: options.transformation.flip,
        rotation: options.transformation.rotation ? options.transformation.rotation * 6e4 : void 0
      }
    });
    ImageRun = class extends Run {
      constructor(options) {
        super({});
        __publicField(this, "imageData");
        const hash2 = hashedId(options.data);
        const key = `${hash2}.${options.type}`;
        this.imageData = options.type === "svg" ? __spreadProps(__spreadValues({
          type: options.type
        }, createImageData(options, key)), {
          fallback: __spreadValues({
            type: options.fallback.type
          }, createImageData(
            __spreadProps(__spreadValues({}, options.fallback), {
              transformation: options.transformation
            }),
            `${hashedId(options.fallback.data)}.${options.fallback.type}`
          ))
        }) : __spreadValues({
          type: options.type
        }, createImageData(options, key));
        const drawing = new Drawing(this.imageData, {
          floating: options.floating,
          docProperties: options.altText,
          outline: options.outline
        });
        this.root.push(drawing);
      }
      prepForXml(context) {
        context.file.Media.addImage(this.imageData.fileName, this.imageData);
        if (this.imageData.type === "svg") {
          context.file.Media.addImage(this.imageData.fallback.fileName, this.imageData.fallback);
        }
        return super.prepForXml(context);
      }
    };
    SequentialIdentifierInstruction = class extends XmlComponent {
      constructor(identifier) {
        super("w:instrText");
        this.root.push(new TextAttributes({ space: SpaceType.PRESERVE }));
        this.root.push(`SEQ ${identifier}`);
      }
    };
    SequentialIdentifier = class extends Run {
      constructor(identifier) {
        super({});
        this.root.push(new Begin(true));
        this.root.push(new SequentialIdentifierInstruction(identifier));
        this.root.push(new Separate());
        this.root.push(new End());
      }
    };
    FldSimpleAttrs = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", { instr: "w:instr" });
      }
    };
    SimpleField = class extends XmlComponent {
      constructor(instruction, cachedValue) {
        super("w:fldSimple");
        this.root.push(new FldSimpleAttrs({ instr: instruction }));
        if (cachedValue !== void 0) {
          this.root.push(new TextRun(cachedValue));
        }
      }
    };
    RelationshipsAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", {
          xmlns: "xmlns"
        });
      }
    };
    RelationshipAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", {
          id: "Id",
          type: "Type",
          target: "Target",
          targetMode: "TargetMode"
        });
      }
    };
    TargetModeType = {
      EXTERNAL: "External"
    };
    Relationship = class extends XmlComponent {
      constructor(id, type2, target, targetMode) {
        super("Relationship");
        this.root.push(
          new RelationshipAttributes({
            id,
            type: type2,
            target,
            targetMode
          })
        );
      }
    };
    Relationships = class extends XmlComponent {
      constructor() {
        super("Relationships");
        this.root.push(
          new RelationshipsAttributes({
            xmlns: "http://schemas.openxmlformats.org/package/2006/relationships"
          })
        );
      }
      createRelationship(id, type2, target, targetMode) {
        const relationship = new Relationship(`rId${id}`, type2, target, targetMode);
        this.root.push(relationship);
        return relationship;
      }
      get RelationshipCount() {
        return this.root.length - 1;
      }
    };
    CommentAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", { id: "w:id", initials: "w:initials", author: "w:author", date: "w:date" });
      }
    };
    RootCommentsAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", {
          "xmlns:cx": "xmlns:cx",
          "xmlns:cx1": "xmlns:cx1",
          "xmlns:cx2": "xmlns:cx2",
          "xmlns:cx3": "xmlns:cx3",
          "xmlns:cx4": "xmlns:cx4",
          "xmlns:cx5": "xmlns:cx5",
          "xmlns:cx6": "xmlns:cx6",
          "xmlns:cx7": "xmlns:cx7",
          "xmlns:cx8": "xmlns:cx8",
          "xmlns:mc": "xmlns:mc",
          "xmlns:aink": "xmlns:aink",
          "xmlns:am3d": "xmlns:am3d",
          "xmlns:o": "xmlns:o",
          "xmlns:r": "xmlns:r",
          "xmlns:m": "xmlns:m",
          "xmlns:v": "xmlns:v",
          "xmlns:wp14": "xmlns:wp14",
          "xmlns:wp": "xmlns:wp",
          "xmlns:w10": "xmlns:w10",
          "xmlns:w": "xmlns:w",
          "xmlns:w14": "xmlns:w14",
          "xmlns:w15": "xmlns:w15",
          "xmlns:w16cex": "xmlns:w16cex",
          "xmlns:w16cid": "xmlns:w16cid",
          "xmlns:w16": "xmlns:w16",
          "xmlns:w16sdtdh": "xmlns:w16sdtdh",
          "xmlns:w16se": "xmlns:w16se",
          "xmlns:wpg": "xmlns:wpg",
          "xmlns:wpi": "xmlns:wpi",
          "xmlns:wne": "xmlns:wne",
          "xmlns:wps": "xmlns:wps"
        });
      }
    };
    Comment = class extends XmlComponent {
      constructor({ id, initials, author, date = /* @__PURE__ */ new Date(), children }) {
        super("w:comment");
        this.root.push(
          new CommentAttributes({
            id,
            initials,
            author,
            date: date.toISOString()
          })
        );
        for (const child of children) {
          this.root.push(child);
        }
      }
    };
    Comments = class extends XmlComponent {
      constructor({ children }) {
        super("w:comments");
        __publicField(this, "relationships");
        this.root.push(
          new RootCommentsAttributes({
            "xmlns:cx": "http://schemas.microsoft.com/office/drawing/2014/chartex",
            "xmlns:cx1": "http://schemas.microsoft.com/office/drawing/2015/9/8/chartex",
            "xmlns:cx2": "http://schemas.microsoft.com/office/drawing/2015/10/21/chartex",
            "xmlns:cx3": "http://schemas.microsoft.com/office/drawing/2016/5/9/chartex",
            "xmlns:cx4": "http://schemas.microsoft.com/office/drawing/2016/5/10/chartex",
            "xmlns:cx5": "http://schemas.microsoft.com/office/drawing/2016/5/11/chartex",
            "xmlns:cx6": "http://schemas.microsoft.com/office/drawing/2016/5/12/chartex",
            "xmlns:cx7": "http://schemas.microsoft.com/office/drawing/2016/5/13/chartex",
            "xmlns:cx8": "http://schemas.microsoft.com/office/drawing/2016/5/14/chartex",
            "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006",
            "xmlns:aink": "http://schemas.microsoft.com/office/drawing/2016/ink",
            "xmlns:am3d": "http://schemas.microsoft.com/office/drawing/2017/model3d",
            "xmlns:o": "urn:schemas-microsoft-com:office:office",
            "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
            "xmlns:m": "http://schemas.openxmlformats.org/officeDocument/2006/math",
            "xmlns:v": "urn:schemas-microsoft-com:vml",
            "xmlns:wp14": "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
            "xmlns:wp": "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
            "xmlns:w10": "urn:schemas-microsoft-com:office:word",
            "xmlns:w": "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
            "xmlns:w14": "http://schemas.microsoft.com/office/word/2010/wordml",
            "xmlns:w15": "http://schemas.microsoft.com/office/word/2012/wordml",
            "xmlns:w16cex": "http://schemas.microsoft.com/office/word/2018/wordml/cex",
            "xmlns:w16cid": "http://schemas.microsoft.com/office/word/2016/wordml/cid",
            "xmlns:w16": "http://schemas.microsoft.com/office/word/2018/wordml",
            "xmlns:w16sdtdh": "http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash",
            "xmlns:w16se": "http://schemas.microsoft.com/office/word/2015/wordml/symex",
            "xmlns:wpg": "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
            "xmlns:wpi": "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
            "xmlns:wne": "http://schemas.microsoft.com/office/word/2006/wordml",
            "xmlns:wps": "http://schemas.microsoft.com/office/word/2010/wordprocessingShape"
          })
        );
        for (const child of children) {
          this.root.push(new Comment(child));
        }
        this.relationships = new Relationships();
      }
      get Relationships() {
        return this.relationships;
      }
    };
    PageBreakBefore = class extends XmlComponent {
      constructor() {
        super("w:pageBreakBefore");
      }
    };
    LineRuleType = {
      AT_LEAST: "atLeast",
      EXACTLY: "exactly",
      EXACT: "exact",
      AUTO: "auto"
    };
    SpacingAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", {
          after: "w:after",
          before: "w:before",
          line: "w:line",
          lineRule: "w:lineRule",
          beforeAutoSpacing: "w:beforeAutospacing",
          afterAutoSpacing: "w:afterAutospacing"
        });
      }
    };
    Spacing = class extends XmlComponent {
      constructor(options) {
        super("w:spacing");
        this.root.push(new SpacingAttributes(options));
      }
    };
    HeadingLevel = {
      HEADING_1: "Heading1",
      HEADING_2: "Heading2",
      HEADING_3: "Heading3",
      HEADING_4: "Heading4",
      HEADING_5: "Heading5",
      HEADING_6: "Heading6",
      TITLE: "Title"
    };
    Style$1 = class Style extends XmlComponent {
      constructor(styleId) {
        super("w:pStyle");
        this.root.push(
          new Attributes({
            val: styleId
          })
        );
      }
    };
    TabStop = class extends XmlComponent {
      constructor(tabDefinitions) {
        super("w:tabs");
        for (const tabDefinition of tabDefinitions) {
          this.root.push(new TabStopItem(tabDefinition));
        }
      }
    };
    TabStopType = {
      LEFT: "left",
      RIGHT: "right",
      CENTER: "center",
      BAR: "bar",
      CLEAR: "clear",
      DECIMAL: "decimal",
      END: "end",
      NUM: "num",
      START: "start"
    };
    TabStopPosition = {
      MAX: 9026
    };
    TabAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", { val: "w:val", pos: "w:pos", leader: "w:leader" });
      }
    };
    TabStopItem = class extends XmlComponent {
      constructor({ type: type2, position, leader }) {
        super("w:tab");
        this.root.push(
          new TabAttributes({
            val: type2,
            pos: position,
            leader
          })
        );
      }
    };
    NumberProperties = class extends XmlComponent {
      constructor(numberId, indentLevel) {
        super("w:numPr");
        this.root.push(new IndentLevel(indentLevel));
        this.root.push(new NumberId(numberId));
      }
    };
    IndentLevel = class extends XmlComponent {
      constructor(level) {
        super("w:ilvl");
        if (level > 9) {
          throw new Error(
            "Level cannot be greater than 9. Read more here: https://answers.microsoft.com/en-us/msoffice/forum/all/does-word-support-more-than-9-list-levels/d130fdcd-1781-446d-8c84-c6c79124e4d7"
          );
        }
        this.root.push(
          new Attributes({
            val: level
          })
        );
      }
    };
    NumberId = class extends XmlComponent {
      constructor(id) {
        super("w:numId");
        this.root.push(
          new Attributes({
            val: typeof id === "string" ? `{${id}}` : id
          })
        );
      }
    };
    FileChild = class extends XmlComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "fileChild", Symbol());
      }
    };
    HyperlinkAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", {
          id: "r:id",
          history: "w:history",
          anchor: "w:anchor"
        });
      }
    };
    ConcreteHyperlink = class extends XmlComponent {
      constructor(children, relationshipId, anchor) {
        super("w:hyperlink");
        __publicField(this, "linkId");
        this.linkId = relationshipId;
        const props = {
          history: 1,
          anchor: anchor ? anchor : void 0,
          id: !anchor ? `rId${this.linkId}` : void 0
        };
        const attributes = new HyperlinkAttributes(props);
        this.root.push(attributes);
        children.forEach((child) => {
          this.root.push(child);
        });
      }
    };
    InternalHyperlink = class extends ConcreteHyperlink {
      constructor(options) {
        super(options.children, uniqueId(), options.anchor);
      }
    };
    ExternalHyperlink = class extends XmlComponent {
      constructor(options) {
        super("w:externalHyperlink");
        this.options = options;
      }
    };
    BookmarkStartAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", {
          id: "w:id",
          name: "w:name"
        });
      }
    };
    BookmarkEndAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", {
          id: "w:id"
        });
      }
    };
    Bookmark = class {
      constructor(options) {
        __publicField(this, "bookmarkUniqueNumericId", bookmarkUniqueNumericIdGen());
        __publicField(this, "start");
        __publicField(this, "children");
        __publicField(this, "end");
        const linkId = this.bookmarkUniqueNumericId();
        this.start = new BookmarkStart(options.id, linkId);
        this.children = options.children;
        this.end = new BookmarkEnd(linkId);
      }
    };
    BookmarkStart = class extends XmlComponent {
      constructor(id, linkId) {
        super("w:bookmarkStart");
        const attributes = new BookmarkStartAttributes({
          name: id,
          id: linkId
        });
        this.root.push(attributes);
      }
    };
    BookmarkEnd = class extends XmlComponent {
      constructor(linkId) {
        super("w:bookmarkEnd");
        const attributes = new BookmarkEndAttributes({
          id: linkId
        });
        this.root.push(attributes);
      }
    };
    OutlineLevel = class extends XmlComponent {
      constructor(level) {
        super("w:outlineLvl");
        this.level = level;
        this.root.push(
          new Attributes({
            val: level
          })
        );
      }
    };
    VerticalAlignTable = {
      TOP: "top",
      CENTER: "center",
      BOTTOM: "bottom"
    };
    VerticalAlignSection = __spreadProps(__spreadValues({}, VerticalAlignTable), {
      BOTH: "both"
    });
    VerticalAlignAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", {
          verticalAlign: "w:val"
        });
      }
    };
    VerticalAlignElement = class extends XmlComponent {
      constructor(value) {
        super("w:vAlign");
        this.root.push(new VerticalAlignAttributes({ verticalAlign: value }));
      }
    };
    Columns = class extends XmlComponent {
      constructor({ space, count, separate, equalWidth, children }) {
        super("w:cols");
        this.root.push(
          new NextAttributeComponent({
            space: { key: "w:space", value: space === void 0 ? void 0 : twipsMeasureValue(space) },
            count: { key: "w:num", value: count === void 0 ? void 0 : decimalNumber(count) },
            separate: { key: "w:sep", value: separate },
            equalWidth: { key: "w:equalWidth", value: equalWidth }
          })
        );
        if (!equalWidth && children) {
          children.forEach((column) => this.addChildElement(column));
        }
      }
    };
    createDocumentGrid = ({ type: type2, linePitch, charSpace }) => new BuilderElement({
      name: "w:docGrid",
      attributes: {
        type: { key: "w:type", value: type2 },
        linePitch: { key: "w:linePitch", value: decimalNumber(linePitch) },
        charSpace: { key: "w:charSpace", value: charSpace ? decimalNumber(charSpace) : void 0 }
      }
    });
    HeaderFooterReferenceType = {
      /** Specifies that this header or footer shall appear on every page in this section which is not overridden with a specific `even` or `first` page header/footer. In a section with all three types specified, this type shall be used on all odd numbered pages (counting from the `first` page in the section, not the section numbering). */
      DEFAULT: "default",
      /** Specifies that this header or footer shall appear on the first page in this section. The appearance of this header or footer is contingent on the setting of the `titlePg` element (§2.10.6). */
      FIRST: "first",
      /** Specifies that this header or footer shall appear on all even numbered pages in this section (counting from the first page in the section, not the section numbering). The appearance of this header or footer is contingent on the setting of the `evenAndOddHeaders` element (§2.10.1). */
      EVEN: "even"
    };
    FooterReferenceAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", {
          type: "w:type",
          id: "r:id"
        });
      }
    };
    HeaderFooterType = {
      HEADER: "w:headerReference",
      FOOTER: "w:footerReference"
    };
    HeaderFooterReference = class extends XmlComponent {
      constructor(type2, options) {
        super(type2);
        this.root.push(
          new FooterReferenceAttributes({
            type: options.type || HeaderFooterReferenceType.DEFAULT,
            id: `rId${options.id}`
          })
        );
      }
    };
    createLineNumberType = ({ countBy, start, restart, distance }) => new BuilderElement({
      name: "w:lnNumType",
      attributes: {
        countBy: { key: "w:countBy", value: countBy === void 0 ? void 0 : decimalNumber(countBy) },
        start: { key: "w:start", value: start === void 0 ? void 0 : decimalNumber(start) },
        restart: { key: "w:restart", value: restart },
        distance: {
          key: "w:distance",
          value: distance === void 0 ? void 0 : twipsMeasureValue(distance)
        }
      }
    });
    PageBordersAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", {
          display: "w:display",
          offsetFrom: "w:offsetFrom",
          zOrder: "w:zOrder"
        });
      }
    };
    PageBorders = class extends IgnoreIfEmptyXmlComponent {
      constructor(options) {
        super("w:pgBorders");
        if (!options) {
          return this;
        }
        if (options.pageBorders) {
          this.root.push(
            new PageBordersAttributes({
              display: options.pageBorders.display,
              offsetFrom: options.pageBorders.offsetFrom,
              zOrder: options.pageBorders.zOrder
            })
          );
        } else {
          this.root.push(new PageBordersAttributes({}));
        }
        if (options.pageBorderTop) {
          this.root.push(new BorderElement("w:top", options.pageBorderTop));
        }
        if (options.pageBorderLeft) {
          this.root.push(new BorderElement("w:left", options.pageBorderLeft));
        }
        if (options.pageBorderBottom) {
          this.root.push(new BorderElement("w:bottom", options.pageBorderBottom));
        }
        if (options.pageBorderRight) {
          this.root.push(new BorderElement("w:right", options.pageBorderRight));
        }
      }
    };
    PageMargin = class extends XmlComponent {
      constructor(top, right, bottom, left, header, footer, gutter) {
        super("w:pgMar");
        this.root.push(
          new NextAttributeComponent({
            top: { key: "w:top", value: signedTwipsMeasureValue(top) },
            right: { key: "w:right", value: twipsMeasureValue(right) },
            bottom: { key: "w:bottom", value: signedTwipsMeasureValue(bottom) },
            left: { key: "w:left", value: twipsMeasureValue(left) },
            header: { key: "w:header", value: twipsMeasureValue(header) },
            footer: { key: "w:footer", value: twipsMeasureValue(footer) },
            gutter: { key: "w:gutter", value: twipsMeasureValue(gutter) }
          })
        );
      }
    };
    PageNumberTypeAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", {
          start: "w:start",
          formatType: "w:fmt",
          separator: "w:chapSep"
        });
      }
    };
    PageNumberType = class extends XmlComponent {
      constructor({ start, formatType, separator }) {
        super("w:pgNumType");
        this.root.push(
          new PageNumberTypeAttributes({
            start: start === void 0 ? void 0 : decimalNumber(start),
            formatType,
            separator
          })
        );
      }
    };
    PageOrientation = {
      /**
       * ## Portrait Mode
       *
       * Specifies that pages in this section shall be printed in portrait mode.
       */
      PORTRAIT: "portrait",
      /**
       * ## Landscape Mode
       *
       * Specifies that pages in this section shall be printed in landscape mode, which prints the page contents with a 90 degree rotation with respect to the normal page orientation.
       */
      LANDSCAPE: "landscape"
    };
    createPageSize = ({ width, height, orientation, code }) => {
      const widthTwips = twipsMeasureValue(width);
      const heightTwips = twipsMeasureValue(height);
      return new BuilderElement({
        name: "w:pgSz",
        attributes: {
          width: { key: "w:w", value: orientation === PageOrientation.LANDSCAPE ? heightTwips : widthTwips },
          height: { key: "w:h", value: orientation === PageOrientation.LANDSCAPE ? widthTwips : heightTwips },
          orientation: { key: "w:orient", value: orientation },
          code: { key: "w:code", value: code }
        }
      });
    };
    PageTextDirectionAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", { val: "w:val" });
      }
    };
    PageTextDirection = class extends XmlComponent {
      constructor(value) {
        super("w:textDirection");
        this.root.push(
          new PageTextDirectionAttributes({
            val: value
          })
        );
      }
    };
    SectionType = {
      NEXT_PAGE: "nextPage",
      NEXT_COLUMN: "nextColumn",
      CONTINUOUS: "continuous",
      EVEN_PAGE: "evenPage",
      ODD_PAGE: "oddPage"
    };
    SectionTypeAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", {
          val: "w:val"
        });
      }
    };
    Type = class extends XmlComponent {
      constructor(value) {
        super("w:type");
        this.root.push(new SectionTypeAttributes({ val: value }));
      }
    };
    sectionMarginDefaults = {
      TOP: 1440,
      RIGHT: 1440,
      BOTTOM: 1440,
      LEFT: 1440,
      HEADER: 708,
      FOOTER: 708,
      GUTTER: 0
    };
    sectionPageSizeDefaults = {
      WIDTH: 11906,
      HEIGHT: 16838,
      ORIENTATION: PageOrientation.PORTRAIT
    };
    SectionProperties = class extends XmlComponent {
      constructor({
        page: {
          size: {
            width = sectionPageSizeDefaults.WIDTH,
            height = sectionPageSizeDefaults.HEIGHT,
            orientation = sectionPageSizeDefaults.ORIENTATION
          } = {},
          margin: {
            top = sectionMarginDefaults.TOP,
            right = sectionMarginDefaults.RIGHT,
            bottom = sectionMarginDefaults.BOTTOM,
            left = sectionMarginDefaults.LEFT,
            header = sectionMarginDefaults.HEADER,
            footer = sectionMarginDefaults.FOOTER,
            gutter = sectionMarginDefaults.GUTTER
          } = {},
          pageNumbers = {},
          borders,
          textDirection
        } = {},
        grid: { linePitch = 360, charSpace, type: gridType } = {},
        headerWrapperGroup = {},
        footerWrapperGroup = {},
        lineNumbers,
        titlePage,
        verticalAlign,
        column,
        type: type2
      } = {}) {
        super("w:sectPr");
        this.addHeaderFooterGroup(HeaderFooterType.HEADER, headerWrapperGroup);
        this.addHeaderFooterGroup(HeaderFooterType.FOOTER, footerWrapperGroup);
        if (type2) {
          this.root.push(new Type(type2));
        }
        this.root.push(createPageSize({ width, height, orientation }));
        this.root.push(new PageMargin(top, right, bottom, left, header, footer, gutter));
        if (borders) {
          this.root.push(new PageBorders(borders));
        }
        if (lineNumbers) {
          this.root.push(createLineNumberType(lineNumbers));
        }
        this.root.push(new PageNumberType(pageNumbers));
        if (column) {
          this.root.push(new Columns(column));
        }
        if (verticalAlign) {
          this.root.push(new VerticalAlignElement(verticalAlign));
        }
        if (titlePage !== void 0) {
          this.root.push(new OnOffElement("w:titlePg", titlePage));
        }
        if (textDirection) {
          this.root.push(new PageTextDirection(textDirection));
        }
        this.root.push(createDocumentGrid({ linePitch, charSpace, type: gridType }));
      }
      addHeaderFooterGroup(type2, group) {
        if (group.default) {
          this.root.push(
            new HeaderFooterReference(type2, {
              type: HeaderFooterReferenceType.DEFAULT,
              id: group.default.View.ReferenceId
            })
          );
        }
        if (group.first) {
          this.root.push(
            new HeaderFooterReference(type2, {
              type: HeaderFooterReferenceType.FIRST,
              id: group.first.View.ReferenceId
            })
          );
        }
        if (group.even) {
          this.root.push(
            new HeaderFooterReference(type2, {
              type: HeaderFooterReferenceType.EVEN,
              id: group.even.View.ReferenceId
            })
          );
        }
      }
    };
    Body = class extends XmlComponent {
      constructor() {
        super("w:body");
        __publicField(this, "sections", []);
      }
      /**
       * Adds new section properties.
       * Note: Previous section is created in paragraph after the current element, and then new section will be added.
       * The spec says:
       *  - section element should be in the last paragraph of the section
       *  - last section should be direct child of body
       *
       * @param options new section options
       */
      addSection(options) {
        const currentSection = this.sections.pop();
        this.root.push(this.createSectionParagraph(currentSection));
        this.sections.push(new SectionProperties(options));
      }
      prepForXml(context) {
        if (this.sections.length === 1) {
          this.root.splice(0, 1);
          this.root.push(this.sections.pop());
        }
        return super.prepForXml(context);
      }
      push(component) {
        this.root.push(component);
      }
      createSectionParagraph(section) {
        const paragraph = new Paragraph({});
        const properties = new ParagraphProperties({});
        properties.push(section);
        paragraph.addChildElement(properties);
        return paragraph;
      }
    };
    DocumentAttributeNamespaces = {
      wpc: "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas",
      mc: "http://schemas.openxmlformats.org/markup-compatibility/2006",
      o: "urn:schemas-microsoft-com:office:office",
      r: "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
      m: "http://schemas.openxmlformats.org/officeDocument/2006/math",
      v: "urn:schemas-microsoft-com:vml",
      wp14: "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
      wp: "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
      w10: "urn:schemas-microsoft-com:office:word",
      w: "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
      w14: "http://schemas.microsoft.com/office/word/2010/wordml",
      w15: "http://schemas.microsoft.com/office/word/2012/wordml",
      wpg: "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
      wpi: "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
      wne: "http://schemas.microsoft.com/office/word/2006/wordml",
      wps: "http://schemas.microsoft.com/office/word/2010/wordprocessingShape",
      cp: "http://schemas.openxmlformats.org/package/2006/metadata/core-properties",
      dc: "http://purl.org/dc/elements/1.1/",
      dcterms: "http://purl.org/dc/terms/",
      dcmitype: "http://purl.org/dc/dcmitype/",
      xsi: "http://www.w3.org/2001/XMLSchema-instance",
      cx: "http://schemas.microsoft.com/office/drawing/2014/chartex",
      cx1: "http://schemas.microsoft.com/office/drawing/2015/9/8/chartex",
      cx2: "http://schemas.microsoft.com/office/drawing/2015/10/21/chartex",
      cx3: "http://schemas.microsoft.com/office/drawing/2016/5/9/chartex",
      cx4: "http://schemas.microsoft.com/office/drawing/2016/5/10/chartex",
      cx5: "http://schemas.microsoft.com/office/drawing/2016/5/11/chartex",
      cx6: "http://schemas.microsoft.com/office/drawing/2016/5/12/chartex",
      cx7: "http://schemas.microsoft.com/office/drawing/2016/5/13/chartex",
      cx8: "http://schemas.microsoft.com/office/drawing/2016/5/14/chartex",
      aink: "http://schemas.microsoft.com/office/drawing/2016/ink",
      am3d: "http://schemas.microsoft.com/office/drawing/2017/model3d",
      w16cex: "http://schemas.microsoft.com/office/word/2018/wordml/cex",
      w16cid: "http://schemas.microsoft.com/office/word/2016/wordml/cid",
      w16: "http://schemas.microsoft.com/office/word/2018/wordml",
      w16sdtdh: "http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash",
      w16se: "http://schemas.microsoft.com/office/word/2015/wordml/symex"
    };
    DocumentAttributes = class extends XmlAttributeComponent {
      constructor(ns, Ignorable) {
        super(__spreadValues({ Ignorable }, Object.fromEntries(ns.map((n) => [n, DocumentAttributeNamespaces[n]]))));
        __publicField(this, "xmlKeys", __spreadValues({
          Ignorable: "mc:Ignorable"
        }, Object.fromEntries(Object.keys(DocumentAttributeNamespaces).map((key) => [key, `xmlns:${key}`]))));
      }
    };
    DocumentBackgroundAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", {
          color: "w:color",
          themeColor: "w:themeColor",
          themeShade: "w:themeShade",
          themeTint: "w:themeTint"
        });
      }
    };
    DocumentBackground = class extends XmlComponent {
      constructor(options) {
        super("w:background");
        this.root.push(
          new DocumentBackgroundAttributes({
            color: options.color === void 0 ? void 0 : hexColorValue(options.color),
            themeColor: options.themeColor,
            themeShade: options.themeShade === void 0 ? void 0 : uCharHexNumber(options.themeShade),
            themeTint: options.themeTint === void 0 ? void 0 : uCharHexNumber(options.themeTint)
          })
        );
      }
    };
    Document = class extends XmlComponent {
      constructor(options) {
        super("w:document");
        __publicField(this, "body");
        this.root.push(
          new DocumentAttributes(
            [
              "wpc",
              "mc",
              "o",
              "r",
              "m",
              "v",
              "wp14",
              "wp",
              "w10",
              "w",
              "w14",
              "w15",
              "wpg",
              "wpi",
              "wne",
              "wps",
              "cx",
              "cx1",
              "cx2",
              "cx3",
              "cx4",
              "cx5",
              "cx6",
              "cx7",
              "cx8",
              "aink",
              "am3d",
              "w16cex",
              "w16cid",
              "w16",
              "w16sdtdh",
              "w16se"
            ],
            "w14 w15 wp14"
          )
        );
        this.body = new Body();
        if (options.background) {
          this.root.push(new DocumentBackground(options.background));
        }
        this.root.push(this.body);
      }
      add(item) {
        this.body.push(item);
        return this;
      }
      get Body() {
        return this.body;
      }
    };
    DocumentWrapper = class {
      constructor(options) {
        __publicField(this, "document");
        __publicField(this, "relationships");
        this.document = new Document(options);
        this.relationships = new Relationships();
      }
      get View() {
        return this.document;
      }
      get Relationships() {
        return this.relationships;
      }
    };
    WordWrapAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", { val: "w:val" });
      }
    };
    WordWrap = class extends XmlComponent {
      constructor() {
        super("w:wordWrap");
        this.root.push(new WordWrapAttributes({ val: 0 }));
      }
    };
    createFrameProperties = (options) => {
      var _a, _b;
      return new BuilderElement({
        name: "w:framePr",
        attributes: {
          anchorLock: {
            key: "w:anchorLock",
            value: options.anchorLock
          },
          dropCap: {
            key: "w:dropCap",
            value: options.dropCap
          },
          width: {
            key: "w:w",
            value: options.width
          },
          height: {
            key: "w:h",
            value: options.height
          },
          x: {
            key: "w:x",
            value: options.position ? options.position.x : void 0
          },
          y: {
            key: "w:y",
            value: options.position ? options.position.y : void 0
          },
          anchorHorizontal: {
            key: "w:hAnchor",
            value: options.anchor.horizontal
          },
          anchorVertical: {
            key: "w:vAnchor",
            value: options.anchor.vertical
          },
          spaceHorizontal: {
            key: "w:hSpace",
            value: (_a = options.space) == null ? void 0 : _a.horizontal
          },
          spaceVertical: {
            key: "w:vSpace",
            value: (_b = options.space) == null ? void 0 : _b.vertical
          },
          rule: {
            key: "w:hRule",
            value: options.rule
          },
          alignmentX: {
            key: "w:xAlign",
            value: options.alignment ? options.alignment.x : void 0
          },
          alignmentY: {
            key: "w:yAlign",
            value: options.alignment ? options.alignment.y : void 0
          },
          lines: {
            key: "w:lines",
            value: options.lines
          },
          wrap: {
            key: "w:wrap",
            value: options.wrap
          }
        }
      });
    };
    ParagraphProperties = class extends IgnoreIfEmptyXmlComponent {
      constructor(options) {
        var _a, _b;
        super("w:pPr");
        __publicField(this, "numberingReferences", []);
        if (!options) {
          return this;
        }
        if (options.heading) {
          this.push(new Style$1(options.heading));
        }
        if (options.bullet) {
          this.push(new Style$1("ListParagraph"));
        }
        if (options.numbering) {
          if (!options.style && !options.heading) {
            if (!options.numbering.custom) {
              this.push(new Style$1("ListParagraph"));
            }
          }
        }
        if (options.style) {
          this.push(new Style$1(options.style));
        }
        if (options.keepNext !== void 0) {
          this.push(new OnOffElement("w:keepNext", options.keepNext));
        }
        if (options.keepLines !== void 0) {
          this.push(new OnOffElement("w:keepLines", options.keepLines));
        }
        if (options.pageBreakBefore) {
          this.push(new PageBreakBefore());
        }
        if (options.frame) {
          this.push(createFrameProperties(options.frame));
        }
        if (options.widowControl !== void 0) {
          this.push(new OnOffElement("w:widowControl", options.widowControl));
        }
        if (options.bullet) {
          this.push(new NumberProperties(1, options.bullet.level));
        }
        if (options.numbering) {
          this.numberingReferences.push({
            reference: options.numbering.reference,
            instance: (_a = options.numbering.instance) != null ? _a : 0
          });
          this.push(new NumberProperties(`${options.numbering.reference}-${(_b = options.numbering.instance) != null ? _b : 0}`, options.numbering.level));
        } else if (options.numbering === false) {
          this.push(new NumberProperties(0, 0));
        }
        if (options.border) {
          this.push(new Border(options.border));
        }
        if (options.thematicBreak) {
          this.push(new ThematicBreak());
        }
        if (options.shading) {
          this.push(new Shading(options.shading));
        }
        if (options.wordWrap) {
          this.push(new WordWrap());
        }
        if (options.overflowPunctuation) {
          this.push(new OnOffElement("w:overflowPunct", options.overflowPunctuation));
        }
        const tabDefinitions = [
          ...options.rightTabStop !== void 0 ? [{ type: TabStopType.RIGHT, position: options.rightTabStop }] : [],
          ...options.tabStops ? options.tabStops : [],
          ...options.leftTabStop !== void 0 ? [{ type: TabStopType.LEFT, position: options.leftTabStop }] : []
        ];
        if (tabDefinitions.length > 0) {
          this.push(new TabStop(tabDefinitions));
        }
        if (options.bidirectional !== void 0) {
          this.push(new OnOffElement("w:bidi", options.bidirectional));
        }
        if (options.spacing) {
          this.push(new Spacing(options.spacing));
        }
        if (options.indent) {
          this.push(new Indent(options.indent));
        }
        if (options.contextualSpacing !== void 0) {
          this.push(new OnOffElement("w:contextualSpacing", options.contextualSpacing));
        }
        if (options.alignment) {
          this.push(new Alignment(options.alignment));
        }
        if (options.outlineLevel !== void 0) {
          this.push(new OutlineLevel(options.outlineLevel));
        }
        if (options.suppressLineNumbers !== void 0) {
          this.push(new OnOffElement("w:suppressLineNumbers", options.suppressLineNumbers));
        }
        if (options.autoSpaceEastAsianText !== void 0) {
          this.push(new OnOffElement("w:autoSpaceDN", options.autoSpaceEastAsianText));
        }
        if (options.run) {
          this.push(new RunProperties(options.run));
        }
      }
      push(item) {
        this.root.push(item);
      }
      prepForXml(context) {
        if (context.viewWrapper instanceof DocumentWrapper) {
          for (const reference of this.numberingReferences) {
            context.file.Numbering.createConcreteNumberingInstance(reference.reference, reference.instance);
          }
        }
        return super.prepForXml(context);
      }
    };
    Paragraph = class extends FileChild {
      constructor(options) {
        super("w:p");
        __publicField(this, "properties");
        if (typeof options === "string") {
          this.properties = new ParagraphProperties({});
          this.root.push(this.properties);
          this.root.push(new TextRun(options));
          return this;
        }
        this.properties = new ParagraphProperties(options);
        this.root.push(this.properties);
        if (options.text) {
          this.root.push(new TextRun(options.text));
        }
        if (options.children) {
          for (const child of options.children) {
            if (child instanceof Bookmark) {
              this.root.push(child.start);
              for (const textRun of child.children) {
                this.root.push(textRun);
              }
              this.root.push(child.end);
              continue;
            }
            this.root.push(child);
          }
        }
      }
      prepForXml(context) {
        for (const element of this.root) {
          if (element instanceof ExternalHyperlink) {
            const index = this.root.indexOf(element);
            const concreteHyperlink = new ConcreteHyperlink(element.options.children, uniqueId());
            context.viewWrapper.Relationships.createRelationship(
              concreteHyperlink.linkId,
              "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink",
              element.options.link,
              TargetModeType.EXTERNAL
            );
            this.root[index] = concreteHyperlink;
          }
        }
        return super.prepForXml(context);
      }
      addRunToFront(run) {
        this.root.splice(1, 0, run);
        return this;
      }
    };
    Math$1 = class Math2 extends XmlComponent {
      constructor(options) {
        super("m:oMath");
        for (const child of options.children) {
          this.root.push(child);
        }
      }
    };
    MathText = class extends XmlComponent {
      constructor(text) {
        super("m:t");
        this.root.push(text);
      }
    };
    MathRun = class extends XmlComponent {
      constructor(text) {
        super("m:r");
        this.root.push(new MathText(text));
      }
    };
    TableGrid = class extends XmlComponent {
      constructor(widths) {
        super("w:tblGrid");
        for (const width of widths) {
          this.root.push(new GridCol(width));
        }
      }
    };
    GridCol = class extends XmlComponent {
      constructor(width) {
        super("w:gridCol");
        if (width !== void 0) {
          this.root.push(
            new NextAttributeComponent({
              width: { key: "w:w", value: twipsMeasureValue(width) }
            })
          );
        }
      }
    };
    TableCellMarginElementType = {
      TABLE: "w:tblCellMar",
      TABLE_CELL: "w:tcMar"
    };
    TableCellMargin = class extends IgnoreIfEmptyXmlComponent {
      constructor(type2, { marginUnitType = WidthType.DXA, top, left, bottom, right }) {
        super(type2);
        if (top !== void 0) {
          this.root.push(new TableWidthElement("w:top", { type: marginUnitType, size: top }));
        }
        if (left !== void 0) {
          this.root.push(new TableWidthElement("w:left", { type: marginUnitType, size: left }));
        }
        if (bottom !== void 0) {
          this.root.push(new TableWidthElement("w:bottom", { type: marginUnitType, size: bottom }));
        }
        if (right !== void 0) {
          this.root.push(new TableWidthElement("w:right", { type: marginUnitType, size: right }));
        }
      }
    };
    WidthType = {
      /** Auto. */
      AUTO: "auto",
      /** Value is in twentieths of a point */
      DXA: "dxa",
      /** No (empty) value. */
      NIL: "nil",
      /** Value is in percentage. */
      PERCENTAGE: "pct"
    };
    TableWidthElement = class extends XmlComponent {
      constructor(name, { type: type2 = WidthType.AUTO, size }) {
        super(name);
        let tableWidthValue = size;
        if (type2 === WidthType.PERCENTAGE && typeof size === "number") {
          tableWidthValue = `${size}%`;
        }
        this.root.push(
          new NextAttributeComponent({
            type: { key: "w:type", value: type2 },
            size: { key: "w:w", value: measurementOrPercentValue(tableWidthValue) }
          })
        );
      }
    };
    TableCellBorders = class extends IgnoreIfEmptyXmlComponent {
      constructor(options) {
        super("w:tcBorders");
        if (options.top) {
          this.root.push(new BorderElement("w:top", options.top));
        }
        if (options.start) {
          this.root.push(new BorderElement("w:start", options.start));
        }
        if (options.left) {
          this.root.push(new BorderElement("w:left", options.left));
        }
        if (options.bottom) {
          this.root.push(new BorderElement("w:bottom", options.bottom));
        }
        if (options.end) {
          this.root.push(new BorderElement("w:end", options.end));
        }
        if (options.right) {
          this.root.push(new BorderElement("w:right", options.right));
        }
      }
    };
    GridSpanAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", { val: "w:val" });
      }
    };
    GridSpan = class extends XmlComponent {
      constructor(value) {
        super("w:gridSpan");
        this.root.push(
          new GridSpanAttributes({
            val: decimalNumber(value)
          })
        );
      }
    };
    VerticalMergeType = {
      /**
       * Cell that is merged with upper one.
       */
      CONTINUE: "continue",
      /**
       * Cell that is starting the vertical merge.
       */
      RESTART: "restart"
    };
    VerticalMergeAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", { val: "w:val" });
      }
    };
    VerticalMerge = class extends XmlComponent {
      constructor(value) {
        super("w:vMerge");
        this.root.push(
          new VerticalMergeAttributes({
            val: value
          })
        );
      }
    };
    TDirectionAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", { val: "w:val" });
      }
    };
    TDirection = class extends XmlComponent {
      constructor(value) {
        super("w:textDirection");
        this.root.push(
          new TDirectionAttributes({
            val: value
          })
        );
      }
    };
    TableCellProperties = class extends IgnoreIfEmptyXmlComponent {
      constructor(options) {
        super("w:tcPr");
        if (options.width) {
          this.root.push(new TableWidthElement("w:tcW", options.width));
        }
        if (options.columnSpan) {
          this.root.push(new GridSpan(options.columnSpan));
        }
        if (options.verticalMerge) {
          this.root.push(new VerticalMerge(options.verticalMerge));
        } else if (options.rowSpan && options.rowSpan > 1) {
          this.root.push(new VerticalMerge(VerticalMergeType.RESTART));
        }
        if (options.borders) {
          this.root.push(new TableCellBorders(options.borders));
        }
        if (options.shading) {
          this.root.push(new Shading(options.shading));
        }
        if (options.margins) {
          this.root.push(new TableCellMargin(TableCellMarginElementType.TABLE_CELL, options.margins));
        }
        if (options.textDirection) {
          this.root.push(new TDirection(options.textDirection));
        }
        if (options.verticalAlign) {
          this.root.push(new VerticalAlignElement(options.verticalAlign));
        }
      }
    };
    TableCell = class extends XmlComponent {
      constructor(options) {
        super("w:tc");
        this.options = options;
        this.root.push(new TableCellProperties(options));
        for (const child of options.children) {
          this.root.push(child);
        }
      }
      prepForXml(context) {
        if (!(this.root[this.root.length - 1] instanceof Paragraph)) {
          this.root.push(new Paragraph({}));
        }
        return super.prepForXml(context);
      }
    };
    NONE_BORDER = {
      style: BorderStyle.NONE,
      size: 0,
      color: "auto"
    };
    DEFAULT_BORDER = {
      style: BorderStyle.SINGLE,
      size: 4,
      color: "auto"
    };
    TableBorders = class extends XmlComponent {
      constructor(options) {
        super("w:tblBorders");
        if (options.top) {
          this.root.push(new BorderElement("w:top", options.top));
        } else {
          this.root.push(new BorderElement("w:top", DEFAULT_BORDER));
        }
        if (options.left) {
          this.root.push(new BorderElement("w:left", options.left));
        } else {
          this.root.push(new BorderElement("w:left", DEFAULT_BORDER));
        }
        if (options.bottom) {
          this.root.push(new BorderElement("w:bottom", options.bottom));
        } else {
          this.root.push(new BorderElement("w:bottom", DEFAULT_BORDER));
        }
        if (options.right) {
          this.root.push(new BorderElement("w:right", options.right));
        } else {
          this.root.push(new BorderElement("w:right", DEFAULT_BORDER));
        }
        if (options.insideHorizontal) {
          this.root.push(new BorderElement("w:insideH", options.insideHorizontal));
        } else {
          this.root.push(new BorderElement("w:insideH", DEFAULT_BORDER));
        }
        if (options.insideVertical) {
          this.root.push(new BorderElement("w:insideV", options.insideVertical));
        } else {
          this.root.push(new BorderElement("w:insideV", DEFAULT_BORDER));
        }
      }
    };
    __publicField(TableBorders, "NONE", {
      top: NONE_BORDER,
      bottom: NONE_BORDER,
      left: NONE_BORDER,
      right: NONE_BORDER,
      insideHorizontal: NONE_BORDER,
      insideVertical: NONE_BORDER
    });
    TableFloatProperties = class extends XmlComponent {
      constructor({
        horizontalAnchor,
        verticalAnchor,
        absoluteHorizontalPosition,
        relativeHorizontalPosition,
        absoluteVerticalPosition,
        relativeVerticalPosition,
        bottomFromText,
        topFromText,
        leftFromText,
        rightFromText,
        overlap
      }) {
        super("w:tblpPr");
        this.root.push(
          new NextAttributeComponent({
            leftFromText: {
              key: "w:leftFromText",
              value: leftFromText === void 0 ? void 0 : twipsMeasureValue(leftFromText)
            },
            rightFromText: {
              key: "w:rightFromText",
              value: rightFromText === void 0 ? void 0 : twipsMeasureValue(rightFromText)
            },
            topFromText: {
              key: "w:topFromText",
              value: topFromText === void 0 ? void 0 : twipsMeasureValue(topFromText)
            },
            bottomFromText: {
              key: "w:bottomFromText",
              value: bottomFromText === void 0 ? void 0 : twipsMeasureValue(bottomFromText)
            },
            absoluteHorizontalPosition: {
              key: "w:tblpX",
              value: absoluteHorizontalPosition === void 0 ? void 0 : signedTwipsMeasureValue(absoluteHorizontalPosition)
            },
            absoluteVerticalPosition: {
              key: "w:tblpY",
              value: absoluteVerticalPosition === void 0 ? void 0 : signedTwipsMeasureValue(absoluteVerticalPosition)
            },
            horizontalAnchor: {
              key: "w:horzAnchor",
              value: horizontalAnchor === void 0 ? void 0 : horizontalAnchor
            },
            relativeHorizontalPosition: {
              key: "w:tblpXSpec",
              value: relativeHorizontalPosition
            },
            relativeVerticalPosition: {
              key: "w:tblpYSpec",
              value: relativeVerticalPosition
            },
            verticalAnchor: {
              key: "w:vertAnchor",
              value: verticalAnchor
            }
          })
        );
        if (overlap) {
          this.root.push(new StringEnumValueElement("w:tblOverlap", overlap));
        }
      }
    };
    TableLayoutAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", { type: "w:type" });
      }
    };
    TableLayout = class extends XmlComponent {
      constructor(type2) {
        super("w:tblLayout");
        this.root.push(new TableLayoutAttributes({ type: type2 }));
      }
    };
    CellSpacingType = {
      /** Value is in twentieths of a point */
      DXA: "dxa"
    };
    TableCellSpacingElement = class extends XmlComponent {
      constructor({ type: type2 = CellSpacingType.DXA, value }) {
        super("w:tblCellSpacing");
        this.root.push(
          new NextAttributeComponent({
            type: { key: "w:type", value: type2 },
            value: { key: "w:w", value: measurementOrPercentValue(value) }
          })
        );
      }
    };
    TableProperties = class extends IgnoreIfEmptyXmlComponent {
      constructor(options) {
        super("w:tblPr");
        if (options.style) {
          this.root.push(new StringValueElement("w:tblStyle", options.style));
        }
        if (options.float) {
          this.root.push(new TableFloatProperties(options.float));
        }
        if (options.visuallyRightToLeft !== void 0) {
          this.root.push(new OnOffElement("w:bidiVisual", options.visuallyRightToLeft));
        }
        if (options.width) {
          this.root.push(new TableWidthElement("w:tblW", options.width));
        }
        if (options.alignment) {
          this.root.push(new Alignment(options.alignment));
        }
        if (options.indent) {
          this.root.push(new TableWidthElement("w:tblInd", options.indent));
        }
        if (options.borders) {
          this.root.push(new TableBorders(options.borders));
        }
        if (options.shading) {
          this.root.push(new Shading(options.shading));
        }
        if (options.layout) {
          this.root.push(new TableLayout(options.layout));
        }
        if (options.cellMargin) {
          this.root.push(new TableCellMargin(TableCellMarginElementType.TABLE, options.cellMargin));
        }
        if (options.cellSpacing) {
          this.root.push(new TableCellSpacingElement(options.cellSpacing));
        }
      }
    };
    Table = class extends FileChild {
      constructor({
        rows,
        width,
        // eslint-disable-next-line functional/immutable-data
        columnWidths = Array(Math.max(...rows.map((row) => row.CellCount))).fill(100),
        margins,
        indent,
        float,
        layout,
        style,
        borders,
        alignment,
        visuallyRightToLeft,
        cellSpacing
      }) {
        super("w:tbl");
        this.root.push(
          new TableProperties({
            borders: borders != null ? borders : {},
            width: width != null ? width : { size: 100 },
            indent,
            float,
            layout,
            style,
            alignment,
            cellMargin: margins,
            visuallyRightToLeft,
            cellSpacing
          })
        );
        this.root.push(new TableGrid(columnWidths));
        for (const row of rows) {
          this.root.push(row);
        }
        rows.forEach((row, rowIndex) => {
          if (rowIndex === rows.length - 1) {
            return;
          }
          let columnIndex = 0;
          row.cells.forEach((cell) => {
            if (cell.options.rowSpan && cell.options.rowSpan > 1) {
              const continueCell = new TableCell({
                // the inserted CONTINUE cell has rowSpan, and will be handled when process the next row
                rowSpan: cell.options.rowSpan - 1,
                columnSpan: cell.options.columnSpan,
                borders: cell.options.borders,
                children: [],
                verticalMerge: VerticalMergeType.CONTINUE
              });
              rows[rowIndex + 1].addCellToColumnIndex(continueCell, columnIndex);
            }
            columnIndex += cell.options.columnSpan || 1;
          });
        });
      }
    };
    TableRowHeightAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", { value: "w:val", rule: "w:hRule" });
      }
    };
    TableRowHeight = class extends XmlComponent {
      constructor(value, rule) {
        super("w:trHeight");
        this.root.push(
          new TableRowHeightAttributes({
            value: twipsMeasureValue(value),
            rule
          })
        );
      }
    };
    TableRowProperties = class extends IgnoreIfEmptyXmlComponent {
      constructor(options) {
        super("w:trPr");
        if (options.cantSplit !== void 0) {
          this.root.push(new OnOffElement("w:cantSplit", options.cantSplit));
        }
        if (options.tableHeader !== void 0) {
          this.root.push(new OnOffElement("w:tblHeader", options.tableHeader));
        }
        if (options.height) {
          this.root.push(new TableRowHeight(options.height.value, options.height.rule));
        }
        if (options.cellSpacing) {
          this.root.push(new TableCellSpacingElement(options.cellSpacing));
        }
      }
    };
    TableRow = class extends XmlComponent {
      constructor(options) {
        super("w:tr");
        this.options = options;
        this.root.push(new TableRowProperties(options));
        for (const child of options.children) {
          this.root.push(child);
        }
      }
      get CellCount() {
        return this.options.children.length;
      }
      get cells() {
        return this.root.filter((xmlComponent) => xmlComponent instanceof TableCell);
      }
      addCellToIndex(cell, index) {
        this.root.splice(index + 1, 0, cell);
      }
      addCellToColumnIndex(cell, columnIndex) {
        const rootIndex = this.columnIndexToRootIndex(columnIndex, true);
        this.addCellToIndex(cell, rootIndex - 1);
      }
      rootIndexToColumnIndex(rootIndex) {
        if (rootIndex < 1 || rootIndex >= this.root.length) {
          throw new Error(`cell 'rootIndex' should between 1 to ${this.root.length - 1}`);
        }
        let colIdx = 0;
        for (let rootIdx = 1; rootIdx < rootIndex; rootIdx++) {
          const cell = this.root[rootIdx];
          colIdx += cell.options.columnSpan || 1;
        }
        return colIdx;
      }
      columnIndexToRootIndex(columnIndex, allowEndNewCell = false) {
        if (columnIndex < 0) {
          throw new Error(`cell 'columnIndex' should not less than zero`);
        }
        let colIdx = 0;
        let rootIdx = 1;
        while (colIdx <= columnIndex) {
          if (rootIdx >= this.root.length) {
            if (allowEndNewCell) {
              return this.root.length;
            } else {
              throw new Error(`cell 'columnIndex' should not great than ${colIdx - 1}`);
            }
          }
          const cell = this.root[rootIdx];
          rootIdx += 1;
          colIdx += cell && cell.options.columnSpan || 1;
        }
        return rootIdx - 1;
      }
    };
    AppPropertiesAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", {
          xmlns: "xmlns",
          vt: "xmlns:vt"
        });
      }
    };
    AppProperties = class extends XmlComponent {
      constructor() {
        super("Properties");
        this.root.push(
          new AppPropertiesAttributes({
            xmlns: "http://schemas.openxmlformats.org/officeDocument/2006/extended-properties",
            vt: "http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes"
          })
        );
      }
    };
    ContentTypeAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", {
          xmlns: "xmlns"
        });
      }
    };
    DefaultAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", {
          contentType: "ContentType",
          extension: "Extension"
        });
      }
    };
    Default = class extends XmlComponent {
      constructor(contentType, extension) {
        super("Default");
        this.root.push(
          new DefaultAttributes({
            contentType,
            extension
          })
        );
      }
    };
    OverrideAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", {
          contentType: "ContentType",
          partName: "PartName"
        });
      }
    };
    Override = class extends XmlComponent {
      constructor(contentType, partName) {
        super("Override");
        this.root.push(
          new OverrideAttributes({
            contentType,
            partName
          })
        );
      }
    };
    ContentTypes = class extends XmlComponent {
      constructor() {
        super("Types");
        this.root.push(
          new ContentTypeAttributes({
            xmlns: "http://schemas.openxmlformats.org/package/2006/content-types"
          })
        );
        this.root.push(new Default("image/png", "png"));
        this.root.push(new Default("image/jpeg", "jpeg"));
        this.root.push(new Default("image/jpeg", "jpg"));
        this.root.push(new Default("image/bmp", "bmp"));
        this.root.push(new Default("image/gif", "gif"));
        this.root.push(new Default("image/svg+xml", "svg"));
        this.root.push(new Default("application/vnd.openxmlformats-package.relationships+xml", "rels"));
        this.root.push(new Default("application/xml", "xml"));
        this.root.push(new Default("application/vnd.openxmlformats-officedocument.obfuscatedFont", "odttf"));
        this.root.push(
          new Override("application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml", "/word/document.xml")
        );
        this.root.push(new Override("application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml", "/word/styles.xml"));
        this.root.push(new Override("application/vnd.openxmlformats-package.core-properties+xml", "/docProps/core.xml"));
        this.root.push(new Override("application/vnd.openxmlformats-officedocument.custom-properties+xml", "/docProps/custom.xml"));
        this.root.push(new Override("application/vnd.openxmlformats-officedocument.extended-properties+xml", "/docProps/app.xml"));
        this.root.push(new Override("application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml", "/word/numbering.xml"));
        this.root.push(new Override("application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml", "/word/footnotes.xml"));
        this.root.push(new Override("application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml", "/word/settings.xml"));
        this.root.push(new Override("application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml", "/word/comments.xml"));
        this.root.push(new Override("application/vnd.openxmlformats-officedocument.wordprocessingml.fontTable+xml", "/word/fontTable.xml"));
      }
      addFooter(index) {
        this.root.push(
          new Override("application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml", `/word/footer${index}.xml`)
        );
      }
      addHeader(index) {
        this.root.push(
          new Override("application/vnd.openxmlformats-officedocument.wordprocessingml.header+xml", `/word/header${index}.xml`)
        );
      }
    };
    CoreProperties = class extends XmlComponent {
      constructor(options) {
        super("cp:coreProperties");
        this.root.push(new DocumentAttributes(["cp", "dc", "dcterms", "dcmitype", "xsi"]));
        if (options.title) {
          this.root.push(new StringContainer("dc:title", options.title));
        }
        if (options.subject) {
          this.root.push(new StringContainer("dc:subject", options.subject));
        }
        if (options.creator) {
          this.root.push(new StringContainer("dc:creator", options.creator));
        }
        if (options.keywords) {
          this.root.push(new StringContainer("cp:keywords", options.keywords));
        }
        if (options.description) {
          this.root.push(new StringContainer("dc:description", options.description));
        }
        if (options.lastModifiedBy) {
          this.root.push(new StringContainer("cp:lastModifiedBy", options.lastModifiedBy));
        }
        if (options.revision) {
          this.root.push(new StringContainer("cp:revision", String(options.revision)));
        }
        this.root.push(new TimestampElement("dcterms:created"));
        this.root.push(new TimestampElement("dcterms:modified"));
      }
    };
    TimestampElementProperties = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", { type: "xsi:type" });
      }
    };
    TimestampElement = class extends XmlComponent {
      constructor(name) {
        super(name);
        this.root.push(
          new TimestampElementProperties({
            type: "dcterms:W3CDTF"
          })
        );
        this.root.push(dateTimeValue(/* @__PURE__ */ new Date()));
      }
    };
    CustomPropertiesAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", {
          xmlns: "xmlns",
          vt: "xmlns:vt"
        });
      }
    };
    CustomPropertyAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", {
          fmtid: "fmtid",
          pid: "pid",
          name: "name"
        });
      }
    };
    CustomProperty = class extends XmlComponent {
      constructor(id, properties) {
        super("property");
        this.root.push(
          new CustomPropertyAttributes({
            fmtid: "{D5CDD505-2E9C-101B-9397-08002B2CF9AE}",
            pid: id.toString(),
            name: properties.name
          })
        );
        this.root.push(new CustomPropertyValue(properties.value));
      }
    };
    CustomPropertyValue = class extends XmlComponent {
      constructor(value) {
        super("vt:lpwstr");
        this.root.push(value);
      }
    };
    CustomProperties = class extends XmlComponent {
      constructor(properties) {
        super("Properties");
        __publicField(this, "nextId");
        __publicField(this, "properties", []);
        this.root.push(
          new CustomPropertiesAttributes({
            xmlns: "http://schemas.openxmlformats.org/officeDocument/2006/custom-properties",
            vt: "http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes"
          })
        );
        this.nextId = 2;
        for (const property of properties) {
          this.addCustomProperty(property);
        }
      }
      prepForXml(context) {
        this.properties.forEach((x) => this.root.push(x));
        return super.prepForXml(context);
      }
      addCustomProperty(property) {
        this.properties.push(new CustomProperty(this.nextId++, property));
      }
    };
    createFontRelationship = ({ id, fontKey, subsetted }, name) => new BuilderElement({
      name,
      attributes: __spreadValues({
        id: { key: "r:id", value: id }
      }, fontKey ? { fontKey: { key: "w:fontKey", value: `{${fontKey}}` } } : {}),
      children: [...subsetted ? [new OnOffElement("w:subsetted", subsetted)] : []]
    });
    createFont = ({
      name,
      altName,
      panose1,
      charset,
      family,
      notTrueType,
      pitch,
      sig,
      embedRegular,
      embedBold,
      embedItalic,
      embedBoldItalic
    }) => (
      // http://www.datypic.com/sc/ooxml/e-w_font-1.html
      new BuilderElement({
        name: "w:font",
        attributes: {
          name: { key: "w:name", value: name }
        },
        children: [
          // http://www.datypic.com/sc/ooxml/e-w_altName-1.html
          ...altName ? [createStringElement("w:altName", altName)] : [],
          // http://www.datypic.com/sc/ooxml/e-w_panose1-1.html
          ...panose1 ? [createStringElement("w:panose1", panose1)] : [],
          // http://www.datypic.com/sc/ooxml/e-w_charset-1.html
          ...charset ? [createStringElement("w:charset", charset)] : [],
          // http://www.datypic.com/sc/ooxml/e-w_family-1.html
          ...[createStringElement("w:family", family)],
          // http://www.datypic.com/sc/ooxml/e-w_notTrueType-1.html
          ...notTrueType ? [new OnOffElement("w:notTrueType", notTrueType)] : [],
          ...[createStringElement("w:pitch", pitch)],
          // http://www.datypic.com/sc/ooxml/e-w_sig-1.html
          ...sig ? [
            new BuilderElement({
              name: "w:sig",
              attributes: {
                usb0: { key: "w:usb0", value: sig.usb0 },
                usb1: { key: "w:usb1", value: sig.usb1 },
                usb2: { key: "w:usb2", value: sig.usb2 },
                usb3: { key: "w:usb3", value: sig.usb3 },
                csb0: { key: "w:csb0", value: sig.csb0 },
                csb1: { key: "w:csb1", value: sig.csb1 }
              }
            })
          ] : [],
          // http://www.datypic.com/sc/ooxml/e-w_embedRegular-1.html
          ...embedRegular ? [createFontRelationship(embedRegular, "w:embedRegular")] : [],
          // http://www.datypic.com/sc/ooxml/e-w_embedBold-1.html
          ...embedBold ? [createFontRelationship(embedBold, "w:embedBold")] : [],
          // http://www.datypic.com/sc/ooxml/e-w_embedItalic-1.html
          ...embedItalic ? [createFontRelationship(embedItalic, "w:embedItalic")] : [],
          // http://www.datypic.com/sc/ooxml/e-w_embedBoldItalic-1.html
          ...embedBoldItalic ? [createFontRelationship(embedBoldItalic, "w:embedBoldItalic")] : []
        ]
      })
    );
    createRegularFont = ({
      name,
      index,
      fontKey,
      characterSet
    }) => createFont({
      name,
      sig: {
        usb0: "E0002AFF",
        usb1: "C000247B",
        usb2: "00000009",
        usb3: "00000000",
        csb0: "000001FF",
        csb1: "00000000"
      },
      charset: characterSet,
      family: "auto",
      pitch: "variable",
      embedRegular: {
        fontKey,
        id: `rId${index}`
      }
    });
    createFontTable = (fonts) => (
      // https://c-rex.net/projects/samples/ooxml/e1/Part4/OOXML_P4_DOCX_Font_topic_ID0ERNCU.html
      // http://www.datypic.com/sc/ooxml/e-w_fonts.html
      new BuilderElement({
        name: "w:fonts",
        attributes: {
          mc: { key: "xmlns:mc", value: "http://schemas.openxmlformats.org/markup-compatibility/2006" },
          r: { key: "xmlns:r", value: "http://schemas.openxmlformats.org/officeDocument/2006/relationships" },
          w: { key: "xmlns:w", value: "http://schemas.openxmlformats.org/wordprocessingml/2006/main" },
          w14: { key: "xmlns:w14", value: "http://schemas.microsoft.com/office/word/2010/wordml" },
          w15: { key: "xmlns:w15", value: "http://schemas.microsoft.com/office/word/2012/wordml" },
          w16cex: { key: "xmlns:w16cex", value: "http://schemas.microsoft.com/office/word/2018/wordml/cex" },
          w16cid: { key: "xmlns:w16cid", value: "http://schemas.microsoft.com/office/word/2016/wordml/cid" },
          w16: { key: "xmlns:w16", value: "http://schemas.microsoft.com/office/word/2018/wordml" },
          w16sdtdh: { key: "xmlns:w16sdtdh", value: "http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash" },
          w16se: { key: "xmlns:w16se", value: "http://schemas.microsoft.com/office/word/2015/wordml/symex" },
          Ignorable: { key: "mc:Ignorable", value: "w14 w15 w16se w16cid w16 w16cex w16sdtdh" }
        },
        children: fonts.map(
          (font, i) => createRegularFont({
            name: font.name,
            index: i + 1,
            fontKey: font.fontKey
          })
        )
      })
    );
    FontWrapper = class {
      constructor(options) {
        __publicField(this, "fontTable");
        __publicField(this, "relationships");
        __publicField(this, "fontOptionsWithKey", []);
        this.options = options;
        this.fontOptionsWithKey = options.map((o) => __spreadProps(__spreadValues({}, o), { fontKey: uniqueUuid() }));
        this.fontTable = createFontTable(this.fontOptionsWithKey);
        this.relationships = new Relationships();
        for (let i = 0; i < options.length; i++) {
          this.relationships.createRelationship(
            i + 1,
            "http://schemas.openxmlformats.org/officeDocument/2006/relationships/font",
            `fonts/${options[i].name}.odttf`
          );
        }
      }
      get View() {
        return this.fontTable;
      }
      get Relationships() {
        return this.relationships;
      }
    };
    FooterAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", {
          wpc: "xmlns:wpc",
          mc: "xmlns:mc",
          o: "xmlns:o",
          r: "xmlns:r",
          m: "xmlns:m",
          v: "xmlns:v",
          wp14: "xmlns:wp14",
          wp: "xmlns:wp",
          w10: "xmlns:w10",
          w: "xmlns:w",
          w14: "xmlns:w14",
          w15: "xmlns:w15",
          wpg: "xmlns:wpg",
          wpi: "xmlns:wpi",
          wne: "xmlns:wne",
          wps: "xmlns:wps",
          cp: "xmlns:cp",
          dc: "xmlns:dc",
          dcterms: "xmlns:dcterms",
          dcmitype: "xmlns:dcmitype",
          xsi: "xmlns:xsi",
          type: "xsi:type"
        });
      }
    };
    Footer$1 = class Footer extends InitializableXmlComponent {
      constructor(referenceNumber, initContent) {
        super("w:ftr", initContent);
        __publicField(this, "refId");
        this.refId = referenceNumber;
        if (!initContent) {
          this.root.push(
            new FooterAttributes({
              wpc: "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas",
              mc: "http://schemas.openxmlformats.org/markup-compatibility/2006",
              o: "urn:schemas-microsoft-com:office:office",
              r: "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
              m: "http://schemas.openxmlformats.org/officeDocument/2006/math",
              v: "urn:schemas-microsoft-com:vml",
              wp14: "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
              wp: "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
              w10: "urn:schemas-microsoft-com:office:word",
              w: "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
              w14: "http://schemas.microsoft.com/office/word/2010/wordml",
              w15: "http://schemas.microsoft.com/office/word/2012/wordml",
              wpg: "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
              wpi: "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
              wne: "http://schemas.microsoft.com/office/word/2006/wordml",
              wps: "http://schemas.microsoft.com/office/word/2010/wordprocessingShape"
            })
          );
        }
      }
      get ReferenceId() {
        return this.refId;
      }
      add(item) {
        this.root.push(item);
      }
    };
    FooterWrapper = class {
      constructor(media, referenceId, initContent) {
        __publicField(this, "footer");
        __publicField(this, "relationships");
        this.media = media;
        this.footer = new Footer$1(referenceId, initContent);
        this.relationships = new Relationships();
      }
      add(item) {
        this.footer.add(item);
      }
      addChildElement(childElement) {
        this.footer.addChildElement(childElement);
      }
      get View() {
        return this.footer;
      }
      get Relationships() {
        return this.relationships;
      }
      get Media() {
        return this.media;
      }
    };
    FootnoteAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", {
          type: "w:type",
          id: "w:id"
        });
      }
    };
    FootnoteRef = class extends XmlComponent {
      constructor() {
        super("w:footnoteRef");
      }
    };
    FootnoteRefRun = class extends Run {
      constructor() {
        super({
          style: "FootnoteReference"
        });
        this.root.push(new FootnoteRef());
      }
    };
    FootnoteType = {
      SEPERATOR: "separator",
      CONTINUATION_SEPERATOR: "continuationSeparator"
    };
    Footnote = class extends XmlComponent {
      constructor(options) {
        super("w:footnote");
        this.root.push(
          new FootnoteAttributes({
            type: options.type,
            id: options.id
          })
        );
        for (let i = 0; i < options.children.length; i++) {
          const child = options.children[i];
          if (i === 0) {
            child.addRunToFront(new FootnoteRefRun());
          }
          this.root.push(child);
        }
      }
    };
    ContinuationSeperator = class extends XmlComponent {
      constructor() {
        super("w:continuationSeparator");
      }
    };
    ContinuationSeperatorRun = class extends Run {
      constructor() {
        super({});
        this.root.push(new ContinuationSeperator());
      }
    };
    Seperator = class extends XmlComponent {
      constructor() {
        super("w:separator");
      }
    };
    SeperatorRun = class extends Run {
      constructor() {
        super({});
        this.root.push(new Seperator());
      }
    };
    FootnotesAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", {
          wpc: "xmlns:wpc",
          mc: "xmlns:mc",
          o: "xmlns:o",
          r: "xmlns:r",
          m: "xmlns:m",
          v: "xmlns:v",
          wp14: "xmlns:wp14",
          wp: "xmlns:wp",
          w10: "xmlns:w10",
          w: "xmlns:w",
          w14: "xmlns:w14",
          w15: "xmlns:w15",
          wpg: "xmlns:wpg",
          wpi: "xmlns:wpi",
          wne: "xmlns:wne",
          wps: "xmlns:wps",
          Ignorable: "mc:Ignorable"
        });
      }
    };
    FootNotes = class extends XmlComponent {
      constructor() {
        super("w:footnotes");
        this.root.push(
          new FootnotesAttributes({
            wpc: "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas",
            mc: "http://schemas.openxmlformats.org/markup-compatibility/2006",
            o: "urn:schemas-microsoft-com:office:office",
            r: "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
            m: "http://schemas.openxmlformats.org/officeDocument/2006/math",
            v: "urn:schemas-microsoft-com:vml",
            wp14: "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
            wp: "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
            w10: "urn:schemas-microsoft-com:office:word",
            w: "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
            w14: "http://schemas.microsoft.com/office/word/2010/wordml",
            w15: "http://schemas.microsoft.com/office/word/2012/wordml",
            wpg: "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
            wpi: "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
            wne: "http://schemas.microsoft.com/office/word/2006/wordml",
            wps: "http://schemas.microsoft.com/office/word/2010/wordprocessingShape",
            Ignorable: "w14 w15 wp14"
          })
        );
        const begin = new Footnote({
          id: -1,
          type: FootnoteType.SEPERATOR,
          children: [
            new Paragraph({
              spacing: {
                after: 0,
                line: 240,
                lineRule: LineRuleType.AUTO
              },
              children: [new SeperatorRun()]
            })
          ]
        });
        this.root.push(begin);
        const spacing = new Footnote({
          id: 0,
          type: FootnoteType.CONTINUATION_SEPERATOR,
          children: [
            new Paragraph({
              spacing: {
                after: 0,
                line: 240,
                lineRule: LineRuleType.AUTO
              },
              children: [new ContinuationSeperatorRun()]
            })
          ]
        });
        this.root.push(spacing);
      }
      createFootNote(id, paragraph) {
        const footnote = new Footnote({
          id,
          children: paragraph
        });
        this.root.push(footnote);
      }
    };
    FootnotesWrapper = class {
      constructor() {
        __publicField(this, "footnotess");
        __publicField(this, "relationships");
        this.footnotess = new FootNotes();
        this.relationships = new Relationships();
      }
      get View() {
        return this.footnotess;
      }
      get Relationships() {
        return this.relationships;
      }
    };
    HeaderAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", {
          wpc: "xmlns:wpc",
          mc: "xmlns:mc",
          o: "xmlns:o",
          r: "xmlns:r",
          m: "xmlns:m",
          v: "xmlns:v",
          wp14: "xmlns:wp14",
          wp: "xmlns:wp",
          w10: "xmlns:w10",
          w: "xmlns:w",
          w14: "xmlns:w14",
          w15: "xmlns:w15",
          wpg: "xmlns:wpg",
          wpi: "xmlns:wpi",
          wne: "xmlns:wne",
          wps: "xmlns:wps",
          cp: "xmlns:cp",
          dc: "xmlns:dc",
          dcterms: "xmlns:dcterms",
          dcmitype: "xmlns:dcmitype",
          xsi: "xmlns:xsi",
          type: "xsi:type",
          cx: "xmlns:cx",
          cx1: "xmlns:cx1",
          cx2: "xmlns:cx2",
          cx3: "xmlns:cx3",
          cx4: "xmlns:cx4",
          cx5: "xmlns:cx5",
          cx6: "xmlns:cx6",
          cx7: "xmlns:cx7",
          cx8: "xmlns:cx8",
          w16cid: "xmlns:w16cid",
          w16se: "xmlns:w16se"
        });
      }
    };
    Header$1 = class Header extends InitializableXmlComponent {
      constructor(referenceNumber, initContent) {
        super("w:hdr", initContent);
        __publicField(this, "refId");
        this.refId = referenceNumber;
        if (!initContent) {
          this.root.push(
            new HeaderAttributes({
              wpc: "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas",
              mc: "http://schemas.openxmlformats.org/markup-compatibility/2006",
              o: "urn:schemas-microsoft-com:office:office",
              r: "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
              m: "http://schemas.openxmlformats.org/officeDocument/2006/math",
              v: "urn:schemas-microsoft-com:vml",
              wp14: "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
              wp: "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
              w10: "urn:schemas-microsoft-com:office:word",
              w: "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
              w14: "http://schemas.microsoft.com/office/word/2010/wordml",
              w15: "http://schemas.microsoft.com/office/word/2012/wordml",
              wpg: "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
              wpi: "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
              wne: "http://schemas.microsoft.com/office/word/2006/wordml",
              wps: "http://schemas.microsoft.com/office/word/2010/wordprocessingShape",
              cx: "http://schemas.microsoft.com/office/drawing/2014/chartex",
              cx1: "http://schemas.microsoft.com/office/drawing/2015/9/8/chartex",
              cx2: "http://schemas.microsoft.com/office/drawing/2015/10/21/chartex",
              cx3: "http://schemas.microsoft.com/office/drawing/2016/5/9/chartex",
              cx4: "http://schemas.microsoft.com/office/drawing/2016/5/10/chartex",
              cx5: "http://schemas.microsoft.com/office/drawing/2016/5/11/chartex",
              cx6: "http://schemas.microsoft.com/office/drawing/2016/5/12/chartex",
              cx7: "http://schemas.microsoft.com/office/drawing/2016/5/13/chartex",
              cx8: "http://schemas.microsoft.com/office/drawing/2016/5/14/chartex",
              w16cid: "http://schemas.microsoft.com/office/word/2016/wordml/cid",
              w16se: "http://schemas.microsoft.com/office/word/2015/wordml/symex"
            })
          );
        }
      }
      get ReferenceId() {
        return this.refId;
      }
      add(item) {
        this.root.push(item);
      }
    };
    HeaderWrapper = class {
      constructor(media, referenceId, initContent) {
        __publicField(this, "header");
        __publicField(this, "relationships");
        this.media = media;
        this.header = new Header$1(referenceId, initContent);
        this.relationships = new Relationships();
      }
      add(item) {
        this.header.add(item);
        return this;
      }
      addChildElement(childElement) {
        this.header.addChildElement(childElement);
      }
      get View() {
        return this.header;
      }
      get Relationships() {
        return this.relationships;
      }
      get Media() {
        return this.media;
      }
    };
    Media = class {
      constructor() {
        __publicField(this, "map");
        this.map = /* @__PURE__ */ new Map();
      }
      addImage(key, mediaData) {
        this.map.set(key, mediaData);
      }
      get Array() {
        return Array.from(this.map.values());
      }
    };
    LevelFormat = {
      DECIMAL: "decimal",
      UPPER_ROMAN: "upperRoman",
      LOWER_ROMAN: "lowerRoman",
      UPPER_LETTER: "upperLetter",
      LOWER_LETTER: "lowerLetter",
      ORDINAL: "ordinal",
      CARDINAL_TEXT: "cardinalText",
      ORDINAL_TEXT: "ordinalText",
      HEX: "hex",
      CHICAGO: "chicago",
      IDEOGRAPH__DIGITAL: "ideographDigital",
      JAPANESE_COUNTING: "japaneseCounting",
      AIUEO: "aiueo",
      IROHA: "iroha",
      DECIMAL_FULL_WIDTH: "decimalFullWidth",
      DECIMAL_HALF_WIDTH: "decimalHalfWidth",
      JAPANESE_LEGAL: "japaneseLegal",
      JAPANESE_DIGITAL_TEN_THOUSAND: "japaneseDigitalTenThousand",
      DECIMAL_ENCLOSED_CIRCLE: "decimalEnclosedCircle",
      DECIMAL_FULL_WIDTH2: "decimalFullWidth2",
      AIUEO_FULL_WIDTH: "aiueoFullWidth",
      IROHA_FULL_WIDTH: "irohaFullWidth",
      DECIMAL_ZERO: "decimalZero",
      BULLET: "bullet",
      GANADA: "ganada",
      CHOSUNG: "chosung",
      DECIMAL_ENCLOSED_FULLSTOP: "decimalEnclosedFullstop",
      DECIMAL_ENCLOSED_PARENTHESES: "decimalEnclosedParen",
      DECIMAL_ENCLOSED_CIRCLE_CHINESE: "decimalEnclosedCircleChinese",
      IDEOGRAPH_ENCLOSED_CIRCLE: "ideographEnclosedCircle",
      IDEOGRAPH_TRADITIONAL: "ideographTraditional",
      IDEOGRAPH_ZODIAC: "ideographZodiac",
      IDEOGRAPH_ZODIAC_TRADITIONAL: "ideographZodiacTraditional",
      TAIWANESE_COUNTING: "taiwaneseCounting",
      IDEOGRAPH_LEGAL_TRADITIONAL: "ideographLegalTraditional",
      TAIWANESE_COUNTING_THOUSAND: "taiwaneseCountingThousand",
      TAIWANESE_DIGITAL: "taiwaneseDigital",
      CHINESE_COUNTING: "chineseCounting",
      CHINESE_LEGAL_SIMPLIFIED: "chineseLegalSimplified",
      CHINESE_COUNTING_THOUSAND: "chineseCountingThousand",
      KOREAN_DIGITAL: "koreanDigital",
      KOREAN_COUNTING: "koreanCounting",
      KOREAN_LEGAL: "koreanLegal",
      KOREAN_DIGITAL2: "koreanDigital2",
      VIETNAMESE_COUNTING: "vietnameseCounting",
      RUSSIAN_LOWER: "russianLower",
      RUSSIAN_UPPER: "russianUpper",
      NONE: "none",
      NUMBER_IN_DASH: "numberInDash",
      HEBREW1: "hebrew1",
      HEBREW2: "hebrew2",
      ARABIC_ALPHA: "arabicAlpha",
      ARABIC_ABJAD: "arabicAbjad",
      HINDI_VOWELS: "hindiVowels",
      HINDI_CONSONANTS: "hindiConsonants",
      HINDI_NUMBERS: "hindiNumbers",
      HINDI_COUNTING: "hindiCounting",
      THAI_LETTERS: "thaiLetters",
      THAI_NUMBERS: "thaiNumbers",
      THAI_COUNTING: "thaiCounting",
      BAHT_TEXT: "bahtText",
      DOLLAR_TEXT: "dollarText",
      CUSTOM: "custom"
    };
    LevelAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", {
          ilvl: "w:ilvl",
          tentative: "w15:tentative"
        });
      }
    };
    NumberFormat = class extends XmlComponent {
      constructor(value) {
        super("w:numFmt");
        this.root.push(
          new Attributes({
            val: value
          })
        );
      }
    };
    LevelText = class extends XmlComponent {
      constructor(value) {
        super("w:lvlText");
        this.root.push(
          new Attributes({
            val: value
          })
        );
      }
    };
    LevelJc = class extends XmlComponent {
      constructor(value) {
        super("w:lvlJc");
        this.root.push(
          new Attributes({
            val: value
          })
        );
      }
    };
    Suffix = class extends XmlComponent {
      constructor(value) {
        super("w:suff");
        this.root.push(
          new Attributes({
            val: value
          })
        );
      }
    };
    IsLegalNumberingStyle = class extends XmlComponent {
      constructor() {
        super("w:isLgl");
      }
    };
    LevelBase = class extends XmlComponent {
      constructor({
        level,
        format,
        text,
        alignment = AlignmentType.START,
        start = 1,
        style,
        suffix,
        isLegalNumberingStyle
      }) {
        super("w:lvl");
        __publicField(this, "paragraphProperties");
        __publicField(this, "runProperties");
        this.root.push(new NumberValueElement("w:start", decimalNumber(start)));
        if (format) {
          this.root.push(new NumberFormat(format));
        }
        if (suffix) {
          this.root.push(new Suffix(suffix));
        }
        if (isLegalNumberingStyle) {
          this.root.push(new IsLegalNumberingStyle());
        }
        if (text) {
          this.root.push(new LevelText(text));
        }
        this.root.push(new LevelJc(alignment));
        this.paragraphProperties = new ParagraphProperties(style && style.paragraph);
        this.runProperties = new RunProperties(style && style.run);
        this.root.push(this.paragraphProperties);
        this.root.push(this.runProperties);
        if (level > 9) {
          throw new Error(
            "Level cannot be greater than 9. Read more here: https://answers.microsoft.com/en-us/msoffice/forum/all/does-word-support-more-than-9-list-levels/d130fdcd-1781-446d-8c84-c6c79124e4d7"
          );
        }
        this.root.push(
          new LevelAttributes({
            ilvl: decimalNumber(level),
            tentative: 1
          })
        );
      }
    };
    Level = class extends LevelBase {
      // This is the level that sits under abstractNum. We make a
      // handful of properties required
    };
    MultiLevelType = class extends XmlComponent {
      constructor(value) {
        super("w:multiLevelType");
        this.root.push(
          new Attributes({
            val: value
          })
        );
      }
    };
    AbstractNumberingAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", {
          abstractNumId: "w:abstractNumId",
          restartNumberingAfterBreak: "w15:restartNumberingAfterBreak"
        });
      }
    };
    AbstractNumbering = class extends XmlComponent {
      constructor(id, levelOptions) {
        super("w:abstractNum");
        __publicField(this, "id");
        this.root.push(
          new AbstractNumberingAttributes({
            abstractNumId: decimalNumber(id),
            restartNumberingAfterBreak: 0
          })
        );
        this.root.push(new MultiLevelType("hybridMultilevel"));
        this.id = id;
        for (const option of levelOptions) {
          this.root.push(new Level(option));
        }
      }
    };
    AbstractNumId = class extends XmlComponent {
      constructor(value) {
        super("w:abstractNumId");
        this.root.push(
          new Attributes({
            val: value
          })
        );
      }
    };
    NumAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", { numId: "w:numId" });
      }
    };
    ConcreteNumbering = class extends XmlComponent {
      constructor(options) {
        super("w:num");
        __publicField(this, "numId");
        __publicField(this, "reference");
        __publicField(this, "instance");
        this.numId = options.numId;
        this.reference = options.reference;
        this.instance = options.instance;
        this.root.push(
          new NumAttributes({
            numId: decimalNumber(options.numId)
          })
        );
        this.root.push(new AbstractNumId(decimalNumber(options.abstractNumId)));
        if (options.overrideLevels && options.overrideLevels.length) {
          for (const level of options.overrideLevels) {
            this.root.push(new LevelOverride(level.num, level.start));
          }
        }
      }
    };
    LevelOverrideAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", { ilvl: "w:ilvl" });
      }
    };
    LevelOverride = class extends XmlComponent {
      constructor(levelNum, start) {
        super("w:lvlOverride");
        this.root.push(new LevelOverrideAttributes({ ilvl: levelNum }));
        if (start !== void 0) {
          this.root.push(new StartOverride(start));
        }
      }
    };
    StartOverrideAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", { val: "w:val" });
      }
    };
    StartOverride = class extends XmlComponent {
      constructor(start) {
        super("w:startOverride");
        this.root.push(new StartOverrideAttributes({ val: start }));
      }
    };
    Numbering = class extends XmlComponent {
      constructor(options) {
        super("w:numbering");
        __publicField(this, "abstractNumberingMap", /* @__PURE__ */ new Map());
        __publicField(this, "concreteNumberingMap", /* @__PURE__ */ new Map());
        __publicField(this, "referenceConfigMap", /* @__PURE__ */ new Map());
        __publicField(this, "abstractNumUniqueNumericId", abstractNumUniqueNumericIdGen());
        __publicField(this, "concreteNumUniqueNumericId", concreteNumUniqueNumericIdGen());
        this.root.push(
          new DocumentAttributes(
            ["wpc", "mc", "o", "r", "m", "v", "wp14", "wp", "w10", "w", "w14", "w15", "wpg", "wpi", "wne", "wps"],
            "w14 w15 wp14"
          )
        );
        const abstractNumbering = new AbstractNumbering(this.abstractNumUniqueNumericId(), [
          {
            level: 0,
            format: LevelFormat.BULLET,
            text: "\u25CF",
            alignment: AlignmentType.LEFT,
            style: {
              paragraph: {
                indent: { left: convertInchesToTwip(0.5), hanging: convertInchesToTwip(0.25) }
              }
            }
          },
          {
            level: 1,
            format: LevelFormat.BULLET,
            text: "\u25CB",
            alignment: AlignmentType.LEFT,
            style: {
              paragraph: {
                indent: { left: convertInchesToTwip(1), hanging: convertInchesToTwip(0.25) }
              }
            }
          },
          {
            level: 2,
            format: LevelFormat.BULLET,
            text: "\u25A0",
            alignment: AlignmentType.LEFT,
            style: {
              paragraph: {
                indent: { left: 2160, hanging: convertInchesToTwip(0.25) }
              }
            }
          },
          {
            level: 3,
            format: LevelFormat.BULLET,
            text: "\u25CF",
            alignment: AlignmentType.LEFT,
            style: {
              paragraph: {
                indent: { left: 2880, hanging: convertInchesToTwip(0.25) }
              }
            }
          },
          {
            level: 4,
            format: LevelFormat.BULLET,
            text: "\u25CB",
            alignment: AlignmentType.LEFT,
            style: {
              paragraph: {
                indent: { left: 3600, hanging: convertInchesToTwip(0.25) }
              }
            }
          },
          {
            level: 5,
            format: LevelFormat.BULLET,
            text: "\u25A0",
            alignment: AlignmentType.LEFT,
            style: {
              paragraph: {
                indent: { left: 4320, hanging: convertInchesToTwip(0.25) }
              }
            }
          },
          {
            level: 6,
            format: LevelFormat.BULLET,
            text: "\u25CF",
            alignment: AlignmentType.LEFT,
            style: {
              paragraph: {
                indent: { left: 5040, hanging: convertInchesToTwip(0.25) }
              }
            }
          },
          {
            level: 7,
            format: LevelFormat.BULLET,
            text: "\u25CF",
            alignment: AlignmentType.LEFT,
            style: {
              paragraph: {
                indent: { left: 5760, hanging: convertInchesToTwip(0.25) }
              }
            }
          },
          {
            level: 8,
            format: LevelFormat.BULLET,
            text: "\u25CF",
            alignment: AlignmentType.LEFT,
            style: {
              paragraph: {
                indent: { left: 6480, hanging: convertInchesToTwip(0.25) }
              }
            }
          }
        ]);
        this.concreteNumberingMap.set(
          "default-bullet-numbering",
          new ConcreteNumbering({
            numId: 1,
            abstractNumId: abstractNumbering.id,
            reference: "default-bullet-numbering",
            instance: 0,
            overrideLevels: [
              {
                num: 0,
                start: 1
              }
            ]
          })
        );
        this.abstractNumberingMap.set("default-bullet-numbering", abstractNumbering);
        for (const con of options.config) {
          this.abstractNumberingMap.set(con.reference, new AbstractNumbering(this.abstractNumUniqueNumericId(), con.levels));
          this.referenceConfigMap.set(con.reference, con.levels);
        }
      }
      prepForXml(context) {
        for (const numbering of this.abstractNumberingMap.values()) {
          this.root.push(numbering);
        }
        for (const numbering of this.concreteNumberingMap.values()) {
          this.root.push(numbering);
        }
        return super.prepForXml(context);
      }
      createConcreteNumberingInstance(reference, instance) {
        const abstractNumbering = this.abstractNumberingMap.get(reference);
        if (!abstractNumbering) {
          return;
        }
        const fullReference = `${reference}-${instance}`;
        if (this.concreteNumberingMap.has(fullReference)) {
          return;
        }
        const referenceConfigLevels = this.referenceConfigMap.get(reference);
        const firstLevelStartNumber = referenceConfigLevels && referenceConfigLevels[0].start;
        const concreteNumberingSettings = {
          numId: this.concreteNumUniqueNumericId(),
          abstractNumId: abstractNumbering.id,
          reference,
          instance,
          overrideLevels: [
            firstLevelStartNumber && Number.isInteger(firstLevelStartNumber) ? {
              num: 0,
              start: firstLevelStartNumber
            } : {
              num: 0,
              start: 1
            }
          ]
        };
        this.concreteNumberingMap.set(fullReference, new ConcreteNumbering(concreteNumberingSettings));
      }
      get ConcreteNumbering() {
        return Array.from(this.concreteNumberingMap.values());
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      get ReferenceConfig() {
        return Array.from(this.referenceConfigMap.values());
      }
    };
    CompatibilitySettingAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", {
          version: "w:val",
          name: "w:name",
          uri: "w:uri"
        });
      }
    };
    CompatibilitySetting = class extends XmlComponent {
      constructor(version) {
        super("w:compatSetting");
        this.root.push(
          new CompatibilitySettingAttributes({
            version,
            uri: "http://schemas.microsoft.com/office/word",
            name: "compatibilityMode"
          })
        );
      }
    };
    Compatibility = class extends XmlComponent {
      constructor(options) {
        super("w:compat");
        if (options.version) {
          this.root.push(new CompatibilitySetting(options.version));
        }
        if (options.useSingleBorderforContiguousCells) {
          this.root.push(new OnOffElement("w:useSingleBorderforContiguousCells", options.useSingleBorderforContiguousCells));
        }
        if (options.wordPerfectJustification) {
          this.root.push(new OnOffElement("w:wpJustification", options.wordPerfectJustification));
        }
        if (options.noTabStopForHangingIndent) {
          this.root.push(new OnOffElement("w:noTabHangInd", options.noTabStopForHangingIndent));
        }
        if (options.noLeading) {
          this.root.push(new OnOffElement("w:noLeading", options.noLeading));
        }
        if (options.spaceForUnderline) {
          this.root.push(new OnOffElement("w:spaceForUL", options.spaceForUnderline));
        }
        if (options.noColumnBalance) {
          this.root.push(new OnOffElement("w:noColumnBalance", options.noColumnBalance));
        }
        if (options.balanceSingleByteDoubleByteWidth) {
          this.root.push(new OnOffElement("w:balanceSingleByteDoubleByteWidth", options.balanceSingleByteDoubleByteWidth));
        }
        if (options.noExtraLineSpacing) {
          this.root.push(new OnOffElement("w:noExtraLineSpacing", options.noExtraLineSpacing));
        }
        if (options.doNotLeaveBackslashAlone) {
          this.root.push(new OnOffElement("w:doNotLeaveBackslashAlone", options.doNotLeaveBackslashAlone));
        }
        if (options.underlineTrailingSpaces) {
          this.root.push(new OnOffElement("w:ulTrailSpace", options.underlineTrailingSpaces));
        }
        if (options.doNotExpandShiftReturn) {
          this.root.push(new OnOffElement("w:doNotExpandShiftReturn", options.doNotExpandShiftReturn));
        }
        if (options.spacingInWholePoints) {
          this.root.push(new OnOffElement("w:spacingInWholePoints", options.spacingInWholePoints));
        }
        if (options.lineWrapLikeWord6) {
          this.root.push(new OnOffElement("w:lineWrapLikeWord6", options.lineWrapLikeWord6));
        }
        if (options.printBodyTextBeforeHeader) {
          this.root.push(new OnOffElement("w:printBodyTextBeforeHeader", options.printBodyTextBeforeHeader));
        }
        if (options.printColorsBlack) {
          this.root.push(new OnOffElement("w:printColBlack", options.printColorsBlack));
        }
        if (options.spaceWidth) {
          this.root.push(new OnOffElement("w:wpSpaceWidth", options.spaceWidth));
        }
        if (options.showBreaksInFrames) {
          this.root.push(new OnOffElement("w:showBreaksInFrames", options.showBreaksInFrames));
        }
        if (options.subFontBySize) {
          this.root.push(new OnOffElement("w:subFontBySize", options.subFontBySize));
        }
        if (options.suppressBottomSpacing) {
          this.root.push(new OnOffElement("w:suppressBottomSpacing", options.suppressBottomSpacing));
        }
        if (options.suppressTopSpacing) {
          this.root.push(new OnOffElement("w:suppressTopSpacing", options.suppressTopSpacing));
        }
        if (options.suppressSpacingAtTopOfPage) {
          this.root.push(new OnOffElement("w:suppressSpacingAtTopOfPage", options.suppressSpacingAtTopOfPage));
        }
        if (options.suppressTopSpacingWP) {
          this.root.push(new OnOffElement("w:suppressTopSpacingWP", options.suppressTopSpacingWP));
        }
        if (options.suppressSpBfAfterPgBrk) {
          this.root.push(new OnOffElement("w:suppressSpBfAfterPgBrk", options.suppressSpBfAfterPgBrk));
        }
        if (options.swapBordersFacingPages) {
          this.root.push(new OnOffElement("w:swapBordersFacingPages", options.swapBordersFacingPages));
        }
        if (options.convertMailMergeEsc) {
          this.root.push(new OnOffElement("w:convMailMergeEsc", options.convertMailMergeEsc));
        }
        if (options.truncateFontHeightsLikeWP6) {
          this.root.push(new OnOffElement("w:truncateFontHeightsLikeWP6", options.truncateFontHeightsLikeWP6));
        }
        if (options.macWordSmallCaps) {
          this.root.push(new OnOffElement("w:mwSmallCaps", options.macWordSmallCaps));
        }
        if (options.usePrinterMetrics) {
          this.root.push(new OnOffElement("w:usePrinterMetrics", options.usePrinterMetrics));
        }
        if (options.doNotSuppressParagraphBorders) {
          this.root.push(new OnOffElement("w:doNotSuppressParagraphBorders", options.doNotSuppressParagraphBorders));
        }
        if (options.wrapTrailSpaces) {
          this.root.push(new OnOffElement("w:wrapTrailSpaces", options.wrapTrailSpaces));
        }
        if (options.footnoteLayoutLikeWW8) {
          this.root.push(new OnOffElement("w:footnoteLayoutLikeWW8", options.footnoteLayoutLikeWW8));
        }
        if (options.shapeLayoutLikeWW8) {
          this.root.push(new OnOffElement("w:shapeLayoutLikeWW8", options.shapeLayoutLikeWW8));
        }
        if (options.alignTablesRowByRow) {
          this.root.push(new OnOffElement("w:alignTablesRowByRow", options.alignTablesRowByRow));
        }
        if (options.forgetLastTabAlignment) {
          this.root.push(new OnOffElement("w:forgetLastTabAlignment", options.forgetLastTabAlignment));
        }
        if (options.adjustLineHeightInTable) {
          this.root.push(new OnOffElement("w:adjustLineHeightInTable", options.adjustLineHeightInTable));
        }
        if (options.autoSpaceLikeWord95) {
          this.root.push(new OnOffElement("w:autoSpaceLikeWord95", options.autoSpaceLikeWord95));
        }
        if (options.noSpaceRaiseLower) {
          this.root.push(new OnOffElement("w:noSpaceRaiseLower", options.noSpaceRaiseLower));
        }
        if (options.doNotUseHTMLParagraphAutoSpacing) {
          this.root.push(new OnOffElement("w:doNotUseHTMLParagraphAutoSpacing", options.doNotUseHTMLParagraphAutoSpacing));
        }
        if (options.layoutRawTableWidth) {
          this.root.push(new OnOffElement("w:layoutRawTableWidth", options.layoutRawTableWidth));
        }
        if (options.layoutTableRowsApart) {
          this.root.push(new OnOffElement("w:layoutTableRowsApart", options.layoutTableRowsApart));
        }
        if (options.useWord97LineBreakRules) {
          this.root.push(new OnOffElement("w:useWord97LineBreakRules", options.useWord97LineBreakRules));
        }
        if (options.doNotBreakWrappedTables) {
          this.root.push(new OnOffElement("w:doNotBreakWrappedTables", options.doNotBreakWrappedTables));
        }
        if (options.doNotSnapToGridInCell) {
          this.root.push(new OnOffElement("w:doNotSnapToGridInCell", options.doNotSnapToGridInCell));
        }
        if (options.selectFieldWithFirstOrLastCharacter) {
          this.root.push(new OnOffElement("w:selectFldWithFirstOrLastChar", options.selectFieldWithFirstOrLastCharacter));
        }
        if (options.applyBreakingRules) {
          this.root.push(new OnOffElement("w:applyBreakingRules", options.applyBreakingRules));
        }
        if (options.doNotWrapTextWithPunctuation) {
          this.root.push(new OnOffElement("w:doNotWrapTextWithPunct", options.doNotWrapTextWithPunctuation));
        }
        if (options.doNotUseEastAsianBreakRules) {
          this.root.push(new OnOffElement("w:doNotUseEastAsianBreakRules", options.doNotUseEastAsianBreakRules));
        }
        if (options.useWord2002TableStyleRules) {
          this.root.push(new OnOffElement("w:useWord2002TableStyleRules", options.useWord2002TableStyleRules));
        }
        if (options.growAutofit) {
          this.root.push(new OnOffElement("w:growAutofit", options.growAutofit));
        }
        if (options.useFELayout) {
          this.root.push(new OnOffElement("w:useFELayout", options.useFELayout));
        }
        if (options.useNormalStyleForList) {
          this.root.push(new OnOffElement("w:useNormalStyleForList", options.useNormalStyleForList));
        }
        if (options.doNotUseIndentAsNumberingTabStop) {
          this.root.push(new OnOffElement("w:doNotUseIndentAsNumberingTabStop", options.doNotUseIndentAsNumberingTabStop));
        }
        if (options.useAlternateEastAsianLineBreakRules) {
          this.root.push(new OnOffElement("w:useAltKinsokuLineBreakRules", options.useAlternateEastAsianLineBreakRules));
        }
        if (options.allowSpaceOfSameStyleInTable) {
          this.root.push(new OnOffElement("w:allowSpaceOfSameStyleInTable", options.allowSpaceOfSameStyleInTable));
        }
        if (options.doNotSuppressIndentation) {
          this.root.push(new OnOffElement("w:doNotSuppressIndentation", options.doNotSuppressIndentation));
        }
        if (options.doNotAutofitConstrainedTables) {
          this.root.push(new OnOffElement("w:doNotAutofitConstrainedTables", options.doNotAutofitConstrainedTables));
        }
        if (options.autofitToFirstFixedWidthCell) {
          this.root.push(new OnOffElement("w:autofitToFirstFixedWidthCell", options.autofitToFirstFixedWidthCell));
        }
        if (options.underlineTabInNumberingList) {
          this.root.push(new OnOffElement("w:underlineTabInNumList", options.underlineTabInNumberingList));
        }
        if (options.displayHangulFixedWidth) {
          this.root.push(new OnOffElement("w:displayHangulFixedWidth", options.displayHangulFixedWidth));
        }
        if (options.splitPgBreakAndParaMark) {
          this.root.push(new OnOffElement("w:splitPgBreakAndParaMark", options.splitPgBreakAndParaMark));
        }
        if (options.doNotVerticallyAlignCellWithSp) {
          this.root.push(new OnOffElement("w:doNotVertAlignCellWithSp", options.doNotVerticallyAlignCellWithSp));
        }
        if (options.doNotBreakConstrainedForcedTable) {
          this.root.push(new OnOffElement("w:doNotBreakConstrainedForcedTable", options.doNotBreakConstrainedForcedTable));
        }
        if (options.ignoreVerticalAlignmentInTextboxes) {
          this.root.push(new OnOffElement("w:doNotVertAlignInTxbx", options.ignoreVerticalAlignmentInTextboxes));
        }
        if (options.useAnsiKerningPairs) {
          this.root.push(new OnOffElement("w:useAnsiKerningPairs", options.useAnsiKerningPairs));
        }
        if (options.cachedColumnBalance) {
          this.root.push(new OnOffElement("w:cachedColBalance", options.cachedColumnBalance));
        }
      }
    };
    SettingsAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", {
          wpc: "xmlns:wpc",
          mc: "xmlns:mc",
          o: "xmlns:o",
          r: "xmlns:r",
          m: "xmlns:m",
          v: "xmlns:v",
          wp14: "xmlns:wp14",
          wp: "xmlns:wp",
          w10: "xmlns:w10",
          w: "xmlns:w",
          w14: "xmlns:w14",
          w15: "xmlns:w15",
          wpg: "xmlns:wpg",
          wpi: "xmlns:wpi",
          wne: "xmlns:wne",
          wps: "xmlns:wps",
          Ignorable: "mc:Ignorable"
        });
      }
    };
    Settings = class extends XmlComponent {
      constructor(options) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        super("w:settings");
        this.root.push(
          new SettingsAttributes({
            wpc: "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas",
            mc: "http://schemas.openxmlformats.org/markup-compatibility/2006",
            o: "urn:schemas-microsoft-com:office:office",
            r: "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
            m: "http://schemas.openxmlformats.org/officeDocument/2006/math",
            v: "urn:schemas-microsoft-com:vml",
            wp14: "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
            wp: "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
            w10: "urn:schemas-microsoft-com:office:word",
            w: "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
            w14: "http://schemas.microsoft.com/office/word/2010/wordml",
            w15: "http://schemas.microsoft.com/office/word/2012/wordml",
            wpg: "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
            wpi: "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
            wne: "http://schemas.microsoft.com/office/word/2006/wordml",
            wps: "http://schemas.microsoft.com/office/word/2010/wordprocessingShape",
            Ignorable: "w14 w15 wp14"
          })
        );
        this.root.push(new OnOffElement("w:displayBackgroundShape", true));
        if (options.trackRevisions !== void 0) {
          this.root.push(new OnOffElement("w:trackRevisions", options.trackRevisions));
        }
        if (options.evenAndOddHeaders !== void 0) {
          this.root.push(new OnOffElement("w:evenAndOddHeaders", options.evenAndOddHeaders));
        }
        if (options.updateFields !== void 0) {
          this.root.push(new OnOffElement("w:updateFields", options.updateFields));
        }
        if (options.defaultTabStop !== void 0) {
          this.root.push(new NumberValueElement("w:defaultTabStop", options.defaultTabStop));
        }
        if (((_a = options.hyphenation) == null ? void 0 : _a.autoHyphenation) !== void 0) {
          this.root.push(new OnOffElement("w:autoHyphenation", options.hyphenation.autoHyphenation));
        }
        if (((_b = options.hyphenation) == null ? void 0 : _b.hyphenationZone) !== void 0) {
          this.root.push(new NumberValueElement("w:hyphenationZone", options.hyphenation.hyphenationZone));
        }
        if (((_c = options.hyphenation) == null ? void 0 : _c.consecutiveHyphenLimit) !== void 0) {
          this.root.push(new NumberValueElement("w:consecutiveHyphenLimit", options.hyphenation.consecutiveHyphenLimit));
        }
        if (((_d = options.hyphenation) == null ? void 0 : _d.doNotHyphenateCaps) !== void 0) {
          this.root.push(new OnOffElement("w:doNotHyphenateCaps", options.hyphenation.doNotHyphenateCaps));
        }
        this.root.push(
          new Compatibility(__spreadProps(__spreadValues({}, (_e = options.compatibility) != null ? _e : {}), {
            version: (_h = (_g = (_f = options.compatibility) == null ? void 0 : _f.version) != null ? _g : options.compatibilityModeVersion) != null ? _h : 15
          }))
        );
      }
    };
    ComponentAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", { val: "w:val" });
      }
    };
    Name = class extends XmlComponent {
      constructor(value) {
        super("w:name");
        this.root.push(new ComponentAttributes({ val: value }));
      }
    };
    UiPriority = class extends XmlComponent {
      constructor(value) {
        super("w:uiPriority");
        this.root.push(new ComponentAttributes({ val: decimalNumber(value) }));
      }
    };
    StyleAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", {
          type: "w:type",
          styleId: "w:styleId",
          default: "w:default",
          customStyle: "w:customStyle"
        });
      }
    };
    Style2 = class extends XmlComponent {
      constructor(attributes, options) {
        super("w:style");
        this.root.push(new StyleAttributes(attributes));
        if (options.name) {
          this.root.push(new Name(options.name));
        }
        if (options.basedOn) {
          this.root.push(new StringValueElement("w:basedOn", options.basedOn));
        }
        if (options.next) {
          this.root.push(new StringValueElement("w:next", options.next));
        }
        if (options.link) {
          this.root.push(new StringValueElement("w:link", options.link));
        }
        if (options.uiPriority !== void 0) {
          this.root.push(new UiPriority(options.uiPriority));
        }
        if (options.semiHidden !== void 0) {
          this.root.push(new OnOffElement("w:semiHidden", options.semiHidden));
        }
        if (options.unhideWhenUsed !== void 0) {
          this.root.push(new OnOffElement("w:unhideWhenUsed", options.unhideWhenUsed));
        }
        if (options.quickFormat !== void 0) {
          this.root.push(new OnOffElement("w:qFormat", options.quickFormat));
        }
      }
    };
    StyleForParagraph = class extends Style2 {
      constructor(options) {
        super({ type: "paragraph", styleId: options.id }, options);
        __publicField(this, "paragraphProperties");
        __publicField(this, "runProperties");
        this.paragraphProperties = new ParagraphProperties(options.paragraph);
        this.runProperties = new RunProperties(options.run);
        this.root.push(this.paragraphProperties);
        this.root.push(this.runProperties);
      }
    };
    StyleForCharacter = class extends Style2 {
      constructor(options) {
        super(
          { type: "character", styleId: options.id },
          __spreadValues({
            uiPriority: 99,
            unhideWhenUsed: true
          }, options)
        );
        __publicField(this, "runProperties");
        this.runProperties = new RunProperties(options.run);
        this.root.push(this.runProperties);
      }
    };
    HeadingStyle = class extends StyleForParagraph {
      constructor(options) {
        super(__spreadValues({
          basedOn: "Normal",
          next: "Normal",
          quickFormat: true
        }, options));
      }
    };
    TitleStyle = class extends HeadingStyle {
      constructor(options) {
        super(__spreadValues({
          id: "Title",
          name: "Title"
        }, options));
      }
    };
    Heading1Style = class extends HeadingStyle {
      constructor(options) {
        super(__spreadValues({
          id: "Heading1",
          name: "Heading 1"
        }, options));
      }
    };
    Heading2Style = class extends HeadingStyle {
      constructor(options) {
        super(__spreadValues({
          id: "Heading2",
          name: "Heading 2"
        }, options));
      }
    };
    Heading3Style = class extends HeadingStyle {
      constructor(options) {
        super(__spreadValues({
          id: "Heading3",
          name: "Heading 3"
        }, options));
      }
    };
    Heading4Style = class extends HeadingStyle {
      constructor(options) {
        super(__spreadValues({
          id: "Heading4",
          name: "Heading 4"
        }, options));
      }
    };
    Heading5Style = class extends HeadingStyle {
      constructor(options) {
        super(__spreadValues({
          id: "Heading5",
          name: "Heading 5"
        }, options));
      }
    };
    Heading6Style = class extends HeadingStyle {
      constructor(options) {
        super(__spreadValues({
          id: "Heading6",
          name: "Heading 6"
        }, options));
      }
    };
    StrongStyle = class extends HeadingStyle {
      constructor(options) {
        super(__spreadValues({
          id: "Strong",
          name: "Strong"
        }, options));
      }
    };
    ListParagraph = class extends StyleForParagraph {
      constructor(options) {
        super(__spreadValues({
          id: "ListParagraph",
          name: "List Paragraph",
          basedOn: "Normal",
          quickFormat: true
        }, options));
      }
    };
    FootnoteText = class extends StyleForParagraph {
      constructor(options) {
        super(__spreadValues({
          id: "FootnoteText",
          name: "footnote text",
          link: "FootnoteTextChar",
          basedOn: "Normal",
          uiPriority: 99,
          semiHidden: true,
          unhideWhenUsed: true,
          paragraph: {
            spacing: {
              after: 0,
              line: 240,
              lineRule: LineRuleType.AUTO
            }
          },
          run: {
            size: 20
          }
        }, options));
      }
    };
    FootnoteReferenceStyle = class extends StyleForCharacter {
      constructor(options) {
        super(__spreadValues({
          id: "FootnoteReference",
          name: "footnote reference",
          basedOn: "DefaultParagraphFont",
          semiHidden: true,
          run: {
            superScript: true
          }
        }, options));
      }
    };
    FootnoteTextChar = class extends StyleForCharacter {
      constructor(options) {
        super(__spreadValues({
          id: "FootnoteTextChar",
          name: "Footnote Text Char",
          basedOn: "DefaultParagraphFont",
          link: "FootnoteText",
          semiHidden: true,
          run: {
            size: 20
          }
        }, options));
      }
    };
    HyperlinkStyle = class extends StyleForCharacter {
      constructor(options) {
        super(__spreadValues({
          id: "Hyperlink",
          name: "Hyperlink",
          basedOn: "DefaultParagraphFont",
          run: {
            color: "0563C1",
            underline: {
              type: UnderlineType.SINGLE
            }
          }
        }, options));
      }
    };
    Styles = class extends XmlComponent {
      constructor(options) {
        super("w:styles");
        if (options.initialStyles) {
          this.root.push(options.initialStyles);
        }
        if (options.importedStyles) {
          for (const style of options.importedStyles) {
            this.root.push(style);
          }
        }
        if (options.paragraphStyles) {
          for (const style of options.paragraphStyles) {
            this.root.push(new StyleForParagraph(style));
          }
        }
        if (options.characterStyles) {
          for (const style of options.characterStyles) {
            this.root.push(new StyleForCharacter(style));
          }
        }
      }
    };
    ParagraphPropertiesDefaults = class extends XmlComponent {
      constructor(options) {
        super("w:pPrDefault");
        this.root.push(new ParagraphProperties(options));
      }
    };
    RunPropertiesDefaults = class extends XmlComponent {
      constructor(options) {
        super("w:rPrDefault");
        this.root.push(new RunProperties(options));
      }
    };
    DocumentDefaults = class extends XmlComponent {
      constructor(options) {
        super("w:docDefaults");
        __publicField(this, "runPropertiesDefaults");
        __publicField(this, "paragraphPropertiesDefaults");
        this.runPropertiesDefaults = new RunPropertiesDefaults(options.run);
        this.paragraphPropertiesDefaults = new ParagraphPropertiesDefaults(options.paragraph);
        this.root.push(this.runPropertiesDefaults);
        this.root.push(this.paragraphPropertiesDefaults);
      }
    };
    ExternalStylesFactory = class {
      /**
       * Creates new Style based on the given styles.
       * Parses the styles and convert them to XmlComponent.
       * Example content from styles.xml:
       * <?xml version="1.0">
       * <w:styles xmlns:mc="some schema" ...>
       *
       *   <w:style w:type="paragraph" w:styleId="Heading1">
       *           <w:name w:val="heading 1"/>
       *           .....
       *   </w:style>
       *
       *   <w:style w:type="paragraph" w:styleId="Heading2">
       *           <w:name w:val="heading 2"/>
       *           .....
       *   </w:style>
       *
       *   <w:docDefaults>Or any other element will be parsed to</w:docDefaults>
       *
       * </w:styles>
       *
       * @param externalStyles context from styles.xml
       */
      newInstance(xmlData) {
        const xmlObj = libExports.xml2js(xmlData, { compact: false });
        let stylesXmlElement;
        for (const xmlElm of xmlObj.elements || []) {
          if (xmlElm.name === "w:styles") {
            stylesXmlElement = xmlElm;
          }
        }
        if (stylesXmlElement === void 0) {
          throw new Error("can not find styles element");
        }
        const stylesElements = stylesXmlElement.elements || [];
        const importedStyle = new Styles({
          initialStyles: new ImportedRootElementAttributes(stylesXmlElement.attributes),
          importedStyles: stylesElements.map((childElm) => convertToXmlComponent(childElm))
        });
        return importedStyle;
      }
    };
    DefaultStylesFactory = class {
      newInstance(options = {}) {
        var _a;
        const documentAttributes = new DocumentAttributes(["mc", "r", "w", "w14", "w15"], "w14 w15");
        return {
          initialStyles: documentAttributes,
          importedStyles: [
            new DocumentDefaults((_a = options.document) != null ? _a : {}),
            new TitleStyle(__spreadValues({
              run: {
                size: 56
              }
            }, options.title)),
            new Heading1Style(__spreadValues({
              run: {
                color: "2E74B5",
                size: 32
              }
            }, options.heading1)),
            new Heading2Style(__spreadValues({
              run: {
                color: "2E74B5",
                size: 26
              }
            }, options.heading2)),
            new Heading3Style(__spreadValues({
              run: {
                color: "1F4D78",
                size: 24
              }
            }, options.heading3)),
            new Heading4Style(__spreadValues({
              run: {
                color: "2E74B5",
                italics: true
              }
            }, options.heading4)),
            new Heading5Style(__spreadValues({
              run: {
                color: "2E74B5"
              }
            }, options.heading5)),
            new Heading6Style(__spreadValues({
              run: {
                color: "1F4D78"
              }
            }, options.heading6)),
            new StrongStyle(__spreadValues({
              run: {
                bold: true
              }
            }, options.strong)),
            new ListParagraph(options.listParagraph || {}),
            new HyperlinkStyle(options.hyperlink || {}),
            new FootnoteReferenceStyle(options.footnoteReference || {}),
            new FootnoteText(options.footnoteText || {}),
            new FootnoteTextChar(options.footnoteTextChar || {})
          ]
        };
      }
    };
    File = class {
      constructor(options) {
        __publicField(this, "currentRelationshipId", 1);
        __publicField(this, "documentWrapper");
        __publicField(this, "headers", []);
        __publicField(this, "footers", []);
        __publicField(this, "coreProperties");
        __publicField(this, "numbering");
        __publicField(this, "media");
        __publicField(this, "fileRelationships");
        __publicField(this, "footnotesWrapper");
        __publicField(this, "settings");
        __publicField(this, "contentTypes");
        __publicField(this, "customProperties");
        __publicField(this, "appProperties");
        __publicField(this, "styles");
        __publicField(this, "comments");
        __publicField(this, "fontWrapper");
        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
        this.coreProperties = new CoreProperties(__spreadProps(__spreadValues({}, options), {
          creator: (_a = options.creator) != null ? _a : "Un-named",
          revision: (_b = options.revision) != null ? _b : 1,
          lastModifiedBy: (_c = options.lastModifiedBy) != null ? _c : "Un-named"
        }));
        this.numbering = new Numbering(options.numbering ? options.numbering : { config: [] });
        this.comments = new Comments((_d = options.comments) != null ? _d : { children: [] });
        this.fileRelationships = new Relationships();
        this.customProperties = new CustomProperties((_e = options.customProperties) != null ? _e : []);
        this.appProperties = new AppProperties();
        this.footnotesWrapper = new FootnotesWrapper();
        this.contentTypes = new ContentTypes();
        this.documentWrapper = new DocumentWrapper({ background: options.background });
        this.settings = new Settings({
          compatibilityModeVersion: options.compatabilityModeVersion,
          compatibility: options.compatibility,
          evenAndOddHeaders: options.evenAndOddHeaderAndFooters ? true : false,
          trackRevisions: (_f = options.features) == null ? void 0 : _f.trackRevisions,
          updateFields: (_g = options.features) == null ? void 0 : _g.updateFields,
          defaultTabStop: options.defaultTabStop,
          hyphenation: {
            autoHyphenation: (_h = options.hyphenation) == null ? void 0 : _h.autoHyphenation,
            hyphenationZone: (_i = options.hyphenation) == null ? void 0 : _i.hyphenationZone,
            consecutiveHyphenLimit: (_j = options.hyphenation) == null ? void 0 : _j.consecutiveHyphenLimit,
            doNotHyphenateCaps: (_k = options.hyphenation) == null ? void 0 : _k.doNotHyphenateCaps
          }
        });
        this.media = new Media();
        if (options.externalStyles !== void 0) {
          const stylesFactory = new ExternalStylesFactory();
          this.styles = stylesFactory.newInstance(options.externalStyles);
        } else if (options.styles) {
          const stylesFactory = new DefaultStylesFactory();
          const defaultStyles = stylesFactory.newInstance(options.styles.default);
          this.styles = new Styles(__spreadValues(__spreadValues({}, defaultStyles), options.styles));
        } else {
          const stylesFactory = new DefaultStylesFactory();
          this.styles = new Styles(stylesFactory.newInstance());
        }
        this.addDefaultRelationships();
        for (const section of options.sections) {
          this.addSection(section);
        }
        if (options.footnotes) {
          for (const key in options.footnotes) {
            this.footnotesWrapper.View.createFootNote(parseFloat(key), options.footnotes[key].children);
          }
        }
        this.fontWrapper = new FontWrapper((_l = options.fonts) != null ? _l : []);
      }
      addSection({ headers = {}, footers = {}, children, properties }) {
        this.documentWrapper.View.Body.addSection(__spreadProps(__spreadValues({}, properties), {
          headerWrapperGroup: {
            default: headers.default ? this.createHeader(headers.default) : void 0,
            first: headers.first ? this.createHeader(headers.first) : void 0,
            even: headers.even ? this.createHeader(headers.even) : void 0
          },
          footerWrapperGroup: {
            default: footers.default ? this.createFooter(footers.default) : void 0,
            first: footers.first ? this.createFooter(footers.first) : void 0,
            even: footers.even ? this.createFooter(footers.even) : void 0
          }
        }));
        for (const child of children) {
          this.documentWrapper.View.add(child);
        }
      }
      createHeader(header) {
        const wrapper = new HeaderWrapper(this.media, this.currentRelationshipId++);
        for (const child of header.options.children) {
          wrapper.add(child);
        }
        this.addHeaderToDocument(wrapper);
        return wrapper;
      }
      createFooter(footer) {
        const wrapper = new FooterWrapper(this.media, this.currentRelationshipId++);
        for (const child of footer.options.children) {
          wrapper.add(child);
        }
        this.addFooterToDocument(wrapper);
        return wrapper;
      }
      addHeaderToDocument(header, type2 = HeaderFooterReferenceType.DEFAULT) {
        this.headers.push({ header, type: type2 });
        this.documentWrapper.Relationships.createRelationship(
          header.View.ReferenceId,
          "http://schemas.openxmlformats.org/officeDocument/2006/relationships/header",
          `header${this.headers.length}.xml`
        );
        this.contentTypes.addHeader(this.headers.length);
      }
      addFooterToDocument(footer, type2 = HeaderFooterReferenceType.DEFAULT) {
        this.footers.push({ footer, type: type2 });
        this.documentWrapper.Relationships.createRelationship(
          footer.View.ReferenceId,
          "http://schemas.openxmlformats.org/officeDocument/2006/relationships/footer",
          `footer${this.footers.length}.xml`
        );
        this.contentTypes.addFooter(this.footers.length);
      }
      addDefaultRelationships() {
        this.fileRelationships.createRelationship(
          1,
          "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
          "word/document.xml"
        );
        this.fileRelationships.createRelationship(
          2,
          "http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties",
          "docProps/core.xml"
        );
        this.fileRelationships.createRelationship(
          3,
          "http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties",
          "docProps/app.xml"
        );
        this.fileRelationships.createRelationship(
          4,
          "http://schemas.openxmlformats.org/officeDocument/2006/relationships/custom-properties",
          "docProps/custom.xml"
        );
        this.documentWrapper.Relationships.createRelationship(
          // eslint-disable-next-line functional/immutable-data
          this.currentRelationshipId++,
          "http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles",
          "styles.xml"
        );
        this.documentWrapper.Relationships.createRelationship(
          // eslint-disable-next-line functional/immutable-data
          this.currentRelationshipId++,
          "http://schemas.openxmlformats.org/officeDocument/2006/relationships/numbering",
          "numbering.xml"
        );
        this.documentWrapper.Relationships.createRelationship(
          // eslint-disable-next-line functional/immutable-data
          this.currentRelationshipId++,
          "http://schemas.openxmlformats.org/officeDocument/2006/relationships/footnotes",
          "footnotes.xml"
        );
        this.documentWrapper.Relationships.createRelationship(
          // eslint-disable-next-line functional/immutable-data
          this.currentRelationshipId++,
          "http://schemas.openxmlformats.org/officeDocument/2006/relationships/settings",
          "settings.xml"
        );
        this.documentWrapper.Relationships.createRelationship(
          // eslint-disable-next-line functional/immutable-data
          this.currentRelationshipId++,
          "http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments",
          "comments.xml"
        );
      }
      get Document() {
        return this.documentWrapper;
      }
      get Styles() {
        return this.styles;
      }
      get CoreProperties() {
        return this.coreProperties;
      }
      get Numbering() {
        return this.numbering;
      }
      get Media() {
        return this.media;
      }
      get FileRelationships() {
        return this.fileRelationships;
      }
      get Headers() {
        return this.headers.map((item) => item.header);
      }
      get Footers() {
        return this.footers.map((item) => item.footer);
      }
      get ContentTypes() {
        return this.contentTypes;
      }
      get CustomProperties() {
        return this.customProperties;
      }
      get AppProperties() {
        return this.appProperties;
      }
      get FootNotes() {
        return this.footnotesWrapper;
      }
      get Settings() {
        return this.settings;
      }
      get Comments() {
        return this.comments;
      }
      get FontTable() {
        return this.fontWrapper;
      }
    };
    FootNoteReferenceRunAttributes = class extends XmlAttributeComponent {
      constructor() {
        super(...arguments);
        __publicField(this, "xmlKeys", {
          id: "w:id"
        });
      }
    };
    FootnoteReference = class extends XmlComponent {
      constructor(id) {
        super("w:footnoteReference");
        this.root.push(
          new FootNoteReferenceRunAttributes({
            id
          })
        );
      }
    };
    FootnoteReferenceRun = class extends Run {
      constructor(id) {
        super({ style: "FootnoteReference" });
        this.root.push(new FootnoteReference(id));
      }
    };
    streamBrowserifyExports = requireStreamBrowserify();
    jszip_min = { exports: {} };
    jszip_minExports = requireJszip_min();
    JSZip = /* @__PURE__ */ getDefaultExportFromCjs$1(jszip_minExports);
    xml$1 = { exports: {} };
    xmlExports = requireXml();
    xml = /* @__PURE__ */ getDefaultExportFromCjs$1(xmlExports);
    obfuscatedStartOffset = 0;
    obfuscatedEndOffset = 32;
    guidSize = 32;
    obfuscate = (buf, fontKey) => {
      const guid = fontKey.replace(/-/g, "");
      if (guid.length !== guidSize) {
        throw new Error(`Error: Cannot extract GUID from font filename: ${fontKey}`);
      }
      const hexStrings = guid.replace(/(..)/g, "$1 ").trim().split(" ");
      const hexNumbers = hexStrings.map((hexString) => parseInt(hexString, 16));
      hexNumbers.reverse();
      const bytesToObfuscate = buf.slice(obfuscatedStartOffset, obfuscatedEndOffset);
      const obfuscatedBytes = bytesToObfuscate.map((byte, i) => byte ^ hexNumbers[i % hexNumbers.length]);
      const out = new Uint8Array(obfuscatedStartOffset + obfuscatedBytes.length + Math.max(0, buf.length - obfuscatedEndOffset));
      out.set(buf.slice(0, obfuscatedStartOffset));
      out.set(obfuscatedBytes, obfuscatedStartOffset);
      out.set(buf.slice(obfuscatedEndOffset), obfuscatedStartOffset + obfuscatedBytes.length);
      return out;
    };
    Formatter = class {
      format(input, context = { stack: [] }) {
        const output = input.prepForXml(context);
        if (output) {
          return output;
        } else {
          throw Error("XMLComponent did not format correctly");
        }
      }
    };
    ImageReplacer = class {
      replace(xmlData, mediaData, offset) {
        let currentXmlData = xmlData;
        mediaData.forEach((image, i) => {
          currentXmlData = currentXmlData.replace(new RegExp(`{${image.fileName}}`, "g"), (offset + i).toString());
        });
        return currentXmlData;
      }
      getMediaData(xmlData, media) {
        return media.Array.filter((image) => xmlData.search(`{${image.fileName}}`) > 0);
      }
    };
    NumberingReplacer = class {
      replace(xmlData, concreteNumberings) {
        let currentXmlData = xmlData;
        for (const concreteNumbering of concreteNumberings) {
          currentXmlData = currentXmlData.replace(
            new RegExp(`{${concreteNumbering.reference}-${concreteNumbering.instance}}`, "g"),
            concreteNumbering.numId.toString()
          );
        }
        return currentXmlData;
      }
    };
    Compiler = class {
      constructor() {
        __publicField(this, "formatter");
        __publicField(this, "imageReplacer");
        __publicField(this, "numberingReplacer");
        this.formatter = new Formatter();
        this.imageReplacer = new ImageReplacer();
        this.numberingReplacer = new NumberingReplacer();
      }
      compile(file, prettifyXml, overrides = []) {
        const zip = new JSZip();
        const xmlifiedFileMapping = this.xmlifyFile(file, prettifyXml);
        const map = new Map(Object.entries(xmlifiedFileMapping));
        for (const [, obj] of map) {
          if (Array.isArray(obj)) {
            for (const subFile of obj) {
              zip.file(subFile.path, subFile.data);
            }
          } else {
            zip.file(obj.path, obj.data);
          }
        }
        for (const subFile of overrides) {
          zip.file(subFile.path, subFile.data);
        }
        for (const data of file.Media.Array) {
          if (data.type !== "svg") {
            zip.file(`word/media/${data.fileName}`, data.data);
          } else {
            zip.file(`word/media/${data.fileName}`, data.data);
            zip.file(`word/media/${data.fallback.fileName}`, data.fallback.data);
          }
        }
        for (const { data: buffer2, name, fontKey } of file.FontTable.fontOptionsWithKey) {
          const [nameWithoutExtension] = name.split(".");
          zip.file(`word/fonts/${nameWithoutExtension}.odttf`, obfuscate(buffer2, fontKey));
        }
        return zip;
      }
      xmlifyFile(file, prettify) {
        const documentRelationshipCount = file.Document.Relationships.RelationshipCount + 1;
        const documentXmlData = xml(
          this.formatter.format(file.Document.View, {
            viewWrapper: file.Document,
            file,
            stack: []
          }),
          {
            indent: prettify,
            declaration: {
              standalone: "yes",
              encoding: "UTF-8"
            }
          }
        );
        const commentRelationshipCount = file.Comments.Relationships.RelationshipCount + 1;
        const commentXmlData = xml(
          this.formatter.format(file.Comments, {
            viewWrapper: {
              View: file.Comments,
              Relationships: file.Comments.Relationships
            },
            file,
            stack: []
          }),
          {
            indent: prettify,
            declaration: {
              standalone: "yes",
              encoding: "UTF-8"
            }
          }
        );
        const documentMediaDatas = this.imageReplacer.getMediaData(documentXmlData, file.Media);
        const commentMediaDatas = this.imageReplacer.getMediaData(commentXmlData, file.Media);
        return {
          Relationships: {
            data: (() => {
              documentMediaDatas.forEach((mediaData, i) => {
                file.Document.Relationships.createRelationship(
                  documentRelationshipCount + i,
                  "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
                  `media/${mediaData.fileName}`
                );
              });
              file.Document.Relationships.createRelationship(
                file.Document.Relationships.RelationshipCount + 1,
                "http://schemas.openxmlformats.org/officeDocument/2006/relationships/fontTable",
                "fontTable.xml"
              );
              return xml(
                this.formatter.format(file.Document.Relationships, {
                  viewWrapper: file.Document,
                  file,
                  stack: []
                }),
                {
                  indent: prettify,
                  declaration: {
                    encoding: "UTF-8"
                  }
                }
              );
            })(),
            path: "word/_rels/document.xml.rels"
          },
          Document: {
            data: (() => {
              const xmlData = this.imageReplacer.replace(documentXmlData, documentMediaDatas, documentRelationshipCount);
              const referenedXmlData = this.numberingReplacer.replace(xmlData, file.Numbering.ConcreteNumbering);
              return referenedXmlData;
            })(),
            path: "word/document.xml"
          },
          Styles: {
            data: (() => {
              const xmlStyles = xml(
                this.formatter.format(file.Styles, {
                  viewWrapper: file.Document,
                  file,
                  stack: []
                }),
                {
                  indent: prettify,
                  declaration: {
                    standalone: "yes",
                    encoding: "UTF-8"
                  }
                }
              );
              const referencedXmlStyles = this.numberingReplacer.replace(xmlStyles, file.Numbering.ConcreteNumbering);
              return referencedXmlStyles;
            })(),
            path: "word/styles.xml"
          },
          Properties: {
            data: xml(
              this.formatter.format(file.CoreProperties, {
                viewWrapper: file.Document,
                file,
                stack: []
              }),
              {
                indent: prettify,
                declaration: {
                  standalone: "yes",
                  encoding: "UTF-8"
                }
              }
            ),
            path: "docProps/core.xml"
          },
          Numbering: {
            data: xml(
              this.formatter.format(file.Numbering, {
                viewWrapper: file.Document,
                file,
                stack: []
              }),
              {
                indent: prettify,
                declaration: {
                  standalone: "yes",
                  encoding: "UTF-8"
                }
              }
            ),
            path: "word/numbering.xml"
          },
          FileRelationships: {
            data: xml(
              this.formatter.format(file.FileRelationships, {
                viewWrapper: file.Document,
                file,
                stack: []
              }),
              {
                indent: prettify,
                declaration: {
                  encoding: "UTF-8"
                }
              }
            ),
            path: "_rels/.rels"
          },
          HeaderRelationships: file.Headers.map((headerWrapper, index) => {
            const xmlData = xml(
              this.formatter.format(headerWrapper.View, {
                viewWrapper: headerWrapper,
                file,
                stack: []
              }),
              {
                indent: prettify,
                declaration: {
                  encoding: "UTF-8"
                }
              }
            );
            const mediaDatas = this.imageReplacer.getMediaData(xmlData, file.Media);
            mediaDatas.forEach((mediaData, i) => {
              headerWrapper.Relationships.createRelationship(
                i,
                "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
                `media/${mediaData.fileName}`
              );
            });
            return {
              data: xml(
                this.formatter.format(headerWrapper.Relationships, {
                  viewWrapper: headerWrapper,
                  file,
                  stack: []
                }),
                {
                  indent: prettify,
                  declaration: {
                    encoding: "UTF-8"
                  }
                }
              ),
              path: `word/_rels/header${index + 1}.xml.rels`
            };
          }),
          FooterRelationships: file.Footers.map((footerWrapper, index) => {
            const xmlData = xml(
              this.formatter.format(footerWrapper.View, {
                viewWrapper: footerWrapper,
                file,
                stack: []
              }),
              {
                indent: prettify,
                declaration: {
                  encoding: "UTF-8"
                }
              }
            );
            const mediaDatas = this.imageReplacer.getMediaData(xmlData, file.Media);
            mediaDatas.forEach((mediaData, i) => {
              footerWrapper.Relationships.createRelationship(
                i,
                "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
                `media/${mediaData.fileName}`
              );
            });
            return {
              data: xml(
                this.formatter.format(footerWrapper.Relationships, {
                  viewWrapper: footerWrapper,
                  file,
                  stack: []
                }),
                {
                  indent: prettify,
                  declaration: {
                    encoding: "UTF-8"
                  }
                }
              ),
              path: `word/_rels/footer${index + 1}.xml.rels`
            };
          }),
          Headers: file.Headers.map((headerWrapper, index) => {
            const tempXmlData = xml(
              this.formatter.format(headerWrapper.View, {
                viewWrapper: headerWrapper,
                file,
                stack: []
              }),
              {
                indent: prettify,
                declaration: {
                  encoding: "UTF-8"
                }
              }
            );
            const mediaDatas = this.imageReplacer.getMediaData(tempXmlData, file.Media);
            const xmlData = this.imageReplacer.replace(tempXmlData, mediaDatas, 0);
            const referenedXmlData = this.numberingReplacer.replace(xmlData, file.Numbering.ConcreteNumbering);
            return {
              data: referenedXmlData,
              path: `word/header${index + 1}.xml`
            };
          }),
          Footers: file.Footers.map((footerWrapper, index) => {
            const tempXmlData = xml(
              this.formatter.format(footerWrapper.View, {
                viewWrapper: footerWrapper,
                file,
                stack: []
              }),
              {
                indent: prettify,
                declaration: {
                  encoding: "UTF-8"
                }
              }
            );
            const mediaDatas = this.imageReplacer.getMediaData(tempXmlData, file.Media);
            const xmlData = this.imageReplacer.replace(tempXmlData, mediaDatas, 0);
            const referenedXmlData = this.numberingReplacer.replace(xmlData, file.Numbering.ConcreteNumbering);
            return {
              data: referenedXmlData,
              path: `word/footer${index + 1}.xml`
            };
          }),
          ContentTypes: {
            data: xml(
              this.formatter.format(file.ContentTypes, {
                viewWrapper: file.Document,
                file,
                stack: []
              }),
              {
                indent: prettify,
                declaration: {
                  encoding: "UTF-8"
                }
              }
            ),
            path: "[Content_Types].xml"
          },
          CustomProperties: {
            data: xml(
              this.formatter.format(file.CustomProperties, {
                viewWrapper: file.Document,
                file,
                stack: []
              }),
              {
                indent: prettify,
                declaration: {
                  standalone: "yes",
                  encoding: "UTF-8"
                }
              }
            ),
            path: "docProps/custom.xml"
          },
          AppProperties: {
            data: xml(
              this.formatter.format(file.AppProperties, {
                viewWrapper: file.Document,
                file,
                stack: []
              }),
              {
                indent: prettify,
                declaration: {
                  standalone: "yes",
                  encoding: "UTF-8"
                }
              }
            ),
            path: "docProps/app.xml"
          },
          FootNotes: {
            data: xml(
              this.formatter.format(file.FootNotes.View, {
                viewWrapper: file.FootNotes,
                file,
                stack: []
              }),
              {
                indent: prettify,
                declaration: {
                  encoding: "UTF-8"
                }
              }
            ),
            path: "word/footnotes.xml"
          },
          FootNotesRelationships: {
            data: xml(
              this.formatter.format(file.FootNotes.Relationships, {
                viewWrapper: file.FootNotes,
                file,
                stack: []
              }),
              {
                indent: prettify,
                declaration: {
                  encoding: "UTF-8"
                }
              }
            ),
            path: "word/_rels/footnotes.xml.rels"
          },
          Settings: {
            data: xml(
              this.formatter.format(file.Settings, {
                viewWrapper: file.Document,
                file,
                stack: []
              }),
              {
                indent: prettify,
                declaration: {
                  standalone: "yes",
                  encoding: "UTF-8"
                }
              }
            ),
            path: "word/settings.xml"
          },
          Comments: {
            data: (() => {
              const xmlData = this.imageReplacer.replace(commentXmlData, commentMediaDatas, commentRelationshipCount);
              const referenedXmlData = this.numberingReplacer.replace(xmlData, file.Numbering.ConcreteNumbering);
              return referenedXmlData;
            })(),
            path: "word/comments.xml"
          },
          CommentsRelationships: {
            data: (() => {
              commentMediaDatas.forEach((mediaData, i) => {
                file.Comments.Relationships.createRelationship(
                  commentRelationshipCount + i,
                  "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
                  `media/${mediaData.fileName}`
                );
              });
              return xml(
                this.formatter.format(file.Comments.Relationships, {
                  viewWrapper: {
                    View: file.Comments,
                    Relationships: file.Comments.Relationships
                  },
                  file,
                  stack: []
                }),
                {
                  indent: prettify,
                  declaration: {
                    encoding: "UTF-8"
                  }
                }
              );
            })(),
            path: "word/_rels/comments.xml.rels"
          },
          FontTable: {
            data: xml(
              this.formatter.format(file.FontTable.View, {
                viewWrapper: file.Document,
                file,
                stack: []
              }),
              {
                indent: prettify,
                declaration: {
                  standalone: "yes",
                  encoding: "UTF-8"
                }
              }
            ),
            path: "word/fontTable.xml"
          },
          FontTableRelationships: {
            data: (() => xml(
              this.formatter.format(file.FontTable.Relationships, {
                viewWrapper: file.Document,
                file,
                stack: []
              }),
              {
                indent: prettify,
                declaration: {
                  encoding: "UTF-8"
                }
              }
            ))(),
            path: "word/_rels/fontTable.xml.rels"
          }
        };
      }
    };
    PrettifyType = {
      NONE: "",
      WITH_2_BLANKS: "  ",
      WITH_4_BLANKS: "    ",
      WITH_TAB: "	"
    };
    convertPrettifyType = (prettify) => prettify === true ? PrettifyType.WITH_2_BLANKS : prettify === false ? void 0 : prettify;
    _Packer = class _Packer2 {
      // eslint-disable-next-line require-await
      static pack(_0, _12, _2) {
        return __async(this, arguments, function* (file, type2, prettify, overrides = []) {
          const zip = this.compiler.compile(file, convertPrettifyType(prettify), overrides);
          return zip.generateAsync({
            type: type2,
            mimeType: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
            compression: "DEFLATE"
          });
        });
      }
      static toString(file, prettify, overrides = []) {
        return _Packer2.pack(file, "string", prettify, overrides);
      }
      static toBuffer(file, prettify, overrides = []) {
        return _Packer2.pack(file, "nodebuffer", prettify, overrides);
      }
      static toBase64String(file, prettify, overrides = []) {
        return _Packer2.pack(file, "base64", prettify, overrides);
      }
      static toBlob(file, prettify, overrides = []) {
        return _Packer2.pack(file, "blob", prettify, overrides);
      }
      static toArrayBuffer(file, prettify, overrides = []) {
        return _Packer2.pack(file, "arraybuffer", prettify, overrides);
      }
      static toStream(file, prettify, overrides = []) {
        const stream = new streamBrowserifyExports.Stream();
        const zip = this.compiler.compile(file, convertPrettifyType(prettify), overrides);
        zip.generateAsync({
          type: "nodebuffer",
          mimeType: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
          compression: "DEFLATE"
        }).then((z) => {
          stream.emit("data", z);
          stream.emit("end");
        });
        return stream;
      }
    };
    __publicField(_Packer, "compiler", new Compiler());
    Packer = _Packer;
    formatter$1 = new Formatter();
    formatter = new Formatter();
    imageReplacer = new ImageReplacer();
    UTF16LE = new Uint8Array([255, 254]);
    UTF16BE = new Uint8Array([254, 255]);
  }
});

// node_modules/.pnpm/image-dimensions@2.5.0/node_modules/image-dimensions/utilities.js
function isValidOffsetToRead(dataView, offset, bytesToRead) {
  return dataView.byteLength >= offset + bytesToRead;
}
function getUint32(dataView, offset, littleEndian = false) {
  if (isValidOffsetToRead(dataView, offset, 4)) {
    return dataView.getUint32(offset, littleEndian);
  }
}
function getUint16(dataView, offset, littleEndian = false) {
  if (isValidOffsetToRead(dataView, offset, 2)) {
    return dataView.getUint16(offset, littleEndian);
  }
}
function getIsobmffFtypBrands(bytes) {
  if (bytes.length < 16) {
    return;
  }
  const isFtyp = bytes[4] === 102 && bytes[5] === 116 && bytes[6] === 121 && bytes[7] === 112;
  if (!isFtyp) {
    return;
  }
  const dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
  const size = getUint32(dataView, 0);
  if (size === void 0 || size < 16 || size > bytes.length) {
    return;
  }
  const brands = [];
  brands.push(String.fromCodePoint(...bytes.slice(8, 12)));
  for (let i = 16; i + 4 <= size; i += 4) {
    brands.push(String.fromCodePoint(...bytes.slice(i, i + 4)));
  }
  return brands;
}
function unboxIsobmffBox(data, offset) {
  const dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);
  const size = getUint32(dataView, offset);
  if (size === void 0) {
    return;
  }
  if (data.length < size + offset || size < 8) {
    return;
  }
  return {
    type: String.fromCodePoint(...data.slice(offset + 4, offset + 8)),
    data: data.slice(offset + 8, offset + size),
    tail: offset + size
  };
}
function getIsobmffIspeSizesFromMeta(data) {
  const sizes = [];
  let offset = 0;
  while (offset < data.length) {
    const box = unboxIsobmffBox(data, offset);
    if (!box) {
      break;
    }
    if (box.type === "meta") {
      parseIsobmffMetaBox(box.data, sizes);
    }
    offset = box.tail;
  }
  return sizes;
}
function parseIsobmffMetaBox(data, sizes) {
  let offset = 4;
  while (offset < data.length) {
    const box = unboxIsobmffBox(data, offset);
    if (!box) {
      break;
    }
    if (box.type === "iprp") {
      parseIsobmffIprpBox(box.data, sizes);
    }
    offset = box.tail;
  }
  return sizes;
}
function parseIsobmffIprpBox(data, sizes) {
  let offset = 0;
  while (offset < data.length) {
    const box = unboxIsobmffBox(data, offset);
    if (!box) {
      break;
    }
    if (box.type === "ipco") {
      parseIsobmffIpcoBox(box.data, sizes);
    }
    offset = box.tail;
  }
}
function parseIsobmffIpcoBox(data, sizes) {
  let offset = 0;
  while (offset < data.length) {
    const box = unboxIsobmffBox(data, offset);
    if (!box) {
      break;
    }
    if (box.type === "ispe") {
      const dataView = new DataView(box.data.buffer, box.data.byteOffset, box.data.byteLength);
      const width = getUint32(dataView, 4);
      const height = getUint32(dataView, 8);
      if (width === void 0 || height === void 0) {
        return;
      }
      sizes.push({
        width,
        height
      });
    }
    offset = box.tail;
  }
}
function getLargestAreaSize(sizes) {
  let maxSize = sizes[0];
  for (const size of sizes) {
    if (size.width * size.height > maxSize.width * maxSize.height) {
      maxSize = size;
    }
  }
  return maxSize;
}
var init_utilities = __esm({
  "node_modules/.pnpm/image-dimensions@2.5.0/node_modules/image-dimensions/utilities.js"() {
  }
});

// node_modules/.pnpm/image-dimensions@2.5.0/node_modules/image-dimensions/types/png.js
function png(bytes) {
  if (!isPng(bytes)) {
    return;
  }
  const dataView = new DataView(bytes.buffer);
  const isAppleMinified = isAppleMinifiedPng(bytes);
  const width = getUint32(dataView, isAppleMinified ? 32 : 16, false);
  const height = getUint32(dataView, isAppleMinified ? 36 : 20, false);
  if (width === void 0 || height === void 0) {
    return;
  }
  return {
    width,
    height,
    type: "png"
  };
}
var isPng, isAppleMinifiedPng;
var init_png = __esm({
  "node_modules/.pnpm/image-dimensions@2.5.0/node_modules/image-dimensions/types/png.js"() {
    init_utilities();
    isPng = (bytes) => bytes[0] === 137 && bytes[1] === 80 && bytes[2] === 78 && bytes[3] === 71 && bytes[4] === 13 && bytes[5] === 10 && bytes[6] === 26 && bytes[7] === 10;
    isAppleMinifiedPng = (bytes) => bytes[12] === 67 && bytes[13] === 103 && bytes[14] === 66 && bytes[15] === 73;
  }
});

// node_modules/.pnpm/image-dimensions@2.5.0/node_modules/image-dimensions/types/jpeg.js
function jpeg(bytes) {
  if (!jsJpeg(bytes)) {
    return;
  }
  const dataView = new DataView(bytes.buffer);
  let offset = 2;
  while (isValidOffsetToRead(dataView, offset, 2)) {
    const marker = dataView.getUint16(offset);
    offset += 2;
    if (marker >= SOF0 && marker <= SOF3) {
      const height = getUint16(dataView, offset + 3, false);
      const width = getUint16(dataView, offset + 5, false);
      if (height === void 0 || width === void 0) {
        return;
      }
      return {
        height,
        width,
        type: "jpeg"
      };
    }
    const segmentLength = getUint16(dataView, offset);
    if (segmentLength === void 0) {
      return;
    }
    offset += segmentLength;
    if (offset > dataView.byteLength) {
      return;
    }
  }
}
var SOF0, SOF3, jsJpeg;
var init_jpeg = __esm({
  "node_modules/.pnpm/image-dimensions@2.5.0/node_modules/image-dimensions/types/jpeg.js"() {
    init_utilities();
    SOF0 = 65472;
    SOF3 = 65475;
    jsJpeg = (bytes) => bytes[0] === 255 && bytes[1] === 216 && bytes[2] === 255;
  }
});

// node_modules/.pnpm/image-dimensions@2.5.0/node_modules/image-dimensions/types/gif.js
function gif(bytes) {
  if (!isGif(bytes)) {
    return;
  }
  const dataView = new DataView(bytes.buffer);
  const width = getUint16(dataView, 6, true);
  const height = getUint16(dataView, 8, true);
  if (width === void 0 || height === void 0) {
    return;
  }
  return {
    width,
    height,
    type: "gif"
  };
}
var isGif;
var init_gif = __esm({
  "node_modules/.pnpm/image-dimensions@2.5.0/node_modules/image-dimensions/types/gif.js"() {
    init_utilities();
    isGif = (bytes) => bytes[0] === 71 && bytes[1] === 73 && bytes[2] === 70 && bytes[3] === 56 && (bytes[4] === 55 || bytes[4] === 57) && bytes[5] === 97;
  }
});

// node_modules/.pnpm/image-dimensions@2.5.0/node_modules/image-dimensions/types/webp.js
function readUInt24LE(dataView, offset) {
  const byte1 = dataView.getUint8(offset);
  const byte2 = dataView.getUint8(offset + 1);
  const byte3 = dataView.getUint8(offset + 2);
  return byte3 << 16 | byte2 << 8 | byte1;
}
function webp(bytes) {
  if (!isWebp(bytes)) {
    return;
  }
  const dataView = new DataView(bytes.buffer);
  const maxSize = 16383;
  if (isVP8Lossy(bytes)) {
    if (!isValidOffsetToRead(dataView, 28, 2)) {
      return;
    }
    return {
      // eslint-disable-next-line no-bitwise
      width: dataView.getUint16(26, true) & maxSize,
      // eslint-disable-next-line no-bitwise
      height: dataView.getUint16(28, true) & maxSize,
      type: "webp"
    };
  }
  if (isVP8Lossless(bytes)) {
    const bits = getUint32(dataView, 21, true);
    if (bits === void 0) {
      return;
    }
    return {
      // eslint-disable-next-line no-bitwise
      width: (bits & maxSize) + 1,
      // eslint-disable-next-line no-bitwise
      height: (bits >> 14 & maxSize) + 1,
      type: "webp"
    };
  }
  if (isVP8Extended(bytes)) {
    if (!isValidOffsetToRead(dataView, 27, 3)) {
      return;
    }
    return {
      width: readUInt24LE(dataView, 24) + 1,
      height: readUInt24LE(dataView, 27) + 1,
      type: "webp"
    };
  }
}
var isWebp, isVP8Lossy, isVP8Lossless, isVP8Extended;
var init_webp = __esm({
  "node_modules/.pnpm/image-dimensions@2.5.0/node_modules/image-dimensions/types/webp.js"() {
    init_utilities();
    isWebp = (bytes) => (
      // RIFF
      bytes[0] === 82 && bytes[1] === 73 && bytes[2] === 70 && bytes[3] === 70 && bytes[8] === 87 && bytes[9] === 69 && bytes[10] === 66 && bytes[11] === 80
    );
    isVP8Lossy = (bytes) => (
      // `VP8 ` (note the space)
      bytes[12] === 86 && bytes[13] === 80 && bytes[14] === 56 && bytes[15] === 32
    );
    isVP8Lossless = (bytes) => (
      // `VP8L`
      bytes[12] === 86 && bytes[13] === 80 && bytes[14] === 56 && bytes[15] === 76
    );
    isVP8Extended = (bytes) => (
      // `VP8X`
      bytes[12] === 86 && bytes[13] === 80 && bytes[14] === 56 && bytes[15] === 88
    );
  }
});

// node_modules/.pnpm/image-dimensions@2.5.0/node_modules/image-dimensions/types/avif.js
function avif(bytes) {
  if (!isAvif(bytes)) {
    return;
  }
  const sizes = getIsobmffIspeSizesFromMeta(bytes);
  if (sizes.length === 0) {
    return;
  }
  return {
    ...getLargestAreaSize(sizes),
    type: "avif"
  };
}
var avifBrands, isAvif;
var init_avif = __esm({
  "node_modules/.pnpm/image-dimensions@2.5.0/node_modules/image-dimensions/types/avif.js"() {
    init_utilities();
    avifBrands = /* @__PURE__ */ new Set([
      "avif",
      "avis",
      "avio"
    ]);
    isAvif = (bytes) => {
      const brands = getIsobmffFtypBrands(bytes);
      if (!brands) {
        return false;
      }
      return brands.some((brand) => avifBrands.has(brand));
    };
  }
});

// node_modules/.pnpm/image-dimensions@2.5.0/node_modules/image-dimensions/types/heic.js
function heic(bytes) {
  if (!isHeic(bytes)) {
    return;
  }
  const sizes = getIsobmffIspeSizesFromMeta(bytes);
  if (sizes.length === 0) {
    return;
  }
  return {
    ...getLargestAreaSize(sizes),
    type: "heic"
  };
}
var heifBrands, isHeic;
var init_heic = __esm({
  "node_modules/.pnpm/image-dimensions@2.5.0/node_modules/image-dimensions/types/heic.js"() {
    init_utilities();
    heifBrands = /* @__PURE__ */ new Set([
      "mif1",
      "msf1",
      "heic",
      "heix",
      "hevc",
      "hevx",
      "heim",
      "heis",
      "hevm",
      "hevs"
    ]);
    isHeic = (bytes) => {
      const brands = getIsobmffFtypBrands(bytes);
      if (!brands) {
        return false;
      }
      return brands.some((brand) => heifBrands.has(brand));
    };
  }
});

// node_modules/.pnpm/image-dimensions@2.5.0/node_modules/image-dimensions/index.js
function imageDimensionsFromData(bytes) {
  if (bytes.length < 3) {
    return;
  }
  bytes = new Uint8Array(bytes);
  return png(bytes) ?? gif(bytes) ?? jpeg(bytes) ?? webp(bytes) ?? avif(bytes) ?? heic(bytes);
}
var init_image_dimensions = __esm({
  "node_modules/.pnpm/image-dimensions@2.5.0/node_modules/image-dimensions/index.js"() {
    init_png();
    init_jpeg();
    init_gif();
    init_webp();
    init_avif();
    init_heic();
  }
});

// node_modules/.pnpm/prosemirror-docx@0.6.1_docx@9.5.1/node_modules/prosemirror-docx/dist/esm/numbering.js
function basicIndentStyle(indent) {
  return {
    alignment: AlignmentType.START,
    style: {
      paragraph: {
        indent: { left: convertInchesToTwip(indent), hanging: convertInchesToTwip(0.18) }
      }
    }
  };
}
function createNumbering(reference, style) {
  return {
    reference,
    levels: styles[style]
  };
}
var numbered, bullets, styles;
var init_numbering = __esm({
  "node_modules/.pnpm/prosemirror-docx@0.6.1_docx@9.5.1/node_modules/prosemirror-docx/dist/esm/numbering.js"() {
    init_dist();
    numbered = Array(3).fill([LevelFormat.DECIMAL, LevelFormat.LOWER_LETTER, LevelFormat.LOWER_ROMAN]).flat().map((format, level) => Object.assign({
      level,
      format,
      text: `%${level + 1}.`
    }, basicIndentStyle((level + 1) / 2)));
    bullets = Array(3).fill(["\u25CF", "\u25CB", "\u25A0"]).flat().map((text, level) => Object.assign({ level, format: LevelFormat.BULLET, text }, basicIndentStyle((level + 1) / 2)));
    styles = {
      numbered,
      bullets
    };
  }
});

// node_modules/.pnpm/prosemirror-docx@0.6.1_docx@9.5.1/node_modules/prosemirror-docx/dist/esm/utils.js
function createShortId() {
  return Math.random().toString(36).slice(2, 11);
}
function buildDoc(state2, opts) {
  var _a;
  let sections = (_a = state2 === null || state2 === void 0 ? void 0 : state2.sections) === null || _a === void 0 ? void 0 : _a.map((section) => ({
    properties: section.config.properties || {
      type: SectionType.CONTINUOUS
    },
    headers: section.config.headers,
    footers: section.config.footers,
    children: section.children
  }));
  if (!sections) {
    sections = [
      {
        headers: void 0,
        footers: void 0,
        properties: {
          type: SectionType.CONTINUOUS
        },
        children: (state2 === null || state2 === void 0 ? void 0 : state2.children) || []
      }
    ];
  }
  const doc = new File(Object.assign({ footnotes: state2.footnotes, numbering: {
    config: state2.numbering
  }, sections }, opts || {}));
  return doc;
}
function createDocFromState(state2) {
  return buildDoc({
    numbering: state2.numbering,
    sections: [
      {
        config: {},
        children: state2.children
      }
    ],
    footnotes: state2.footnotes
  });
}
function writeDocx(doc, write) {
  return __awaiter(this, void 0, void 0, function* () {
    const buffer2 = yield Packer.toBuffer(doc);
    yield write === null || write === void 0 ? void 0 : write(buffer2);
    return buffer2;
  });
}
function getLatexFromNode(node) {
  let math = "";
  node.forEach((child) => {
    if (child.isText)
      math += child.text;
  });
  return math;
}
var __awaiter;
var init_utils = __esm({
  "node_modules/.pnpm/prosemirror-docx@0.6.1_docx@9.5.1/node_modules/prosemirror-docx/dist/esm/utils.js"() {
    init_dist();
    __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
  }
});

// node_modules/.pnpm/prosemirror-docx@0.6.1_docx@9.5.1/node_modules/prosemirror-docx/dist/esm/serializer.js
function createReferenceBookmark(id, kind, before, after) {
  const textBefore = before ? [new TextRun(before)] : [];
  const textAfter = after ? [new TextRun(after)] : [];
  return new Bookmark({
    id,
    children: [...textBefore, new SequentialIdentifier(kind), ...textAfter]
  });
}
var __awaiter2, MAX_IMAGE_WIDTH, DocxSerializerState, DocxSerializer, DocxSerializerStateAsync, DocxSerializerAsync;
var init_serializer = __esm({
  "node_modules/.pnpm/prosemirror-docx@0.6.1_docx@9.5.1/node_modules/prosemirror-docx/dist/esm/serializer.js"() {
    init_dist();
    init_image_dimensions();
    init_numbering();
    init_utils();
    __awaiter2 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    MAX_IMAGE_WIDTH = 600;
    DocxSerializerState = class {
      constructor(nodes, marks, options) {
        this.currentSectionIndex = 0;
        this.footnotes = {};
        this.current = [];
        this.maxImageWidth = MAX_IMAGE_WIDTH;
        this.$footnoteCounter = 0;
        this.nodes = nodes;
        this.marks = marks;
        this.options = options !== null && options !== void 0 ? options : {};
        this.children = [];
        this.numbering = [];
        if (options.sections && options.sections.length > 0) {
          this.sections = options.sections.map((config) => ({
            config,
            children: []
          }));
          this.children = this.sections[0].children;
        } else {
          this.sections = [];
        }
      }
      renderContent(parent, opts) {
        parent.forEach((node, _, i) => {
          if (opts)
            this.addParagraphOptions(opts);
          this.render(node, parent, i);
        });
      }
      render(node, parent, index) {
        if (typeof parent === "number")
          throw new Error("!");
        if (!this.nodes[node.type.name])
          throw new Error(`Token type \`${node.type.name}\` not supported by Word renderer`);
        this.nodes[node.type.name](this, node, parent, index);
      }
      renderMarks(node, marks) {
        return marks.map((mark) => {
          var _a, _b;
          return (_b = (_a = this.marks)[mark.type.name]) === null || _b === void 0 ? void 0 : _b.call(_a, this, node, mark);
        }).reduce((a, b) => Object.assign(Object.assign({}, a), b), {});
      }
      renderInline(parent) {
        let currentLink;
        const closeLink = () => {
          if (!currentLink)
            return;
          const hyperlink = new ExternalHyperlink({
            link: currentLink.link,
            // child: this.current[0],
            children: this.current
          });
          this.current = [...currentLink.stack, hyperlink];
          currentLink = void 0;
        };
        const openLink = (href) => {
          const sameLink = href === (currentLink === null || currentLink === void 0 ? void 0 : currentLink.link);
          this.addRunOptions({ style: "Hyperlink" });
          const oneLink = true;
          if (!oneLink) {
            closeLink();
          } else {
            if (currentLink && sameLink)
              return;
            if (currentLink && !sameLink) {
              closeLink();
            }
          }
          currentLink = {
            link: href,
            stack: this.current
          };
          this.current = [];
        };
        const progress = (node, offset, index) => {
          const links = node.marks.filter((m) => m.type.name === "link");
          const hasLink = links.length > 0;
          if (hasLink) {
            openLink(links[0].attrs.href);
          } else if (!hasLink && currentLink) {
            closeLink();
          }
          if (node.isText) {
            this.text(node.text, this.renderMarks(node, [...node.marks]));
          } else {
            this.render(node, parent, index);
          }
        };
        parent.forEach(progress);
        closeLink();
      }
      renderList(node, style) {
        if (!this.currentNumbering) {
          const nextId = createShortId();
          this.numbering.push(createNumbering(nextId, style));
          this.currentNumbering = { reference: nextId, level: 0 };
        } else {
          const { reference, level } = this.currentNumbering;
          this.currentNumbering = { reference, level: level + 1 };
        }
        this.renderContent(node);
        if (this.currentNumbering.level === 0) {
          delete this.currentNumbering;
        } else {
          const { reference, level } = this.currentNumbering;
          this.currentNumbering = { reference, level: level - 1 };
        }
      }
      // This is a pass through to the paragraphs, etc. underneath they will close the block
      renderListItem(node) {
        if (!this.currentNumbering)
          throw new Error("Trying to create a list item without a list?");
        this.addParagraphOptions({ numbering: this.currentNumbering });
        this.renderContent(node);
      }
      addParagraphOptions(opts) {
        this.nextParentParagraphOpts = Object.assign(Object.assign({}, this.nextParentParagraphOpts), opts);
      }
      addRunOptions(opts) {
        this.nextRunOpts = Object.assign(Object.assign({}, this.nextRunOpts), opts);
      }
      text(text, opts) {
        if (!text)
          return;
        this.current.push(new TextRun(Object.assign(Object.assign({ text }, this.nextRunOpts), opts)));
        delete this.nextRunOpts;
      }
      math(latex, opts = { inline: true }) {
        var _a;
        if (opts.inline || !opts.numbered) {
          this.current.push(new Math$1({ children: [new MathRun(latex)] }));
          return;
        }
        const id = (_a = opts.id) !== null && _a !== void 0 ? _a : createShortId();
        this.current = [
          new TextRun("	"),
          new Math$1({
            children: [new MathRun(latex)]
          }),
          new TextRun("	("),
          createReferenceBookmark(id, "Equation"),
          new TextRun(")")
        ];
        this.addParagraphOptions({
          tabStops: [
            {
              type: TabStopType.CENTER,
              position: TabStopPosition.MAX / 2
            },
            {
              type: TabStopType.RIGHT,
              position: TabStopPosition.MAX
            }
          ]
        });
      }
      image(src, widthPercent = 70, align = "center", imageRunOpts, imageType) {
        const buffer2 = this.options.getImageBuffer(src);
        const dimensions = imageDimensionsFromData(buffer2);
        if (!dimensions)
          return;
        const aspect = dimensions.height / dimensions.width;
        const width = this.maxImageWidth * (widthPercent / 100);
        let it;
        try {
          it = imageType || src.replace(/.*\./, "").toLowerCase();
        } catch (e) {
          it = "png";
        }
        this.current.push(new ImageRun(Object.assign(Object.assign({ data: buffer2 }, imageRunOpts), { type: it, transformation: Object.assign(Object.assign({}, (imageRunOpts === null || imageRunOpts === void 0 ? void 0 : imageRunOpts.transformation) || {}), { width, height: width * aspect }) })));
        let alignment;
        switch (align) {
          case "right":
            alignment = AlignmentType.RIGHT;
            break;
          case "left":
            alignment = AlignmentType.LEFT;
            break;
          default:
            alignment = AlignmentType.CENTER;
        }
        this.addParagraphOptions({
          alignment
        });
      }
      table(node, opts = {}) {
        const { getCellOptions, getRowOptions, tableOptions } = opts;
        const actualChildren = this.children;
        const rows = [];
        node.content.forEach((row) => {
          const cells = [];
          let tableHeader = true;
          row.content.forEach((cell) => {
            if (cell.type.name !== "table_header") {
              tableHeader = false;
            }
          });
          this.maxImageWidth = MAX_IMAGE_WIDTH / row.content.childCount;
          row.content.forEach((cell) => {
            var _a, _b;
            this.children = [];
            this.renderContent(cell);
            const tableCellOpts = { children: this.children };
            const colspan = (_a = cell.attrs.colspan) !== null && _a !== void 0 ? _a : 1;
            const rowspan = (_b = cell.attrs.rowspan) !== null && _b !== void 0 ? _b : 1;
            if (colspan > 1)
              tableCellOpts.columnSpan = colspan;
            if (rowspan > 1)
              tableCellOpts.rowSpan = rowspan;
            cells.push(new TableCell(Object.assign(Object.assign({}, tableCellOpts), (getCellOptions === null || getCellOptions === void 0 ? void 0 : getCellOptions(cell)) || {})));
          });
          rows.push(new TableRow(Object.assign(Object.assign({}, (getRowOptions === null || getRowOptions === void 0 ? void 0 : getRowOptions(row)) || {}), { children: cells, tableHeader })));
        });
        this.maxImageWidth = MAX_IMAGE_WIDTH;
        const table = new Table(Object.assign(Object.assign({}, tableOptions), { rows }));
        actualChildren.push(table);
        actualChildren.push(new Paragraph(""));
        this.children = actualChildren;
      }
      captionLabel(id, kind, { suffix } = { suffix: ": " }) {
        this.current.push(...[createReferenceBookmark(id, kind, `${kind} `), new TextRun(suffix)]);
      }
      footnote(node) {
        const { current, nextRunOpts } = this;
        this.current = [];
        delete this.nextRunOpts;
        this.$footnoteCounter += 1;
        this.renderInline(node);
        this.footnotes[this.$footnoteCounter] = {
          children: [new Paragraph({ children: this.current })]
        };
        this.current = current;
        this.nextRunOpts = nextRunOpts;
        this.current.push(new FootnoteReferenceRun(this.$footnoteCounter));
      }
      closeBlock(node, props) {
        const paragraph = new Paragraph(Object.assign(Object.assign({ children: this.current }, this.nextParentParagraphOpts), props));
        this.current = [];
        delete this.nextParentParagraphOpts;
        this.children.push(paragraph);
      }
      /**
       * Move to the next section. If no more sections are available,
       * this will be ignored (content continues in current section).
       */
      nextSection() {
        if (this.currentSectionIndex < this.sections.length - 1) {
          this.currentSectionIndex += 1;
          this.children = this.sections[this.currentSectionIndex].children;
        }
      }
      /**
       * Update the current section's configuration
       */
      setSectionConfig(config) {
        this.sections[this.currentSectionIndex].config = Object.assign(Object.assign({}, this.sections[this.currentSectionIndex].config), config);
      }
      /**
       * Add a new section with the given configuration and switch to it
       */
      addSection(config = {}) {
        this.sections.push({
          config,
          children: []
        });
        this.currentSectionIndex = this.sections.length - 1;
        this.children = this.sections[this.currentSectionIndex].children;
      }
      /**
       * Get the current section index
       */
      getCurrentSectionIndex() {
        return this.currentSectionIndex;
      }
      /**
       * Get the current section configuration
       */
      getCurrentSectionConfig() {
        return this.sections[this.currentSectionIndex].config;
      }
      /**
       * Get the current serialization state for document creation
       */
      getSerializationState() {
        return {
          numbering: this.numbering,
          sections: this.sections,
          footnotes: this.footnotes
        };
      }
      createReference(id, before, after) {
        const children = [];
        if (before)
          children.push(new TextRun(before));
        children.push(new SimpleField(`REF ${id} \\h`));
        if (after)
          children.push(new TextRun(after));
        const ref2 = new InternalHyperlink({ anchor: id, children });
        this.current.push(ref2);
      }
    };
    DocxSerializer = class {
      constructor(nodes, marks) {
        this.nodes = nodes;
        this.marks = marks;
      }
      serialize(content, options, getDocumentOptions) {
        const state2 = new DocxSerializerState(this.nodes, this.marks, options);
        state2.renderContent(content);
        return buildDoc(state2, getDocumentOptions === null || getDocumentOptions === void 0 ? void 0 : getDocumentOptions(state2));
      }
    };
    DocxSerializerStateAsync = class {
      constructor(nodes, marks, options) {
        this.currentSectionIndex = 0;
        this.footnotes = {};
        this.current = [];
        this.maxImageWidth = MAX_IMAGE_WIDTH;
        this.$footnoteCounter = 0;
        this.nodes = nodes;
        this.marks = marks;
        this.options = options !== null && options !== void 0 ? options : {};
        this.children = [];
        this.numbering = [];
        if (options.sections && options.sections.length > 0) {
          this.sections = options.sections.map((config) => ({
            config,
            children: []
          }));
          this.children = this.sections[0].children;
        } else {
          this.sections = [];
        }
      }
      renderContent(parent, opts) {
        return __awaiter2(this, void 0, void 0, function* () {
          for (let i = 0; i < parent.childCount; i += 1) {
            const node = parent.child(i);
            if (opts)
              this.addParagraphOptions(opts);
            yield this.render(node, parent, i);
          }
        });
      }
      render(node, parent, index) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (typeof parent === "number")
            throw new Error("!");
          if (!this.nodes[node.type.name])
            throw new Error(`Token type \`${node.type.name}\` not supported by Word renderer`);
          yield Promise.resolve(this.nodes[node.type.name](this, node, parent, index));
        });
      }
      renderMarks(node, marks) {
        return marks.map((mark) => {
          var _a, _b;
          return (_b = (_a = this.marks)[mark.type.name]) === null || _b === void 0 ? void 0 : _b.call(_a, this, node, mark);
        }).reduce((a, b) => Object.assign(Object.assign({}, a), b), {});
      }
      renderInline(parent) {
        return __awaiter2(this, void 0, void 0, function* () {
          let currentLink;
          const closeLink = () => {
            if (!currentLink)
              return;
            const hyperlink = new ExternalHyperlink({
              link: currentLink.link,
              // child: this.current[0],
              children: this.current
            });
            this.current = [...currentLink.stack, hyperlink];
            currentLink = void 0;
          };
          const openLink = (href) => {
            const sameLink = href === (currentLink === null || currentLink === void 0 ? void 0 : currentLink.link);
            this.addRunOptions({ style: "Hyperlink" });
            const oneLink = true;
            if (!oneLink) {
              closeLink();
            } else {
              if (currentLink && sameLink)
                return;
              if (currentLink && !sameLink) {
                closeLink();
              }
            }
            currentLink = {
              link: href,
              stack: this.current
            };
            this.current = [];
          };
          const progress = (node, offset, index) => __awaiter2(this, void 0, void 0, function* () {
            const links = node.marks.filter((m) => m.type.name === "link");
            const hasLink = links.length > 0;
            if (hasLink) {
              openLink(links[0].attrs.href);
            } else if (!hasLink && currentLink) {
              closeLink();
            }
            if (node.isText) {
              this.text(node.text, this.renderMarks(node, [...node.marks]));
            } else {
              yield this.render(node, parent, index);
            }
          });
          for (let i = 0; i < parent.childCount; i += 1) {
            yield progress(parent.child(i), 0, i);
          }
          closeLink();
        });
      }
      renderList(node, style) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (!this.currentNumbering) {
            const nextId = createShortId();
            this.numbering.push(createNumbering(nextId, style));
            this.currentNumbering = { reference: nextId, level: 0 };
          } else {
            const { reference, level } = this.currentNumbering;
            this.currentNumbering = { reference, level: level + 1 };
          }
          yield this.renderContent(node);
          if (this.currentNumbering.level === 0) {
            delete this.currentNumbering;
          } else {
            const { reference, level } = this.currentNumbering;
            this.currentNumbering = { reference, level: level - 1 };
          }
        });
      }
      // This is a pass through to the paragraphs, etc. underneath they will close the block
      renderListItem(node) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (!this.currentNumbering)
            throw new Error("Trying to create a list item without a list?");
          this.addParagraphOptions({ numbering: this.currentNumbering });
          yield this.renderContent(node);
        });
      }
      addParagraphOptions(opts) {
        this.nextParentParagraphOpts = Object.assign(Object.assign({}, this.nextParentParagraphOpts), opts);
      }
      addRunOptions(opts) {
        this.nextRunOpts = Object.assign(Object.assign({}, this.nextRunOpts), opts);
      }
      text(text, opts) {
        if (!text)
          return;
        this.current.push(new TextRun(Object.assign(Object.assign({ text }, this.nextRunOpts), opts)));
        delete this.nextRunOpts;
      }
      math(latex, opts = { inline: true }) {
        var _a;
        if (opts.inline || !opts.numbered) {
          this.current.push(new Math$1({ children: [new MathRun(latex)] }));
          return;
        }
        const id = (_a = opts.id) !== null && _a !== void 0 ? _a : createShortId();
        this.current = [
          new TextRun("	"),
          new Math$1({
            children: [new MathRun(latex)]
          }),
          new TextRun("	("),
          createReferenceBookmark(id, "Equation"),
          new TextRun(")")
        ];
        this.addParagraphOptions({
          tabStops: [
            {
              type: TabStopType.CENTER,
              position: TabStopPosition.MAX / 2
            },
            {
              type: TabStopType.RIGHT,
              position: TabStopPosition.MAX
            }
          ]
        });
      }
      image(src, widthPercent = 70, align = "center", imageRunOpts, imageType) {
        return __awaiter2(this, void 0, void 0, function* () {
          const buffer2 = yield Promise.resolve(this.options.getImageBuffer(src));
          const dimensions = imageDimensionsFromData(buffer2);
          if (!dimensions)
            return;
          const aspect = dimensions.height / dimensions.width;
          const width = this.maxImageWidth * (widthPercent / 100);
          let it;
          try {
            it = imageType || src.replace(/.*\./, "").toLowerCase();
          } catch (e) {
            it = "png";
          }
          this.current.push(new ImageRun(Object.assign(Object.assign({ data: buffer2 }, imageRunOpts), { type: it, transformation: Object.assign(Object.assign({}, (imageRunOpts === null || imageRunOpts === void 0 ? void 0 : imageRunOpts.transformation) || {}), { width, height: width * aspect }) })));
          let alignment;
          switch (align) {
            case "right":
              alignment = AlignmentType.RIGHT;
              break;
            case "left":
              alignment = AlignmentType.LEFT;
              break;
            default:
              alignment = AlignmentType.CENTER;
          }
          this.addParagraphOptions({
            alignment
          });
        });
      }
      table(node, opts = {}) {
        var _a, _b;
        return __awaiter2(this, void 0, void 0, function* () {
          const { getCellOptions, getRowOptions, tableOptions } = opts;
          const actualChildren = this.children;
          const rows = [];
          for (let rowIndex = 0; rowIndex < node.content.childCount; rowIndex += 1) {
            const row = node.content.child(rowIndex);
            const cells = [];
            let tableHeader = true;
            for (let cellIndex = 0; cellIndex < row.content.childCount; cellIndex += 1) {
              const cell = row.content.child(cellIndex);
              if (cell.type.name !== "table_header") {
                tableHeader = false;
              }
            }
            this.maxImageWidth = MAX_IMAGE_WIDTH / row.content.childCount;
            for (let cellIndex = 0; cellIndex < row.content.childCount; cellIndex += 1) {
              const cell = row.content.child(cellIndex);
              this.children = [];
              yield this.renderContent(cell);
              const tableCellOpts = { children: this.children };
              const colspan = (_a = cell.attrs.colspan) !== null && _a !== void 0 ? _a : 1;
              const rowspan = (_b = cell.attrs.rowspan) !== null && _b !== void 0 ? _b : 1;
              if (colspan > 1)
                tableCellOpts.columnSpan = colspan;
              if (rowspan > 1)
                tableCellOpts.rowSpan = rowspan;
              cells.push(new TableCell(Object.assign(Object.assign({}, tableCellOpts), (getCellOptions === null || getCellOptions === void 0 ? void 0 : getCellOptions(cell)) || {})));
            }
            rows.push(new TableRow(Object.assign(Object.assign({}, (getRowOptions === null || getRowOptions === void 0 ? void 0 : getRowOptions(row)) || {}), { children: cells, tableHeader })));
          }
          this.maxImageWidth = MAX_IMAGE_WIDTH;
          const table = new Table(Object.assign(Object.assign({}, tableOptions), { rows }));
          actualChildren.push(table);
          actualChildren.push(new Paragraph(""));
          this.children = actualChildren;
        });
      }
      captionLabel(id, kind, { suffix } = { suffix: ": " }) {
        this.current.push(...[createReferenceBookmark(id, kind, `${kind} `), new TextRun(suffix)]);
      }
      footnote(node) {
        return __awaiter2(this, void 0, void 0, function* () {
          const { current, nextRunOpts } = this;
          this.current = [];
          delete this.nextRunOpts;
          this.$footnoteCounter += 1;
          yield this.renderInline(node);
          this.footnotes[this.$footnoteCounter] = {
            children: [new Paragraph({ children: this.current })]
          };
          this.current = current;
          this.nextRunOpts = nextRunOpts;
          this.current.push(new FootnoteReferenceRun(this.$footnoteCounter));
        });
      }
      closeBlock(node, props) {
        const paragraph = new Paragraph(Object.assign(Object.assign({ children: this.current }, this.nextParentParagraphOpts), props));
        this.current = [];
        delete this.nextParentParagraphOpts;
        this.children.push(paragraph);
      }
      /**
       * Move to the next section. If no more sections are available,
       * this will be ignored (content continues in current section).
       */
      nextSection() {
        if (this.currentSectionIndex < this.sections.length - 1) {
          this.currentSectionIndex += 1;
          this.children = this.sections[this.currentSectionIndex].children;
        }
      }
      /**
       * Update the current section's configuration
       */
      setSectionConfig(config) {
        this.sections[this.currentSectionIndex].config = Object.assign(Object.assign({}, this.sections[this.currentSectionIndex].config), config);
      }
      /**
       * Add a new section with the given configuration and switch to it
       */
      addSection(config = {}) {
        this.sections.push({
          config,
          children: []
        });
        this.currentSectionIndex = this.sections.length - 1;
        this.children = this.sections[this.currentSectionIndex].children;
      }
      /**
       * Get the current section index
       */
      getCurrentSectionIndex() {
        return this.currentSectionIndex;
      }
      /**
       * Get the current section configuration
       */
      getCurrentSectionConfig() {
        return this.sections[this.currentSectionIndex].config;
      }
      /**
       * Get the current serialization state for document creation
       */
      getSerializationState() {
        return {
          numbering: this.numbering,
          sections: this.sections,
          footnotes: this.footnotes
        };
      }
      createReference(id, before, after) {
        const children = [];
        if (before)
          children.push(new TextRun(before));
        children.push(new SimpleField(`REF ${id} \\h`));
        if (after)
          children.push(new TextRun(after));
        const ref2 = new InternalHyperlink({ anchor: id, children });
        this.current.push(ref2);
      }
    };
    DocxSerializerAsync = class {
      constructor(nodes, marks) {
        this.nodes = nodes;
        this.marks = marks;
      }
      serializeAsync(content, options, getDocumentOptions) {
        return __awaiter2(this, void 0, void 0, function* () {
          const state2 = new DocxSerializerStateAsync(this.nodes, this.marks, options);
          yield state2.renderContent(content);
          return buildDoc(state2, getDocumentOptions === null || getDocumentOptions === void 0 ? void 0 : getDocumentOptions(state2));
        });
      }
    };
  }
});

// node_modules/.pnpm/prosemirror-docx@0.6.1_docx@9.5.1/node_modules/prosemirror-docx/dist/esm/schema.js
var __awaiter3, defaultNodes, defaultAsyncNodes, defaultMarks, defaultDocxSerializer, defaultDocxSerializerAsync;
var init_schema = __esm({
  "node_modules/.pnpm/prosemirror-docx@0.6.1_docx@9.5.1/node_modules/prosemirror-docx/dist/esm/schema.js"() {
    init_dist();
    init_serializer();
    init_utils();
    __awaiter3 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    defaultNodes = {
      text(state2, node) {
        var _a;
        state2.text((_a = node.text) !== null && _a !== void 0 ? _a : "");
      },
      paragraph(state2, node) {
        state2.renderInline(node);
        state2.closeBlock(node);
      },
      heading(state2, node) {
        state2.renderInline(node);
        const heading = [
          HeadingLevel.HEADING_1,
          HeadingLevel.HEADING_2,
          HeadingLevel.HEADING_3,
          HeadingLevel.HEADING_4,
          HeadingLevel.HEADING_5,
          HeadingLevel.HEADING_6
        ][node.attrs.level - 1];
        state2.closeBlock(node, { heading });
      },
      blockquote(state2, node) {
        state2.renderContent(node, { style: "IntenseQuote" });
      },
      code_block(state2, node) {
        state2.renderContent(node);
        state2.closeBlock(node);
      },
      horizontal_rule(state2, node) {
        state2.closeBlock(node, { thematicBreak: true });
        state2.closeBlock(node);
      },
      hard_break(state2) {
        state2.addRunOptions({ break: 1 });
      },
      ordered_list(state2, node) {
        state2.renderList(node, "numbered");
      },
      bullet_list(state2, node) {
        state2.renderList(node, "bullets");
      },
      list_item(state2, node) {
        state2.renderListItem(node);
      },
      // Presentational
      image(state2, node) {
        const { src } = node.attrs;
        state2.image(src);
        state2.closeBlock(node);
      },
      // Technical
      math(state2, node) {
        state2.math(getLatexFromNode(node), { inline: true });
      },
      equation(state2, node) {
        const { id, numbered: numbered2 } = node.attrs;
        state2.math(getLatexFromNode(node), { inline: false, numbered: numbered2, id });
        state2.closeBlock(node);
      },
      table(state2, node) {
        state2.table(node);
      }
    };
    defaultAsyncNodes = {
      text(state2, node) {
        var _a;
        state2.text((_a = node.text) !== null && _a !== void 0 ? _a : "");
      },
      paragraph(state2, node) {
        return __awaiter3(this, void 0, void 0, function* () {
          yield state2.renderInline(node);
          state2.closeBlock(node);
        });
      },
      heading(state2, node) {
        return __awaiter3(this, void 0, void 0, function* () {
          yield state2.renderInline(node);
          const heading = [
            HeadingLevel.HEADING_1,
            HeadingLevel.HEADING_2,
            HeadingLevel.HEADING_3,
            HeadingLevel.HEADING_4,
            HeadingLevel.HEADING_5,
            HeadingLevel.HEADING_6
          ][node.attrs.level - 1];
          state2.closeBlock(node, { heading });
        });
      },
      blockquote(state2, node) {
        state2.renderContent(node, { style: "IntenseQuote" });
      },
      code_block(state2, node) {
        state2.renderContent(node);
        state2.closeBlock(node);
      },
      horizontal_rule(state2, node) {
        state2.closeBlock(node, { thematicBreak: true });
        state2.closeBlock(node);
      },
      hard_break(state2) {
        state2.addRunOptions({ break: 1 });
      },
      ordered_list(state2, node) {
        return __awaiter3(this, void 0, void 0, function* () {
          yield state2.renderList(node, "numbered");
        });
      },
      bullet_list(state2, node) {
        return __awaiter3(this, void 0, void 0, function* () {
          yield state2.renderList(node, "bullets");
        });
      },
      list_item(state2, node) {
        return __awaiter3(this, void 0, void 0, function* () {
          yield state2.renderListItem(node);
        });
      },
      // Presentational
      image(state2, node) {
        return __awaiter3(this, void 0, void 0, function* () {
          const { src } = node.attrs;
          yield state2.image(src);
          state2.closeBlock(node);
        });
      },
      // Technical
      math(state2, node) {
        state2.math(getLatexFromNode(node), { inline: true });
      },
      equation(state2, node) {
        const { id, numbered: numbered2 } = node.attrs;
        state2.math(getLatexFromNode(node), { inline: false, numbered: numbered2, id });
        state2.closeBlock(node);
      },
      table(state2, node) {
        return __awaiter3(this, void 0, void 0, function* () {
          yield state2.table(node);
        });
      }
    };
    defaultMarks = {
      em() {
        return { italics: true };
      },
      strong() {
        return { bold: true };
      },
      italic() {
        return { italics: true };
      },
      bold() {
        return { bold: true };
      },
      link() {
        return {};
      },
      code() {
        return {
          font: {
            name: "Monospace"
          },
          color: "000000",
          shading: {
            type: ShadingType.SOLID,
            color: "D2D3D2",
            fill: "D2D3D2"
          }
        };
      },
      abbr() {
        return {};
      },
      subscript() {
        return { subScript: true };
      },
      superscript() {
        return { superScript: true };
      },
      strikethrough() {
        return { strike: true };
      },
      underline() {
        return {
          underline: {}
        };
      },
      smallcaps() {
        return { smallCaps: true };
      },
      allcaps() {
        return { allCaps: true };
      }
    };
    defaultDocxSerializer = new DocxSerializer(defaultNodes, defaultMarks);
    defaultDocxSerializerAsync = new DocxSerializerAsync(defaultAsyncNodes, defaultMarks);
  }
});

// node_modules/.pnpm/prosemirror-docx@0.6.1_docx@9.5.1/node_modules/prosemirror-docx/dist/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  DocxSerializer: () => DocxSerializer,
  DocxSerializerAsync: () => DocxSerializerAsync,
  DocxSerializerState: () => DocxSerializerState,
  DocxSerializerStateAsync: () => DocxSerializerStateAsync,
  MAX_IMAGE_WIDTH: () => MAX_IMAGE_WIDTH,
  buildDoc: () => buildDoc,
  createDocFromState: () => createDocFromState,
  defaultAsyncNodes: () => defaultAsyncNodes,
  defaultDocxSerializer: () => defaultDocxSerializer,
  defaultDocxSerializerAsync: () => defaultDocxSerializerAsync,
  defaultMarks: () => defaultMarks,
  defaultNodes: () => defaultNodes,
  writeDocx: () => writeDocx
});
var init_esm = __esm({
  "node_modules/.pnpm/prosemirror-docx@0.6.1_docx@9.5.1/node_modules/prosemirror-docx/dist/esm/index.js"() {
    init_serializer();
    init_schema();
    init_utils();
  }
});

// node_modules/.pnpm/docx@9.5.1/node_modules/docx/dist/index.cjs
var require_dist34 = __commonJS({
  "node_modules/.pnpm/docx@9.5.1/node_modules/docx/dist/index.cjs"(exports2) {
    "use strict";
    var __defProp3 = Object.defineProperty;
    var __defProps2 = Object.defineProperties;
    var __getOwnPropDescs2 = Object.getOwnPropertyDescriptors;
    var __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
    var __hasOwnProp3 = Object.prototype.hasOwnProperty;
    var __propIsEnum2 = Object.prototype.propertyIsEnumerable;
    var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __spreadValues2 = (a, b) => {
      for (var prop in b || (b = {}))
        if (__hasOwnProp3.call(b, prop))
          __defNormalProp2(a, prop, b[prop]);
      if (__getOwnPropSymbols2)
        for (var prop of __getOwnPropSymbols2(b)) {
          if (__propIsEnum2.call(b, prop))
            __defNormalProp2(a, prop, b[prop]);
        }
      return a;
    };
    var __spreadProps2 = (a, b) => __defProps2(a, __getOwnPropDescs2(b));
    var __objRest = (source, exclude) => {
      var target = {};
      for (var prop in source)
        if (__hasOwnProp3.call(source, prop) && exclude.indexOf(prop) < 0)
          target[prop] = source[prop];
      if (source != null && __getOwnPropSymbols2)
        for (var prop of __getOwnPropSymbols2(source)) {
          if (exclude.indexOf(prop) < 0 && __propIsEnum2.call(source, prop))
            target[prop] = source[prop];
        }
      return target;
    };
    var __publicField2 = (obj, key, value) => __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
    var __async2 = (__this, __arguments, generator) => {
      return new Promise((resolve, reject) => {
        var fulfilled = (value) => {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        };
        var rejected = (value) => {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        };
        var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
        step((generator = generator.apply(__this, __arguments)).next());
      });
    };
    Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
    var BaseXmlComponent2 = class {
      constructor(rootKey) {
        __publicField2(this, "rootKey");
        this.rootKey = rootKey;
      }
    };
    var EMPTY_OBJECT2 = Object.seal({});
    var XmlComponent2 = class extends BaseXmlComponent2 {
      constructor(rootKey) {
        super(rootKey);
        __publicField2(this, "root");
        this.root = new Array();
      }
      // This method is called by the formatter to get the XML representation of this component.
      // It is called recursively for all child components.
      // It is a serializer to be used in the xml library.
      // https://www.npmjs.com/package/xml
      // Child components can override this method to customize the XML representation, or execute side effects.
      prepForXml(context) {
        var _a;
        context.stack.push(this);
        const children = this.root.map((comp) => {
          if (comp instanceof BaseXmlComponent2) {
            return comp.prepForXml(context);
          }
          return comp;
        }).filter((comp) => comp !== void 0);
        context.stack.pop();
        return {
          [this.rootKey]: children.length ? children.length === 1 && ((_a = children[0]) == null ? void 0 : _a._attr) ? children[0] : children : EMPTY_OBJECT2
        };
      }
      /**
       * @deprecated Do not use this method. It is only used internally by the library. It will be removed in a future version.
       */
      addChildElement(child) {
        this.root.push(child);
        return this;
      }
    };
    var IgnoreIfEmptyXmlComponent2 = class extends XmlComponent2 {
      prepForXml(context) {
        const result = super.prepForXml(context);
        if (result && (typeof result[this.rootKey] !== "object" || Object.keys(result[this.rootKey]).length)) {
          return result;
        }
        return void 0;
      }
    };
    var XmlAttributeComponent2 = class extends BaseXmlComponent2 {
      constructor(root) {
        super("_attr");
        __publicField2(this, "xmlKeys");
        this.root = root;
      }
      prepForXml(_) {
        const attrs = {};
        Object.entries(this.root).forEach(([key, value]) => {
          if (value !== void 0) {
            const newKey = this.xmlKeys && this.xmlKeys[key] || key;
            attrs[newKey] = value;
          }
        });
        return { _attr: attrs };
      }
    };
    var NextAttributeComponent2 = class extends BaseXmlComponent2 {
      constructor(root) {
        super("_attr");
        this.root = root;
      }
      prepForXml(_) {
        const attrs = Object.values(this.root).filter(({ value }) => value !== void 0).reduce((acc, { key, value }) => __spreadProps2(__spreadValues2({}, acc), { [key]: value }), {});
        return { _attr: attrs };
      }
    };
    var Attributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", {
          val: "w:val",
          color: "w:color",
          fill: "w:fill",
          space: "w:space",
          sz: "w:sz",
          type: "w:type",
          rsidR: "w:rsidR",
          rsidRPr: "w:rsidRPr",
          rsidSect: "w:rsidSect",
          w: "w:w",
          h: "w:h",
          top: "w:top",
          right: "w:right",
          bottom: "w:bottom",
          left: "w:left",
          header: "w:header",
          footer: "w:footer",
          gutter: "w:gutter",
          linePitch: "w:linePitch",
          pos: "w:pos"
        });
      }
    };
    var commonjsGlobal2 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    function getDefaultExportFromCjs$12(x) {
      return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
    }
    var sax2 = {};
    var events2 = { exports: {} };
    var hasRequiredEvents2;
    function requireEvents2() {
      if (hasRequiredEvents2) return events2.exports;
      hasRequiredEvents2 = 1;
      var R = typeof Reflect === "object" ? Reflect : null;
      var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
        return Function.prototype.apply.call(target, receiver, args);
      };
      var ReflectOwnKeys;
      if (R && typeof R.ownKeys === "function") {
        ReflectOwnKeys = R.ownKeys;
      } else if (Object.getOwnPropertySymbols) {
        ReflectOwnKeys = function ReflectOwnKeys2(target) {
          return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
        };
      } else {
        ReflectOwnKeys = function ReflectOwnKeys2(target) {
          return Object.getOwnPropertyNames(target);
        };
      }
      function ProcessEmitWarning(warning) {
        if (console && console.warn) console.warn(warning);
      }
      var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
        return value !== value;
      };
      function EventEmitter() {
        EventEmitter.init.call(this);
      }
      events2.exports = EventEmitter;
      events2.exports.once = once;
      EventEmitter.EventEmitter = EventEmitter;
      EventEmitter.prototype._events = void 0;
      EventEmitter.prototype._eventsCount = 0;
      EventEmitter.prototype._maxListeners = void 0;
      var defaultMaxListeners = 10;
      function checkListener(listener) {
        if (typeof listener !== "function") {
          throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
        }
      }
      Object.defineProperty(EventEmitter, "defaultMaxListeners", {
        enumerable: true,
        get: function() {
          return defaultMaxListeners;
        },
        set: function(arg) {
          if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
            throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
          }
          defaultMaxListeners = arg;
        }
      });
      EventEmitter.init = function() {
        if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        }
        this._maxListeners = this._maxListeners || void 0;
      };
      EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
        if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
          throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
        }
        this._maxListeners = n;
        return this;
      };
      function _getMaxListeners(that) {
        if (that._maxListeners === void 0)
          return EventEmitter.defaultMaxListeners;
        return that._maxListeners;
      }
      EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
        return _getMaxListeners(this);
      };
      EventEmitter.prototype.emit = function emit(type22) {
        var args = [];
        for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
        var doError = type22 === "error";
        var events22 = this._events;
        if (events22 !== void 0)
          doError = doError && events22.error === void 0;
        else if (!doError)
          return false;
        if (doError) {
          var er;
          if (args.length > 0)
            er = args[0];
          if (er instanceof Error) {
            throw er;
          }
          var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
          err.context = er;
          throw err;
        }
        var handler = events22[type22];
        if (handler === void 0)
          return false;
        if (typeof handler === "function") {
          ReflectApply(handler, this, args);
        } else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i = 0; i < len; ++i)
            ReflectApply(listeners[i], this, args);
        }
        return true;
      };
      function _addListener(target, type22, listener, prepend) {
        var m;
        var events22;
        var existing;
        checkListener(listener);
        events22 = target._events;
        if (events22 === void 0) {
          events22 = target._events = /* @__PURE__ */ Object.create(null);
          target._eventsCount = 0;
        } else {
          if (events22.newListener !== void 0) {
            target.emit(
              "newListener",
              type22,
              listener.listener ? listener.listener : listener
            );
            events22 = target._events;
          }
          existing = events22[type22];
        }
        if (existing === void 0) {
          existing = events22[type22] = listener;
          ++target._eventsCount;
        } else {
          if (typeof existing === "function") {
            existing = events22[type22] = prepend ? [listener, existing] : [existing, listener];
          } else if (prepend) {
            existing.unshift(listener);
          } else {
            existing.push(listener);
          }
          m = _getMaxListeners(target);
          if (m > 0 && existing.length > m && !existing.warned) {
            existing.warned = true;
            var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type22) + " listeners added. Use emitter.setMaxListeners() to increase limit");
            w.name = "MaxListenersExceededWarning";
            w.emitter = target;
            w.type = type22;
            w.count = existing.length;
            ProcessEmitWarning(w);
          }
        }
        return target;
      }
      EventEmitter.prototype.addListener = function addListener(type22, listener) {
        return _addListener(this, type22, listener, false);
      };
      EventEmitter.prototype.on = EventEmitter.prototype.addListener;
      EventEmitter.prototype.prependListener = function prependListener(type22, listener) {
        return _addListener(this, type22, listener, true);
      };
      function onceWrapper() {
        if (!this.fired) {
          this.target.removeListener(this.type, this.wrapFn);
          this.fired = true;
          if (arguments.length === 0)
            return this.listener.call(this.target);
          return this.listener.apply(this.target, arguments);
        }
      }
      function _onceWrap(target, type22, listener) {
        var state22 = { fired: false, wrapFn: void 0, target, type: type22, listener };
        var wrapped = onceWrapper.bind(state22);
        wrapped.listener = listener;
        state22.wrapFn = wrapped;
        return wrapped;
      }
      EventEmitter.prototype.once = function once2(type22, listener) {
        checkListener(listener);
        this.on(type22, _onceWrap(this, type22, listener));
        return this;
      };
      EventEmitter.prototype.prependOnceListener = function prependOnceListener(type22, listener) {
        checkListener(listener);
        this.prependListener(type22, _onceWrap(this, type22, listener));
        return this;
      };
      EventEmitter.prototype.removeListener = function removeListener(type22, listener) {
        var list, events22, position, i, originalListener;
        checkListener(listener);
        events22 = this._events;
        if (events22 === void 0)
          return this;
        list = events22[type22];
        if (list === void 0)
          return this;
        if (list === listener || list.listener === listener) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else {
            delete events22[type22];
            if (events22.removeListener)
              this.emit("removeListener", type22, list.listener || listener);
          }
        } else if (typeof list !== "function") {
          position = -1;
          for (i = list.length - 1; i >= 0; i--) {
            if (list[i] === listener || list[i].listener === listener) {
              originalListener = list[i].listener;
              position = i;
              break;
            }
          }
          if (position < 0)
            return this;
          if (position === 0)
            list.shift();
          else {
            spliceOne(list, position);
          }
          if (list.length === 1)
            events22[type22] = list[0];
          if (events22.removeListener !== void 0)
            this.emit("removeListener", type22, originalListener || listener);
        }
        return this;
      };
      EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
      EventEmitter.prototype.removeAllListeners = function removeAllListeners(type22) {
        var listeners, events22, i;
        events22 = this._events;
        if (events22 === void 0)
          return this;
        if (events22.removeListener === void 0) {
          if (arguments.length === 0) {
            this._events = /* @__PURE__ */ Object.create(null);
            this._eventsCount = 0;
          } else if (events22[type22] !== void 0) {
            if (--this._eventsCount === 0)
              this._events = /* @__PURE__ */ Object.create(null);
            else
              delete events22[type22];
          }
          return this;
        }
        if (arguments.length === 0) {
          var keys = Object.keys(events22);
          var key;
          for (i = 0; i < keys.length; ++i) {
            key = keys[i];
            if (key === "removeListener") continue;
            this.removeAllListeners(key);
          }
          this.removeAllListeners("removeListener");
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
          return this;
        }
        listeners = events22[type22];
        if (typeof listeners === "function") {
          this.removeListener(type22, listeners);
        } else if (listeners !== void 0) {
          for (i = listeners.length - 1; i >= 0; i--) {
            this.removeListener(type22, listeners[i]);
          }
        }
        return this;
      };
      function _listeners(target, type22, unwrap) {
        var events22 = target._events;
        if (events22 === void 0)
          return [];
        var evlistener = events22[type22];
        if (evlistener === void 0)
          return [];
        if (typeof evlistener === "function")
          return unwrap ? [evlistener.listener || evlistener] : [evlistener];
        return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
      }
      EventEmitter.prototype.listeners = function listeners(type22) {
        return _listeners(this, type22, true);
      };
      EventEmitter.prototype.rawListeners = function rawListeners(type22) {
        return _listeners(this, type22, false);
      };
      EventEmitter.listenerCount = function(emitter, type22) {
        if (typeof emitter.listenerCount === "function") {
          return emitter.listenerCount(type22);
        } else {
          return listenerCount.call(emitter, type22);
        }
      };
      EventEmitter.prototype.listenerCount = listenerCount;
      function listenerCount(type22) {
        var events22 = this._events;
        if (events22 !== void 0) {
          var evlistener = events22[type22];
          if (typeof evlistener === "function") {
            return 1;
          } else if (evlistener !== void 0) {
            return evlistener.length;
          }
        }
        return 0;
      }
      EventEmitter.prototype.eventNames = function eventNames() {
        return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
      };
      function arrayClone(arr, n) {
        var copy = new Array(n);
        for (var i = 0; i < n; ++i)
          copy[i] = arr[i];
        return copy;
      }
      function spliceOne(list, index) {
        for (; index + 1 < list.length; index++)
          list[index] = list[index + 1];
        list.pop();
      }
      function unwrapListeners(arr) {
        var ret = new Array(arr.length);
        for (var i = 0; i < ret.length; ++i) {
          ret[i] = arr[i].listener || arr[i];
        }
        return ret;
      }
      function once(emitter, name) {
        return new Promise(function(resolve, reject) {
          function errorListener(err) {
            emitter.removeListener(name, resolver);
            reject(err);
          }
          function resolver() {
            if (typeof emitter.removeListener === "function") {
              emitter.removeListener("error", errorListener);
            }
            resolve([].slice.call(arguments));
          }
          eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
          if (name !== "error") {
            addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
          }
        });
      }
      function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
        if (typeof emitter.on === "function") {
          eventTargetAgnosticAddListener(emitter, "error", handler, flags);
        }
      }
      function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
        if (typeof emitter.on === "function") {
          if (flags.once) {
            emitter.once(name, listener);
          } else {
            emitter.on(name, listener);
          }
        } else if (typeof emitter.addEventListener === "function") {
          emitter.addEventListener(name, function wrapListener(arg) {
            if (flags.once) {
              emitter.removeEventListener(name, wrapListener);
            }
            listener(arg);
          });
        } else {
          throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
        }
      }
      return events2.exports;
    }
    var inherits_browser2 = { exports: {} };
    var hasRequiredInherits_browser2;
    function requireInherits_browser2() {
      if (hasRequiredInherits_browser2) return inherits_browser2.exports;
      hasRequiredInherits_browser2 = 1;
      if (typeof Object.create === "function") {
        inherits_browser2.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
          }
        };
      } else {
        inherits_browser2.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {
            };
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          }
        };
      }
      return inherits_browser2.exports;
    }
    function getDefaultExportFromCjs2(x) {
      return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
    }
    var browser$12 = { exports: {} };
    var process2 = browser$12.exports = {};
    var cachedSetTimeout2;
    var cachedClearTimeout2;
    function defaultSetTimout2() {
      throw new Error("setTimeout has not been defined");
    }
    function defaultClearTimeout2() {
      throw new Error("clearTimeout has not been defined");
    }
    (function() {
      try {
        if (typeof setTimeout === "function") {
          cachedSetTimeout2 = setTimeout;
        } else {
          cachedSetTimeout2 = defaultSetTimout2;
        }
      } catch (e) {
        cachedSetTimeout2 = defaultSetTimout2;
      }
      try {
        if (typeof clearTimeout === "function") {
          cachedClearTimeout2 = clearTimeout;
        } else {
          cachedClearTimeout2 = defaultClearTimeout2;
        }
      } catch (e) {
        cachedClearTimeout2 = defaultClearTimeout2;
      }
    })();
    function runTimeout2(fun) {
      if (cachedSetTimeout2 === setTimeout) {
        return setTimeout(fun, 0);
      }
      if ((cachedSetTimeout2 === defaultSetTimout2 || !cachedSetTimeout2) && setTimeout) {
        cachedSetTimeout2 = setTimeout;
        return setTimeout(fun, 0);
      }
      try {
        return cachedSetTimeout2(fun, 0);
      } catch (e) {
        try {
          return cachedSetTimeout2.call(null, fun, 0);
        } catch (e2) {
          return cachedSetTimeout2.call(this, fun, 0);
        }
      }
    }
    function runClearTimeout2(marker) {
      if (cachedClearTimeout2 === clearTimeout) {
        return clearTimeout(marker);
      }
      if ((cachedClearTimeout2 === defaultClearTimeout2 || !cachedClearTimeout2) && clearTimeout) {
        cachedClearTimeout2 = clearTimeout;
        return clearTimeout(marker);
      }
      try {
        return cachedClearTimeout2(marker);
      } catch (e) {
        try {
          return cachedClearTimeout2.call(null, marker);
        } catch (e2) {
          return cachedClearTimeout2.call(this, marker);
        }
      }
    }
    var queue2 = [];
    var draining2 = false;
    var currentQueue2;
    var queueIndex2 = -1;
    function cleanUpNextTick2() {
      if (!draining2 || !currentQueue2) {
        return;
      }
      draining2 = false;
      if (currentQueue2.length) {
        queue2 = currentQueue2.concat(queue2);
      } else {
        queueIndex2 = -1;
      }
      if (queue2.length) {
        drainQueue2();
      }
    }
    function drainQueue2() {
      if (draining2) {
        return;
      }
      var timeout = runTimeout2(cleanUpNextTick2);
      draining2 = true;
      var len = queue2.length;
      while (len) {
        currentQueue2 = queue2;
        queue2 = [];
        while (++queueIndex2 < len) {
          if (currentQueue2) {
            currentQueue2[queueIndex2].run();
          }
        }
        queueIndex2 = -1;
        len = queue2.length;
      }
      currentQueue2 = null;
      draining2 = false;
      runClearTimeout2(timeout);
    }
    process2.nextTick = function(fun) {
      var args = new Array(arguments.length - 1);
      if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
          args[i - 1] = arguments[i];
        }
      }
      queue2.push(new Item2(fun, args));
      if (queue2.length === 1 && !draining2) {
        runTimeout2(drainQueue2);
      }
    };
    function Item2(fun, array) {
      this.fun = fun;
      this.array = array;
    }
    Item2.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    process2.title = "browser";
    process2.browser = true;
    process2.env = {};
    process2.argv = [];
    process2.version = "";
    process2.versions = {};
    function noop2() {
    }
    process2.on = noop2;
    process2.addListener = noop2;
    process2.once = noop2;
    process2.off = noop2;
    process2.removeListener = noop2;
    process2.removeAllListeners = noop2;
    process2.emit = noop2;
    process2.prependListener = noop2;
    process2.prependOnceListener = noop2;
    process2.listeners = function(name) {
      return [];
    };
    process2.binding = function(name) {
      throw new Error("process.binding is not supported");
    };
    process2.cwd = function() {
      return "/";
    };
    process2.chdir = function(dir) {
      throw new Error("process.chdir is not supported");
    };
    process2.umask = function() {
      return 0;
    };
    var browserExports2 = browser$12.exports;
    var process$12 = /* @__PURE__ */ getDefaultExportFromCjs2(browserExports2);
    var streamBrowser2;
    var hasRequiredStreamBrowser2;
    function requireStreamBrowser2() {
      if (hasRequiredStreamBrowser2) return streamBrowser2;
      hasRequiredStreamBrowser2 = 1;
      streamBrowser2 = requireEvents2().EventEmitter;
      return streamBrowser2;
    }
    var buffer2 = {};
    var base64Js2 = {};
    var hasRequiredBase64Js2;
    function requireBase64Js2() {
      if (hasRequiredBase64Js2) return base64Js2;
      hasRequiredBase64Js2 = 1;
      base64Js2.byteLength = byteLength;
      base64Js2.toByteArray = toByteArray;
      base64Js2.fromByteArray = fromByteArray;
      var lookup = [];
      var revLookup = [];
      var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      for (var i = 0, len = code.length; i < len; ++i) {
        lookup[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
      }
      revLookup["-".charCodeAt(0)] = 62;
      revLookup["_".charCodeAt(0)] = 63;
      function getLens(b64) {
        var len2 = b64.length;
        if (len2 % 4 > 0) {
          throw new Error("Invalid string. Length must be a multiple of 4");
        }
        var validLen = b64.indexOf("=");
        if (validLen === -1) validLen = len2;
        var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
        return [validLen, placeHoldersLen];
      }
      function byteLength(b64) {
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function _byteLength(b64, validLen, placeHoldersLen) {
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function toByteArray(b64) {
        var tmp;
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
        var curByte = 0;
        var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
        var i2;
        for (i2 = 0; i2 < len2; i2 += 4) {
          tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
          arr[curByte++] = tmp >> 16 & 255;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 2) {
          tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 1) {
          tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        return arr;
      }
      function tripletToBase64(num) {
        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
      }
      function encodeChunk(uint8, start, end) {
        var tmp;
        var output = [];
        for (var i2 = start; i2 < end; i2 += 3) {
          tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
          output.push(tripletToBase64(tmp));
        }
        return output.join("");
      }
      function fromByteArray(uint8) {
        var tmp;
        var len2 = uint8.length;
        var extraBytes = len2 % 3;
        var parts = [];
        var maxChunkLength = 16383;
        for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
          parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
        }
        if (extraBytes === 1) {
          tmp = uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
          );
        } else if (extraBytes === 2) {
          tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
          );
        }
        return parts.join("");
      }
      return base64Js2;
    }
    var ieee7542 = {};
    var hasRequiredIeee7542;
    function requireIeee7542() {
      if (hasRequiredIeee7542) return ieee7542;
      hasRequiredIeee7542 = 1;
      ieee7542.read = function(buffer22, offset, isLE, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s = buffer22[offset + i];
        i += d;
        e = s & (1 << -nBits) - 1;
        s >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer22[offset + i], i += d, nBits -= 8) {
        }
        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer22[offset + i], i += d, nBits -= 8) {
        }
        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : (s ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias;
        }
        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
      };
      ieee7542.write = function(buffer22, value, offset, isLE, mLen, nBytes) {
        var e, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax;
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
          }
          if (e + eBias >= 1) {
            value += rt / c;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c >= 2) {
            e++;
            c /= 2;
          }
          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }
        for (; mLen >= 8; buffer22[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
        }
        e = e << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer22[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
        }
        buffer22[offset + i - d] |= s * 128;
      };
      return ieee7542;
    }
    var hasRequiredBuffer2;
    function requireBuffer2() {
      if (hasRequiredBuffer2) return buffer2;
      hasRequiredBuffer2 = 1;
      (function(exports22) {
        var base64 = requireBase64Js2();
        var ieee75422 = requireIeee7542();
        var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
        exports22.Buffer = Buffer2;
        exports22.SlowBuffer = SlowBuffer;
        exports22.INSPECT_MAX_BYTES = 50;
        var K_MAX_LENGTH = 2147483647;
        exports22.kMaxLength = K_MAX_LENGTH;
        Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
        if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
          console.error(
            "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
          );
        }
        function typedArraySupport() {
          try {
            var arr = new Uint8Array(1);
            var proto = { foo: function() {
              return 42;
            } };
            Object.setPrototypeOf(proto, Uint8Array.prototype);
            Object.setPrototypeOf(arr, proto);
            return arr.foo() === 42;
          } catch (e) {
            return false;
          }
        }
        Object.defineProperty(Buffer2.prototype, "parent", {
          enumerable: true,
          get: function() {
            if (!Buffer2.isBuffer(this)) return void 0;
            return this.buffer;
          }
        });
        Object.defineProperty(Buffer2.prototype, "offset", {
          enumerable: true,
          get: function() {
            if (!Buffer2.isBuffer(this)) return void 0;
            return this.byteOffset;
          }
        });
        function createBuffer(length) {
          if (length > K_MAX_LENGTH) {
            throw new RangeError('The value "' + length + '" is invalid for option "size"');
          }
          var buf = new Uint8Array(length);
          Object.setPrototypeOf(buf, Buffer2.prototype);
          return buf;
        }
        function Buffer2(arg, encodingOrOffset, length) {
          if (typeof arg === "number") {
            if (typeof encodingOrOffset === "string") {
              throw new TypeError(
                'The "string" argument must be of type string. Received type number'
              );
            }
            return allocUnsafe(arg);
          }
          return from(arg, encodingOrOffset, length);
        }
        Buffer2.poolSize = 8192;
        function from(value, encodingOrOffset, length) {
          if (typeof value === "string") {
            return fromString(value, encodingOrOffset);
          }
          if (ArrayBuffer.isView(value)) {
            return fromArrayView(value);
          }
          if (value == null) {
            throw new TypeError(
              "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
            );
          }
          if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
            return fromArrayBuffer(value, encodingOrOffset, length);
          }
          if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
            return fromArrayBuffer(value, encodingOrOffset, length);
          }
          if (typeof value === "number") {
            throw new TypeError(
              'The "value" argument must not be of type number. Received type number'
            );
          }
          var valueOf = value.valueOf && value.valueOf();
          if (valueOf != null && valueOf !== value) {
            return Buffer2.from(valueOf, encodingOrOffset, length);
          }
          var b = fromObject(value);
          if (b) return b;
          if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
            return Buffer2.from(
              value[Symbol.toPrimitive]("string"),
              encodingOrOffset,
              length
            );
          }
          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
          );
        }
        Buffer2.from = function(value, encodingOrOffset, length) {
          return from(value, encodingOrOffset, length);
        };
        Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
        Object.setPrototypeOf(Buffer2, Uint8Array);
        function assertSize(size) {
          if (typeof size !== "number") {
            throw new TypeError('"size" argument must be of type number');
          } else if (size < 0) {
            throw new RangeError('The value "' + size + '" is invalid for option "size"');
          }
        }
        function alloc(size, fill, encoding) {
          assertSize(size);
          if (size <= 0) {
            return createBuffer(size);
          }
          if (fill !== void 0) {
            return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
          }
          return createBuffer(size);
        }
        Buffer2.alloc = function(size, fill, encoding) {
          return alloc(size, fill, encoding);
        };
        function allocUnsafe(size) {
          assertSize(size);
          return createBuffer(size < 0 ? 0 : checked(size) | 0);
        }
        Buffer2.allocUnsafe = function(size) {
          return allocUnsafe(size);
        };
        Buffer2.allocUnsafeSlow = function(size) {
          return allocUnsafe(size);
        };
        function fromString(string, encoding) {
          if (typeof encoding !== "string" || encoding === "") {
            encoding = "utf8";
          }
          if (!Buffer2.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
          var length = byteLength(string, encoding) | 0;
          var buf = createBuffer(length);
          var actual = buf.write(string, encoding);
          if (actual !== length) {
            buf = buf.slice(0, actual);
          }
          return buf;
        }
        function fromArrayLike(array) {
          var length = array.length < 0 ? 0 : checked(array.length) | 0;
          var buf = createBuffer(length);
          for (var i = 0; i < length; i += 1) {
            buf[i] = array[i] & 255;
          }
          return buf;
        }
        function fromArrayView(arrayView) {
          if (isInstance(arrayView, Uint8Array)) {
            var copy = new Uint8Array(arrayView);
            return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
          }
          return fromArrayLike(arrayView);
        }
        function fromArrayBuffer(array, byteOffset, length) {
          if (byteOffset < 0 || array.byteLength < byteOffset) {
            throw new RangeError('"offset" is outside of buffer bounds');
          }
          if (array.byteLength < byteOffset + (length || 0)) {
            throw new RangeError('"length" is outside of buffer bounds');
          }
          var buf;
          if (byteOffset === void 0 && length === void 0) {
            buf = new Uint8Array(array);
          } else if (length === void 0) {
            buf = new Uint8Array(array, byteOffset);
          } else {
            buf = new Uint8Array(array, byteOffset, length);
          }
          Object.setPrototypeOf(buf, Buffer2.prototype);
          return buf;
        }
        function fromObject(obj) {
          if (Buffer2.isBuffer(obj)) {
            var len = checked(obj.length) | 0;
            var buf = createBuffer(len);
            if (buf.length === 0) {
              return buf;
            }
            obj.copy(buf, 0, 0, len);
            return buf;
          }
          if (obj.length !== void 0) {
            if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
              return createBuffer(0);
            }
            return fromArrayLike(obj);
          }
          if (obj.type === "Buffer" && Array.isArray(obj.data)) {
            return fromArrayLike(obj.data);
          }
        }
        function checked(length) {
          if (length >= K_MAX_LENGTH) {
            throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
          }
          return length | 0;
        }
        function SlowBuffer(length) {
          if (+length != length) {
            length = 0;
          }
          return Buffer2.alloc(+length);
        }
        Buffer2.isBuffer = function isBuffer(b) {
          return b != null && b._isBuffer === true && b !== Buffer2.prototype;
        };
        Buffer2.compare = function compare(a, b) {
          if (isInstance(a, Uint8Array)) a = Buffer2.from(a, a.offset, a.byteLength);
          if (isInstance(b, Uint8Array)) b = Buffer2.from(b, b.offset, b.byteLength);
          if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
            throw new TypeError(
              'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
            );
          }
          if (a === b) return 0;
          var x = a.length;
          var y = b.length;
          for (var i = 0, len = Math.min(x, y); i < len; ++i) {
            if (a[i] !== b[i]) {
              x = a[i];
              y = b[i];
              break;
            }
          }
          if (x < y) return -1;
          if (y < x) return 1;
          return 0;
        };
        Buffer2.isEncoding = function isEncoding(encoding) {
          switch (String(encoding).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return true;
            default:
              return false;
          }
        };
        Buffer2.concat = function concat(list, length) {
          if (!Array.isArray(list)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          }
          if (list.length === 0) {
            return Buffer2.alloc(0);
          }
          var i;
          if (length === void 0) {
            length = 0;
            for (i = 0; i < list.length; ++i) {
              length += list[i].length;
            }
          }
          var buffer22 = Buffer2.allocUnsafe(length);
          var pos = 0;
          for (i = 0; i < list.length; ++i) {
            var buf = list[i];
            if (isInstance(buf, Uint8Array)) {
              if (pos + buf.length > buffer22.length) {
                Buffer2.from(buf).copy(buffer22, pos);
              } else {
                Uint8Array.prototype.set.call(
                  buffer22,
                  buf,
                  pos
                );
              }
            } else if (!Buffer2.isBuffer(buf)) {
              throw new TypeError('"list" argument must be an Array of Buffers');
            } else {
              buf.copy(buffer22, pos);
            }
            pos += buf.length;
          }
          return buffer22;
        };
        function byteLength(string, encoding) {
          if (Buffer2.isBuffer(string)) {
            return string.length;
          }
          if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
            return string.byteLength;
          }
          if (typeof string !== "string") {
            throw new TypeError(
              'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
            );
          }
          var len = string.length;
          var mustMatch = arguments.length > 2 && arguments[2] === true;
          if (!mustMatch && len === 0) return 0;
          var loweredCase = false;
          for (; ; ) {
            switch (encoding) {
              case "ascii":
              case "latin1":
              case "binary":
                return len;
              case "utf8":
              case "utf-8":
                return utf8ToBytes(string).length;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return len * 2;
              case "hex":
                return len >>> 1;
              case "base64":
                return base64ToBytes(string).length;
              default:
                if (loweredCase) {
                  return mustMatch ? -1 : utf8ToBytes(string).length;
                }
                encoding = ("" + encoding).toLowerCase();
                loweredCase = true;
            }
          }
        }
        Buffer2.byteLength = byteLength;
        function slowToString(encoding, start, end) {
          var loweredCase = false;
          if (start === void 0 || start < 0) {
            start = 0;
          }
          if (start > this.length) {
            return "";
          }
          if (end === void 0 || end > this.length) {
            end = this.length;
          }
          if (end <= 0) {
            return "";
          }
          end >>>= 0;
          start >>>= 0;
          if (end <= start) {
            return "";
          }
          if (!encoding) encoding = "utf8";
          while (true) {
            switch (encoding) {
              case "hex":
                return hexSlice(this, start, end);
              case "utf8":
              case "utf-8":
                return utf8Slice(this, start, end);
              case "ascii":
                return asciiSlice(this, start, end);
              case "latin1":
              case "binary":
                return latin1Slice(this, start, end);
              case "base64":
                return base64Slice(this, start, end);
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return utf16leSlice(this, start, end);
              default:
                if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
                encoding = (encoding + "").toLowerCase();
                loweredCase = true;
            }
          }
        }
        Buffer2.prototype._isBuffer = true;
        function swap(b, n, m) {
          var i = b[n];
          b[n] = b[m];
          b[m] = i;
        }
        Buffer2.prototype.swap16 = function swap16() {
          var len = this.length;
          if (len % 2 !== 0) {
            throw new RangeError("Buffer size must be a multiple of 16-bits");
          }
          for (var i = 0; i < len; i += 2) {
            swap(this, i, i + 1);
          }
          return this;
        };
        Buffer2.prototype.swap32 = function swap32() {
          var len = this.length;
          if (len % 4 !== 0) {
            throw new RangeError("Buffer size must be a multiple of 32-bits");
          }
          for (var i = 0; i < len; i += 4) {
            swap(this, i, i + 3);
            swap(this, i + 1, i + 2);
          }
          return this;
        };
        Buffer2.prototype.swap64 = function swap64() {
          var len = this.length;
          if (len % 8 !== 0) {
            throw new RangeError("Buffer size must be a multiple of 64-bits");
          }
          for (var i = 0; i < len; i += 8) {
            swap(this, i, i + 7);
            swap(this, i + 1, i + 6);
            swap(this, i + 2, i + 5);
            swap(this, i + 3, i + 4);
          }
          return this;
        };
        Buffer2.prototype.toString = function toString() {
          var length = this.length;
          if (length === 0) return "";
          if (arguments.length === 0) return utf8Slice(this, 0, length);
          return slowToString.apply(this, arguments);
        };
        Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
        Buffer2.prototype.equals = function equals(b) {
          if (!Buffer2.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
          if (this === b) return true;
          return Buffer2.compare(this, b) === 0;
        };
        Buffer2.prototype.inspect = function inspect() {
          var str = "";
          var max22 = exports22.INSPECT_MAX_BYTES;
          str = this.toString("hex", 0, max22).replace(/(.{2})/g, "$1 ").trim();
          if (this.length > max22) str += " ... ";
          return "<Buffer " + str + ">";
        };
        if (customInspectSymbol) {
          Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
        }
        Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
          if (isInstance(target, Uint8Array)) {
            target = Buffer2.from(target, target.offset, target.byteLength);
          }
          if (!Buffer2.isBuffer(target)) {
            throw new TypeError(
              'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
            );
          }
          if (start === void 0) {
            start = 0;
          }
          if (end === void 0) {
            end = target ? target.length : 0;
          }
          if (thisStart === void 0) {
            thisStart = 0;
          }
          if (thisEnd === void 0) {
            thisEnd = this.length;
          }
          if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
            throw new RangeError("out of range index");
          }
          if (thisStart >= thisEnd && start >= end) {
            return 0;
          }
          if (thisStart >= thisEnd) {
            return -1;
          }
          if (start >= end) {
            return 1;
          }
          start >>>= 0;
          end >>>= 0;
          thisStart >>>= 0;
          thisEnd >>>= 0;
          if (this === target) return 0;
          var x = thisEnd - thisStart;
          var y = end - start;
          var len = Math.min(x, y);
          var thisCopy = this.slice(thisStart, thisEnd);
          var targetCopy = target.slice(start, end);
          for (var i = 0; i < len; ++i) {
            if (thisCopy[i] !== targetCopy[i]) {
              x = thisCopy[i];
              y = targetCopy[i];
              break;
            }
          }
          if (x < y) return -1;
          if (y < x) return 1;
          return 0;
        };
        function bidirectionalIndexOf(buffer22, val, byteOffset, encoding, dir) {
          if (buffer22.length === 0) return -1;
          if (typeof byteOffset === "string") {
            encoding = byteOffset;
            byteOffset = 0;
          } else if (byteOffset > 2147483647) {
            byteOffset = 2147483647;
          } else if (byteOffset < -2147483648) {
            byteOffset = -2147483648;
          }
          byteOffset = +byteOffset;
          if (numberIsNaN(byteOffset)) {
            byteOffset = dir ? 0 : buffer22.length - 1;
          }
          if (byteOffset < 0) byteOffset = buffer22.length + byteOffset;
          if (byteOffset >= buffer22.length) {
            if (dir) return -1;
            else byteOffset = buffer22.length - 1;
          } else if (byteOffset < 0) {
            if (dir) byteOffset = 0;
            else return -1;
          }
          if (typeof val === "string") {
            val = Buffer2.from(val, encoding);
          }
          if (Buffer2.isBuffer(val)) {
            if (val.length === 0) {
              return -1;
            }
            return arrayIndexOf(buffer22, val, byteOffset, encoding, dir);
          } else if (typeof val === "number") {
            val = val & 255;
            if (typeof Uint8Array.prototype.indexOf === "function") {
              if (dir) {
                return Uint8Array.prototype.indexOf.call(buffer22, val, byteOffset);
              } else {
                return Uint8Array.prototype.lastIndexOf.call(buffer22, val, byteOffset);
              }
            }
            return arrayIndexOf(buffer22, [val], byteOffset, encoding, dir);
          }
          throw new TypeError("val must be string, number or Buffer");
        }
        function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
          var indexSize = 1;
          var arrLength = arr.length;
          var valLength = val.length;
          if (encoding !== void 0) {
            encoding = String(encoding).toLowerCase();
            if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
              if (arr.length < 2 || val.length < 2) {
                return -1;
              }
              indexSize = 2;
              arrLength /= 2;
              valLength /= 2;
              byteOffset /= 2;
            }
          }
          function read(buf, i2) {
            if (indexSize === 1) {
              return buf[i2];
            } else {
              return buf.readUInt16BE(i2 * indexSize);
            }
          }
          var i;
          if (dir) {
            var foundIndex = -1;
            for (i = byteOffset; i < arrLength; i++) {
              if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                if (foundIndex === -1) foundIndex = i;
                if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
              } else {
                if (foundIndex !== -1) i -= i - foundIndex;
                foundIndex = -1;
              }
            }
          } else {
            if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
            for (i = byteOffset; i >= 0; i--) {
              var found = true;
              for (var j = 0; j < valLength; j++) {
                if (read(arr, i + j) !== read(val, j)) {
                  found = false;
                  break;
                }
              }
              if (found) return i;
            }
          }
          return -1;
        }
        Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
          return this.indexOf(val, byteOffset, encoding) !== -1;
        };
        Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
          return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
        };
        Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
          return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
        };
        function hexWrite(buf, string, offset, length) {
          offset = Number(offset) || 0;
          var remaining = buf.length - offset;
          if (!length) {
            length = remaining;
          } else {
            length = Number(length);
            if (length > remaining) {
              length = remaining;
            }
          }
          var strLen = string.length;
          if (length > strLen / 2) {
            length = strLen / 2;
          }
          for (var i = 0; i < length; ++i) {
            var parsed = parseInt(string.substr(i * 2, 2), 16);
            if (numberIsNaN(parsed)) return i;
            buf[offset + i] = parsed;
          }
          return i;
        }
        function utf8Write(buf, string, offset, length) {
          return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
        }
        function asciiWrite(buf, string, offset, length) {
          return blitBuffer(asciiToBytes(string), buf, offset, length);
        }
        function base64Write(buf, string, offset, length) {
          return blitBuffer(base64ToBytes(string), buf, offset, length);
        }
        function ucs2Write(buf, string, offset, length) {
          return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
        }
        Buffer2.prototype.write = function write(string, offset, length, encoding) {
          if (offset === void 0) {
            encoding = "utf8";
            length = this.length;
            offset = 0;
          } else if (length === void 0 && typeof offset === "string") {
            encoding = offset;
            length = this.length;
            offset = 0;
          } else if (isFinite(offset)) {
            offset = offset >>> 0;
            if (isFinite(length)) {
              length = length >>> 0;
              if (encoding === void 0) encoding = "utf8";
            } else {
              encoding = length;
              length = void 0;
            }
          } else {
            throw new Error(
              "Buffer.write(string, encoding, offset[, length]) is no longer supported"
            );
          }
          var remaining = this.length - offset;
          if (length === void 0 || length > remaining) length = remaining;
          if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
            throw new RangeError("Attempt to write outside buffer bounds");
          }
          if (!encoding) encoding = "utf8";
          var loweredCase = false;
          for (; ; ) {
            switch (encoding) {
              case "hex":
                return hexWrite(this, string, offset, length);
              case "utf8":
              case "utf-8":
                return utf8Write(this, string, offset, length);
              case "ascii":
              case "latin1":
              case "binary":
                return asciiWrite(this, string, offset, length);
              case "base64":
                return base64Write(this, string, offset, length);
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return ucs2Write(this, string, offset, length);
              default:
                if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
                encoding = ("" + encoding).toLowerCase();
                loweredCase = true;
            }
          }
        };
        Buffer2.prototype.toJSON = function toJSON() {
          return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0)
          };
        };
        function base64Slice(buf, start, end) {
          if (start === 0 && end === buf.length) {
            return base64.fromByteArray(buf);
          } else {
            return base64.fromByteArray(buf.slice(start, end));
          }
        }
        function utf8Slice(buf, start, end) {
          end = Math.min(buf.length, end);
          var res = [];
          var i = start;
          while (i < end) {
            var firstByte = buf[i];
            var codePoint = null;
            var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
            if (i + bytesPerSequence <= end) {
              var secondByte, thirdByte, fourthByte, tempCodePoint;
              switch (bytesPerSequence) {
                case 1:
                  if (firstByte < 128) {
                    codePoint = firstByte;
                  }
                  break;
                case 2:
                  secondByte = buf[i + 1];
                  if ((secondByte & 192) === 128) {
                    tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                    if (tempCodePoint > 127) {
                      codePoint = tempCodePoint;
                    }
                  }
                  break;
                case 3:
                  secondByte = buf[i + 1];
                  thirdByte = buf[i + 2];
                  if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                    tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                    if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                      codePoint = tempCodePoint;
                    }
                  }
                  break;
                case 4:
                  secondByte = buf[i + 1];
                  thirdByte = buf[i + 2];
                  fourthByte = buf[i + 3];
                  if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                    tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                    if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                      codePoint = tempCodePoint;
                    }
                  }
              }
            }
            if (codePoint === null) {
              codePoint = 65533;
              bytesPerSequence = 1;
            } else if (codePoint > 65535) {
              codePoint -= 65536;
              res.push(codePoint >>> 10 & 1023 | 55296);
              codePoint = 56320 | codePoint & 1023;
            }
            res.push(codePoint);
            i += bytesPerSequence;
          }
          return decodeCodePointsArray(res);
        }
        var MAX_ARGUMENTS_LENGTH = 4096;
        function decodeCodePointsArray(codePoints) {
          var len = codePoints.length;
          if (len <= MAX_ARGUMENTS_LENGTH) {
            return String.fromCharCode.apply(String, codePoints);
          }
          var res = "";
          var i = 0;
          while (i < len) {
            res += String.fromCharCode.apply(
              String,
              codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
            );
          }
          return res;
        }
        function asciiSlice(buf, start, end) {
          var ret = "";
          end = Math.min(buf.length, end);
          for (var i = start; i < end; ++i) {
            ret += String.fromCharCode(buf[i] & 127);
          }
          return ret;
        }
        function latin1Slice(buf, start, end) {
          var ret = "";
          end = Math.min(buf.length, end);
          for (var i = start; i < end; ++i) {
            ret += String.fromCharCode(buf[i]);
          }
          return ret;
        }
        function hexSlice(buf, start, end) {
          var len = buf.length;
          if (!start || start < 0) start = 0;
          if (!end || end < 0 || end > len) end = len;
          var out = "";
          for (var i = start; i < end; ++i) {
            out += hexSliceLookupTable[buf[i]];
          }
          return out;
        }
        function utf16leSlice(buf, start, end) {
          var bytes = buf.slice(start, end);
          var res = "";
          for (var i = 0; i < bytes.length - 1; i += 2) {
            res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
          }
          return res;
        }
        Buffer2.prototype.slice = function slice(start, end) {
          var len = this.length;
          start = ~~start;
          end = end === void 0 ? len : ~~end;
          if (start < 0) {
            start += len;
            if (start < 0) start = 0;
          } else if (start > len) {
            start = len;
          }
          if (end < 0) {
            end += len;
            if (end < 0) end = 0;
          } else if (end > len) {
            end = len;
          }
          if (end < start) end = start;
          var newBuf = this.subarray(start, end);
          Object.setPrototypeOf(newBuf, Buffer2.prototype);
          return newBuf;
        };
        function checkOffset(offset, ext, length) {
          if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
          if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
        }
        Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
          offset = offset >>> 0;
          byteLength2 = byteLength2 >>> 0;
          if (!noAssert) checkOffset(offset, byteLength2, this.length);
          var val = this[offset];
          var mul = 1;
          var i = 0;
          while (++i < byteLength2 && (mul *= 256)) {
            val += this[offset + i] * mul;
          }
          return val;
        };
        Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
          offset = offset >>> 0;
          byteLength2 = byteLength2 >>> 0;
          if (!noAssert) {
            checkOffset(offset, byteLength2, this.length);
          }
          var val = this[offset + --byteLength2];
          var mul = 1;
          while (byteLength2 > 0 && (mul *= 256)) {
            val += this[offset + --byteLength2] * mul;
          }
          return val;
        };
        Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
          offset = offset >>> 0;
          if (!noAssert) checkOffset(offset, 1, this.length);
          return this[offset];
        };
        Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
          offset = offset >>> 0;
          if (!noAssert) checkOffset(offset, 2, this.length);
          return this[offset] | this[offset + 1] << 8;
        };
        Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
          offset = offset >>> 0;
          if (!noAssert) checkOffset(offset, 2, this.length);
          return this[offset] << 8 | this[offset + 1];
        };
        Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
          offset = offset >>> 0;
          if (!noAssert) checkOffset(offset, 4, this.length);
          return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
        };
        Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
          offset = offset >>> 0;
          if (!noAssert) checkOffset(offset, 4, this.length);
          return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
        };
        Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
          offset = offset >>> 0;
          byteLength2 = byteLength2 >>> 0;
          if (!noAssert) checkOffset(offset, byteLength2, this.length);
          var val = this[offset];
          var mul = 1;
          var i = 0;
          while (++i < byteLength2 && (mul *= 256)) {
            val += this[offset + i] * mul;
          }
          mul *= 128;
          if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
          return val;
        };
        Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
          offset = offset >>> 0;
          byteLength2 = byteLength2 >>> 0;
          if (!noAssert) checkOffset(offset, byteLength2, this.length);
          var i = byteLength2;
          var mul = 1;
          var val = this[offset + --i];
          while (i > 0 && (mul *= 256)) {
            val += this[offset + --i] * mul;
          }
          mul *= 128;
          if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
          return val;
        };
        Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
          offset = offset >>> 0;
          if (!noAssert) checkOffset(offset, 1, this.length);
          if (!(this[offset] & 128)) return this[offset];
          return (255 - this[offset] + 1) * -1;
        };
        Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
          offset = offset >>> 0;
          if (!noAssert) checkOffset(offset, 2, this.length);
          var val = this[offset] | this[offset + 1] << 8;
          return val & 32768 ? val | 4294901760 : val;
        };
        Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
          offset = offset >>> 0;
          if (!noAssert) checkOffset(offset, 2, this.length);
          var val = this[offset + 1] | this[offset] << 8;
          return val & 32768 ? val | 4294901760 : val;
        };
        Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
          offset = offset >>> 0;
          if (!noAssert) checkOffset(offset, 4, this.length);
          return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
        };
        Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
          offset = offset >>> 0;
          if (!noAssert) checkOffset(offset, 4, this.length);
          return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
        };
        Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
          offset = offset >>> 0;
          if (!noAssert) checkOffset(offset, 4, this.length);
          return ieee75422.read(this, offset, true, 23, 4);
        };
        Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
          offset = offset >>> 0;
          if (!noAssert) checkOffset(offset, 4, this.length);
          return ieee75422.read(this, offset, false, 23, 4);
        };
        Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
          offset = offset >>> 0;
          if (!noAssert) checkOffset(offset, 8, this.length);
          return ieee75422.read(this, offset, true, 52, 8);
        };
        Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
          offset = offset >>> 0;
          if (!noAssert) checkOffset(offset, 8, this.length);
          return ieee75422.read(this, offset, false, 52, 8);
        };
        function checkInt(buf, value, offset, ext, max22, min22) {
          if (!Buffer2.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
          if (value > max22 || value < min22) throw new RangeError('"value" argument is out of bounds');
          if (offset + ext > buf.length) throw new RangeError("Index out of range");
        }
        Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
          value = +value;
          offset = offset >>> 0;
          byteLength2 = byteLength2 >>> 0;
          if (!noAssert) {
            var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
            checkInt(this, value, offset, byteLength2, maxBytes, 0);
          }
          var mul = 1;
          var i = 0;
          this[offset] = value & 255;
          while (++i < byteLength2 && (mul *= 256)) {
            this[offset + i] = value / mul & 255;
          }
          return offset + byteLength2;
        };
        Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
          value = +value;
          offset = offset >>> 0;
          byteLength2 = byteLength2 >>> 0;
          if (!noAssert) {
            var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
            checkInt(this, value, offset, byteLength2, maxBytes, 0);
          }
          var i = byteLength2 - 1;
          var mul = 1;
          this[offset + i] = value & 255;
          while (--i >= 0 && (mul *= 256)) {
            this[offset + i] = value / mul & 255;
          }
          return offset + byteLength2;
        };
        Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
          value = +value;
          offset = offset >>> 0;
          if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
          this[offset] = value & 255;
          return offset + 1;
        };
        Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
          value = +value;
          offset = offset >>> 0;
          if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
          this[offset] = value & 255;
          this[offset + 1] = value >>> 8;
          return offset + 2;
        };
        Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
          value = +value;
          offset = offset >>> 0;
          if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
          this[offset] = value >>> 8;
          this[offset + 1] = value & 255;
          return offset + 2;
        };
        Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
          value = +value;
          offset = offset >>> 0;
          if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
          this[offset + 3] = value >>> 24;
          this[offset + 2] = value >>> 16;
          this[offset + 1] = value >>> 8;
          this[offset] = value & 255;
          return offset + 4;
        };
        Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
          value = +value;
          offset = offset >>> 0;
          if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
          this[offset] = value >>> 24;
          this[offset + 1] = value >>> 16;
          this[offset + 2] = value >>> 8;
          this[offset + 3] = value & 255;
          return offset + 4;
        };
        Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
          value = +value;
          offset = offset >>> 0;
          if (!noAssert) {
            var limit = Math.pow(2, 8 * byteLength2 - 1);
            checkInt(this, value, offset, byteLength2, limit - 1, -limit);
          }
          var i = 0;
          var mul = 1;
          var sub = 0;
          this[offset] = value & 255;
          while (++i < byteLength2 && (mul *= 256)) {
            if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
              sub = 1;
            }
            this[offset + i] = (value / mul >> 0) - sub & 255;
          }
          return offset + byteLength2;
        };
        Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
          value = +value;
          offset = offset >>> 0;
          if (!noAssert) {
            var limit = Math.pow(2, 8 * byteLength2 - 1);
            checkInt(this, value, offset, byteLength2, limit - 1, -limit);
          }
          var i = byteLength2 - 1;
          var mul = 1;
          var sub = 0;
          this[offset + i] = value & 255;
          while (--i >= 0 && (mul *= 256)) {
            if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
              sub = 1;
            }
            this[offset + i] = (value / mul >> 0) - sub & 255;
          }
          return offset + byteLength2;
        };
        Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
          value = +value;
          offset = offset >>> 0;
          if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
          if (value < 0) value = 255 + value + 1;
          this[offset] = value & 255;
          return offset + 1;
        };
        Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
          value = +value;
          offset = offset >>> 0;
          if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
          this[offset] = value & 255;
          this[offset + 1] = value >>> 8;
          return offset + 2;
        };
        Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
          value = +value;
          offset = offset >>> 0;
          if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
          this[offset] = value >>> 8;
          this[offset + 1] = value & 255;
          return offset + 2;
        };
        Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
          value = +value;
          offset = offset >>> 0;
          if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
          this[offset] = value & 255;
          this[offset + 1] = value >>> 8;
          this[offset + 2] = value >>> 16;
          this[offset + 3] = value >>> 24;
          return offset + 4;
        };
        Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
          value = +value;
          offset = offset >>> 0;
          if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
          if (value < 0) value = 4294967295 + value + 1;
          this[offset] = value >>> 24;
          this[offset + 1] = value >>> 16;
          this[offset + 2] = value >>> 8;
          this[offset + 3] = value & 255;
          return offset + 4;
        };
        function checkIEEE754(buf, value, offset, ext, max22, min22) {
          if (offset + ext > buf.length) throw new RangeError("Index out of range");
          if (offset < 0) throw new RangeError("Index out of range");
        }
        function writeFloat(buf, value, offset, littleEndian, noAssert) {
          value = +value;
          offset = offset >>> 0;
          if (!noAssert) {
            checkIEEE754(buf, value, offset, 4);
          }
          ieee75422.write(buf, value, offset, littleEndian, 23, 4);
          return offset + 4;
        }
        Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
          return writeFloat(this, value, offset, true, noAssert);
        };
        Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
          return writeFloat(this, value, offset, false, noAssert);
        };
        function writeDouble(buf, value, offset, littleEndian, noAssert) {
          value = +value;
          offset = offset >>> 0;
          if (!noAssert) {
            checkIEEE754(buf, value, offset, 8);
          }
          ieee75422.write(buf, value, offset, littleEndian, 52, 8);
          return offset + 8;
        }
        Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
          return writeDouble(this, value, offset, true, noAssert);
        };
        Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
          return writeDouble(this, value, offset, false, noAssert);
        };
        Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
          if (!Buffer2.isBuffer(target)) throw new TypeError("argument should be a Buffer");
          if (!start) start = 0;
          if (!end && end !== 0) end = this.length;
          if (targetStart >= target.length) targetStart = target.length;
          if (!targetStart) targetStart = 0;
          if (end > 0 && end < start) end = start;
          if (end === start) return 0;
          if (target.length === 0 || this.length === 0) return 0;
          if (targetStart < 0) {
            throw new RangeError("targetStart out of bounds");
          }
          if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
          if (end < 0) throw new RangeError("sourceEnd out of bounds");
          if (end > this.length) end = this.length;
          if (target.length - targetStart < end - start) {
            end = target.length - targetStart + start;
          }
          var len = end - start;
          if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
            this.copyWithin(targetStart, start, end);
          } else {
            Uint8Array.prototype.set.call(
              target,
              this.subarray(start, end),
              targetStart
            );
          }
          return len;
        };
        Buffer2.prototype.fill = function fill(val, start, end, encoding) {
          if (typeof val === "string") {
            if (typeof start === "string") {
              encoding = start;
              start = 0;
              end = this.length;
            } else if (typeof end === "string") {
              encoding = end;
              end = this.length;
            }
            if (encoding !== void 0 && typeof encoding !== "string") {
              throw new TypeError("encoding must be a string");
            }
            if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
              throw new TypeError("Unknown encoding: " + encoding);
            }
            if (val.length === 1) {
              var code = val.charCodeAt(0);
              if (encoding === "utf8" && code < 128 || encoding === "latin1") {
                val = code;
              }
            }
          } else if (typeof val === "number") {
            val = val & 255;
          } else if (typeof val === "boolean") {
            val = Number(val);
          }
          if (start < 0 || this.length < start || this.length < end) {
            throw new RangeError("Out of range index");
          }
          if (end <= start) {
            return this;
          }
          start = start >>> 0;
          end = end === void 0 ? this.length : end >>> 0;
          if (!val) val = 0;
          var i;
          if (typeof val === "number") {
            for (i = start; i < end; ++i) {
              this[i] = val;
            }
          } else {
            var bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
            var len = bytes.length;
            if (len === 0) {
              throw new TypeError('The value "' + val + '" is invalid for argument "value"');
            }
            for (i = 0; i < end - start; ++i) {
              this[i + start] = bytes[i % len];
            }
          }
          return this;
        };
        var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
        function base64clean(str) {
          str = str.split("=")[0];
          str = str.trim().replace(INVALID_BASE64_RE, "");
          if (str.length < 2) return "";
          while (str.length % 4 !== 0) {
            str = str + "=";
          }
          return str;
        }
        function utf8ToBytes(string, units) {
          units = units || Infinity;
          var codePoint;
          var length = string.length;
          var leadSurrogate = null;
          var bytes = [];
          for (var i = 0; i < length; ++i) {
            codePoint = string.charCodeAt(i);
            if (codePoint > 55295 && codePoint < 57344) {
              if (!leadSurrogate) {
                if (codePoint > 56319) {
                  if ((units -= 3) > -1) bytes.push(239, 191, 189);
                  continue;
                } else if (i + 1 === length) {
                  if ((units -= 3) > -1) bytes.push(239, 191, 189);
                  continue;
                }
                leadSurrogate = codePoint;
                continue;
              }
              if (codePoint < 56320) {
                if ((units -= 3) > -1) bytes.push(239, 191, 189);
                leadSurrogate = codePoint;
                continue;
              }
              codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
            } else if (leadSurrogate) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
            }
            leadSurrogate = null;
            if (codePoint < 128) {
              if ((units -= 1) < 0) break;
              bytes.push(codePoint);
            } else if (codePoint < 2048) {
              if ((units -= 2) < 0) break;
              bytes.push(
                codePoint >> 6 | 192,
                codePoint & 63 | 128
              );
            } else if (codePoint < 65536) {
              if ((units -= 3) < 0) break;
              bytes.push(
                codePoint >> 12 | 224,
                codePoint >> 6 & 63 | 128,
                codePoint & 63 | 128
              );
            } else if (codePoint < 1114112) {
              if ((units -= 4) < 0) break;
              bytes.push(
                codePoint >> 18 | 240,
                codePoint >> 12 & 63 | 128,
                codePoint >> 6 & 63 | 128,
                codePoint & 63 | 128
              );
            } else {
              throw new Error("Invalid code point");
            }
          }
          return bytes;
        }
        function asciiToBytes(str) {
          var byteArray = [];
          for (var i = 0; i < str.length; ++i) {
            byteArray.push(str.charCodeAt(i) & 255);
          }
          return byteArray;
        }
        function utf16leToBytes(str, units) {
          var c, hi, lo;
          var byteArray = [];
          for (var i = 0; i < str.length; ++i) {
            if ((units -= 2) < 0) break;
            c = str.charCodeAt(i);
            hi = c >> 8;
            lo = c % 256;
            byteArray.push(lo);
            byteArray.push(hi);
          }
          return byteArray;
        }
        function base64ToBytes(str) {
          return base64.toByteArray(base64clean(str));
        }
        function blitBuffer(src, dst, offset, length) {
          for (var i = 0; i < length; ++i) {
            if (i + offset >= dst.length || i >= src.length) break;
            dst[i + offset] = src[i];
          }
          return i;
        }
        function isInstance(obj, type22) {
          return obj instanceof type22 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type22.name;
        }
        function numberIsNaN(obj) {
          return obj !== obj;
        }
        var hexSliceLookupTable = (function() {
          var alphabet = "0123456789abcdef";
          var table = new Array(256);
          for (var i = 0; i < 16; ++i) {
            var i16 = i * 16;
            for (var j = 0; j < 16; ++j) {
              table[i16 + j] = alphabet[i] + alphabet[j];
            }
          }
          return table;
        })();
      })(buffer2);
      return buffer2;
    }
    var util2 = {};
    var types2 = {};
    var shams$12;
    var hasRequiredShams$12;
    function requireShams$12() {
      if (hasRequiredShams$12) return shams$12;
      hasRequiredShams$12 = 1;
      shams$12 = function hasSymbols22() {
        if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
          return false;
        }
        if (typeof Symbol.iterator === "symbol") {
          return true;
        }
        var obj = {};
        var sym = Symbol("test");
        var symObj = Object(sym);
        if (typeof sym === "string") {
          return false;
        }
        if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
          return false;
        }
        if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
          return false;
        }
        var symVal = 42;
        obj[sym] = symVal;
        for (var _ in obj) {
          return false;
        }
        if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
          return false;
        }
        if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
          return false;
        }
        var syms = Object.getOwnPropertySymbols(obj);
        if (syms.length !== 1 || syms[0] !== sym) {
          return false;
        }
        if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
          return false;
        }
        if (typeof Object.getOwnPropertyDescriptor === "function") {
          var descriptor = (
            /** @type {PropertyDescriptor} */
            Object.getOwnPropertyDescriptor(obj, sym)
          );
          if (descriptor.value !== symVal || descriptor.enumerable !== true) {
            return false;
          }
        }
        return true;
      };
      return shams$12;
    }
    var shams2;
    var hasRequiredShams2;
    function requireShams2() {
      if (hasRequiredShams2) return shams2;
      hasRequiredShams2 = 1;
      var hasSymbols22 = requireShams$12();
      shams2 = function hasToStringTagShams() {
        return hasSymbols22() && !!Symbol.toStringTag;
      };
      return shams2;
    }
    var esObjectAtoms2;
    var hasRequiredEsObjectAtoms2;
    function requireEsObjectAtoms2() {
      if (hasRequiredEsObjectAtoms2) return esObjectAtoms2;
      hasRequiredEsObjectAtoms2 = 1;
      esObjectAtoms2 = Object;
      return esObjectAtoms2;
    }
    var esErrors2;
    var hasRequiredEsErrors2;
    function requireEsErrors2() {
      if (hasRequiredEsErrors2) return esErrors2;
      hasRequiredEsErrors2 = 1;
      esErrors2 = Error;
      return esErrors2;
    }
    var _eval2;
    var hasRequired_eval2;
    function require_eval2() {
      if (hasRequired_eval2) return _eval2;
      hasRequired_eval2 = 1;
      _eval2 = EvalError;
      return _eval2;
    }
    var range2;
    var hasRequiredRange2;
    function requireRange2() {
      if (hasRequiredRange2) return range2;
      hasRequiredRange2 = 1;
      range2 = RangeError;
      return range2;
    }
    var ref2;
    var hasRequiredRef2;
    function requireRef2() {
      if (hasRequiredRef2) return ref2;
      hasRequiredRef2 = 1;
      ref2 = ReferenceError;
      return ref2;
    }
    var syntax2;
    var hasRequiredSyntax2;
    function requireSyntax2() {
      if (hasRequiredSyntax2) return syntax2;
      hasRequiredSyntax2 = 1;
      syntax2 = SyntaxError;
      return syntax2;
    }
    var type2;
    var hasRequiredType2;
    function requireType2() {
      if (hasRequiredType2) return type2;
      hasRequiredType2 = 1;
      type2 = TypeError;
      return type2;
    }
    var uri2;
    var hasRequiredUri2;
    function requireUri2() {
      if (hasRequiredUri2) return uri2;
      hasRequiredUri2 = 1;
      uri2 = URIError;
      return uri2;
    }
    var abs2;
    var hasRequiredAbs2;
    function requireAbs2() {
      if (hasRequiredAbs2) return abs2;
      hasRequiredAbs2 = 1;
      abs2 = Math.abs;
      return abs2;
    }
    var floor2;
    var hasRequiredFloor2;
    function requireFloor2() {
      if (hasRequiredFloor2) return floor2;
      hasRequiredFloor2 = 1;
      floor2 = Math.floor;
      return floor2;
    }
    var max2;
    var hasRequiredMax2;
    function requireMax2() {
      if (hasRequiredMax2) return max2;
      hasRequiredMax2 = 1;
      max2 = Math.max;
      return max2;
    }
    var min2;
    var hasRequiredMin2;
    function requireMin2() {
      if (hasRequiredMin2) return min2;
      hasRequiredMin2 = 1;
      min2 = Math.min;
      return min2;
    }
    var pow2;
    var hasRequiredPow2;
    function requirePow2() {
      if (hasRequiredPow2) return pow2;
      hasRequiredPow2 = 1;
      pow2 = Math.pow;
      return pow2;
    }
    var round2;
    var hasRequiredRound2;
    function requireRound2() {
      if (hasRequiredRound2) return round2;
      hasRequiredRound2 = 1;
      round2 = Math.round;
      return round2;
    }
    var _isNaN2;
    var hasRequired_isNaN2;
    function require_isNaN2() {
      if (hasRequired_isNaN2) return _isNaN2;
      hasRequired_isNaN2 = 1;
      _isNaN2 = Number.isNaN || function isNaN2(a) {
        return a !== a;
      };
      return _isNaN2;
    }
    var sign2;
    var hasRequiredSign2;
    function requireSign2() {
      if (hasRequiredSign2) return sign2;
      hasRequiredSign2 = 1;
      var $isNaN = /* @__PURE__ */ require_isNaN2();
      sign2 = function sign22(number) {
        if ($isNaN(number) || number === 0) {
          return number;
        }
        return number < 0 ? -1 : 1;
      };
      return sign2;
    }
    var gOPD2;
    var hasRequiredGOPD2;
    function requireGOPD2() {
      if (hasRequiredGOPD2) return gOPD2;
      hasRequiredGOPD2 = 1;
      gOPD2 = Object.getOwnPropertyDescriptor;
      return gOPD2;
    }
    var gopd2;
    var hasRequiredGopd2;
    function requireGopd2() {
      if (hasRequiredGopd2) return gopd2;
      hasRequiredGopd2 = 1;
      var $gOPD = /* @__PURE__ */ requireGOPD2();
      if ($gOPD) {
        try {
          $gOPD([], "length");
        } catch (e) {
          $gOPD = null;
        }
      }
      gopd2 = $gOPD;
      return gopd2;
    }
    var esDefineProperty2;
    var hasRequiredEsDefineProperty2;
    function requireEsDefineProperty2() {
      if (hasRequiredEsDefineProperty2) return esDefineProperty2;
      hasRequiredEsDefineProperty2 = 1;
      var $defineProperty = Object.defineProperty || false;
      if ($defineProperty) {
        try {
          $defineProperty({}, "a", { value: 1 });
        } catch (e) {
          $defineProperty = false;
        }
      }
      esDefineProperty2 = $defineProperty;
      return esDefineProperty2;
    }
    var hasSymbols2;
    var hasRequiredHasSymbols2;
    function requireHasSymbols2() {
      if (hasRequiredHasSymbols2) return hasSymbols2;
      hasRequiredHasSymbols2 = 1;
      var origSymbol = typeof Symbol !== "undefined" && Symbol;
      var hasSymbolSham = requireShams$12();
      hasSymbols2 = function hasNativeSymbols() {
        if (typeof origSymbol !== "function") {
          return false;
        }
        if (typeof Symbol !== "function") {
          return false;
        }
        if (typeof origSymbol("foo") !== "symbol") {
          return false;
        }
        if (typeof Symbol("bar") !== "symbol") {
          return false;
        }
        return hasSymbolSham();
      };
      return hasSymbols2;
    }
    var Reflect_getPrototypeOf2;
    var hasRequiredReflect_getPrototypeOf2;
    function requireReflect_getPrototypeOf2() {
      if (hasRequiredReflect_getPrototypeOf2) return Reflect_getPrototypeOf2;
      hasRequiredReflect_getPrototypeOf2 = 1;
      Reflect_getPrototypeOf2 = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
      return Reflect_getPrototypeOf2;
    }
    var Object_getPrototypeOf2;
    var hasRequiredObject_getPrototypeOf2;
    function requireObject_getPrototypeOf2() {
      if (hasRequiredObject_getPrototypeOf2) return Object_getPrototypeOf2;
      hasRequiredObject_getPrototypeOf2 = 1;
      var $Object = /* @__PURE__ */ requireEsObjectAtoms2();
      Object_getPrototypeOf2 = $Object.getPrototypeOf || null;
      return Object_getPrototypeOf2;
    }
    var implementation2;
    var hasRequiredImplementation2;
    function requireImplementation2() {
      if (hasRequiredImplementation2) return implementation2;
      hasRequiredImplementation2 = 1;
      var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
      var toStr = Object.prototype.toString;
      var max22 = Math.max;
      var funcType = "[object Function]";
      var concatty = function concatty2(a, b) {
        var arr = [];
        for (var i = 0; i < a.length; i += 1) {
          arr[i] = a[i];
        }
        for (var j = 0; j < b.length; j += 1) {
          arr[j + a.length] = b[j];
        }
        return arr;
      };
      var slicy = function slicy2(arrLike, offset) {
        var arr = [];
        for (var i = offset, j = 0; i < arrLike.length; i += 1, j += 1) {
          arr[j] = arrLike[i];
        }
        return arr;
      };
      var joiny = function(arr, joiner) {
        var str = "";
        for (var i = 0; i < arr.length; i += 1) {
          str += arr[i];
          if (i + 1 < arr.length) {
            str += joiner;
          }
        }
        return str;
      };
      implementation2 = function bind(that) {
        var target = this;
        if (typeof target !== "function" || toStr.apply(target) !== funcType) {
          throw new TypeError(ERROR_MESSAGE + target);
        }
        var args = slicy(arguments, 1);
        var bound;
        var binder = function() {
          if (this instanceof bound) {
            var result = target.apply(
              this,
              concatty(args, arguments)
            );
            if (Object(result) === result) {
              return result;
            }
            return this;
          }
          return target.apply(
            that,
            concatty(args, arguments)
          );
        };
        var boundLength = max22(0, target.length - args.length);
        var boundArgs = [];
        for (var i = 0; i < boundLength; i++) {
          boundArgs[i] = "$" + i;
        }
        bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
        if (target.prototype) {
          var Empty = function Empty2() {
          };
          Empty.prototype = target.prototype;
          bound.prototype = new Empty();
          Empty.prototype = null;
        }
        return bound;
      };
      return implementation2;
    }
    var functionBind2;
    var hasRequiredFunctionBind2;
    function requireFunctionBind2() {
      if (hasRequiredFunctionBind2) return functionBind2;
      hasRequiredFunctionBind2 = 1;
      var implementation22 = requireImplementation2();
      functionBind2 = Function.prototype.bind || implementation22;
      return functionBind2;
    }
    var functionCall2;
    var hasRequiredFunctionCall2;
    function requireFunctionCall2() {
      if (hasRequiredFunctionCall2) return functionCall2;
      hasRequiredFunctionCall2 = 1;
      functionCall2 = Function.prototype.call;
      return functionCall2;
    }
    var functionApply2;
    var hasRequiredFunctionApply2;
    function requireFunctionApply2() {
      if (hasRequiredFunctionApply2) return functionApply2;
      hasRequiredFunctionApply2 = 1;
      functionApply2 = Function.prototype.apply;
      return functionApply2;
    }
    var reflectApply2;
    var hasRequiredReflectApply2;
    function requireReflectApply2() {
      if (hasRequiredReflectApply2) return reflectApply2;
      hasRequiredReflectApply2 = 1;
      reflectApply2 = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
      return reflectApply2;
    }
    var actualApply2;
    var hasRequiredActualApply2;
    function requireActualApply2() {
      if (hasRequiredActualApply2) return actualApply2;
      hasRequiredActualApply2 = 1;
      var bind = requireFunctionBind2();
      var $apply = requireFunctionApply2();
      var $call = requireFunctionCall2();
      var $reflectApply = requireReflectApply2();
      actualApply2 = $reflectApply || bind.call($call, $apply);
      return actualApply2;
    }
    var callBindApplyHelpers2;
    var hasRequiredCallBindApplyHelpers2;
    function requireCallBindApplyHelpers2() {
      if (hasRequiredCallBindApplyHelpers2) return callBindApplyHelpers2;
      hasRequiredCallBindApplyHelpers2 = 1;
      var bind = requireFunctionBind2();
      var $TypeError = /* @__PURE__ */ requireType2();
      var $call = requireFunctionCall2();
      var $actualApply = requireActualApply2();
      callBindApplyHelpers2 = function callBindBasic(args) {
        if (args.length < 1 || typeof args[0] !== "function") {
          throw new $TypeError("a function is required");
        }
        return $actualApply(bind, $call, args);
      };
      return callBindApplyHelpers2;
    }
    var get2;
    var hasRequiredGet2;
    function requireGet2() {
      if (hasRequiredGet2) return get2;
      hasRequiredGet2 = 1;
      var callBind22 = requireCallBindApplyHelpers2();
      var gOPD22 = /* @__PURE__ */ requireGopd2();
      var hasProtoAccessor;
      try {
        hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
        [].__proto__ === Array.prototype;
      } catch (e) {
        if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
          throw e;
        }
      }
      var desc = !!hasProtoAccessor && gOPD22 && gOPD22(
        Object.prototype,
        /** @type {keyof typeof Object.prototype} */
        "__proto__"
      );
      var $Object = Object;
      var $getPrototypeOf = $Object.getPrototypeOf;
      get2 = desc && typeof desc.get === "function" ? callBind22([desc.get]) : typeof $getPrototypeOf === "function" ? (
        /** @type {import('./get')} */
        (function getDunder(value) {
          return $getPrototypeOf(value == null ? value : $Object(value));
        })
      ) : false;
      return get2;
    }
    var getProto2;
    var hasRequiredGetProto2;
    function requireGetProto2() {
      if (hasRequiredGetProto2) return getProto2;
      hasRequiredGetProto2 = 1;
      var reflectGetProto = requireReflect_getPrototypeOf2();
      var originalGetProto = requireObject_getPrototypeOf2();
      var getDunderProto = /* @__PURE__ */ requireGet2();
      getProto2 = reflectGetProto ? function getProto22(O) {
        return reflectGetProto(O);
      } : originalGetProto ? function getProto22(O) {
        if (!O || typeof O !== "object" && typeof O !== "function") {
          throw new TypeError("getProto: not an object");
        }
        return originalGetProto(O);
      } : getDunderProto ? function getProto22(O) {
        return getDunderProto(O);
      } : null;
      return getProto2;
    }
    var hasown2;
    var hasRequiredHasown2;
    function requireHasown2() {
      if (hasRequiredHasown2) return hasown2;
      hasRequiredHasown2 = 1;
      var call = Function.prototype.call;
      var $hasOwn = Object.prototype.hasOwnProperty;
      var bind = requireFunctionBind2();
      hasown2 = bind.call(call, $hasOwn);
      return hasown2;
    }
    var getIntrinsic2;
    var hasRequiredGetIntrinsic2;
    function requireGetIntrinsic2() {
      if (hasRequiredGetIntrinsic2) return getIntrinsic2;
      hasRequiredGetIntrinsic2 = 1;
      var undefined$1;
      var $Object = /* @__PURE__ */ requireEsObjectAtoms2();
      var $Error = /* @__PURE__ */ requireEsErrors2();
      var $EvalError = /* @__PURE__ */ require_eval2();
      var $RangeError = /* @__PURE__ */ requireRange2();
      var $ReferenceError = /* @__PURE__ */ requireRef2();
      var $SyntaxError = /* @__PURE__ */ requireSyntax2();
      var $TypeError = /* @__PURE__ */ requireType2();
      var $URIError = /* @__PURE__ */ requireUri2();
      var abs22 = /* @__PURE__ */ requireAbs2();
      var floor22 = /* @__PURE__ */ requireFloor2();
      var max22 = /* @__PURE__ */ requireMax2();
      var min22 = /* @__PURE__ */ requireMin2();
      var pow22 = /* @__PURE__ */ requirePow2();
      var round22 = /* @__PURE__ */ requireRound2();
      var sign22 = /* @__PURE__ */ requireSign2();
      var $Function = Function;
      var getEvalledConstructor = function(expressionSyntax) {
        try {
          return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
        } catch (e) {
        }
      };
      var $gOPD = /* @__PURE__ */ requireGopd2();
      var $defineProperty = /* @__PURE__ */ requireEsDefineProperty2();
      var throwTypeError = function() {
        throw new $TypeError();
      };
      var ThrowTypeError = $gOPD ? (function() {
        try {
          arguments.callee;
          return throwTypeError;
        } catch (calleeThrows) {
          try {
            return $gOPD(arguments, "callee").get;
          } catch (gOPDthrows) {
            return throwTypeError;
          }
        }
      })() : throwTypeError;
      var hasSymbols22 = requireHasSymbols2()();
      var getProto22 = requireGetProto2();
      var $ObjectGPO = requireObject_getPrototypeOf2();
      var $ReflectGPO = requireReflect_getPrototypeOf2();
      var $apply = requireFunctionApply2();
      var $call = requireFunctionCall2();
      var needsEval = {};
      var TypedArray = typeof Uint8Array === "undefined" || !getProto22 ? undefined$1 : getProto22(Uint8Array);
      var INTRINSICS = {
        __proto__: null,
        "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
        "%Array%": Array,
        "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
        "%ArrayIteratorPrototype%": hasSymbols22 && getProto22 ? getProto22([][Symbol.iterator]()) : undefined$1,
        "%AsyncFromSyncIteratorPrototype%": undefined$1,
        "%AsyncFunction%": needsEval,
        "%AsyncGenerator%": needsEval,
        "%AsyncGeneratorFunction%": needsEval,
        "%AsyncIteratorPrototype%": needsEval,
        "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
        "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
        "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
        "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
        "%Boolean%": Boolean,
        "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
        "%Date%": Date,
        "%decodeURI%": decodeURI,
        "%decodeURIComponent%": decodeURIComponent,
        "%encodeURI%": encodeURI,
        "%encodeURIComponent%": encodeURIComponent,
        "%Error%": $Error,
        "%eval%": eval,
        // eslint-disable-line no-eval
        "%EvalError%": $EvalError,
        "%Float16Array%": typeof Float16Array === "undefined" ? undefined$1 : Float16Array,
        "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
        "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
        "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
        "%Function%": $Function,
        "%GeneratorFunction%": needsEval,
        "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
        "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
        "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
        "%isFinite%": isFinite,
        "%isNaN%": isNaN,
        "%IteratorPrototype%": hasSymbols22 && getProto22 ? getProto22(getProto22([][Symbol.iterator]())) : undefined$1,
        "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
        "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
        "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols22 || !getProto22 ? undefined$1 : getProto22((/* @__PURE__ */ new Map())[Symbol.iterator]()),
        "%Math%": Math,
        "%Number%": Number,
        "%Object%": $Object,
        "%Object.getOwnPropertyDescriptor%": $gOPD,
        "%parseFloat%": parseFloat,
        "%parseInt%": parseInt,
        "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
        "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
        "%RangeError%": $RangeError,
        "%ReferenceError%": $ReferenceError,
        "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
        "%RegExp%": RegExp,
        "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
        "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols22 || !getProto22 ? undefined$1 : getProto22((/* @__PURE__ */ new Set())[Symbol.iterator]()),
        "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
        "%String%": String,
        "%StringIteratorPrototype%": hasSymbols22 && getProto22 ? getProto22(""[Symbol.iterator]()) : undefined$1,
        "%Symbol%": hasSymbols22 ? Symbol : undefined$1,
        "%SyntaxError%": $SyntaxError,
        "%ThrowTypeError%": ThrowTypeError,
        "%TypedArray%": TypedArray,
        "%TypeError%": $TypeError,
        "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
        "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
        "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
        "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
        "%URIError%": $URIError,
        "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
        "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
        "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet,
        "%Function.prototype.call%": $call,
        "%Function.prototype.apply%": $apply,
        "%Object.defineProperty%": $defineProperty,
        "%Object.getPrototypeOf%": $ObjectGPO,
        "%Math.abs%": abs22,
        "%Math.floor%": floor22,
        "%Math.max%": max22,
        "%Math.min%": min22,
        "%Math.pow%": pow22,
        "%Math.round%": round22,
        "%Math.sign%": sign22,
        "%Reflect.getPrototypeOf%": $ReflectGPO
      };
      if (getProto22) {
        try {
          null.error;
        } catch (e) {
          var errorProto = getProto22(getProto22(e));
          INTRINSICS["%Error.prototype%"] = errorProto;
        }
      }
      var doEval = function doEval2(name) {
        var value;
        if (name === "%AsyncFunction%") {
          value = getEvalledConstructor("async function () {}");
        } else if (name === "%GeneratorFunction%") {
          value = getEvalledConstructor("function* () {}");
        } else if (name === "%AsyncGeneratorFunction%") {
          value = getEvalledConstructor("async function* () {}");
        } else if (name === "%AsyncGenerator%") {
          var fn = doEval2("%AsyncGeneratorFunction%");
          if (fn) {
            value = fn.prototype;
          }
        } else if (name === "%AsyncIteratorPrototype%") {
          var gen = doEval2("%AsyncGenerator%");
          if (gen && getProto22) {
            value = getProto22(gen.prototype);
          }
        }
        INTRINSICS[name] = value;
        return value;
      };
      var LEGACY_ALIASES = {
        __proto__: null,
        "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
        "%ArrayPrototype%": ["Array", "prototype"],
        "%ArrayProto_entries%": ["Array", "prototype", "entries"],
        "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
        "%ArrayProto_keys%": ["Array", "prototype", "keys"],
        "%ArrayProto_values%": ["Array", "prototype", "values"],
        "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
        "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
        "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
        "%BooleanPrototype%": ["Boolean", "prototype"],
        "%DataViewPrototype%": ["DataView", "prototype"],
        "%DatePrototype%": ["Date", "prototype"],
        "%ErrorPrototype%": ["Error", "prototype"],
        "%EvalErrorPrototype%": ["EvalError", "prototype"],
        "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
        "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
        "%FunctionPrototype%": ["Function", "prototype"],
        "%Generator%": ["GeneratorFunction", "prototype"],
        "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
        "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
        "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
        "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
        "%JSONParse%": ["JSON", "parse"],
        "%JSONStringify%": ["JSON", "stringify"],
        "%MapPrototype%": ["Map", "prototype"],
        "%NumberPrototype%": ["Number", "prototype"],
        "%ObjectPrototype%": ["Object", "prototype"],
        "%ObjProto_toString%": ["Object", "prototype", "toString"],
        "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
        "%PromisePrototype%": ["Promise", "prototype"],
        "%PromiseProto_then%": ["Promise", "prototype", "then"],
        "%Promise_all%": ["Promise", "all"],
        "%Promise_reject%": ["Promise", "reject"],
        "%Promise_resolve%": ["Promise", "resolve"],
        "%RangeErrorPrototype%": ["RangeError", "prototype"],
        "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
        "%RegExpPrototype%": ["RegExp", "prototype"],
        "%SetPrototype%": ["Set", "prototype"],
        "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
        "%StringPrototype%": ["String", "prototype"],
        "%SymbolPrototype%": ["Symbol", "prototype"],
        "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
        "%TypedArrayPrototype%": ["TypedArray", "prototype"],
        "%TypeErrorPrototype%": ["TypeError", "prototype"],
        "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
        "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
        "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
        "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
        "%URIErrorPrototype%": ["URIError", "prototype"],
        "%WeakMapPrototype%": ["WeakMap", "prototype"],
        "%WeakSetPrototype%": ["WeakSet", "prototype"]
      };
      var bind = requireFunctionBind2();
      var hasOwn = /* @__PURE__ */ requireHasown2();
      var $concat = bind.call($call, Array.prototype.concat);
      var $spliceApply = bind.call($apply, Array.prototype.splice);
      var $replace = bind.call($call, String.prototype.replace);
      var $strSlice = bind.call($call, String.prototype.slice);
      var $exec = bind.call($call, RegExp.prototype.exec);
      var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
      var reEscapeChar = /\\(\\)?/g;
      var stringToPath = function stringToPath2(string) {
        var first = $strSlice(string, 0, 1);
        var last = $strSlice(string, -1);
        if (first === "%" && last !== "%") {
          throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
        } else if (last === "%" && first !== "%") {
          throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
        }
        var result = [];
        $replace(string, rePropName, function(match, number, quote, subString) {
          result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
        });
        return result;
      };
      var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
        var intrinsicName = name;
        var alias;
        if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
          alias = LEGACY_ALIASES[intrinsicName];
          intrinsicName = "%" + alias[0] + "%";
        }
        if (hasOwn(INTRINSICS, intrinsicName)) {
          var value = INTRINSICS[intrinsicName];
          if (value === needsEval) {
            value = doEval(intrinsicName);
          }
          if (typeof value === "undefined" && !allowMissing) {
            throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
          }
          return {
            alias,
            name: intrinsicName,
            value
          };
        }
        throw new $SyntaxError("intrinsic " + name + " does not exist!");
      };
      getIntrinsic2 = function GetIntrinsic(name, allowMissing) {
        if (typeof name !== "string" || name.length === 0) {
          throw new $TypeError("intrinsic name must be a non-empty string");
        }
        if (arguments.length > 1 && typeof allowMissing !== "boolean") {
          throw new $TypeError('"allowMissing" argument must be a boolean');
        }
        if ($exec(/^%?[^%]*%?$/, name) === null) {
          throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
        }
        var parts = stringToPath(name);
        var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
        var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
        var intrinsicRealName = intrinsic.name;
        var value = intrinsic.value;
        var skipFurtherCaching = false;
        var alias = intrinsic.alias;
        if (alias) {
          intrinsicBaseName = alias[0];
          $spliceApply(parts, $concat([0, 1], alias));
        }
        for (var i = 1, isOwn = true; i < parts.length; i += 1) {
          var part = parts[i];
          var first = $strSlice(part, 0, 1);
          var last = $strSlice(part, -1);
          if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
            throw new $SyntaxError("property names with quotes must have matching quotes");
          }
          if (part === "constructor" || !isOwn) {
            skipFurtherCaching = true;
          }
          intrinsicBaseName += "." + part;
          intrinsicRealName = "%" + intrinsicBaseName + "%";
          if (hasOwn(INTRINSICS, intrinsicRealName)) {
            value = INTRINSICS[intrinsicRealName];
          } else if (value != null) {
            if (!(part in value)) {
              if (!allowMissing) {
                throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
              }
              return void 0;
            }
            if ($gOPD && i + 1 >= parts.length) {
              var desc = $gOPD(value, part);
              isOwn = !!desc;
              if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
                value = desc.get;
              } else {
                value = value[part];
              }
            } else {
              isOwn = hasOwn(value, part);
              value = value[part];
            }
            if (isOwn && !skipFurtherCaching) {
              INTRINSICS[intrinsicRealName] = value;
            }
          }
        }
        return value;
      };
      return getIntrinsic2;
    }
    var callBind2 = { exports: {} };
    var defineDataProperty2;
    var hasRequiredDefineDataProperty2;
    function requireDefineDataProperty2() {
      if (hasRequiredDefineDataProperty2) return defineDataProperty2;
      hasRequiredDefineDataProperty2 = 1;
      var $defineProperty = /* @__PURE__ */ requireEsDefineProperty2();
      var $SyntaxError = /* @__PURE__ */ requireSyntax2();
      var $TypeError = /* @__PURE__ */ requireType2();
      var gopd22 = /* @__PURE__ */ requireGopd2();
      defineDataProperty2 = function defineDataProperty22(obj, property, value) {
        if (!obj || typeof obj !== "object" && typeof obj !== "function") {
          throw new $TypeError("`obj` must be an object or a function`");
        }
        if (typeof property !== "string" && typeof property !== "symbol") {
          throw new $TypeError("`property` must be a string or a symbol`");
        }
        if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
          throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
        }
        if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
          throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
        }
        if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
          throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
        }
        if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
          throw new $TypeError("`loose`, if provided, must be a boolean");
        }
        var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
        var nonWritable = arguments.length > 4 ? arguments[4] : null;
        var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
        var loose = arguments.length > 6 ? arguments[6] : false;
        var desc = !!gopd22 && gopd22(obj, property);
        if ($defineProperty) {
          $defineProperty(obj, property, {
            configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
            enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
            value,
            writable: nonWritable === null && desc ? desc.writable : !nonWritable
          });
        } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
          obj[property] = value;
        } else {
          throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
        }
      };
      return defineDataProperty2;
    }
    var hasPropertyDescriptors_12;
    var hasRequiredHasPropertyDescriptors2;
    function requireHasPropertyDescriptors2() {
      if (hasRequiredHasPropertyDescriptors2) return hasPropertyDescriptors_12;
      hasRequiredHasPropertyDescriptors2 = 1;
      var $defineProperty = /* @__PURE__ */ requireEsDefineProperty2();
      var hasPropertyDescriptors = function hasPropertyDescriptors2() {
        return !!$defineProperty;
      };
      hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
        if (!$defineProperty) {
          return null;
        }
        try {
          return $defineProperty([], "length", { value: 1 }).length !== 1;
        } catch (e) {
          return true;
        }
      };
      hasPropertyDescriptors_12 = hasPropertyDescriptors;
      return hasPropertyDescriptors_12;
    }
    var setFunctionLength2;
    var hasRequiredSetFunctionLength2;
    function requireSetFunctionLength2() {
      if (hasRequiredSetFunctionLength2) return setFunctionLength2;
      hasRequiredSetFunctionLength2 = 1;
      var GetIntrinsic = /* @__PURE__ */ requireGetIntrinsic2();
      var define = /* @__PURE__ */ requireDefineDataProperty2();
      var hasDescriptors = /* @__PURE__ */ requireHasPropertyDescriptors2()();
      var gOPD22 = /* @__PURE__ */ requireGopd2();
      var $TypeError = /* @__PURE__ */ requireType2();
      var $floor = GetIntrinsic("%Math.floor%");
      setFunctionLength2 = function setFunctionLength22(fn, length) {
        if (typeof fn !== "function") {
          throw new $TypeError("`fn` is not a function");
        }
        if (typeof length !== "number" || length < 0 || length > 4294967295 || $floor(length) !== length) {
          throw new $TypeError("`length` must be a positive 32-bit integer");
        }
        var loose = arguments.length > 2 && !!arguments[2];
        var functionLengthIsConfigurable = true;
        var functionLengthIsWritable = true;
        if ("length" in fn && gOPD22) {
          var desc = gOPD22(fn, "length");
          if (desc && !desc.configurable) {
            functionLengthIsConfigurable = false;
          }
          if (desc && !desc.writable) {
            functionLengthIsWritable = false;
          }
        }
        if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
          if (hasDescriptors) {
            define(
              /** @type {Parameters<define>[0]} */
              fn,
              "length",
              length,
              true,
              true
            );
          } else {
            define(
              /** @type {Parameters<define>[0]} */
              fn,
              "length",
              length
            );
          }
        }
        return fn;
      };
      return setFunctionLength2;
    }
    var hasRequiredCallBind2;
    function requireCallBind2() {
      if (hasRequiredCallBind2) return callBind2.exports;
      hasRequiredCallBind2 = 1;
      (function(module22) {
        var bind = requireFunctionBind2();
        var GetIntrinsic = /* @__PURE__ */ requireGetIntrinsic2();
        var setFunctionLength22 = /* @__PURE__ */ requireSetFunctionLength2();
        var $TypeError = /* @__PURE__ */ requireType2();
        var $apply = GetIntrinsic("%Function.prototype.apply%");
        var $call = GetIntrinsic("%Function.prototype.call%");
        var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
        var $defineProperty = /* @__PURE__ */ requireEsDefineProperty2();
        var $max = GetIntrinsic("%Math.max%");
        module22.exports = function callBind22(originalFunction) {
          if (typeof originalFunction !== "function") {
            throw new $TypeError("a function is required");
          }
          var func = $reflectApply(bind, $call, arguments);
          return setFunctionLength22(
            func,
            1 + $max(0, originalFunction.length - (arguments.length - 1)),
            true
          );
        };
        var applyBind = function applyBind2() {
          return $reflectApply(bind, $apply, arguments);
        };
        if ($defineProperty) {
          $defineProperty(module22.exports, "apply", { value: applyBind });
        } else {
          module22.exports.apply = applyBind;
        }
      })(callBind2);
      return callBind2.exports;
    }
    var callBound2;
    var hasRequiredCallBound2;
    function requireCallBound2() {
      if (hasRequiredCallBound2) return callBound2;
      hasRequiredCallBound2 = 1;
      var GetIntrinsic = /* @__PURE__ */ requireGetIntrinsic2();
      var callBind22 = requireCallBind2();
      var $indexOf = callBind22(GetIntrinsic("String.prototype.indexOf"));
      callBound2 = function callBoundIntrinsic(name, allowMissing) {
        var intrinsic = GetIntrinsic(name, !!allowMissing);
        if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
          return callBind22(intrinsic);
        }
        return intrinsic;
      };
      return callBound2;
    }
    var isArguments2;
    var hasRequiredIsArguments2;
    function requireIsArguments2() {
      if (hasRequiredIsArguments2) return isArguments2;
      hasRequiredIsArguments2 = 1;
      var hasToStringTag = requireShams2()();
      var callBound22 = requireCallBound2();
      var $toString = callBound22("Object.prototype.toString");
      var isStandardArguments = function isArguments22(value) {
        if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
          return false;
        }
        return $toString(value) === "[object Arguments]";
      };
      var isLegacyArguments = function isArguments22(value) {
        if (isStandardArguments(value)) {
          return true;
        }
        return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && $toString(value.callee) === "[object Function]";
      };
      var supportsStandardArguments = (function() {
        return isStandardArguments(arguments);
      })();
      isStandardArguments.isLegacyArguments = isLegacyArguments;
      isArguments2 = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
      return isArguments2;
    }
    var isGeneratorFunction2;
    var hasRequiredIsGeneratorFunction2;
    function requireIsGeneratorFunction2() {
      if (hasRequiredIsGeneratorFunction2) return isGeneratorFunction2;
      hasRequiredIsGeneratorFunction2 = 1;
      var toStr = Object.prototype.toString;
      var fnToStr = Function.prototype.toString;
      var isFnRegex = /^\s*(?:function)?\*/;
      var hasToStringTag = requireShams2()();
      var getProto22 = Object.getPrototypeOf;
      var getGeneratorFunc = function() {
        if (!hasToStringTag) {
          return false;
        }
        try {
          return Function("return function*() {}")();
        } catch (e) {
        }
      };
      var GeneratorFunction;
      isGeneratorFunction2 = function isGeneratorFunction22(fn) {
        if (typeof fn !== "function") {
          return false;
        }
        if (isFnRegex.test(fnToStr.call(fn))) {
          return true;
        }
        if (!hasToStringTag) {
          var str = toStr.call(fn);
          return str === "[object GeneratorFunction]";
        }
        if (!getProto22) {
          return false;
        }
        if (typeof GeneratorFunction === "undefined") {
          var generatorFunc = getGeneratorFunc();
          GeneratorFunction = generatorFunc ? getProto22(generatorFunc) : false;
        }
        return getProto22(fn) === GeneratorFunction;
      };
      return isGeneratorFunction2;
    }
    var isCallable2;
    var hasRequiredIsCallable2;
    function requireIsCallable2() {
      if (hasRequiredIsCallable2) return isCallable2;
      hasRequiredIsCallable2 = 1;
      var fnToStr = Function.prototype.toString;
      var reflectApply22 = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
      var badArrayLike;
      var isCallableMarker;
      if (typeof reflectApply22 === "function" && typeof Object.defineProperty === "function") {
        try {
          badArrayLike = Object.defineProperty({}, "length", {
            get: function() {
              throw isCallableMarker;
            }
          });
          isCallableMarker = {};
          reflectApply22(function() {
            throw 42;
          }, null, badArrayLike);
        } catch (_) {
          if (_ !== isCallableMarker) {
            reflectApply22 = null;
          }
        }
      } else {
        reflectApply22 = null;
      }
      var constructorRegex = /^\s*class\b/;
      var isES6ClassFn = function isES6ClassFunction(value) {
        try {
          var fnStr = fnToStr.call(value);
          return constructorRegex.test(fnStr);
        } catch (e) {
          return false;
        }
      };
      var tryFunctionObject = function tryFunctionToStr(value) {
        try {
          if (isES6ClassFn(value)) {
            return false;
          }
          fnToStr.call(value);
          return true;
        } catch (e) {
          return false;
        }
      };
      var toStr = Object.prototype.toString;
      var objectClass = "[object Object]";
      var fnClass = "[object Function]";
      var genClass = "[object GeneratorFunction]";
      var ddaClass = "[object HTMLAllCollection]";
      var ddaClass2 = "[object HTML document.all class]";
      var ddaClass3 = "[object HTMLCollection]";
      var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
      var isIE68 = !(0 in [,]);
      var isDDA = function isDocumentDotAll() {
        return false;
      };
      if (typeof document === "object") {
        var all = document.all;
        if (toStr.call(all) === toStr.call(document.all)) {
          isDDA = function isDocumentDotAll(value) {
            if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
              try {
                var str = toStr.call(value);
                return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
              } catch (e) {
              }
            }
            return false;
          };
        }
      }
      isCallable2 = reflectApply22 ? function isCallable22(value) {
        if (isDDA(value)) {
          return true;
        }
        if (!value) {
          return false;
        }
        if (typeof value !== "function" && typeof value !== "object") {
          return false;
        }
        try {
          reflectApply22(value, null, badArrayLike);
        } catch (e) {
          if (e !== isCallableMarker) {
            return false;
          }
        }
        return !isES6ClassFn(value) && tryFunctionObject(value);
      } : function isCallable22(value) {
        if (isDDA(value)) {
          return true;
        }
        if (!value) {
          return false;
        }
        if (typeof value !== "function" && typeof value !== "object") {
          return false;
        }
        if (hasToStringTag) {
          return tryFunctionObject(value);
        }
        if (isES6ClassFn(value)) {
          return false;
        }
        var strClass = toStr.call(value);
        if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
          return false;
        }
        return tryFunctionObject(value);
      };
      return isCallable2;
    }
    var forEach_12;
    var hasRequiredForEach2;
    function requireForEach2() {
      if (hasRequiredForEach2) return forEach_12;
      hasRequiredForEach2 = 1;
      var isCallable22 = requireIsCallable2();
      var toStr = Object.prototype.toString;
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var forEachArray = function forEachArray2(array, iterator, receiver) {
        for (var i = 0, len = array.length; i < len; i++) {
          if (hasOwnProperty.call(array, i)) {
            if (receiver == null) {
              iterator(array[i], i, array);
            } else {
              iterator.call(receiver, array[i], i, array);
            }
          }
        }
      };
      var forEachString = function forEachString2(string, iterator, receiver) {
        for (var i = 0, len = string.length; i < len; i++) {
          if (receiver == null) {
            iterator(string.charAt(i), i, string);
          } else {
            iterator.call(receiver, string.charAt(i), i, string);
          }
        }
      };
      var forEachObject = function forEachObject2(object, iterator, receiver) {
        for (var k in object) {
          if (hasOwnProperty.call(object, k)) {
            if (receiver == null) {
              iterator(object[k], k, object);
            } else {
              iterator.call(receiver, object[k], k, object);
            }
          }
        }
      };
      var forEach = function forEach2(list, iterator, thisArg) {
        if (!isCallable22(iterator)) {
          throw new TypeError("iterator must be a function");
        }
        var receiver;
        if (arguments.length >= 3) {
          receiver = thisArg;
        }
        if (toStr.call(list) === "[object Array]") {
          forEachArray(list, iterator, receiver);
        } else if (typeof list === "string") {
          forEachString(list, iterator, receiver);
        } else {
          forEachObject(list, iterator, receiver);
        }
      };
      forEach_12 = forEach;
      return forEach_12;
    }
    var possibleTypedArrayNames2;
    var hasRequiredPossibleTypedArrayNames2;
    function requirePossibleTypedArrayNames2() {
      if (hasRequiredPossibleTypedArrayNames2) return possibleTypedArrayNames2;
      hasRequiredPossibleTypedArrayNames2 = 1;
      possibleTypedArrayNames2 = [
        "Float32Array",
        "Float64Array",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "BigInt64Array",
        "BigUint64Array"
      ];
      return possibleTypedArrayNames2;
    }
    var availableTypedArrays2;
    var hasRequiredAvailableTypedArrays2;
    function requireAvailableTypedArrays2() {
      if (hasRequiredAvailableTypedArrays2) return availableTypedArrays2;
      hasRequiredAvailableTypedArrays2 = 1;
      var possibleNames = /* @__PURE__ */ requirePossibleTypedArrayNames2();
      var g = typeof globalThis === "undefined" ? commonjsGlobal2 : globalThis;
      availableTypedArrays2 = function availableTypedArrays22() {
        var out = [];
        for (var i = 0; i < possibleNames.length; i++) {
          if (typeof g[possibleNames[i]] === "function") {
            out[out.length] = possibleNames[i];
          }
        }
        return out;
      };
      return availableTypedArrays2;
    }
    var whichTypedArray2;
    var hasRequiredWhichTypedArray2;
    function requireWhichTypedArray2() {
      if (hasRequiredWhichTypedArray2) return whichTypedArray2;
      hasRequiredWhichTypedArray2 = 1;
      var forEach = requireForEach2();
      var availableTypedArrays22 = /* @__PURE__ */ requireAvailableTypedArrays2();
      var callBind22 = requireCallBind2();
      var callBound22 = requireCallBound2();
      var gOPD22 = /* @__PURE__ */ requireGopd2();
      var $toString = callBound22("Object.prototype.toString");
      var hasToStringTag = requireShams2()();
      var g = typeof globalThis === "undefined" ? commonjsGlobal2 : globalThis;
      var typedArrays = availableTypedArrays22();
      var $slice = callBound22("String.prototype.slice");
      var getPrototypeOf = Object.getPrototypeOf;
      var $indexOf = callBound22("Array.prototype.indexOf", true) || function indexOf(array, value) {
        for (var i = 0; i < array.length; i += 1) {
          if (array[i] === value) {
            return i;
          }
        }
        return -1;
      };
      var cache = { __proto__: null };
      if (hasToStringTag && gOPD22 && getPrototypeOf) {
        forEach(typedArrays, function(typedArray) {
          var arr = new g[typedArray]();
          if (Symbol.toStringTag in arr) {
            var proto = getPrototypeOf(arr);
            var descriptor = gOPD22(proto, Symbol.toStringTag);
            if (!descriptor) {
              var superProto = getPrototypeOf(proto);
              descriptor = gOPD22(superProto, Symbol.toStringTag);
            }
            cache["$" + typedArray] = callBind22(descriptor.get);
          }
        });
      } else {
        forEach(typedArrays, function(typedArray) {
          var arr = new g[typedArray]();
          var fn = arr.slice || arr.set;
          if (fn) {
            cache["$" + typedArray] = callBind22(fn);
          }
        });
      }
      var tryTypedArrays = function tryAllTypedArrays(value) {
        var found = false;
        forEach(
          // eslint-disable-next-line no-extra-parens
          /** @type {Record<`\$${TypedArrayName}`, Getter>} */
          /** @type {any} */
          cache,
          /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
          function(getter, typedArray) {
            if (!found) {
              try {
                if ("$" + getter(value) === typedArray) {
                  found = $slice(typedArray, 1);
                }
              } catch (e) {
              }
            }
          }
        );
        return found;
      };
      var trySlices = function tryAllSlices(value) {
        var found = false;
        forEach(
          // eslint-disable-next-line no-extra-parens
          /** @type {Record<`\$${TypedArrayName}`, Getter>} */
          /** @type {any} */
          cache,
          /** @type {(getter: typeof cache, name: `\$${import('.').TypedArrayName}`) => void} */
          function(getter, name) {
            if (!found) {
              try {
                getter(value);
                found = $slice(name, 1);
              } catch (e) {
              }
            }
          }
        );
        return found;
      };
      whichTypedArray2 = function whichTypedArray22(value) {
        if (!value || typeof value !== "object") {
          return false;
        }
        if (!hasToStringTag) {
          var tag = $slice($toString(value), 8, -1);
          if ($indexOf(typedArrays, tag) > -1) {
            return tag;
          }
          if (tag !== "Object") {
            return false;
          }
          return trySlices(value);
        }
        if (!gOPD22) {
          return null;
        }
        return tryTypedArrays(value);
      };
      return whichTypedArray2;
    }
    var isTypedArray2;
    var hasRequiredIsTypedArray2;
    function requireIsTypedArray2() {
      if (hasRequiredIsTypedArray2) return isTypedArray2;
      hasRequiredIsTypedArray2 = 1;
      var whichTypedArray22 = /* @__PURE__ */ requireWhichTypedArray2();
      isTypedArray2 = function isTypedArray22(value) {
        return !!whichTypedArray22(value);
      };
      return isTypedArray2;
    }
    var hasRequiredTypes2;
    function requireTypes2() {
      if (hasRequiredTypes2) return types2;
      hasRequiredTypes2 = 1;
      (function(exports22) {
        var isArgumentsObject = requireIsArguments2();
        var isGeneratorFunction22 = requireIsGeneratorFunction2();
        var whichTypedArray22 = /* @__PURE__ */ requireWhichTypedArray2();
        var isTypedArray22 = /* @__PURE__ */ requireIsTypedArray2();
        function uncurryThis(f) {
          return f.call.bind(f);
        }
        var BigIntSupported = typeof BigInt !== "undefined";
        var SymbolSupported = typeof Symbol !== "undefined";
        var ObjectToString = uncurryThis(Object.prototype.toString);
        var numberValue = uncurryThis(Number.prototype.valueOf);
        var stringValue = uncurryThis(String.prototype.valueOf);
        var booleanValue = uncurryThis(Boolean.prototype.valueOf);
        if (BigIntSupported) {
          var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
        }
        if (SymbolSupported) {
          var symbolValue = uncurryThis(Symbol.prototype.valueOf);
        }
        function checkBoxedPrimitive(value, prototypeValueOf) {
          if (typeof value !== "object") {
            return false;
          }
          try {
            prototypeValueOf(value);
            return true;
          } catch (e) {
            return false;
          }
        }
        exports22.isArgumentsObject = isArgumentsObject;
        exports22.isGeneratorFunction = isGeneratorFunction22;
        exports22.isTypedArray = isTypedArray22;
        function isPromise(input) {
          return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
        }
        exports22.isPromise = isPromise;
        function isArrayBufferView(value) {
          if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
            return ArrayBuffer.isView(value);
          }
          return isTypedArray22(value) || isDataView(value);
        }
        exports22.isArrayBufferView = isArrayBufferView;
        function isUint8Array(value) {
          return whichTypedArray22(value) === "Uint8Array";
        }
        exports22.isUint8Array = isUint8Array;
        function isUint8ClampedArray(value) {
          return whichTypedArray22(value) === "Uint8ClampedArray";
        }
        exports22.isUint8ClampedArray = isUint8ClampedArray;
        function isUint16Array(value) {
          return whichTypedArray22(value) === "Uint16Array";
        }
        exports22.isUint16Array = isUint16Array;
        function isUint32Array(value) {
          return whichTypedArray22(value) === "Uint32Array";
        }
        exports22.isUint32Array = isUint32Array;
        function isInt8Array(value) {
          return whichTypedArray22(value) === "Int8Array";
        }
        exports22.isInt8Array = isInt8Array;
        function isInt16Array(value) {
          return whichTypedArray22(value) === "Int16Array";
        }
        exports22.isInt16Array = isInt16Array;
        function isInt32Array(value) {
          return whichTypedArray22(value) === "Int32Array";
        }
        exports22.isInt32Array = isInt32Array;
        function isFloat32Array(value) {
          return whichTypedArray22(value) === "Float32Array";
        }
        exports22.isFloat32Array = isFloat32Array;
        function isFloat64Array(value) {
          return whichTypedArray22(value) === "Float64Array";
        }
        exports22.isFloat64Array = isFloat64Array;
        function isBigInt64Array(value) {
          return whichTypedArray22(value) === "BigInt64Array";
        }
        exports22.isBigInt64Array = isBigInt64Array;
        function isBigUint64Array(value) {
          return whichTypedArray22(value) === "BigUint64Array";
        }
        exports22.isBigUint64Array = isBigUint64Array;
        function isMapToString(value) {
          return ObjectToString(value) === "[object Map]";
        }
        isMapToString.working = typeof Map !== "undefined" && isMapToString(/* @__PURE__ */ new Map());
        function isMap(value) {
          if (typeof Map === "undefined") {
            return false;
          }
          return isMapToString.working ? isMapToString(value) : value instanceof Map;
        }
        exports22.isMap = isMap;
        function isSetToString(value) {
          return ObjectToString(value) === "[object Set]";
        }
        isSetToString.working = typeof Set !== "undefined" && isSetToString(/* @__PURE__ */ new Set());
        function isSet(value) {
          if (typeof Set === "undefined") {
            return false;
          }
          return isSetToString.working ? isSetToString(value) : value instanceof Set;
        }
        exports22.isSet = isSet;
        function isWeakMapToString(value) {
          return ObjectToString(value) === "[object WeakMap]";
        }
        isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(/* @__PURE__ */ new WeakMap());
        function isWeakMap(value) {
          if (typeof WeakMap === "undefined") {
            return false;
          }
          return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
        }
        exports22.isWeakMap = isWeakMap;
        function isWeakSetToString(value) {
          return ObjectToString(value) === "[object WeakSet]";
        }
        isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(/* @__PURE__ */ new WeakSet());
        function isWeakSet(value) {
          return isWeakSetToString(value);
        }
        exports22.isWeakSet = isWeakSet;
        function isArrayBufferToString(value) {
          return ObjectToString(value) === "[object ArrayBuffer]";
        }
        isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
        function isArrayBuffer(value) {
          if (typeof ArrayBuffer === "undefined") {
            return false;
          }
          return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
        }
        exports22.isArrayBuffer = isArrayBuffer;
        function isDataViewToString(value) {
          return ObjectToString(value) === "[object DataView]";
        }
        isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
        function isDataView(value) {
          if (typeof DataView === "undefined") {
            return false;
          }
          return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
        }
        exports22.isDataView = isDataView;
        var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : void 0;
        function isSharedArrayBufferToString(value) {
          return ObjectToString(value) === "[object SharedArrayBuffer]";
        }
        function isSharedArrayBuffer(value) {
          if (typeof SharedArrayBufferCopy === "undefined") {
            return false;
          }
          if (typeof isSharedArrayBufferToString.working === "undefined") {
            isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
          }
          return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
        }
        exports22.isSharedArrayBuffer = isSharedArrayBuffer;
        function isAsyncFunction(value) {
          return ObjectToString(value) === "[object AsyncFunction]";
        }
        exports22.isAsyncFunction = isAsyncFunction;
        function isMapIterator(value) {
          return ObjectToString(value) === "[object Map Iterator]";
        }
        exports22.isMapIterator = isMapIterator;
        function isSetIterator(value) {
          return ObjectToString(value) === "[object Set Iterator]";
        }
        exports22.isSetIterator = isSetIterator;
        function isGeneratorObject(value) {
          return ObjectToString(value) === "[object Generator]";
        }
        exports22.isGeneratorObject = isGeneratorObject;
        function isWebAssemblyCompiledModule(value) {
          return ObjectToString(value) === "[object WebAssembly.Module]";
        }
        exports22.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
        function isNumberObject(value) {
          return checkBoxedPrimitive(value, numberValue);
        }
        exports22.isNumberObject = isNumberObject;
        function isStringObject(value) {
          return checkBoxedPrimitive(value, stringValue);
        }
        exports22.isStringObject = isStringObject;
        function isBooleanObject(value) {
          return checkBoxedPrimitive(value, booleanValue);
        }
        exports22.isBooleanObject = isBooleanObject;
        function isBigIntObject(value) {
          return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
        }
        exports22.isBigIntObject = isBigIntObject;
        function isSymbolObject(value) {
          return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
        }
        exports22.isSymbolObject = isSymbolObject;
        function isBoxedPrimitive(value) {
          return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
        }
        exports22.isBoxedPrimitive = isBoxedPrimitive;
        function isAnyArrayBuffer(value) {
          return typeof Uint8Array !== "undefined" && (isArrayBuffer(value) || isSharedArrayBuffer(value));
        }
        exports22.isAnyArrayBuffer = isAnyArrayBuffer;
        ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method) {
          Object.defineProperty(exports22, method, {
            enumerable: false,
            value: function() {
              throw new Error(method + " is not supported in userland");
            }
          });
        });
      })(types2);
      return types2;
    }
    var isBufferBrowser2;
    var hasRequiredIsBufferBrowser2;
    function requireIsBufferBrowser2() {
      if (hasRequiredIsBufferBrowser2) return isBufferBrowser2;
      hasRequiredIsBufferBrowser2 = 1;
      isBufferBrowser2 = function isBuffer(arg) {
        return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
      };
      return isBufferBrowser2;
    }
    var hasRequiredUtil2;
    function requireUtil2() {
      if (hasRequiredUtil2) return util2;
      hasRequiredUtil2 = 1;
      (function(exports22) {
        var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
          var keys = Object.keys(obj);
          var descriptors = {};
          for (var i = 0; i < keys.length; i++) {
            descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
          }
          return descriptors;
        };
        var formatRegExp = /%[sdj%]/g;
        exports22.format = function(f) {
          if (!isString(f)) {
            var objects = [];
            for (var i = 0; i < arguments.length; i++) {
              objects.push(inspect(arguments[i]));
            }
            return objects.join(" ");
          }
          var i = 1;
          var args = arguments;
          var len = args.length;
          var str = String(f).replace(formatRegExp, function(x2) {
            if (x2 === "%%") return "%";
            if (i >= len) return x2;
            switch (x2) {
              case "%s":
                return String(args[i++]);
              case "%d":
                return Number(args[i++]);
              case "%j":
                try {
                  return JSON.stringify(args[i++]);
                } catch (_) {
                  return "[Circular]";
                }
              default:
                return x2;
            }
          });
          for (var x = args[i]; i < len; x = args[++i]) {
            if (isNull(x) || !isObject(x)) {
              str += " " + x;
            } else {
              str += " " + inspect(x);
            }
          }
          return str;
        };
        exports22.deprecate = function(fn, msg) {
          if (typeof process$12 !== "undefined" && process$12.noDeprecation === true) {
            return fn;
          }
          if (typeof process$12 === "undefined") {
            return function() {
              return exports22.deprecate(fn, msg).apply(this, arguments);
            };
          }
          var warned = false;
          function deprecated() {
            if (!warned) {
              if (process$12.throwDeprecation) {
                throw new Error(msg);
              } else if (process$12.traceDeprecation) {
                console.trace(msg);
              } else {
                console.error(msg);
              }
              warned = true;
            }
            return fn.apply(this, arguments);
          }
          return deprecated;
        };
        var debugs = {};
        var debugEnvRegex = /^$/;
        if (process$12.env.NODE_DEBUG) {
          var debugEnv = process$12.env.NODE_DEBUG;
          debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
          debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
        }
        exports22.debuglog = function(set) {
          set = set.toUpperCase();
          if (!debugs[set]) {
            if (debugEnvRegex.test(set)) {
              var pid = process$12.pid;
              debugs[set] = function() {
                var msg = exports22.format.apply(exports22, arguments);
                console.error("%s %d: %s", set, pid, msg);
              };
            } else {
              debugs[set] = function() {
              };
            }
          }
          return debugs[set];
        };
        function inspect(obj, opts) {
          var ctx = {
            seen: [],
            stylize: stylizeNoColor
          };
          if (arguments.length >= 3) ctx.depth = arguments[2];
          if (arguments.length >= 4) ctx.colors = arguments[3];
          if (isBoolean(opts)) {
            ctx.showHidden = opts;
          } else if (opts) {
            exports22._extend(ctx, opts);
          }
          if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
          if (isUndefined(ctx.depth)) ctx.depth = 2;
          if (isUndefined(ctx.colors)) ctx.colors = false;
          if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
          if (ctx.colors) ctx.stylize = stylizeWithColor;
          return formatValue(ctx, obj, ctx.depth);
        }
        exports22.inspect = inspect;
        inspect.colors = {
          "bold": [1, 22],
          "italic": [3, 23],
          "underline": [4, 24],
          "inverse": [7, 27],
          "white": [37, 39],
          "grey": [90, 39],
          "black": [30, 39],
          "blue": [34, 39],
          "cyan": [36, 39],
          "green": [32, 39],
          "magenta": [35, 39],
          "red": [31, 39],
          "yellow": [33, 39]
        };
        inspect.styles = {
          "special": "cyan",
          "number": "yellow",
          "boolean": "yellow",
          "undefined": "grey",
          "null": "bold",
          "string": "green",
          "date": "magenta",
          // "name": intentionally not styling
          "regexp": "red"
        };
        function stylizeWithColor(str, styleType) {
          var style = inspect.styles[styleType];
          if (style) {
            return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
          } else {
            return str;
          }
        }
        function stylizeNoColor(str, styleType) {
          return str;
        }
        function arrayToHash(array) {
          var hash22 = {};
          array.forEach(function(val, idx) {
            hash22[val] = true;
          });
          return hash22;
        }
        function formatValue(ctx, value, recurseTimes) {
          if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
          value.inspect !== exports22.inspect && // Also filter out any prototype objects using the circular check.
          !(value.constructor && value.constructor.prototype === value)) {
            var ret = value.inspect(recurseTimes, ctx);
            if (!isString(ret)) {
              ret = formatValue(ctx, ret, recurseTimes);
            }
            return ret;
          }
          var primitive = formatPrimitive(ctx, value);
          if (primitive) {
            return primitive;
          }
          var keys = Object.keys(value);
          var visibleKeys = arrayToHash(keys);
          if (ctx.showHidden) {
            keys = Object.getOwnPropertyNames(value);
          }
          if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
            return formatError(value);
          }
          if (keys.length === 0) {
            if (isFunction(value)) {
              var name = value.name ? ": " + value.name : "";
              return ctx.stylize("[Function" + name + "]", "special");
            }
            if (isRegExp(value)) {
              return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
            }
            if (isDate(value)) {
              return ctx.stylize(Date.prototype.toString.call(value), "date");
            }
            if (isError(value)) {
              return formatError(value);
            }
          }
          var base = "", array = false, braces = ["{", "}"];
          if (isArray(value)) {
            array = true;
            braces = ["[", "]"];
          }
          if (isFunction(value)) {
            var n = value.name ? ": " + value.name : "";
            base = " [Function" + n + "]";
          }
          if (isRegExp(value)) {
            base = " " + RegExp.prototype.toString.call(value);
          }
          if (isDate(value)) {
            base = " " + Date.prototype.toUTCString.call(value);
          }
          if (isError(value)) {
            base = " " + formatError(value);
          }
          if (keys.length === 0 && (!array || value.length == 0)) {
            return braces[0] + base + braces[1];
          }
          if (recurseTimes < 0) {
            if (isRegExp(value)) {
              return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
            } else {
              return ctx.stylize("[Object]", "special");
            }
          }
          ctx.seen.push(value);
          var output;
          if (array) {
            output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
          } else {
            output = keys.map(function(key) {
              return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
            });
          }
          ctx.seen.pop();
          return reduceToSingleString(output, base, braces);
        }
        function formatPrimitive(ctx, value) {
          if (isUndefined(value))
            return ctx.stylize("undefined", "undefined");
          if (isString(value)) {
            var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
            return ctx.stylize(simple, "string");
          }
          if (isNumber(value))
            return ctx.stylize("" + value, "number");
          if (isBoolean(value))
            return ctx.stylize("" + value, "boolean");
          if (isNull(value))
            return ctx.stylize("null", "null");
        }
        function formatError(value) {
          return "[" + Error.prototype.toString.call(value) + "]";
        }
        function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
          var output = [];
          for (var i = 0, l = value.length; i < l; ++i) {
            if (hasOwnProperty(value, String(i))) {
              output.push(formatProperty(
                ctx,
                value,
                recurseTimes,
                visibleKeys,
                String(i),
                true
              ));
            } else {
              output.push("");
            }
          }
          keys.forEach(function(key) {
            if (!key.match(/^\d+$/)) {
              output.push(formatProperty(
                ctx,
                value,
                recurseTimes,
                visibleKeys,
                key,
                true
              ));
            }
          });
          return output;
        }
        function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
          var name, str, desc;
          desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
          if (desc.get) {
            if (desc.set) {
              str = ctx.stylize("[Getter/Setter]", "special");
            } else {
              str = ctx.stylize("[Getter]", "special");
            }
          } else {
            if (desc.set) {
              str = ctx.stylize("[Setter]", "special");
            }
          }
          if (!hasOwnProperty(visibleKeys, key)) {
            name = "[" + key + "]";
          }
          if (!str) {
            if (ctx.seen.indexOf(desc.value) < 0) {
              if (isNull(recurseTimes)) {
                str = formatValue(ctx, desc.value, null);
              } else {
                str = formatValue(ctx, desc.value, recurseTimes - 1);
              }
              if (str.indexOf("\n") > -1) {
                if (array) {
                  str = str.split("\n").map(function(line) {
                    return "  " + line;
                  }).join("\n").slice(2);
                } else {
                  str = "\n" + str.split("\n").map(function(line) {
                    return "   " + line;
                  }).join("\n");
                }
              }
            } else {
              str = ctx.stylize("[Circular]", "special");
            }
          }
          if (isUndefined(name)) {
            if (array && key.match(/^\d+$/)) {
              return str;
            }
            name = JSON.stringify("" + key);
            if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
              name = name.slice(1, -1);
              name = ctx.stylize(name, "name");
            } else {
              name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
              name = ctx.stylize(name, "string");
            }
          }
          return name + ": " + str;
        }
        function reduceToSingleString(output, base, braces) {
          var length = output.reduce(function(prev, cur) {
            if (cur.indexOf("\n") >= 0) ;
            return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
          }, 0);
          if (length > 60) {
            return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
          }
          return braces[0] + base + " " + output.join(", ") + " " + braces[1];
        }
        exports22.types = requireTypes2();
        function isArray(ar) {
          return Array.isArray(ar);
        }
        exports22.isArray = isArray;
        function isBoolean(arg) {
          return typeof arg === "boolean";
        }
        exports22.isBoolean = isBoolean;
        function isNull(arg) {
          return arg === null;
        }
        exports22.isNull = isNull;
        function isNullOrUndefined(arg) {
          return arg == null;
        }
        exports22.isNullOrUndefined = isNullOrUndefined;
        function isNumber(arg) {
          return typeof arg === "number";
        }
        exports22.isNumber = isNumber;
        function isString(arg) {
          return typeof arg === "string";
        }
        exports22.isString = isString;
        function isSymbol(arg) {
          return typeof arg === "symbol";
        }
        exports22.isSymbol = isSymbol;
        function isUndefined(arg) {
          return arg === void 0;
        }
        exports22.isUndefined = isUndefined;
        function isRegExp(re) {
          return isObject(re) && objectToString(re) === "[object RegExp]";
        }
        exports22.isRegExp = isRegExp;
        exports22.types.isRegExp = isRegExp;
        function isObject(arg) {
          return typeof arg === "object" && arg !== null;
        }
        exports22.isObject = isObject;
        function isDate(d) {
          return isObject(d) && objectToString(d) === "[object Date]";
        }
        exports22.isDate = isDate;
        exports22.types.isDate = isDate;
        function isError(e) {
          return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
        }
        exports22.isError = isError;
        exports22.types.isNativeError = isError;
        function isFunction(arg) {
          return typeof arg === "function";
        }
        exports22.isFunction = isFunction;
        function isPrimitive(arg) {
          return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
          typeof arg === "undefined";
        }
        exports22.isPrimitive = isPrimitive;
        exports22.isBuffer = requireIsBufferBrowser2();
        function objectToString(o) {
          return Object.prototype.toString.call(o);
        }
        function pad(n) {
          return n < 10 ? "0" + n.toString(10) : n.toString(10);
        }
        var months = [
          "Jan",
          "Feb",
          "Mar",
          "Apr",
          "May",
          "Jun",
          "Jul",
          "Aug",
          "Sep",
          "Oct",
          "Nov",
          "Dec"
        ];
        function timestamp() {
          var d = /* @__PURE__ */ new Date();
          var time = [
            pad(d.getHours()),
            pad(d.getMinutes()),
            pad(d.getSeconds())
          ].join(":");
          return [d.getDate(), months[d.getMonth()], time].join(" ");
        }
        exports22.log = function() {
          console.log("%s - %s", timestamp(), exports22.format.apply(exports22, arguments));
        };
        exports22.inherits = requireInherits_browser2();
        exports22._extend = function(origin, add) {
          if (!add || !isObject(add)) return origin;
          var keys = Object.keys(add);
          var i = keys.length;
          while (i--) {
            origin[keys[i]] = add[keys[i]];
          }
          return origin;
        };
        function hasOwnProperty(obj, prop) {
          return Object.prototype.hasOwnProperty.call(obj, prop);
        }
        var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
        exports22.promisify = function promisify(original) {
          if (typeof original !== "function")
            throw new TypeError('The "original" argument must be of type Function');
          if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
            var fn = original[kCustomPromisifiedSymbol];
            if (typeof fn !== "function") {
              throw new TypeError('The "util.promisify.custom" argument must be of type Function');
            }
            Object.defineProperty(fn, kCustomPromisifiedSymbol, {
              value: fn,
              enumerable: false,
              writable: false,
              configurable: true
            });
            return fn;
          }
          function fn() {
            var promiseResolve, promiseReject;
            var promise = new Promise(function(resolve, reject) {
              promiseResolve = resolve;
              promiseReject = reject;
            });
            var args = [];
            for (var i = 0; i < arguments.length; i++) {
              args.push(arguments[i]);
            }
            args.push(function(err, value) {
              if (err) {
                promiseReject(err);
              } else {
                promiseResolve(value);
              }
            });
            try {
              original.apply(this, args);
            } catch (err) {
              promiseReject(err);
            }
            return promise;
          }
          Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
          if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
            value: fn,
            enumerable: false,
            writable: false,
            configurable: true
          });
          return Object.defineProperties(
            fn,
            getOwnPropertyDescriptors(original)
          );
        };
        exports22.promisify.custom = kCustomPromisifiedSymbol;
        function callbackifyOnRejected(reason, cb) {
          if (!reason) {
            var newReason = new Error("Promise was rejected with a falsy value");
            newReason.reason = reason;
            reason = newReason;
          }
          return cb(reason);
        }
        function callbackify(original) {
          if (typeof original !== "function") {
            throw new TypeError('The "original" argument must be of type Function');
          }
          function callbackified() {
            var args = [];
            for (var i = 0; i < arguments.length; i++) {
              args.push(arguments[i]);
            }
            var maybeCb = args.pop();
            if (typeof maybeCb !== "function") {
              throw new TypeError("The last argument must be of type Function");
            }
            var self2 = this;
            var cb = function() {
              return maybeCb.apply(self2, arguments);
            };
            original.apply(this, args).then(
              function(ret) {
                process$12.nextTick(cb.bind(null, null, ret));
              },
              function(rej) {
                process$12.nextTick(callbackifyOnRejected.bind(null, rej, cb));
              }
            );
          }
          Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
          Object.defineProperties(
            callbackified,
            getOwnPropertyDescriptors(original)
          );
          return callbackified;
        }
        exports22.callbackify = callbackify;
      })(util2);
      return util2;
    }
    var buffer_list2;
    var hasRequiredBuffer_list2;
    function requireBuffer_list2() {
      if (hasRequiredBuffer_list2) return buffer_list2;
      hasRequiredBuffer_list2 = 1;
      function ownKeys(object, enumerableOnly) {
        var keys = Object.keys(object);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object);
          if (enumerableOnly) symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
          keys.push.apply(keys, symbols);
        }
        return keys;
      }
      function _objectSpread(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {};
          if (i % 2) {
            ownKeys(Object(source), true).forEach(function(key) {
              _defineProperty(target, key, source[key]);
            });
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
          } else {
            ownKeys(Object(source)).forEach(function(key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
        }
        return target;
      }
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        return Constructor;
      }
      var _require = requireBuffer2(), Buffer2 = _require.Buffer;
      var _require2 = requireUtil2(), inspect = _require2.inspect;
      var custom = inspect && inspect.custom || "inspect";
      function copyBuffer(src, target, offset) {
        Buffer2.prototype.copy.call(src, target, offset);
      }
      buffer_list2 = /* @__PURE__ */ (function() {
        function BufferList() {
          _classCallCheck(this, BufferList);
          this.head = null;
          this.tail = null;
          this.length = 0;
        }
        _createClass(BufferList, [{
          key: "push",
          value: function push(v) {
            var entry = {
              data: v,
              next: null
            };
            if (this.length > 0) this.tail.next = entry;
            else this.head = entry;
            this.tail = entry;
            ++this.length;
          }
        }, {
          key: "unshift",
          value: function unshift(v) {
            var entry = {
              data: v,
              next: this.head
            };
            if (this.length === 0) this.tail = entry;
            this.head = entry;
            ++this.length;
          }
        }, {
          key: "shift",
          value: function shift() {
            if (this.length === 0) return;
            var ret = this.head.data;
            if (this.length === 1) this.head = this.tail = null;
            else this.head = this.head.next;
            --this.length;
            return ret;
          }
        }, {
          key: "clear",
          value: function clear() {
            this.head = this.tail = null;
            this.length = 0;
          }
        }, {
          key: "join",
          value: function join(s) {
            if (this.length === 0) return "";
            var p = this.head;
            var ret = "" + p.data;
            while (p = p.next) {
              ret += s + p.data;
            }
            return ret;
          }
        }, {
          key: "concat",
          value: function concat(n) {
            if (this.length === 0) return Buffer2.alloc(0);
            var ret = Buffer2.allocUnsafe(n >>> 0);
            var p = this.head;
            var i = 0;
            while (p) {
              copyBuffer(p.data, ret, i);
              i += p.data.length;
              p = p.next;
            }
            return ret;
          }
          // Consumes a specified amount of bytes or characters from the buffered data.
        }, {
          key: "consume",
          value: function consume(n, hasStrings) {
            var ret;
            if (n < this.head.data.length) {
              ret = this.head.data.slice(0, n);
              this.head.data = this.head.data.slice(n);
            } else if (n === this.head.data.length) {
              ret = this.shift();
            } else {
              ret = hasStrings ? this._getString(n) : this._getBuffer(n);
            }
            return ret;
          }
        }, {
          key: "first",
          value: function first() {
            return this.head.data;
          }
          // Consumes a specified amount of characters from the buffered data.
        }, {
          key: "_getString",
          value: function _getString(n) {
            var p = this.head;
            var c = 1;
            var ret = p.data;
            n -= ret.length;
            while (p = p.next) {
              var str = p.data;
              var nb = n > str.length ? str.length : n;
              if (nb === str.length) ret += str;
              else ret += str.slice(0, n);
              n -= nb;
              if (n === 0) {
                if (nb === str.length) {
                  ++c;
                  if (p.next) this.head = p.next;
                  else this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = str.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          }
          // Consumes a specified amount of bytes from the buffered data.
        }, {
          key: "_getBuffer",
          value: function _getBuffer(n) {
            var ret = Buffer2.allocUnsafe(n);
            var p = this.head;
            var c = 1;
            p.data.copy(ret);
            n -= p.data.length;
            while (p = p.next) {
              var buf = p.data;
              var nb = n > buf.length ? buf.length : n;
              buf.copy(ret, ret.length - n, 0, nb);
              n -= nb;
              if (n === 0) {
                if (nb === buf.length) {
                  ++c;
                  if (p.next) this.head = p.next;
                  else this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = buf.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          }
          // Make sure the linked list only shows the minimal necessary information.
        }, {
          key: custom,
          value: function value(_, options) {
            return inspect(this, _objectSpread({}, options, {
              // Only inspect one level.
              depth: 0,
              // It should not recurse.
              customInspect: false
            }));
          }
        }]);
        return BufferList;
      })();
      return buffer_list2;
    }
    var destroy_12;
    var hasRequiredDestroy2;
    function requireDestroy2() {
      if (hasRequiredDestroy2) return destroy_12;
      hasRequiredDestroy2 = 1;
      function destroy(err, cb) {
        var _this = this;
        var readableDestroyed = this._readableState && this._readableState.destroyed;
        var writableDestroyed = this._writableState && this._writableState.destroyed;
        if (readableDestroyed || writableDestroyed) {
          if (cb) {
            cb(err);
          } else if (err) {
            if (!this._writableState) {
              process$12.nextTick(emitErrorNT, this, err);
            } else if (!this._writableState.errorEmitted) {
              this._writableState.errorEmitted = true;
              process$12.nextTick(emitErrorNT, this, err);
            }
          }
          return this;
        }
        if (this._readableState) {
          this._readableState.destroyed = true;
        }
        if (this._writableState) {
          this._writableState.destroyed = true;
        }
        this._destroy(err || null, function(err2) {
          if (!cb && err2) {
            if (!_this._writableState) {
              process$12.nextTick(emitErrorAndCloseNT, _this, err2);
            } else if (!_this._writableState.errorEmitted) {
              _this._writableState.errorEmitted = true;
              process$12.nextTick(emitErrorAndCloseNT, _this, err2);
            } else {
              process$12.nextTick(emitCloseNT, _this);
            }
          } else if (cb) {
            process$12.nextTick(emitCloseNT, _this);
            cb(err2);
          } else {
            process$12.nextTick(emitCloseNT, _this);
          }
        });
        return this;
      }
      function emitErrorAndCloseNT(self2, err) {
        emitErrorNT(self2, err);
        emitCloseNT(self2);
      }
      function emitCloseNT(self2) {
        if (self2._writableState && !self2._writableState.emitClose) return;
        if (self2._readableState && !self2._readableState.emitClose) return;
        self2.emit("close");
      }
      function undestroy() {
        if (this._readableState) {
          this._readableState.destroyed = false;
          this._readableState.reading = false;
          this._readableState.ended = false;
          this._readableState.endEmitted = false;
        }
        if (this._writableState) {
          this._writableState.destroyed = false;
          this._writableState.ended = false;
          this._writableState.ending = false;
          this._writableState.finalCalled = false;
          this._writableState.prefinished = false;
          this._writableState.finished = false;
          this._writableState.errorEmitted = false;
        }
      }
      function emitErrorNT(self2, err) {
        self2.emit("error", err);
      }
      function errorOrDestroy(stream, err) {
        var rState = stream._readableState;
        var wState = stream._writableState;
        if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);
        else stream.emit("error", err);
      }
      destroy_12 = {
        destroy,
        undestroy,
        errorOrDestroy
      };
      return destroy_12;
    }
    var errorsBrowser2 = {};
    var hasRequiredErrorsBrowser2;
    function requireErrorsBrowser2() {
      if (hasRequiredErrorsBrowser2) return errorsBrowser2;
      hasRequiredErrorsBrowser2 = 1;
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      var codes = {};
      function createErrorType(code, message, Base) {
        if (!Base) {
          Base = Error;
        }
        function getMessage(arg1, arg2, arg3) {
          if (typeof message === "string") {
            return message;
          } else {
            return message(arg1, arg2, arg3);
          }
        }
        var NodeError = /* @__PURE__ */ (function(_Base) {
          _inheritsLoose(NodeError2, _Base);
          function NodeError2(arg1, arg2, arg3) {
            return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
          }
          return NodeError2;
        })(Base);
        NodeError.prototype.name = Base.name;
        NodeError.prototype.code = code;
        codes[code] = NodeError;
      }
      function oneOf(expected, thing) {
        if (Array.isArray(expected)) {
          var len = expected.length;
          expected = expected.map(function(i) {
            return String(i);
          });
          if (len > 2) {
            return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
          } else if (len === 2) {
            return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
          } else {
            return "of ".concat(thing, " ").concat(expected[0]);
          }
        } else {
          return "of ".concat(thing, " ").concat(String(expected));
        }
      }
      function startsWith(str, search, pos) {
        return str.substr(0, search.length) === search;
      }
      function endsWith(str, search, this_len) {
        if (this_len === void 0 || this_len > str.length) {
          this_len = str.length;
        }
        return str.substring(this_len - search.length, this_len) === search;
      }
      function includes(str, search, start) {
        if (typeof start !== "number") {
          start = 0;
        }
        if (start + search.length > str.length) {
          return false;
        } else {
          return str.indexOf(search, start) !== -1;
        }
      }
      createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
        return 'The value "' + value + '" is invalid for option "' + name + '"';
      }, TypeError);
      createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
        var determiner;
        if (typeof expected === "string" && startsWith(expected, "not ")) {
          determiner = "must not be";
          expected = expected.replace(/^not /, "");
        } else {
          determiner = "must be";
        }
        var msg;
        if (endsWith(name, " argument")) {
          msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        } else {
          var type22 = includes(name, ".") ? "property" : "argument";
          msg = 'The "'.concat(name, '" ').concat(type22, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        }
        msg += ". Received type ".concat(typeof actual);
        return msg;
      }, TypeError);
      createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
      createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
        return "The " + name + " method is not implemented";
      });
      createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
      createErrorType("ERR_STREAM_DESTROYED", function(name) {
        return "Cannot call " + name + " after a stream was destroyed";
      });
      createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
      createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
      createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
      createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
      createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
        return "Unknown encoding: " + arg;
      }, TypeError);
      createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
      errorsBrowser2.codes = codes;
      return errorsBrowser2;
    }
    var state2;
    var hasRequiredState2;
    function requireState2() {
      if (hasRequiredState2) return state2;
      hasRequiredState2 = 1;
      var ERR_INVALID_OPT_VALUE = requireErrorsBrowser2().codes.ERR_INVALID_OPT_VALUE;
      function highWaterMarkFrom(options, isDuplex, duplexKey) {
        return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
      }
      function getHighWaterMark(state22, options, duplexKey, isDuplex) {
        var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
        if (hwm != null) {
          if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
            var name = isDuplex ? duplexKey : "highWaterMark";
            throw new ERR_INVALID_OPT_VALUE(name, hwm);
          }
          return Math.floor(hwm);
        }
        return state22.objectMode ? 16 : 16 * 1024;
      }
      state2 = {
        getHighWaterMark
      };
      return state2;
    }
    var browser2;
    var hasRequiredBrowser2;
    function requireBrowser2() {
      if (hasRequiredBrowser2) return browser2;
      hasRequiredBrowser2 = 1;
      browser2 = deprecate;
      function deprecate(fn, msg) {
        if (config("noDeprecation")) {
          return fn;
        }
        var warned = false;
        function deprecated() {
          if (!warned) {
            if (config("throwDeprecation")) {
              throw new Error(msg);
            } else if (config("traceDeprecation")) {
              console.trace(msg);
            } else {
              console.warn(msg);
            }
            warned = true;
          }
          return fn.apply(this, arguments);
        }
        return deprecated;
      }
      function config(name) {
        try {
          if (!commonjsGlobal2.localStorage) return false;
        } catch (_) {
          return false;
        }
        var val = commonjsGlobal2.localStorage[name];
        if (null == val) return false;
        return String(val).toLowerCase() === "true";
      }
      return browser2;
    }
    var _stream_writable2;
    var hasRequired_stream_writable2;
    function require_stream_writable2() {
      if (hasRequired_stream_writable2) return _stream_writable2;
      hasRequired_stream_writable2 = 1;
      _stream_writable2 = Writable;
      function CorkedRequest(state22) {
        var _this = this;
        this.next = null;
        this.entry = null;
        this.finish = function() {
          onCorkedFinish(_this, state22);
        };
      }
      var Duplex;
      Writable.WritableState = WritableState;
      var internalUtil = {
        deprecate: requireBrowser2()
      };
      var Stream = requireStreamBrowser2();
      var Buffer2 = requireBuffer2().Buffer;
      var OurUint8Array = commonjsGlobal2.Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer2.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var destroyImpl = requireDestroy2();
      var _require = requireState2(), getHighWaterMark = _require.getHighWaterMark;
      var _require$codes = requireErrorsBrowser2().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
      var errorOrDestroy = destroyImpl.errorOrDestroy;
      requireInherits_browser2()(Writable, Stream);
      function nop() {
      }
      function WritableState(options, stream, isDuplex) {
        Duplex = Duplex || require_stream_duplex2();
        options = options || {};
        if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
        this.objectMode = !!options.objectMode;
        if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
        this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
        this.finalCalled = false;
        this.needDrain = false;
        this.ending = false;
        this.ended = false;
        this.finished = false;
        this.destroyed = false;
        var noDecode = options.decodeStrings === false;
        this.decodeStrings = !noDecode;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.length = 0;
        this.writing = false;
        this.corked = 0;
        this.sync = true;
        this.bufferProcessing = false;
        this.onwrite = function(er) {
          onwrite(stream, er);
        };
        this.writecb = null;
        this.writelen = 0;
        this.bufferedRequest = null;
        this.lastBufferedRequest = null;
        this.pendingcb = 0;
        this.prefinished = false;
        this.errorEmitted = false;
        this.emitClose = options.emitClose !== false;
        this.autoDestroy = !!options.autoDestroy;
        this.bufferedRequestCount = 0;
        this.corkedRequestsFree = new CorkedRequest(this);
      }
      WritableState.prototype.getBuffer = function getBuffer() {
        var current = this.bufferedRequest;
        var out = [];
        while (current) {
          out.push(current);
          current = current.next;
        }
        return out;
      };
      (function() {
        try {
          Object.defineProperty(WritableState.prototype, "buffer", {
            get: internalUtil.deprecate(function writableStateBufferGetter() {
              return this.getBuffer();
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
          });
        } catch (_) {
        }
      })();
      var realHasInstance;
      if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
        realHasInstance = Function.prototype[Symbol.hasInstance];
        Object.defineProperty(Writable, Symbol.hasInstance, {
          value: function value(object) {
            if (realHasInstance.call(this, object)) return true;
            if (this !== Writable) return false;
            return object && object._writableState instanceof WritableState;
          }
        });
      } else {
        realHasInstance = function realHasInstance2(object) {
          return object instanceof this;
        };
      }
      function Writable(options) {
        Duplex = Duplex || require_stream_duplex2();
        var isDuplex = this instanceof Duplex;
        if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
        this._writableState = new WritableState(options, this, isDuplex);
        this.writable = true;
        if (options) {
          if (typeof options.write === "function") this._write = options.write;
          if (typeof options.writev === "function") this._writev = options.writev;
          if (typeof options.destroy === "function") this._destroy = options.destroy;
          if (typeof options.final === "function") this._final = options.final;
        }
        Stream.call(this);
      }
      Writable.prototype.pipe = function() {
        errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
      };
      function writeAfterEnd(stream, cb) {
        var er = new ERR_STREAM_WRITE_AFTER_END();
        errorOrDestroy(stream, er);
        process$12.nextTick(cb, er);
      }
      function validChunk(stream, state22, chunk, cb) {
        var er;
        if (chunk === null) {
          er = new ERR_STREAM_NULL_VALUES();
        } else if (typeof chunk !== "string" && !state22.objectMode) {
          er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
        }
        if (er) {
          errorOrDestroy(stream, er);
          process$12.nextTick(cb, er);
          return false;
        }
        return true;
      }
      Writable.prototype.write = function(chunk, encoding, cb) {
        var state22 = this._writableState;
        var ret = false;
        var isBuf = !state22.objectMode && _isUint8Array(chunk);
        if (isBuf && !Buffer2.isBuffer(chunk)) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (typeof encoding === "function") {
          cb = encoding;
          encoding = null;
        }
        if (isBuf) encoding = "buffer";
        else if (!encoding) encoding = state22.defaultEncoding;
        if (typeof cb !== "function") cb = nop;
        if (state22.ending) writeAfterEnd(this, cb);
        else if (isBuf || validChunk(this, state22, chunk, cb)) {
          state22.pendingcb++;
          ret = writeOrBuffer(this, state22, isBuf, chunk, encoding, cb);
        }
        return ret;
      };
      Writable.prototype.cork = function() {
        this._writableState.corked++;
      };
      Writable.prototype.uncork = function() {
        var state22 = this._writableState;
        if (state22.corked) {
          state22.corked--;
          if (!state22.writing && !state22.corked && !state22.bufferProcessing && state22.bufferedRequest) clearBuffer(this, state22);
        }
      };
      Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
        if (typeof encoding === "string") encoding = encoding.toLowerCase();
        if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
        this._writableState.defaultEncoding = encoding;
        return this;
      };
      Object.defineProperty(Writable.prototype, "writableBuffer", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: false,
        get: function get22() {
          return this._writableState && this._writableState.getBuffer();
        }
      });
      function decodeChunk(state22, chunk, encoding) {
        if (!state22.objectMode && state22.decodeStrings !== false && typeof chunk === "string") {
          chunk = Buffer2.from(chunk, encoding);
        }
        return chunk;
      }
      Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: false,
        get: function get22() {
          return this._writableState.highWaterMark;
        }
      });
      function writeOrBuffer(stream, state22, isBuf, chunk, encoding, cb) {
        if (!isBuf) {
          var newChunk = decodeChunk(state22, chunk, encoding);
          if (chunk !== newChunk) {
            isBuf = true;
            encoding = "buffer";
            chunk = newChunk;
          }
        }
        var len = state22.objectMode ? 1 : chunk.length;
        state22.length += len;
        var ret = state22.length < state22.highWaterMark;
        if (!ret) state22.needDrain = true;
        if (state22.writing || state22.corked) {
          var last = state22.lastBufferedRequest;
          state22.lastBufferedRequest = {
            chunk,
            encoding,
            isBuf,
            callback: cb,
            next: null
          };
          if (last) {
            last.next = state22.lastBufferedRequest;
          } else {
            state22.bufferedRequest = state22.lastBufferedRequest;
          }
          state22.bufferedRequestCount += 1;
        } else {
          doWrite(stream, state22, false, len, chunk, encoding, cb);
        }
        return ret;
      }
      function doWrite(stream, state22, writev, len, chunk, encoding, cb) {
        state22.writelen = len;
        state22.writecb = cb;
        state22.writing = true;
        state22.sync = true;
        if (state22.destroyed) state22.onwrite(new ERR_STREAM_DESTROYED("write"));
        else if (writev) stream._writev(chunk, state22.onwrite);
        else stream._write(chunk, encoding, state22.onwrite);
        state22.sync = false;
      }
      function onwriteError(stream, state22, sync, er, cb) {
        --state22.pendingcb;
        if (sync) {
          process$12.nextTick(cb, er);
          process$12.nextTick(finishMaybe, stream, state22);
          stream._writableState.errorEmitted = true;
          errorOrDestroy(stream, er);
        } else {
          cb(er);
          stream._writableState.errorEmitted = true;
          errorOrDestroy(stream, er);
          finishMaybe(stream, state22);
        }
      }
      function onwriteStateUpdate(state22) {
        state22.writing = false;
        state22.writecb = null;
        state22.length -= state22.writelen;
        state22.writelen = 0;
      }
      function onwrite(stream, er) {
        var state22 = stream._writableState;
        var sync = state22.sync;
        var cb = state22.writecb;
        if (typeof cb !== "function") throw new ERR_MULTIPLE_CALLBACK();
        onwriteStateUpdate(state22);
        if (er) onwriteError(stream, state22, sync, er, cb);
        else {
          var finished = needFinish(state22) || stream.destroyed;
          if (!finished && !state22.corked && !state22.bufferProcessing && state22.bufferedRequest) {
            clearBuffer(stream, state22);
          }
          if (sync) {
            process$12.nextTick(afterWrite, stream, state22, finished, cb);
          } else {
            afterWrite(stream, state22, finished, cb);
          }
        }
      }
      function afterWrite(stream, state22, finished, cb) {
        if (!finished) onwriteDrain(stream, state22);
        state22.pendingcb--;
        cb();
        finishMaybe(stream, state22);
      }
      function onwriteDrain(stream, state22) {
        if (state22.length === 0 && state22.needDrain) {
          state22.needDrain = false;
          stream.emit("drain");
        }
      }
      function clearBuffer(stream, state22) {
        state22.bufferProcessing = true;
        var entry = state22.bufferedRequest;
        if (stream._writev && entry && entry.next) {
          var l = state22.bufferedRequestCount;
          var buffer22 = new Array(l);
          var holder = state22.corkedRequestsFree;
          holder.entry = entry;
          var count = 0;
          var allBuffers = true;
          while (entry) {
            buffer22[count] = entry;
            if (!entry.isBuf) allBuffers = false;
            entry = entry.next;
            count += 1;
          }
          buffer22.allBuffers = allBuffers;
          doWrite(stream, state22, true, state22.length, buffer22, "", holder.finish);
          state22.pendingcb++;
          state22.lastBufferedRequest = null;
          if (holder.next) {
            state22.corkedRequestsFree = holder.next;
            holder.next = null;
          } else {
            state22.corkedRequestsFree = new CorkedRequest(state22);
          }
          state22.bufferedRequestCount = 0;
        } else {
          while (entry) {
            var chunk = entry.chunk;
            var encoding = entry.encoding;
            var cb = entry.callback;
            var len = state22.objectMode ? 1 : chunk.length;
            doWrite(stream, state22, false, len, chunk, encoding, cb);
            entry = entry.next;
            state22.bufferedRequestCount--;
            if (state22.writing) {
              break;
            }
          }
          if (entry === null) state22.lastBufferedRequest = null;
        }
        state22.bufferedRequest = entry;
        state22.bufferProcessing = false;
      }
      Writable.prototype._write = function(chunk, encoding, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
      };
      Writable.prototype._writev = null;
      Writable.prototype.end = function(chunk, encoding, cb) {
        var state22 = this._writableState;
        if (typeof chunk === "function") {
          cb = chunk;
          chunk = null;
          encoding = null;
        } else if (typeof encoding === "function") {
          cb = encoding;
          encoding = null;
        }
        if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
        if (state22.corked) {
          state22.corked = 1;
          this.uncork();
        }
        if (!state22.ending) endWritable(this, state22, cb);
        return this;
      };
      Object.defineProperty(Writable.prototype, "writableLength", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: false,
        get: function get22() {
          return this._writableState.length;
        }
      });
      function needFinish(state22) {
        return state22.ending && state22.length === 0 && state22.bufferedRequest === null && !state22.finished && !state22.writing;
      }
      function callFinal(stream, state22) {
        stream._final(function(err) {
          state22.pendingcb--;
          if (err) {
            errorOrDestroy(stream, err);
          }
          state22.prefinished = true;
          stream.emit("prefinish");
          finishMaybe(stream, state22);
        });
      }
      function prefinish(stream, state22) {
        if (!state22.prefinished && !state22.finalCalled) {
          if (typeof stream._final === "function" && !state22.destroyed) {
            state22.pendingcb++;
            state22.finalCalled = true;
            process$12.nextTick(callFinal, stream, state22);
          } else {
            state22.prefinished = true;
            stream.emit("prefinish");
          }
        }
      }
      function finishMaybe(stream, state22) {
        var need = needFinish(state22);
        if (need) {
          prefinish(stream, state22);
          if (state22.pendingcb === 0) {
            state22.finished = true;
            stream.emit("finish");
            if (state22.autoDestroy) {
              var rState = stream._readableState;
              if (!rState || rState.autoDestroy && rState.endEmitted) {
                stream.destroy();
              }
            }
          }
        }
        return need;
      }
      function endWritable(stream, state22, cb) {
        state22.ending = true;
        finishMaybe(stream, state22);
        if (cb) {
          if (state22.finished) process$12.nextTick(cb);
          else stream.once("finish", cb);
        }
        state22.ended = true;
        stream.writable = false;
      }
      function onCorkedFinish(corkReq, state22, err) {
        var entry = corkReq.entry;
        corkReq.entry = null;
        while (entry) {
          var cb = entry.callback;
          state22.pendingcb--;
          cb(err);
          entry = entry.next;
        }
        state22.corkedRequestsFree.next = corkReq;
      }
      Object.defineProperty(Writable.prototype, "destroyed", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: false,
        get: function get22() {
          if (this._writableState === void 0) {
            return false;
          }
          return this._writableState.destroyed;
        },
        set: function set(value) {
          if (!this._writableState) {
            return;
          }
          this._writableState.destroyed = value;
        }
      });
      Writable.prototype.destroy = destroyImpl.destroy;
      Writable.prototype._undestroy = destroyImpl.undestroy;
      Writable.prototype._destroy = function(err, cb) {
        cb(err);
      };
      return _stream_writable2;
    }
    var _stream_duplex2;
    var hasRequired_stream_duplex2;
    function require_stream_duplex2() {
      if (hasRequired_stream_duplex2) return _stream_duplex2;
      hasRequired_stream_duplex2 = 1;
      var objectKeys = Object.keys || function(obj) {
        var keys2 = [];
        for (var key in obj) {
          keys2.push(key);
        }
        return keys2;
      };
      _stream_duplex2 = Duplex;
      var Readable = require_stream_readable2();
      var Writable = require_stream_writable2();
      requireInherits_browser2()(Duplex, Readable);
      {
        var keys = objectKeys(Writable.prototype);
        for (var v = 0; v < keys.length; v++) {
          var method = keys[v];
          if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
        }
      }
      function Duplex(options) {
        if (!(this instanceof Duplex)) return new Duplex(options);
        Readable.call(this, options);
        Writable.call(this, options);
        this.allowHalfOpen = true;
        if (options) {
          if (options.readable === false) this.readable = false;
          if (options.writable === false) this.writable = false;
          if (options.allowHalfOpen === false) {
            this.allowHalfOpen = false;
            this.once("end", onend);
          }
        }
      }
      Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: false,
        get: function get22() {
          return this._writableState.highWaterMark;
        }
      });
      Object.defineProperty(Duplex.prototype, "writableBuffer", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: false,
        get: function get22() {
          return this._writableState && this._writableState.getBuffer();
        }
      });
      Object.defineProperty(Duplex.prototype, "writableLength", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: false,
        get: function get22() {
          return this._writableState.length;
        }
      });
      function onend() {
        if (this._writableState.ended) return;
        process$12.nextTick(onEndNT, this);
      }
      function onEndNT(self2) {
        self2.end();
      }
      Object.defineProperty(Duplex.prototype, "destroyed", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: false,
        get: function get22() {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return false;
          }
          return this._readableState.destroyed && this._writableState.destroyed;
        },
        set: function set(value) {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return;
          }
          this._readableState.destroyed = value;
          this._writableState.destroyed = value;
        }
      });
      return _stream_duplex2;
    }
    var string_decoder2 = {};
    var safeBuffer2 = { exports: {} };
    var hasRequiredSafeBuffer2;
    function requireSafeBuffer2() {
      if (hasRequiredSafeBuffer2) return safeBuffer2.exports;
      hasRequiredSafeBuffer2 = 1;
      (function(module22, exports22) {
        var buffer22 = requireBuffer2();
        var Buffer2 = buffer22.Buffer;
        function copyProps(src, dst) {
          for (var key in src) {
            dst[key] = src[key];
          }
        }
        if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
          module22.exports = buffer22;
        } else {
          copyProps(buffer22, exports22);
          exports22.Buffer = SafeBuffer;
        }
        function SafeBuffer(arg, encodingOrOffset, length) {
          return Buffer2(arg, encodingOrOffset, length);
        }
        copyProps(Buffer2, SafeBuffer);
        SafeBuffer.from = function(arg, encodingOrOffset, length) {
          if (typeof arg === "number") {
            throw new TypeError("Argument must not be a number");
          }
          return Buffer2(arg, encodingOrOffset, length);
        };
        SafeBuffer.alloc = function(size, fill, encoding) {
          if (typeof size !== "number") {
            throw new TypeError("Argument must be a number");
          }
          var buf = Buffer2(size);
          if (fill !== void 0) {
            if (typeof encoding === "string") {
              buf.fill(fill, encoding);
            } else {
              buf.fill(fill);
            }
          } else {
            buf.fill(0);
          }
          return buf;
        };
        SafeBuffer.allocUnsafe = function(size) {
          if (typeof size !== "number") {
            throw new TypeError("Argument must be a number");
          }
          return Buffer2(size);
        };
        SafeBuffer.allocUnsafeSlow = function(size) {
          if (typeof size !== "number") {
            throw new TypeError("Argument must be a number");
          }
          return buffer22.SlowBuffer(size);
        };
      })(safeBuffer2, safeBuffer2.exports);
      return safeBuffer2.exports;
    }
    var hasRequiredString_decoder2;
    function requireString_decoder2() {
      if (hasRequiredString_decoder2) return string_decoder2;
      hasRequiredString_decoder2 = 1;
      var Buffer2 = requireSafeBuffer2().Buffer;
      var isEncoding = Buffer2.isEncoding || function(encoding) {
        encoding = "" + encoding;
        switch (encoding && encoding.toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
          case "raw":
            return true;
          default:
            return false;
        }
      };
      function _normalizeEncoding(enc) {
        if (!enc) return "utf8";
        var retried;
        while (true) {
          switch (enc) {
            case "utf8":
            case "utf-8":
              return "utf8";
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return "utf16le";
            case "latin1":
            case "binary":
              return "latin1";
            case "base64":
            case "ascii":
            case "hex":
              return enc;
            default:
              if (retried) return;
              enc = ("" + enc).toLowerCase();
              retried = true;
          }
        }
      }
      function normalizeEncoding(enc) {
        var nenc = _normalizeEncoding(enc);
        if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
        return nenc || enc;
      }
      string_decoder2.StringDecoder = StringDecoder;
      function StringDecoder(encoding) {
        this.encoding = normalizeEncoding(encoding);
        var nb;
        switch (this.encoding) {
          case "utf16le":
            this.text = utf16Text;
            this.end = utf16End;
            nb = 4;
            break;
          case "utf8":
            this.fillLast = utf8FillLast;
            nb = 4;
            break;
          case "base64":
            this.text = base64Text;
            this.end = base64End;
            nb = 3;
            break;
          default:
            this.write = simpleWrite;
            this.end = simpleEnd;
            return;
        }
        this.lastNeed = 0;
        this.lastTotal = 0;
        this.lastChar = Buffer2.allocUnsafe(nb);
      }
      StringDecoder.prototype.write = function(buf) {
        if (buf.length === 0) return "";
        var r;
        var i;
        if (this.lastNeed) {
          r = this.fillLast(buf);
          if (r === void 0) return "";
          i = this.lastNeed;
          this.lastNeed = 0;
        } else {
          i = 0;
        }
        if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
        return r || "";
      };
      StringDecoder.prototype.end = utf8End;
      StringDecoder.prototype.text = utf8Text;
      StringDecoder.prototype.fillLast = function(buf) {
        if (this.lastNeed <= buf.length) {
          buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
          return this.lastChar.toString(this.encoding, 0, this.lastTotal);
        }
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
        this.lastNeed -= buf.length;
      };
      function utf8CheckByte(byte) {
        if (byte <= 127) return 0;
        else if (byte >> 5 === 6) return 2;
        else if (byte >> 4 === 14) return 3;
        else if (byte >> 3 === 30) return 4;
        return byte >> 6 === 2 ? -1 : -2;
      }
      function utf8CheckIncomplete(self2, buf, i) {
        var j = buf.length - 1;
        if (j < i) return 0;
        var nb = utf8CheckByte(buf[j]);
        if (nb >= 0) {
          if (nb > 0) self2.lastNeed = nb - 1;
          return nb;
        }
        if (--j < i || nb === -2) return 0;
        nb = utf8CheckByte(buf[j]);
        if (nb >= 0) {
          if (nb > 0) self2.lastNeed = nb - 2;
          return nb;
        }
        if (--j < i || nb === -2) return 0;
        nb = utf8CheckByte(buf[j]);
        if (nb >= 0) {
          if (nb > 0) {
            if (nb === 2) nb = 0;
            else self2.lastNeed = nb - 3;
          }
          return nb;
        }
        return 0;
      }
      function utf8CheckExtraBytes(self2, buf, p) {
        if ((buf[0] & 192) !== 128) {
          self2.lastNeed = 0;
          return "\uFFFD";
        }
        if (self2.lastNeed > 1 && buf.length > 1) {
          if ((buf[1] & 192) !== 128) {
            self2.lastNeed = 1;
            return "\uFFFD";
          }
          if (self2.lastNeed > 2 && buf.length > 2) {
            if ((buf[2] & 192) !== 128) {
              self2.lastNeed = 2;
              return "\uFFFD";
            }
          }
        }
      }
      function utf8FillLast(buf) {
        var p = this.lastTotal - this.lastNeed;
        var r = utf8CheckExtraBytes(this, buf);
        if (r !== void 0) return r;
        if (this.lastNeed <= buf.length) {
          buf.copy(this.lastChar, p, 0, this.lastNeed);
          return this.lastChar.toString(this.encoding, 0, this.lastTotal);
        }
        buf.copy(this.lastChar, p, 0, buf.length);
        this.lastNeed -= buf.length;
      }
      function utf8Text(buf, i) {
        var total = utf8CheckIncomplete(this, buf, i);
        if (!this.lastNeed) return buf.toString("utf8", i);
        this.lastTotal = total;
        var end = buf.length - (total - this.lastNeed);
        buf.copy(this.lastChar, 0, end);
        return buf.toString("utf8", i, end);
      }
      function utf8End(buf) {
        var r = buf && buf.length ? this.write(buf) : "";
        if (this.lastNeed) return r + "\uFFFD";
        return r;
      }
      function utf16Text(buf, i) {
        if ((buf.length - i) % 2 === 0) {
          var r = buf.toString("utf16le", i);
          if (r) {
            var c = r.charCodeAt(r.length - 1);
            if (c >= 55296 && c <= 56319) {
              this.lastNeed = 2;
              this.lastTotal = 4;
              this.lastChar[0] = buf[buf.length - 2];
              this.lastChar[1] = buf[buf.length - 1];
              return r.slice(0, -1);
            }
          }
          return r;
        }
        this.lastNeed = 1;
        this.lastTotal = 2;
        this.lastChar[0] = buf[buf.length - 1];
        return buf.toString("utf16le", i, buf.length - 1);
      }
      function utf16End(buf) {
        var r = buf && buf.length ? this.write(buf) : "";
        if (this.lastNeed) {
          var end = this.lastTotal - this.lastNeed;
          return r + this.lastChar.toString("utf16le", 0, end);
        }
        return r;
      }
      function base64Text(buf, i) {
        var n = (buf.length - i) % 3;
        if (n === 0) return buf.toString("base64", i);
        this.lastNeed = 3 - n;
        this.lastTotal = 3;
        if (n === 1) {
          this.lastChar[0] = buf[buf.length - 1];
        } else {
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
        }
        return buf.toString("base64", i, buf.length - n);
      }
      function base64End(buf) {
        var r = buf && buf.length ? this.write(buf) : "";
        if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
        return r;
      }
      function simpleWrite(buf) {
        return buf.toString(this.encoding);
      }
      function simpleEnd(buf) {
        return buf && buf.length ? this.write(buf) : "";
      }
      return string_decoder2;
    }
    var endOfStream2;
    var hasRequiredEndOfStream2;
    function requireEndOfStream2() {
      if (hasRequiredEndOfStream2) return endOfStream2;
      hasRequiredEndOfStream2 = 1;
      var ERR_STREAM_PREMATURE_CLOSE = requireErrorsBrowser2().codes.ERR_STREAM_PREMATURE_CLOSE;
      function once(callback) {
        var called = false;
        return function() {
          if (called) return;
          called = true;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          callback.apply(this, args);
        };
      }
      function noop22() {
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      function eos(stream, opts, callback) {
        if (typeof opts === "function") return eos(stream, null, opts);
        if (!opts) opts = {};
        callback = once(callback || noop22);
        var readable = opts.readable || opts.readable !== false && stream.readable;
        var writable = opts.writable || opts.writable !== false && stream.writable;
        var onlegacyfinish = function onlegacyfinish2() {
          if (!stream.writable) onfinish();
        };
        var writableEnded = stream._writableState && stream._writableState.finished;
        var onfinish = function onfinish2() {
          writable = false;
          writableEnded = true;
          if (!readable) callback.call(stream);
        };
        var readableEnded = stream._readableState && stream._readableState.endEmitted;
        var onend = function onend2() {
          readable = false;
          readableEnded = true;
          if (!writable) callback.call(stream);
        };
        var onerror = function onerror2(err) {
          callback.call(stream, err);
        };
        var onclose = function onclose2() {
          var err;
          if (readable && !readableEnded) {
            if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
          if (writable && !writableEnded) {
            if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
        };
        var onrequest = function onrequest2() {
          stream.req.on("finish", onfinish);
        };
        if (isRequest(stream)) {
          stream.on("complete", onfinish);
          stream.on("abort", onclose);
          if (stream.req) onrequest();
          else stream.on("request", onrequest);
        } else if (writable && !stream._writableState) {
          stream.on("end", onlegacyfinish);
          stream.on("close", onlegacyfinish);
        }
        stream.on("end", onend);
        stream.on("finish", onfinish);
        if (opts.error !== false) stream.on("error", onerror);
        stream.on("close", onclose);
        return function() {
          stream.removeListener("complete", onfinish);
          stream.removeListener("abort", onclose);
          stream.removeListener("request", onrequest);
          if (stream.req) stream.req.removeListener("finish", onfinish);
          stream.removeListener("end", onlegacyfinish);
          stream.removeListener("close", onlegacyfinish);
          stream.removeListener("finish", onfinish);
          stream.removeListener("end", onend);
          stream.removeListener("error", onerror);
          stream.removeListener("close", onclose);
        };
      }
      endOfStream2 = eos;
      return endOfStream2;
    }
    var async_iterator2;
    var hasRequiredAsync_iterator2;
    function requireAsync_iterator2() {
      if (hasRequiredAsync_iterator2) return async_iterator2;
      hasRequiredAsync_iterator2 = 1;
      var _Object$setPrototypeO;
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      var finished = requireEndOfStream2();
      var kLastResolve = Symbol("lastResolve");
      var kLastReject = Symbol("lastReject");
      var kError = Symbol("error");
      var kEnded = Symbol("ended");
      var kLastPromise = Symbol("lastPromise");
      var kHandlePromise = Symbol("handlePromise");
      var kStream = Symbol("stream");
      function createIterResult(value, done) {
        return {
          value,
          done
        };
      }
      function readAndResolve(iter) {
        var resolve = iter[kLastResolve];
        if (resolve !== null) {
          var data = iter[kStream].read();
          if (data !== null) {
            iter[kLastPromise] = null;
            iter[kLastResolve] = null;
            iter[kLastReject] = null;
            resolve(createIterResult(data, false));
          }
        }
      }
      function onReadable(iter) {
        process$12.nextTick(readAndResolve, iter);
      }
      function wrapForNext(lastPromise, iter) {
        return function(resolve, reject) {
          lastPromise.then(function() {
            if (iter[kEnded]) {
              resolve(createIterResult(void 0, true));
              return;
            }
            iter[kHandlePromise](resolve, reject);
          }, reject);
        };
      }
      var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
      });
      var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
        get stream() {
          return this[kStream];
        },
        next: function next() {
          var _this = this;
          var error = this[kError];
          if (error !== null) {
            return Promise.reject(error);
          }
          if (this[kEnded]) {
            return Promise.resolve(createIterResult(void 0, true));
          }
          if (this[kStream].destroyed) {
            return new Promise(function(resolve, reject) {
              process$12.nextTick(function() {
                if (_this[kError]) {
                  reject(_this[kError]);
                } else {
                  resolve(createIterResult(void 0, true));
                }
              });
            });
          }
          var lastPromise = this[kLastPromise];
          var promise;
          if (lastPromise) {
            promise = new Promise(wrapForNext(lastPromise, this));
          } else {
            var data = this[kStream].read();
            if (data !== null) {
              return Promise.resolve(createIterResult(data, false));
            }
            promise = new Promise(this[kHandlePromise]);
          }
          this[kLastPromise] = promise;
          return promise;
        }
      }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
        return this;
      }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
        var _this2 = this;
        return new Promise(function(resolve, reject) {
          _this2[kStream].destroy(null, function(err) {
            if (err) {
              reject(err);
              return;
            }
            resolve(createIterResult(void 0, true));
          });
        });
      }), _Object$setPrototypeO), AsyncIteratorPrototype);
      var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
        var _Object$create;
        var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
          value: stream,
          writable: true
        }), _defineProperty(_Object$create, kLastResolve, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kLastReject, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kError, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kEnded, {
          value: stream._readableState.endEmitted,
          writable: true
        }), _defineProperty(_Object$create, kHandlePromise, {
          value: function value(resolve, reject) {
            var data = iterator[kStream].read();
            if (data) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              resolve(createIterResult(data, false));
            } else {
              iterator[kLastResolve] = resolve;
              iterator[kLastReject] = reject;
            }
          },
          writable: true
        }), _Object$create));
        iterator[kLastPromise] = null;
        finished(stream, function(err) {
          if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
            var reject = iterator[kLastReject];
            if (reject !== null) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              reject(err);
            }
            iterator[kError] = err;
            return;
          }
          var resolve = iterator[kLastResolve];
          if (resolve !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(void 0, true));
          }
          iterator[kEnded] = true;
        });
        stream.on("readable", onReadable.bind(null, iterator));
        return iterator;
      };
      async_iterator2 = createReadableStreamAsyncIterator;
      return async_iterator2;
    }
    var fromBrowser2;
    var hasRequiredFromBrowser2;
    function requireFromBrowser2() {
      if (hasRequiredFromBrowser2) return fromBrowser2;
      hasRequiredFromBrowser2 = 1;
      fromBrowser2 = function() {
        throw new Error("Readable.from is not available in the browser");
      };
      return fromBrowser2;
    }
    var _stream_readable2;
    var hasRequired_stream_readable2;
    function require_stream_readable2() {
      if (hasRequired_stream_readable2) return _stream_readable2;
      hasRequired_stream_readable2 = 1;
      _stream_readable2 = Readable;
      var Duplex;
      Readable.ReadableState = ReadableState;
      requireEvents2().EventEmitter;
      var EElistenerCount = function EElistenerCount2(emitter, type22) {
        return emitter.listeners(type22).length;
      };
      var Stream = requireStreamBrowser2();
      var Buffer2 = requireBuffer2().Buffer;
      var OurUint8Array = commonjsGlobal2.Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer2.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var debugUtil = requireUtil2();
      var debug;
      if (debugUtil && debugUtil.debuglog) {
        debug = debugUtil.debuglog("stream");
      } else {
        debug = function debug2() {
        };
      }
      var BufferList = requireBuffer_list2();
      var destroyImpl = requireDestroy2();
      var _require = requireState2(), getHighWaterMark = _require.getHighWaterMark;
      var _require$codes = requireErrorsBrowser2().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
      var StringDecoder;
      var createReadableStreamAsyncIterator;
      var from;
      requireInherits_browser2()(Readable, Stream);
      var errorOrDestroy = destroyImpl.errorOrDestroy;
      var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
      function prependListener(emitter, event, fn) {
        if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
        if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
        else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);
        else emitter._events[event] = [fn, emitter._events[event]];
      }
      function ReadableState(options, stream, isDuplex) {
        Duplex = Duplex || require_stream_duplex2();
        options = options || {};
        if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
        this.objectMode = !!options.objectMode;
        if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
        this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
        this.buffer = new BufferList();
        this.length = 0;
        this.pipes = null;
        this.pipesCount = 0;
        this.flowing = null;
        this.ended = false;
        this.endEmitted = false;
        this.reading = false;
        this.sync = true;
        this.needReadable = false;
        this.emittedReadable = false;
        this.readableListening = false;
        this.resumeScheduled = false;
        this.paused = true;
        this.emitClose = options.emitClose !== false;
        this.autoDestroy = !!options.autoDestroy;
        this.destroyed = false;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.awaitDrain = 0;
        this.readingMore = false;
        this.decoder = null;
        this.encoding = null;
        if (options.encoding) {
          if (!StringDecoder) StringDecoder = requireString_decoder2().StringDecoder;
          this.decoder = new StringDecoder(options.encoding);
          this.encoding = options.encoding;
        }
      }
      function Readable(options) {
        Duplex = Duplex || require_stream_duplex2();
        if (!(this instanceof Readable)) return new Readable(options);
        var isDuplex = this instanceof Duplex;
        this._readableState = new ReadableState(options, this, isDuplex);
        this.readable = true;
        if (options) {
          if (typeof options.read === "function") this._read = options.read;
          if (typeof options.destroy === "function") this._destroy = options.destroy;
        }
        Stream.call(this);
      }
      Object.defineProperty(Readable.prototype, "destroyed", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: false,
        get: function get22() {
          if (this._readableState === void 0) {
            return false;
          }
          return this._readableState.destroyed;
        },
        set: function set(value) {
          if (!this._readableState) {
            return;
          }
          this._readableState.destroyed = value;
        }
      });
      Readable.prototype.destroy = destroyImpl.destroy;
      Readable.prototype._undestroy = destroyImpl.undestroy;
      Readable.prototype._destroy = function(err, cb) {
        cb(err);
      };
      Readable.prototype.push = function(chunk, encoding) {
        var state22 = this._readableState;
        var skipChunkCheck;
        if (!state22.objectMode) {
          if (typeof chunk === "string") {
            encoding = encoding || state22.defaultEncoding;
            if (encoding !== state22.encoding) {
              chunk = Buffer2.from(chunk, encoding);
              encoding = "";
            }
            skipChunkCheck = true;
          }
        } else {
          skipChunkCheck = true;
        }
        return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
      };
      Readable.prototype.unshift = function(chunk) {
        return readableAddChunk(this, chunk, null, true, false);
      };
      function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
        debug("readableAddChunk", chunk);
        var state22 = stream._readableState;
        if (chunk === null) {
          state22.reading = false;
          onEofChunk(stream, state22);
        } else {
          var er;
          if (!skipChunkCheck) er = chunkInvalid(state22, chunk);
          if (er) {
            errorOrDestroy(stream, er);
          } else if (state22.objectMode || chunk && chunk.length > 0) {
            if (typeof chunk !== "string" && !state22.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
              chunk = _uint8ArrayToBuffer(chunk);
            }
            if (addToFront) {
              if (state22.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
              else addChunk(stream, state22, chunk, true);
            } else if (state22.ended) {
              errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
            } else if (state22.destroyed) {
              return false;
            } else {
              state22.reading = false;
              if (state22.decoder && !encoding) {
                chunk = state22.decoder.write(chunk);
                if (state22.objectMode || chunk.length !== 0) addChunk(stream, state22, chunk, false);
                else maybeReadMore(stream, state22);
              } else {
                addChunk(stream, state22, chunk, false);
              }
            }
          } else if (!addToFront) {
            state22.reading = false;
            maybeReadMore(stream, state22);
          }
        }
        return !state22.ended && (state22.length < state22.highWaterMark || state22.length === 0);
      }
      function addChunk(stream, state22, chunk, addToFront) {
        if (state22.flowing && state22.length === 0 && !state22.sync) {
          state22.awaitDrain = 0;
          stream.emit("data", chunk);
        } else {
          state22.length += state22.objectMode ? 1 : chunk.length;
          if (addToFront) state22.buffer.unshift(chunk);
          else state22.buffer.push(chunk);
          if (state22.needReadable) emitReadable(stream);
        }
        maybeReadMore(stream, state22);
      }
      function chunkInvalid(state22, chunk) {
        var er;
        if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state22.objectMode) {
          er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
        return er;
      }
      Readable.prototype.isPaused = function() {
        return this._readableState.flowing === false;
      };
      Readable.prototype.setEncoding = function(enc) {
        if (!StringDecoder) StringDecoder = requireString_decoder2().StringDecoder;
        var decoder = new StringDecoder(enc);
        this._readableState.decoder = decoder;
        this._readableState.encoding = this._readableState.decoder.encoding;
        var p = this._readableState.buffer.head;
        var content = "";
        while (p !== null) {
          content += decoder.write(p.data);
          p = p.next;
        }
        this._readableState.buffer.clear();
        if (content !== "") this._readableState.buffer.push(content);
        this._readableState.length = content.length;
        return this;
      };
      var MAX_HWM = 1073741824;
      function computeNewHighWaterMark(n) {
        if (n >= MAX_HWM) {
          n = MAX_HWM;
        } else {
          n--;
          n |= n >>> 1;
          n |= n >>> 2;
          n |= n >>> 4;
          n |= n >>> 8;
          n |= n >>> 16;
          n++;
        }
        return n;
      }
      function howMuchToRead(n, state22) {
        if (n <= 0 || state22.length === 0 && state22.ended) return 0;
        if (state22.objectMode) return 1;
        if (n !== n) {
          if (state22.flowing && state22.length) return state22.buffer.head.data.length;
          else return state22.length;
        }
        if (n > state22.highWaterMark) state22.highWaterMark = computeNewHighWaterMark(n);
        if (n <= state22.length) return n;
        if (!state22.ended) {
          state22.needReadable = true;
          return 0;
        }
        return state22.length;
      }
      Readable.prototype.read = function(n) {
        debug("read", n);
        n = parseInt(n, 10);
        var state22 = this._readableState;
        var nOrig = n;
        if (n !== 0) state22.emittedReadable = false;
        if (n === 0 && state22.needReadable && ((state22.highWaterMark !== 0 ? state22.length >= state22.highWaterMark : state22.length > 0) || state22.ended)) {
          debug("read: emitReadable", state22.length, state22.ended);
          if (state22.length === 0 && state22.ended) endReadable(this);
          else emitReadable(this);
          return null;
        }
        n = howMuchToRead(n, state22);
        if (n === 0 && state22.ended) {
          if (state22.length === 0) endReadable(this);
          return null;
        }
        var doRead = state22.needReadable;
        debug("need readable", doRead);
        if (state22.length === 0 || state22.length - n < state22.highWaterMark) {
          doRead = true;
          debug("length less than watermark", doRead);
        }
        if (state22.ended || state22.reading) {
          doRead = false;
          debug("reading or ended", doRead);
        } else if (doRead) {
          debug("do read");
          state22.reading = true;
          state22.sync = true;
          if (state22.length === 0) state22.needReadable = true;
          this._read(state22.highWaterMark);
          state22.sync = false;
          if (!state22.reading) n = howMuchToRead(nOrig, state22);
        }
        var ret;
        if (n > 0) ret = fromList(n, state22);
        else ret = null;
        if (ret === null) {
          state22.needReadable = state22.length <= state22.highWaterMark;
          n = 0;
        } else {
          state22.length -= n;
          state22.awaitDrain = 0;
        }
        if (state22.length === 0) {
          if (!state22.ended) state22.needReadable = true;
          if (nOrig !== n && state22.ended) endReadable(this);
        }
        if (ret !== null) this.emit("data", ret);
        return ret;
      };
      function onEofChunk(stream, state22) {
        debug("onEofChunk");
        if (state22.ended) return;
        if (state22.decoder) {
          var chunk = state22.decoder.end();
          if (chunk && chunk.length) {
            state22.buffer.push(chunk);
            state22.length += state22.objectMode ? 1 : chunk.length;
          }
        }
        state22.ended = true;
        if (state22.sync) {
          emitReadable(stream);
        } else {
          state22.needReadable = false;
          if (!state22.emittedReadable) {
            state22.emittedReadable = true;
            emitReadable_(stream);
          }
        }
      }
      function emitReadable(stream) {
        var state22 = stream._readableState;
        debug("emitReadable", state22.needReadable, state22.emittedReadable);
        state22.needReadable = false;
        if (!state22.emittedReadable) {
          debug("emitReadable", state22.flowing);
          state22.emittedReadable = true;
          process$12.nextTick(emitReadable_, stream);
        }
      }
      function emitReadable_(stream) {
        var state22 = stream._readableState;
        debug("emitReadable_", state22.destroyed, state22.length, state22.ended);
        if (!state22.destroyed && (state22.length || state22.ended)) {
          stream.emit("readable");
          state22.emittedReadable = false;
        }
        state22.needReadable = !state22.flowing && !state22.ended && state22.length <= state22.highWaterMark;
        flow(stream);
      }
      function maybeReadMore(stream, state22) {
        if (!state22.readingMore) {
          state22.readingMore = true;
          process$12.nextTick(maybeReadMore_, stream, state22);
        }
      }
      function maybeReadMore_(stream, state22) {
        while (!state22.reading && !state22.ended && (state22.length < state22.highWaterMark || state22.flowing && state22.length === 0)) {
          var len = state22.length;
          debug("maybeReadMore read 0");
          stream.read(0);
          if (len === state22.length)
            break;
        }
        state22.readingMore = false;
      }
      Readable.prototype._read = function(n) {
        errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
      };
      Readable.prototype.pipe = function(dest, pipeOpts) {
        var src = this;
        var state22 = this._readableState;
        switch (state22.pipesCount) {
          case 0:
            state22.pipes = dest;
            break;
          case 1:
            state22.pipes = [state22.pipes, dest];
            break;
          default:
            state22.pipes.push(dest);
            break;
        }
        state22.pipesCount += 1;
        debug("pipe count=%d opts=%j", state22.pipesCount, pipeOpts);
        var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process$12.stdout && dest !== process$12.stderr;
        var endFn = doEnd ? onend : unpipe;
        if (state22.endEmitted) process$12.nextTick(endFn);
        else src.once("end", endFn);
        dest.on("unpipe", onunpipe);
        function onunpipe(readable, unpipeInfo) {
          debug("onunpipe");
          if (readable === src) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
              unpipeInfo.hasUnpiped = true;
              cleanup();
            }
          }
        }
        function onend() {
          debug("onend");
          dest.end();
        }
        var ondrain = pipeOnDrain(src);
        dest.on("drain", ondrain);
        var cleanedUp = false;
        function cleanup() {
          debug("cleanup");
          dest.removeListener("close", onclose);
          dest.removeListener("finish", onfinish);
          dest.removeListener("drain", ondrain);
          dest.removeListener("error", onerror);
          dest.removeListener("unpipe", onunpipe);
          src.removeListener("end", onend);
          src.removeListener("end", unpipe);
          src.removeListener("data", ondata);
          cleanedUp = true;
          if (state22.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
        }
        src.on("data", ondata);
        function ondata(chunk) {
          debug("ondata");
          var ret = dest.write(chunk);
          debug("dest.write", ret);
          if (ret === false) {
            if ((state22.pipesCount === 1 && state22.pipes === dest || state22.pipesCount > 1 && indexOf(state22.pipes, dest) !== -1) && !cleanedUp) {
              debug("false write response, pause", state22.awaitDrain);
              state22.awaitDrain++;
            }
            src.pause();
          }
        }
        function onerror(er) {
          debug("onerror", er);
          unpipe();
          dest.removeListener("error", onerror);
          if (EElistenerCount(dest, "error") === 0) errorOrDestroy(dest, er);
        }
        prependListener(dest, "error", onerror);
        function onclose() {
          dest.removeListener("finish", onfinish);
          unpipe();
        }
        dest.once("close", onclose);
        function onfinish() {
          debug("onfinish");
          dest.removeListener("close", onclose);
          unpipe();
        }
        dest.once("finish", onfinish);
        function unpipe() {
          debug("unpipe");
          src.unpipe(dest);
        }
        dest.emit("pipe", src);
        if (!state22.flowing) {
          debug("pipe resume");
          src.resume();
        }
        return dest;
      };
      function pipeOnDrain(src) {
        return function pipeOnDrainFunctionResult() {
          var state22 = src._readableState;
          debug("pipeOnDrain", state22.awaitDrain);
          if (state22.awaitDrain) state22.awaitDrain--;
          if (state22.awaitDrain === 0 && EElistenerCount(src, "data")) {
            state22.flowing = true;
            flow(src);
          }
        };
      }
      Readable.prototype.unpipe = function(dest) {
        var state22 = this._readableState;
        var unpipeInfo = {
          hasUnpiped: false
        };
        if (state22.pipesCount === 0) return this;
        if (state22.pipesCount === 1) {
          if (dest && dest !== state22.pipes) return this;
          if (!dest) dest = state22.pipes;
          state22.pipes = null;
          state22.pipesCount = 0;
          state22.flowing = false;
          if (dest) dest.emit("unpipe", this, unpipeInfo);
          return this;
        }
        if (!dest) {
          var dests = state22.pipes;
          var len = state22.pipesCount;
          state22.pipes = null;
          state22.pipesCount = 0;
          state22.flowing = false;
          for (var i = 0; i < len; i++) {
            dests[i].emit("unpipe", this, {
              hasUnpiped: false
            });
          }
          return this;
        }
        var index = indexOf(state22.pipes, dest);
        if (index === -1) return this;
        state22.pipes.splice(index, 1);
        state22.pipesCount -= 1;
        if (state22.pipesCount === 1) state22.pipes = state22.pipes[0];
        dest.emit("unpipe", this, unpipeInfo);
        return this;
      };
      Readable.prototype.on = function(ev, fn) {
        var res = Stream.prototype.on.call(this, ev, fn);
        var state22 = this._readableState;
        if (ev === "data") {
          state22.readableListening = this.listenerCount("readable") > 0;
          if (state22.flowing !== false) this.resume();
        } else if (ev === "readable") {
          if (!state22.endEmitted && !state22.readableListening) {
            state22.readableListening = state22.needReadable = true;
            state22.flowing = false;
            state22.emittedReadable = false;
            debug("on readable", state22.length, state22.reading);
            if (state22.length) {
              emitReadable(this);
            } else if (!state22.reading) {
              process$12.nextTick(nReadingNextTick, this);
            }
          }
        }
        return res;
      };
      Readable.prototype.addListener = Readable.prototype.on;
      Readable.prototype.removeListener = function(ev, fn) {
        var res = Stream.prototype.removeListener.call(this, ev, fn);
        if (ev === "readable") {
          process$12.nextTick(updateReadableListening, this);
        }
        return res;
      };
      Readable.prototype.removeAllListeners = function(ev) {
        var res = Stream.prototype.removeAllListeners.apply(this, arguments);
        if (ev === "readable" || ev === void 0) {
          process$12.nextTick(updateReadableListening, this);
        }
        return res;
      };
      function updateReadableListening(self2) {
        var state22 = self2._readableState;
        state22.readableListening = self2.listenerCount("readable") > 0;
        if (state22.resumeScheduled && !state22.paused) {
          state22.flowing = true;
        } else if (self2.listenerCount("data") > 0) {
          self2.resume();
        }
      }
      function nReadingNextTick(self2) {
        debug("readable nexttick read 0");
        self2.read(0);
      }
      Readable.prototype.resume = function() {
        var state22 = this._readableState;
        if (!state22.flowing) {
          debug("resume");
          state22.flowing = !state22.readableListening;
          resume(this, state22);
        }
        state22.paused = false;
        return this;
      };
      function resume(stream, state22) {
        if (!state22.resumeScheduled) {
          state22.resumeScheduled = true;
          process$12.nextTick(resume_, stream, state22);
        }
      }
      function resume_(stream, state22) {
        debug("resume", state22.reading);
        if (!state22.reading) {
          stream.read(0);
        }
        state22.resumeScheduled = false;
        stream.emit("resume");
        flow(stream);
        if (state22.flowing && !state22.reading) stream.read(0);
      }
      Readable.prototype.pause = function() {
        debug("call pause flowing=%j", this._readableState.flowing);
        if (this._readableState.flowing !== false) {
          debug("pause");
          this._readableState.flowing = false;
          this.emit("pause");
        }
        this._readableState.paused = true;
        return this;
      };
      function flow(stream) {
        var state22 = stream._readableState;
        debug("flow", state22.flowing);
        while (state22.flowing && stream.read() !== null) {
        }
      }
      Readable.prototype.wrap = function(stream) {
        var _this = this;
        var state22 = this._readableState;
        var paused = false;
        stream.on("end", function() {
          debug("wrapped end");
          if (state22.decoder && !state22.ended) {
            var chunk = state22.decoder.end();
            if (chunk && chunk.length) _this.push(chunk);
          }
          _this.push(null);
        });
        stream.on("data", function(chunk) {
          debug("wrapped data");
          if (state22.decoder) chunk = state22.decoder.write(chunk);
          if (state22.objectMode && (chunk === null || chunk === void 0)) return;
          else if (!state22.objectMode && (!chunk || !chunk.length)) return;
          var ret = _this.push(chunk);
          if (!ret) {
            paused = true;
            stream.pause();
          }
        });
        for (var i in stream) {
          if (this[i] === void 0 && typeof stream[i] === "function") {
            this[i] = /* @__PURE__ */ (function methodWrap(method) {
              return function methodWrapReturnFunction() {
                return stream[method].apply(stream, arguments);
              };
            })(i);
          }
        }
        for (var n = 0; n < kProxyEvents.length; n++) {
          stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
        }
        this._read = function(n2) {
          debug("wrapped _read", n2);
          if (paused) {
            paused = false;
            stream.resume();
          }
        };
        return this;
      };
      if (typeof Symbol === "function") {
        Readable.prototype[Symbol.asyncIterator] = function() {
          if (createReadableStreamAsyncIterator === void 0) {
            createReadableStreamAsyncIterator = requireAsync_iterator2();
          }
          return createReadableStreamAsyncIterator(this);
        };
      }
      Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: false,
        get: function get22() {
          return this._readableState.highWaterMark;
        }
      });
      Object.defineProperty(Readable.prototype, "readableBuffer", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: false,
        get: function get22() {
          return this._readableState && this._readableState.buffer;
        }
      });
      Object.defineProperty(Readable.prototype, "readableFlowing", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: false,
        get: function get22() {
          return this._readableState.flowing;
        },
        set: function set(state22) {
          if (this._readableState) {
            this._readableState.flowing = state22;
          }
        }
      });
      Readable._fromList = fromList;
      Object.defineProperty(Readable.prototype, "readableLength", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: false,
        get: function get22() {
          return this._readableState.length;
        }
      });
      function fromList(n, state22) {
        if (state22.length === 0) return null;
        var ret;
        if (state22.objectMode) ret = state22.buffer.shift();
        else if (!n || n >= state22.length) {
          if (state22.decoder) ret = state22.buffer.join("");
          else if (state22.buffer.length === 1) ret = state22.buffer.first();
          else ret = state22.buffer.concat(state22.length);
          state22.buffer.clear();
        } else {
          ret = state22.buffer.consume(n, state22.decoder);
        }
        return ret;
      }
      function endReadable(stream) {
        var state22 = stream._readableState;
        debug("endReadable", state22.endEmitted);
        if (!state22.endEmitted) {
          state22.ended = true;
          process$12.nextTick(endReadableNT, state22, stream);
        }
      }
      function endReadableNT(state22, stream) {
        debug("endReadableNT", state22.endEmitted, state22.length);
        if (!state22.endEmitted && state22.length === 0) {
          state22.endEmitted = true;
          stream.readable = false;
          stream.emit("end");
          if (state22.autoDestroy) {
            var wState = stream._writableState;
            if (!wState || wState.autoDestroy && wState.finished) {
              stream.destroy();
            }
          }
        }
      }
      if (typeof Symbol === "function") {
        Readable.from = function(iterable, opts) {
          if (from === void 0) {
            from = requireFromBrowser2();
          }
          return from(Readable, iterable, opts);
        };
      }
      function indexOf(xs, x) {
        for (var i = 0, l = xs.length; i < l; i++) {
          if (xs[i] === x) return i;
        }
        return -1;
      }
      return _stream_readable2;
    }
    var _stream_transform2;
    var hasRequired_stream_transform2;
    function require_stream_transform2() {
      if (hasRequired_stream_transform2) return _stream_transform2;
      hasRequired_stream_transform2 = 1;
      _stream_transform2 = Transform;
      var _require$codes = requireErrorsBrowser2().codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
      var Duplex = require_stream_duplex2();
      requireInherits_browser2()(Transform, Duplex);
      function afterTransform(er, data) {
        var ts = this._transformState;
        ts.transforming = false;
        var cb = ts.writecb;
        if (cb === null) {
          return this.emit("error", new ERR_MULTIPLE_CALLBACK());
        }
        ts.writechunk = null;
        ts.writecb = null;
        if (data != null)
          this.push(data);
        cb(er);
        var rs = this._readableState;
        rs.reading = false;
        if (rs.needReadable || rs.length < rs.highWaterMark) {
          this._read(rs.highWaterMark);
        }
      }
      function Transform(options) {
        if (!(this instanceof Transform)) return new Transform(options);
        Duplex.call(this, options);
        this._transformState = {
          afterTransform: afterTransform.bind(this),
          needTransform: false,
          transforming: false,
          writecb: null,
          writechunk: null,
          writeencoding: null
        };
        this._readableState.needReadable = true;
        this._readableState.sync = false;
        if (options) {
          if (typeof options.transform === "function") this._transform = options.transform;
          if (typeof options.flush === "function") this._flush = options.flush;
        }
        this.on("prefinish", prefinish);
      }
      function prefinish() {
        var _this = this;
        if (typeof this._flush === "function" && !this._readableState.destroyed) {
          this._flush(function(er, data) {
            done(_this, er, data);
          });
        } else {
          done(this, null, null);
        }
      }
      Transform.prototype.push = function(chunk, encoding) {
        this._transformState.needTransform = false;
        return Duplex.prototype.push.call(this, chunk, encoding);
      };
      Transform.prototype._transform = function(chunk, encoding, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
      };
      Transform.prototype._write = function(chunk, encoding, cb) {
        var ts = this._transformState;
        ts.writecb = cb;
        ts.writechunk = chunk;
        ts.writeencoding = encoding;
        if (!ts.transforming) {
          var rs = this._readableState;
          if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
        }
      };
      Transform.prototype._read = function(n) {
        var ts = this._transformState;
        if (ts.writechunk !== null && !ts.transforming) {
          ts.transforming = true;
          this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
        } else {
          ts.needTransform = true;
        }
      };
      Transform.prototype._destroy = function(err, cb) {
        Duplex.prototype._destroy.call(this, err, function(err2) {
          cb(err2);
        });
      };
      function done(stream, er, data) {
        if (er) return stream.emit("error", er);
        if (data != null)
          stream.push(data);
        if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
        if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
        return stream.push(null);
      }
      return _stream_transform2;
    }
    var _stream_passthrough2;
    var hasRequired_stream_passthrough2;
    function require_stream_passthrough2() {
      if (hasRequired_stream_passthrough2) return _stream_passthrough2;
      hasRequired_stream_passthrough2 = 1;
      _stream_passthrough2 = PassThrough;
      var Transform = require_stream_transform2();
      requireInherits_browser2()(PassThrough, Transform);
      function PassThrough(options) {
        if (!(this instanceof PassThrough)) return new PassThrough(options);
        Transform.call(this, options);
      }
      PassThrough.prototype._transform = function(chunk, encoding, cb) {
        cb(null, chunk);
      };
      return _stream_passthrough2;
    }
    var pipeline_12;
    var hasRequiredPipeline2;
    function requirePipeline2() {
      if (hasRequiredPipeline2) return pipeline_12;
      hasRequiredPipeline2 = 1;
      var eos;
      function once(callback) {
        var called = false;
        return function() {
          if (called) return;
          called = true;
          callback.apply(void 0, arguments);
        };
      }
      var _require$codes = requireErrorsBrowser2().codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
      function noop22(err) {
        if (err) throw err;
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      function destroyer(stream, reading, writing, callback) {
        callback = once(callback);
        var closed = false;
        stream.on("close", function() {
          closed = true;
        });
        if (eos === void 0) eos = requireEndOfStream2();
        eos(stream, {
          readable: reading,
          writable: writing
        }, function(err) {
          if (err) return callback(err);
          closed = true;
          callback();
        });
        var destroyed = false;
        return function(err) {
          if (closed) return;
          if (destroyed) return;
          destroyed = true;
          if (isRequest(stream)) return stream.abort();
          if (typeof stream.destroy === "function") return stream.destroy();
          callback(err || new ERR_STREAM_DESTROYED("pipe"));
        };
      }
      function call(fn) {
        fn();
      }
      function pipe(from, to) {
        return from.pipe(to);
      }
      function popCallback(streams) {
        if (!streams.length) return noop22;
        if (typeof streams[streams.length - 1] !== "function") return noop22;
        return streams.pop();
      }
      function pipeline() {
        for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
          streams[_key] = arguments[_key];
        }
        var callback = popCallback(streams);
        if (Array.isArray(streams[0])) streams = streams[0];
        if (streams.length < 2) {
          throw new ERR_MISSING_ARGS("streams");
        }
        var error;
        var destroys = streams.map(function(stream, i) {
          var reading = i < streams.length - 1;
          var writing = i > 0;
          return destroyer(stream, reading, writing, function(err) {
            if (!error) error = err;
            if (err) destroys.forEach(call);
            if (reading) return;
            destroys.forEach(call);
            callback(error);
          });
        });
        return streams.reduce(pipe);
      }
      pipeline_12 = pipeline;
      return pipeline_12;
    }
    var streamBrowserify2;
    var hasRequiredStreamBrowserify2;
    function requireStreamBrowserify2() {
      if (hasRequiredStreamBrowserify2) return streamBrowserify2;
      hasRequiredStreamBrowserify2 = 1;
      streamBrowserify2 = Stream;
      var EE = requireEvents2().EventEmitter;
      var inherits = requireInherits_browser2();
      inherits(Stream, EE);
      Stream.Readable = require_stream_readable2();
      Stream.Writable = require_stream_writable2();
      Stream.Duplex = require_stream_duplex2();
      Stream.Transform = require_stream_transform2();
      Stream.PassThrough = require_stream_passthrough2();
      Stream.finished = requireEndOfStream2();
      Stream.pipeline = requirePipeline2();
      Stream.Stream = Stream;
      function Stream() {
        EE.call(this);
      }
      Stream.prototype.pipe = function(dest, options) {
        var source = this;
        function ondata(chunk) {
          if (dest.writable) {
            if (false === dest.write(chunk) && source.pause) {
              source.pause();
            }
          }
        }
        source.on("data", ondata);
        function ondrain() {
          if (source.readable && source.resume) {
            source.resume();
          }
        }
        dest.on("drain", ondrain);
        if (!dest._isStdio && (!options || options.end !== false)) {
          source.on("end", onend);
          source.on("close", onclose);
        }
        var didOnEnd = false;
        function onend() {
          if (didOnEnd) return;
          didOnEnd = true;
          dest.end();
        }
        function onclose() {
          if (didOnEnd) return;
          didOnEnd = true;
          if (typeof dest.destroy === "function") dest.destroy();
        }
        function onerror(er) {
          cleanup();
          if (EE.listenerCount(this, "error") === 0) {
            throw er;
          }
        }
        source.on("error", onerror);
        dest.on("error", onerror);
        function cleanup() {
          source.removeListener("data", ondata);
          dest.removeListener("drain", ondrain);
          source.removeListener("end", onend);
          source.removeListener("close", onclose);
          source.removeListener("error", onerror);
          dest.removeListener("error", onerror);
          source.removeListener("end", cleanup);
          source.removeListener("close", cleanup);
          dest.removeListener("close", cleanup);
        }
        source.on("end", cleanup);
        source.on("close", cleanup);
        dest.on("close", cleanup);
        dest.emit("pipe", source);
        return dest;
      };
      return streamBrowserify2;
    }
    var hasRequiredSax2;
    function requireSax2() {
      if (hasRequiredSax2) return sax2;
      hasRequiredSax2 = 1;
      (function(exports22) {
        (function(sax22) {
          sax22.parser = function(strict, opt) {
            return new SAXParser(strict, opt);
          };
          sax22.SAXParser = SAXParser;
          sax22.SAXStream = SAXStream;
          sax22.createStream = createStream;
          sax22.MAX_BUFFER_LENGTH = 64 * 1024;
          var buffers = [
            "comment",
            "sgmlDecl",
            "textNode",
            "tagName",
            "doctype",
            "procInstName",
            "procInstBody",
            "entity",
            "attribName",
            "attribValue",
            "cdata",
            "script"
          ];
          sax22.EVENTS = [
            "text",
            "processinginstruction",
            "sgmldeclaration",
            "doctype",
            "comment",
            "opentagstart",
            "attribute",
            "opentag",
            "closetag",
            "opencdata",
            "cdata",
            "closecdata",
            "error",
            "end",
            "ready",
            "script",
            "opennamespace",
            "closenamespace"
          ];
          function SAXParser(strict, opt) {
            if (!(this instanceof SAXParser)) {
              return new SAXParser(strict, opt);
            }
            var parser = this;
            clearBuffers(parser);
            parser.q = parser.c = "";
            parser.bufferCheckPosition = sax22.MAX_BUFFER_LENGTH;
            parser.opt = opt || {};
            parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
            parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
            parser.tags = [];
            parser.closed = parser.closedRoot = parser.sawRoot = false;
            parser.tag = parser.error = null;
            parser.strict = !!strict;
            parser.noscript = !!(strict || parser.opt.noscript);
            parser.state = S.BEGIN;
            parser.strictEntities = parser.opt.strictEntities;
            parser.ENTITIES = parser.strictEntities ? Object.create(sax22.XML_ENTITIES) : Object.create(sax22.ENTITIES);
            parser.attribList = [];
            if (parser.opt.xmlns) {
              parser.ns = Object.create(rootNS);
            }
            parser.trackPosition = parser.opt.position !== false;
            if (parser.trackPosition) {
              parser.position = parser.line = parser.column = 0;
            }
            emit(parser, "onready");
          }
          if (!Object.create) {
            Object.create = function(o) {
              function F() {
              }
              F.prototype = o;
              var newf = new F();
              return newf;
            };
          }
          if (!Object.keys) {
            Object.keys = function(o) {
              var a = [];
              for (var i in o) if (o.hasOwnProperty(i)) a.push(i);
              return a;
            };
          }
          function checkBufferLength(parser) {
            var maxAllowed = Math.max(sax22.MAX_BUFFER_LENGTH, 10);
            var maxActual = 0;
            for (var i = 0, l = buffers.length; i < l; i++) {
              var len = parser[buffers[i]].length;
              if (len > maxAllowed) {
                switch (buffers[i]) {
                  case "textNode":
                    closeText(parser);
                    break;
                  case "cdata":
                    emitNode(parser, "oncdata", parser.cdata);
                    parser.cdata = "";
                    break;
                  case "script":
                    emitNode(parser, "onscript", parser.script);
                    parser.script = "";
                    break;
                  default:
                    error(parser, "Max buffer length exceeded: " + buffers[i]);
                }
              }
              maxActual = Math.max(maxActual, len);
            }
            var m = sax22.MAX_BUFFER_LENGTH - maxActual;
            parser.bufferCheckPosition = m + parser.position;
          }
          function clearBuffers(parser) {
            for (var i = 0, l = buffers.length; i < l; i++) {
              parser[buffers[i]] = "";
            }
          }
          function flushBuffers(parser) {
            closeText(parser);
            if (parser.cdata !== "") {
              emitNode(parser, "oncdata", parser.cdata);
              parser.cdata = "";
            }
            if (parser.script !== "") {
              emitNode(parser, "onscript", parser.script);
              parser.script = "";
            }
          }
          SAXParser.prototype = {
            end: function() {
              end(this);
            },
            write,
            resume: function() {
              this.error = null;
              return this;
            },
            close: function() {
              return this.write(null);
            },
            flush: function() {
              flushBuffers(this);
            }
          };
          var Stream;
          try {
            Stream = requireStreamBrowserify2().Stream;
          } catch (ex) {
            Stream = function() {
            };
          }
          var streamWraps = sax22.EVENTS.filter(function(ev) {
            return ev !== "error" && ev !== "end";
          });
          function createStream(strict, opt) {
            return new SAXStream(strict, opt);
          }
          function SAXStream(strict, opt) {
            if (!(this instanceof SAXStream)) {
              return new SAXStream(strict, opt);
            }
            Stream.apply(this);
            this._parser = new SAXParser(strict, opt);
            this.writable = true;
            this.readable = true;
            var me = this;
            this._parser.onend = function() {
              me.emit("end");
            };
            this._parser.onerror = function(er) {
              me.emit("error", er);
              me._parser.error = null;
            };
            this._decoder = null;
            streamWraps.forEach(function(ev) {
              Object.defineProperty(me, "on" + ev, {
                get: function() {
                  return me._parser["on" + ev];
                },
                set: function(h) {
                  if (!h) {
                    me.removeAllListeners(ev);
                    me._parser["on" + ev] = h;
                    return h;
                  }
                  me.on(ev, h);
                },
                enumerable: true,
                configurable: false
              });
            });
          }
          SAXStream.prototype = Object.create(Stream.prototype, {
            constructor: {
              value: SAXStream
            }
          });
          SAXStream.prototype.write = function(data) {
            if (typeof Buffer === "function" && typeof Buffer.isBuffer === "function" && Buffer.isBuffer(data)) {
              if (!this._decoder) {
                var SD = requireString_decoder2().StringDecoder;
                this._decoder = new SD("utf8");
              }
              data = this._decoder.write(data);
            }
            this._parser.write(data.toString());
            this.emit("data", data);
            return true;
          };
          SAXStream.prototype.end = function(chunk) {
            if (chunk && chunk.length) {
              this.write(chunk);
            }
            this._parser.end();
            return true;
          };
          SAXStream.prototype.on = function(ev, handler) {
            var me = this;
            if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) {
              me._parser["on" + ev] = function() {
                var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
                args.splice(0, 0, ev);
                me.emit.apply(me, args);
              };
            }
            return Stream.prototype.on.call(me, ev, handler);
          };
          var CDATA = "[CDATA[";
          var DOCTYPE = "DOCTYPE";
          var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
          var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
          var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
          var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
          var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
          var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
          var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
          function isWhitespace(c) {
            return c === " " || c === "\n" || c === "\r" || c === "	";
          }
          function isQuote(c) {
            return c === '"' || c === "'";
          }
          function isAttribEnd(c) {
            return c === ">" || isWhitespace(c);
          }
          function isMatch(regex, c) {
            return regex.test(c);
          }
          function notMatch(regex, c) {
            return !isMatch(regex, c);
          }
          var S = 0;
          sax22.STATE = {
            BEGIN: S++,
            // leading byte order mark or whitespace
            BEGIN_WHITESPACE: S++,
            // leading whitespace
            TEXT: S++,
            // general stuff
            TEXT_ENTITY: S++,
            // &amp and such.
            OPEN_WAKA: S++,
            // <
            SGML_DECL: S++,
            // <!BLARG
            SGML_DECL_QUOTED: S++,
            // <!BLARG foo "bar
            DOCTYPE: S++,
            // <!DOCTYPE
            DOCTYPE_QUOTED: S++,
            // <!DOCTYPE "//blah
            DOCTYPE_DTD: S++,
            // <!DOCTYPE "//blah" [ ...
            DOCTYPE_DTD_QUOTED: S++,
            // <!DOCTYPE "//blah" [ "foo
            COMMENT_STARTING: S++,
            // <!-
            COMMENT: S++,
            // <!--
            COMMENT_ENDING: S++,
            // <!-- blah -
            COMMENT_ENDED: S++,
            // <!-- blah --
            CDATA: S++,
            // <![CDATA[ something
            CDATA_ENDING: S++,
            // ]
            CDATA_ENDING_2: S++,
            // ]]
            PROC_INST: S++,
            // <?hi
            PROC_INST_BODY: S++,
            // <?hi there
            PROC_INST_ENDING: S++,
            // <?hi "there" ?
            OPEN_TAG: S++,
            // <strong
            OPEN_TAG_SLASH: S++,
            // <strong /
            ATTRIB: S++,
            // <a
            ATTRIB_NAME: S++,
            // <a foo
            ATTRIB_NAME_SAW_WHITE: S++,
            // <a foo _
            ATTRIB_VALUE: S++,
            // <a foo=
            ATTRIB_VALUE_QUOTED: S++,
            // <a foo="bar
            ATTRIB_VALUE_CLOSED: S++,
            // <a foo="bar"
            ATTRIB_VALUE_UNQUOTED: S++,
            // <a foo=bar
            ATTRIB_VALUE_ENTITY_Q: S++,
            // <foo bar="&quot;"
            ATTRIB_VALUE_ENTITY_U: S++,
            // <foo bar=&quot
            CLOSE_TAG: S++,
            // </a
            CLOSE_TAG_SAW_WHITE: S++,
            // </a   >
            SCRIPT: S++,
            // <script> ...
            SCRIPT_ENDING: S++
            // <script> ... <
          };
          sax22.XML_ENTITIES = {
            "amp": "&",
            "gt": ">",
            "lt": "<",
            "quot": '"',
            "apos": "'"
          };
          sax22.ENTITIES = {
            "amp": "&",
            "gt": ">",
            "lt": "<",
            "quot": '"',
            "apos": "'",
            "AElig": 198,
            "Aacute": 193,
            "Acirc": 194,
            "Agrave": 192,
            "Aring": 197,
            "Atilde": 195,
            "Auml": 196,
            "Ccedil": 199,
            "ETH": 208,
            "Eacute": 201,
            "Ecirc": 202,
            "Egrave": 200,
            "Euml": 203,
            "Iacute": 205,
            "Icirc": 206,
            "Igrave": 204,
            "Iuml": 207,
            "Ntilde": 209,
            "Oacute": 211,
            "Ocirc": 212,
            "Ograve": 210,
            "Oslash": 216,
            "Otilde": 213,
            "Ouml": 214,
            "THORN": 222,
            "Uacute": 218,
            "Ucirc": 219,
            "Ugrave": 217,
            "Uuml": 220,
            "Yacute": 221,
            "aacute": 225,
            "acirc": 226,
            "aelig": 230,
            "agrave": 224,
            "aring": 229,
            "atilde": 227,
            "auml": 228,
            "ccedil": 231,
            "eacute": 233,
            "ecirc": 234,
            "egrave": 232,
            "eth": 240,
            "euml": 235,
            "iacute": 237,
            "icirc": 238,
            "igrave": 236,
            "iuml": 239,
            "ntilde": 241,
            "oacute": 243,
            "ocirc": 244,
            "ograve": 242,
            "oslash": 248,
            "otilde": 245,
            "ouml": 246,
            "szlig": 223,
            "thorn": 254,
            "uacute": 250,
            "ucirc": 251,
            "ugrave": 249,
            "uuml": 252,
            "yacute": 253,
            "yuml": 255,
            "copy": 169,
            "reg": 174,
            "nbsp": 160,
            "iexcl": 161,
            "cent": 162,
            "pound": 163,
            "curren": 164,
            "yen": 165,
            "brvbar": 166,
            "sect": 167,
            "uml": 168,
            "ordf": 170,
            "laquo": 171,
            "not": 172,
            "shy": 173,
            "macr": 175,
            "deg": 176,
            "plusmn": 177,
            "sup1": 185,
            "sup2": 178,
            "sup3": 179,
            "acute": 180,
            "micro": 181,
            "para": 182,
            "middot": 183,
            "cedil": 184,
            "ordm": 186,
            "raquo": 187,
            "frac14": 188,
            "frac12": 189,
            "frac34": 190,
            "iquest": 191,
            "times": 215,
            "divide": 247,
            "OElig": 338,
            "oelig": 339,
            "Scaron": 352,
            "scaron": 353,
            "Yuml": 376,
            "fnof": 402,
            "circ": 710,
            "tilde": 732,
            "Alpha": 913,
            "Beta": 914,
            "Gamma": 915,
            "Delta": 916,
            "Epsilon": 917,
            "Zeta": 918,
            "Eta": 919,
            "Theta": 920,
            "Iota": 921,
            "Kappa": 922,
            "Lambda": 923,
            "Mu": 924,
            "Nu": 925,
            "Xi": 926,
            "Omicron": 927,
            "Pi": 928,
            "Rho": 929,
            "Sigma": 931,
            "Tau": 932,
            "Upsilon": 933,
            "Phi": 934,
            "Chi": 935,
            "Psi": 936,
            "Omega": 937,
            "alpha": 945,
            "beta": 946,
            "gamma": 947,
            "delta": 948,
            "epsilon": 949,
            "zeta": 950,
            "eta": 951,
            "theta": 952,
            "iota": 953,
            "kappa": 954,
            "lambda": 955,
            "mu": 956,
            "nu": 957,
            "xi": 958,
            "omicron": 959,
            "pi": 960,
            "rho": 961,
            "sigmaf": 962,
            "sigma": 963,
            "tau": 964,
            "upsilon": 965,
            "phi": 966,
            "chi": 967,
            "psi": 968,
            "omega": 969,
            "thetasym": 977,
            "upsih": 978,
            "piv": 982,
            "ensp": 8194,
            "emsp": 8195,
            "thinsp": 8201,
            "zwnj": 8204,
            "zwj": 8205,
            "lrm": 8206,
            "rlm": 8207,
            "ndash": 8211,
            "mdash": 8212,
            "lsquo": 8216,
            "rsquo": 8217,
            "sbquo": 8218,
            "ldquo": 8220,
            "rdquo": 8221,
            "bdquo": 8222,
            "dagger": 8224,
            "Dagger": 8225,
            "bull": 8226,
            "hellip": 8230,
            "permil": 8240,
            "prime": 8242,
            "Prime": 8243,
            "lsaquo": 8249,
            "rsaquo": 8250,
            "oline": 8254,
            "frasl": 8260,
            "euro": 8364,
            "image": 8465,
            "weierp": 8472,
            "real": 8476,
            "trade": 8482,
            "alefsym": 8501,
            "larr": 8592,
            "uarr": 8593,
            "rarr": 8594,
            "darr": 8595,
            "harr": 8596,
            "crarr": 8629,
            "lArr": 8656,
            "uArr": 8657,
            "rArr": 8658,
            "dArr": 8659,
            "hArr": 8660,
            "forall": 8704,
            "part": 8706,
            "exist": 8707,
            "empty": 8709,
            "nabla": 8711,
            "isin": 8712,
            "notin": 8713,
            "ni": 8715,
            "prod": 8719,
            "sum": 8721,
            "minus": 8722,
            "lowast": 8727,
            "radic": 8730,
            "prop": 8733,
            "infin": 8734,
            "ang": 8736,
            "and": 8743,
            "or": 8744,
            "cap": 8745,
            "cup": 8746,
            "int": 8747,
            "there4": 8756,
            "sim": 8764,
            "cong": 8773,
            "asymp": 8776,
            "ne": 8800,
            "equiv": 8801,
            "le": 8804,
            "ge": 8805,
            "sub": 8834,
            "sup": 8835,
            "nsub": 8836,
            "sube": 8838,
            "supe": 8839,
            "oplus": 8853,
            "otimes": 8855,
            "perp": 8869,
            "sdot": 8901,
            "lceil": 8968,
            "rceil": 8969,
            "lfloor": 8970,
            "rfloor": 8971,
            "lang": 9001,
            "rang": 9002,
            "loz": 9674,
            "spades": 9824,
            "clubs": 9827,
            "hearts": 9829,
            "diams": 9830
          };
          Object.keys(sax22.ENTITIES).forEach(function(key) {
            var e = sax22.ENTITIES[key];
            var s2 = typeof e === "number" ? String.fromCharCode(e) : e;
            sax22.ENTITIES[key] = s2;
          });
          for (var s in sax22.STATE) {
            sax22.STATE[sax22.STATE[s]] = s;
          }
          S = sax22.STATE;
          function emit(parser, event, data) {
            parser[event] && parser[event](data);
          }
          function emitNode(parser, nodeType, data) {
            if (parser.textNode) closeText(parser);
            emit(parser, nodeType, data);
          }
          function closeText(parser) {
            parser.textNode = textopts(parser.opt, parser.textNode);
            if (parser.textNode) emit(parser, "ontext", parser.textNode);
            parser.textNode = "";
          }
          function textopts(opt, text) {
            if (opt.trim) text = text.trim();
            if (opt.normalize) text = text.replace(/\s+/g, " ");
            return text;
          }
          function error(parser, er) {
            closeText(parser);
            if (parser.trackPosition) {
              er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
            }
            er = new Error(er);
            parser.error = er;
            emit(parser, "onerror", er);
            return parser;
          }
          function end(parser) {
            if (parser.sawRoot && !parser.closedRoot) strictFail(parser, "Unclosed root tag");
            if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {
              error(parser, "Unexpected end");
            }
            closeText(parser);
            parser.c = "";
            parser.closed = true;
            emit(parser, "onend");
            SAXParser.call(parser, parser.strict, parser.opt);
            return parser;
          }
          function strictFail(parser, message) {
            if (typeof parser !== "object" || !(parser instanceof SAXParser)) {
              throw new Error("bad call to strictFail");
            }
            if (parser.strict) {
              error(parser, message);
            }
          }
          function newTag(parser) {
            if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();
            var parent = parser.tags[parser.tags.length - 1] || parser;
            var tag = parser.tag = { name: parser.tagName, attributes: {} };
            if (parser.opt.xmlns) {
              tag.ns = parent.ns;
            }
            parser.attribList.length = 0;
            emitNode(parser, "onopentagstart", tag);
          }
          function qname(name, attribute) {
            var i = name.indexOf(":");
            var qualName = i < 0 ? ["", name] : name.split(":");
            var prefix = qualName[0];
            var local = qualName[1];
            if (attribute && name === "xmlns") {
              prefix = "xmlns";
              local = "";
            }
            return { prefix, local };
          }
          function attrib(parser) {
            if (!parser.strict) {
              parser.attribName = parser.attribName[parser.looseCase]();
            }
            if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
              parser.attribName = parser.attribValue = "";
              return;
            }
            if (parser.opt.xmlns) {
              var qn = qname(parser.attribName, true);
              var prefix = qn.prefix;
              var local = qn.local;
              if (prefix === "xmlns") {
                if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
                  strictFail(
                    parser,
                    "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser.attribValue
                  );
                } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
                  strictFail(
                    parser,
                    "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\nActual: " + parser.attribValue
                  );
                } else {
                  var tag = parser.tag;
                  var parent = parser.tags[parser.tags.length - 1] || parser;
                  if (tag.ns === parent.ns) {
                    tag.ns = Object.create(parent.ns);
                  }
                  tag.ns[local] = parser.attribValue;
                }
              }
              parser.attribList.push([parser.attribName, parser.attribValue]);
            } else {
              parser.tag.attributes[parser.attribName] = parser.attribValue;
              emitNode(parser, "onattribute", {
                name: parser.attribName,
                value: parser.attribValue
              });
            }
            parser.attribName = parser.attribValue = "";
          }
          function openTag(parser, selfClosing) {
            if (parser.opt.xmlns) {
              var tag = parser.tag;
              var qn = qname(parser.tagName);
              tag.prefix = qn.prefix;
              tag.local = qn.local;
              tag.uri = tag.ns[qn.prefix] || "";
              if (tag.prefix && !tag.uri) {
                strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName));
                tag.uri = qn.prefix;
              }
              var parent = parser.tags[parser.tags.length - 1] || parser;
              if (tag.ns && parent.ns !== tag.ns) {
                Object.keys(tag.ns).forEach(function(p) {
                  emitNode(parser, "onopennamespace", {
                    prefix: p,
                    uri: tag.ns[p]
                  });
                });
              }
              for (var i = 0, l = parser.attribList.length; i < l; i++) {
                var nv = parser.attribList[i];
                var name = nv[0];
                var value = nv[1];
                var qualName = qname(name, true);
                var prefix = qualName.prefix;
                var local = qualName.local;
                var uri22 = prefix === "" ? "" : tag.ns[prefix] || "";
                var a = {
                  name,
                  value,
                  prefix,
                  local,
                  uri: uri22
                };
                if (prefix && prefix !== "xmlns" && !uri22) {
                  strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix));
                  a.uri = prefix;
                }
                parser.tag.attributes[name] = a;
                emitNode(parser, "onattribute", a);
              }
              parser.attribList.length = 0;
            }
            parser.tag.isSelfClosing = !!selfClosing;
            parser.sawRoot = true;
            parser.tags.push(parser.tag);
            emitNode(parser, "onopentag", parser.tag);
            if (!selfClosing) {
              if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
                parser.state = S.SCRIPT;
              } else {
                parser.state = S.TEXT;
              }
              parser.tag = null;
              parser.tagName = "";
            }
            parser.attribName = parser.attribValue = "";
            parser.attribList.length = 0;
          }
          function closeTag(parser) {
            if (!parser.tagName) {
              strictFail(parser, "Weird empty close tag.");
              parser.textNode += "</>";
              parser.state = S.TEXT;
              return;
            }
            if (parser.script) {
              if (parser.tagName !== "script") {
                parser.script += "</" + parser.tagName + ">";
                parser.tagName = "";
                parser.state = S.SCRIPT;
                return;
              }
              emitNode(parser, "onscript", parser.script);
              parser.script = "";
            }
            var t = parser.tags.length;
            var tagName = parser.tagName;
            if (!parser.strict) {
              tagName = tagName[parser.looseCase]();
            }
            var closeTo = tagName;
            while (t--) {
              var close = parser.tags[t];
              if (close.name !== closeTo) {
                strictFail(parser, "Unexpected close tag");
              } else {
                break;
              }
            }
            if (t < 0) {
              strictFail(parser, "Unmatched closing tag: " + parser.tagName);
              parser.textNode += "</" + parser.tagName + ">";
              parser.state = S.TEXT;
              return;
            }
            parser.tagName = tagName;
            var s2 = parser.tags.length;
            while (s2-- > t) {
              var tag = parser.tag = parser.tags.pop();
              parser.tagName = parser.tag.name;
              emitNode(parser, "onclosetag", parser.tagName);
              var x = {};
              for (var i in tag.ns) {
                x[i] = tag.ns[i];
              }
              var parent = parser.tags[parser.tags.length - 1] || parser;
              if (parser.opt.xmlns && tag.ns !== parent.ns) {
                Object.keys(tag.ns).forEach(function(p) {
                  var n = tag.ns[p];
                  emitNode(parser, "onclosenamespace", { prefix: p, uri: n });
                });
              }
            }
            if (t === 0) parser.closedRoot = true;
            parser.tagName = parser.attribValue = parser.attribName = "";
            parser.attribList.length = 0;
            parser.state = S.TEXT;
          }
          function parseEntity(parser) {
            var entity = parser.entity;
            var entityLC = entity.toLowerCase();
            var num;
            var numStr = "";
            if (parser.ENTITIES[entity]) {
              return parser.ENTITIES[entity];
            }
            if (parser.ENTITIES[entityLC]) {
              return parser.ENTITIES[entityLC];
            }
            entity = entityLC;
            if (entity.charAt(0) === "#") {
              if (entity.charAt(1) === "x") {
                entity = entity.slice(2);
                num = parseInt(entity, 16);
                numStr = num.toString(16);
              } else {
                entity = entity.slice(1);
                num = parseInt(entity, 10);
                numStr = num.toString(10);
              }
            }
            entity = entity.replace(/^0+/, "");
            if (isNaN(num) || numStr.toLowerCase() !== entity) {
              strictFail(parser, "Invalid character entity");
              return "&" + parser.entity + ";";
            }
            return String.fromCodePoint(num);
          }
          function beginWhiteSpace(parser, c) {
            if (c === "<") {
              parser.state = S.OPEN_WAKA;
              parser.startTagPosition = parser.position;
            } else if (!isWhitespace(c)) {
              strictFail(parser, "Non-whitespace before first tag.");
              parser.textNode = c;
              parser.state = S.TEXT;
            }
          }
          function charAt(chunk, i) {
            var result = "";
            if (i < chunk.length) {
              result = chunk.charAt(i);
            }
            return result;
          }
          function write(chunk) {
            var parser = this;
            if (this.error) {
              throw this.error;
            }
            if (parser.closed) {
              return error(
                parser,
                "Cannot write after close. Assign an onready handler."
              );
            }
            if (chunk === null) {
              return end(parser);
            }
            if (typeof chunk === "object") {
              chunk = chunk.toString();
            }
            var i = 0;
            var c = "";
            while (true) {
              c = charAt(chunk, i++);
              parser.c = c;
              if (!c) {
                break;
              }
              if (parser.trackPosition) {
                parser.position++;
                if (c === "\n") {
                  parser.line++;
                  parser.column = 0;
                } else {
                  parser.column++;
                }
              }
              switch (parser.state) {
                case S.BEGIN:
                  parser.state = S.BEGIN_WHITESPACE;
                  if (c === "\uFEFF") {
                    continue;
                  }
                  beginWhiteSpace(parser, c);
                  continue;
                case S.BEGIN_WHITESPACE:
                  beginWhiteSpace(parser, c);
                  continue;
                case S.TEXT:
                  if (parser.sawRoot && !parser.closedRoot) {
                    var starti = i - 1;
                    while (c && c !== "<" && c !== "&") {
                      c = charAt(chunk, i++);
                      if (c && parser.trackPosition) {
                        parser.position++;
                        if (c === "\n") {
                          parser.line++;
                          parser.column = 0;
                        } else {
                          parser.column++;
                        }
                      }
                    }
                    parser.textNode += chunk.substring(starti, i - 1);
                  }
                  if (c === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
                    parser.state = S.OPEN_WAKA;
                    parser.startTagPosition = parser.position;
                  } else {
                    if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
                      strictFail(parser, "Text data outside of root node.");
                    }
                    if (c === "&") {
                      parser.state = S.TEXT_ENTITY;
                    } else {
                      parser.textNode += c;
                    }
                  }
                  continue;
                case S.SCRIPT:
                  if (c === "<") {
                    parser.state = S.SCRIPT_ENDING;
                  } else {
                    parser.script += c;
                  }
                  continue;
                case S.SCRIPT_ENDING:
                  if (c === "/") {
                    parser.state = S.CLOSE_TAG;
                  } else {
                    parser.script += "<" + c;
                    parser.state = S.SCRIPT;
                  }
                  continue;
                case S.OPEN_WAKA:
                  if (c === "!") {
                    parser.state = S.SGML_DECL;
                    parser.sgmlDecl = "";
                  } else if (isWhitespace(c)) ;
                  else if (isMatch(nameStart, c)) {
                    parser.state = S.OPEN_TAG;
                    parser.tagName = c;
                  } else if (c === "/") {
                    parser.state = S.CLOSE_TAG;
                    parser.tagName = "";
                  } else if (c === "?") {
                    parser.state = S.PROC_INST;
                    parser.procInstName = parser.procInstBody = "";
                  } else {
                    strictFail(parser, "Unencoded <");
                    if (parser.startTagPosition + 1 < parser.position) {
                      var pad = parser.position - parser.startTagPosition;
                      c = new Array(pad).join(" ") + c;
                    }
                    parser.textNode += "<" + c;
                    parser.state = S.TEXT;
                  }
                  continue;
                case S.SGML_DECL:
                  if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
                    emitNode(parser, "onopencdata");
                    parser.state = S.CDATA;
                    parser.sgmlDecl = "";
                    parser.cdata = "";
                  } else if (parser.sgmlDecl + c === "--") {
                    parser.state = S.COMMENT;
                    parser.comment = "";
                    parser.sgmlDecl = "";
                  } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
                    parser.state = S.DOCTYPE;
                    if (parser.doctype || parser.sawRoot) {
                      strictFail(
                        parser,
                        "Inappropriately located doctype declaration"
                      );
                    }
                    parser.doctype = "";
                    parser.sgmlDecl = "";
                  } else if (c === ">") {
                    emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
                    parser.sgmlDecl = "";
                    parser.state = S.TEXT;
                  } else if (isQuote(c)) {
                    parser.state = S.SGML_DECL_QUOTED;
                    parser.sgmlDecl += c;
                  } else {
                    parser.sgmlDecl += c;
                  }
                  continue;
                case S.SGML_DECL_QUOTED:
                  if (c === parser.q) {
                    parser.state = S.SGML_DECL;
                    parser.q = "";
                  }
                  parser.sgmlDecl += c;
                  continue;
                case S.DOCTYPE:
                  if (c === ">") {
                    parser.state = S.TEXT;
                    emitNode(parser, "ondoctype", parser.doctype);
                    parser.doctype = true;
                  } else {
                    parser.doctype += c;
                    if (c === "[") {
                      parser.state = S.DOCTYPE_DTD;
                    } else if (isQuote(c)) {
                      parser.state = S.DOCTYPE_QUOTED;
                      parser.q = c;
                    }
                  }
                  continue;
                case S.DOCTYPE_QUOTED:
                  parser.doctype += c;
                  if (c === parser.q) {
                    parser.q = "";
                    parser.state = S.DOCTYPE;
                  }
                  continue;
                case S.DOCTYPE_DTD:
                  parser.doctype += c;
                  if (c === "]") {
                    parser.state = S.DOCTYPE;
                  } else if (isQuote(c)) {
                    parser.state = S.DOCTYPE_DTD_QUOTED;
                    parser.q = c;
                  }
                  continue;
                case S.DOCTYPE_DTD_QUOTED:
                  parser.doctype += c;
                  if (c === parser.q) {
                    parser.state = S.DOCTYPE_DTD;
                    parser.q = "";
                  }
                  continue;
                case S.COMMENT:
                  if (c === "-") {
                    parser.state = S.COMMENT_ENDING;
                  } else {
                    parser.comment += c;
                  }
                  continue;
                case S.COMMENT_ENDING:
                  if (c === "-") {
                    parser.state = S.COMMENT_ENDED;
                    parser.comment = textopts(parser.opt, parser.comment);
                    if (parser.comment) {
                      emitNode(parser, "oncomment", parser.comment);
                    }
                    parser.comment = "";
                  } else {
                    parser.comment += "-" + c;
                    parser.state = S.COMMENT;
                  }
                  continue;
                case S.COMMENT_ENDED:
                  if (c !== ">") {
                    strictFail(parser, "Malformed comment");
                    parser.comment += "--" + c;
                    parser.state = S.COMMENT;
                  } else {
                    parser.state = S.TEXT;
                  }
                  continue;
                case S.CDATA:
                  if (c === "]") {
                    parser.state = S.CDATA_ENDING;
                  } else {
                    parser.cdata += c;
                  }
                  continue;
                case S.CDATA_ENDING:
                  if (c === "]") {
                    parser.state = S.CDATA_ENDING_2;
                  } else {
                    parser.cdata += "]" + c;
                    parser.state = S.CDATA;
                  }
                  continue;
                case S.CDATA_ENDING_2:
                  if (c === ">") {
                    if (parser.cdata) {
                      emitNode(parser, "oncdata", parser.cdata);
                    }
                    emitNode(parser, "onclosecdata");
                    parser.cdata = "";
                    parser.state = S.TEXT;
                  } else if (c === "]") {
                    parser.cdata += "]";
                  } else {
                    parser.cdata += "]]" + c;
                    parser.state = S.CDATA;
                  }
                  continue;
                case S.PROC_INST:
                  if (c === "?") {
                    parser.state = S.PROC_INST_ENDING;
                  } else if (isWhitespace(c)) {
                    parser.state = S.PROC_INST_BODY;
                  } else {
                    parser.procInstName += c;
                  }
                  continue;
                case S.PROC_INST_BODY:
                  if (!parser.procInstBody && isWhitespace(c)) {
                    continue;
                  } else if (c === "?") {
                    parser.state = S.PROC_INST_ENDING;
                  } else {
                    parser.procInstBody += c;
                  }
                  continue;
                case S.PROC_INST_ENDING:
                  if (c === ">") {
                    emitNode(parser, "onprocessinginstruction", {
                      name: parser.procInstName,
                      body: parser.procInstBody
                    });
                    parser.procInstName = parser.procInstBody = "";
                    parser.state = S.TEXT;
                  } else {
                    parser.procInstBody += "?" + c;
                    parser.state = S.PROC_INST_BODY;
                  }
                  continue;
                case S.OPEN_TAG:
                  if (isMatch(nameBody, c)) {
                    parser.tagName += c;
                  } else {
                    newTag(parser);
                    if (c === ">") {
                      openTag(parser);
                    } else if (c === "/") {
                      parser.state = S.OPEN_TAG_SLASH;
                    } else {
                      if (!isWhitespace(c)) {
                        strictFail(parser, "Invalid character in tag name");
                      }
                      parser.state = S.ATTRIB;
                    }
                  }
                  continue;
                case S.OPEN_TAG_SLASH:
                  if (c === ">") {
                    openTag(parser, true);
                    closeTag(parser);
                  } else {
                    strictFail(parser, "Forward-slash in opening tag not followed by >");
                    parser.state = S.ATTRIB;
                  }
                  continue;
                case S.ATTRIB:
                  if (isWhitespace(c)) {
                    continue;
                  } else if (c === ">") {
                    openTag(parser);
                  } else if (c === "/") {
                    parser.state = S.OPEN_TAG_SLASH;
                  } else if (isMatch(nameStart, c)) {
                    parser.attribName = c;
                    parser.attribValue = "";
                    parser.state = S.ATTRIB_NAME;
                  } else {
                    strictFail(parser, "Invalid attribute name");
                  }
                  continue;
                case S.ATTRIB_NAME:
                  if (c === "=") {
                    parser.state = S.ATTRIB_VALUE;
                  } else if (c === ">") {
                    strictFail(parser, "Attribute without value");
                    parser.attribValue = parser.attribName;
                    attrib(parser);
                    openTag(parser);
                  } else if (isWhitespace(c)) {
                    parser.state = S.ATTRIB_NAME_SAW_WHITE;
                  } else if (isMatch(nameBody, c)) {
                    parser.attribName += c;
                  } else {
                    strictFail(parser, "Invalid attribute name");
                  }
                  continue;
                case S.ATTRIB_NAME_SAW_WHITE:
                  if (c === "=") {
                    parser.state = S.ATTRIB_VALUE;
                  } else if (isWhitespace(c)) {
                    continue;
                  } else {
                    strictFail(parser, "Attribute without value");
                    parser.tag.attributes[parser.attribName] = "";
                    parser.attribValue = "";
                    emitNode(parser, "onattribute", {
                      name: parser.attribName,
                      value: ""
                    });
                    parser.attribName = "";
                    if (c === ">") {
                      openTag(parser);
                    } else if (isMatch(nameStart, c)) {
                      parser.attribName = c;
                      parser.state = S.ATTRIB_NAME;
                    } else {
                      strictFail(parser, "Invalid attribute name");
                      parser.state = S.ATTRIB;
                    }
                  }
                  continue;
                case S.ATTRIB_VALUE:
                  if (isWhitespace(c)) {
                    continue;
                  } else if (isQuote(c)) {
                    parser.q = c;
                    parser.state = S.ATTRIB_VALUE_QUOTED;
                  } else {
                    strictFail(parser, "Unquoted attribute value");
                    parser.state = S.ATTRIB_VALUE_UNQUOTED;
                    parser.attribValue = c;
                  }
                  continue;
                case S.ATTRIB_VALUE_QUOTED:
                  if (c !== parser.q) {
                    if (c === "&") {
                      parser.state = S.ATTRIB_VALUE_ENTITY_Q;
                    } else {
                      parser.attribValue += c;
                    }
                    continue;
                  }
                  attrib(parser);
                  parser.q = "";
                  parser.state = S.ATTRIB_VALUE_CLOSED;
                  continue;
                case S.ATTRIB_VALUE_CLOSED:
                  if (isWhitespace(c)) {
                    parser.state = S.ATTRIB;
                  } else if (c === ">") {
                    openTag(parser);
                  } else if (c === "/") {
                    parser.state = S.OPEN_TAG_SLASH;
                  } else if (isMatch(nameStart, c)) {
                    strictFail(parser, "No whitespace between attributes");
                    parser.attribName = c;
                    parser.attribValue = "";
                    parser.state = S.ATTRIB_NAME;
                  } else {
                    strictFail(parser, "Invalid attribute name");
                  }
                  continue;
                case S.ATTRIB_VALUE_UNQUOTED:
                  if (!isAttribEnd(c)) {
                    if (c === "&") {
                      parser.state = S.ATTRIB_VALUE_ENTITY_U;
                    } else {
                      parser.attribValue += c;
                    }
                    continue;
                  }
                  attrib(parser);
                  if (c === ">") {
                    openTag(parser);
                  } else {
                    parser.state = S.ATTRIB;
                  }
                  continue;
                case S.CLOSE_TAG:
                  if (!parser.tagName) {
                    if (isWhitespace(c)) {
                      continue;
                    } else if (notMatch(nameStart, c)) {
                      if (parser.script) {
                        parser.script += "</" + c;
                        parser.state = S.SCRIPT;
                      } else {
                        strictFail(parser, "Invalid tagname in closing tag.");
                      }
                    } else {
                      parser.tagName = c;
                    }
                  } else if (c === ">") {
                    closeTag(parser);
                  } else if (isMatch(nameBody, c)) {
                    parser.tagName += c;
                  } else if (parser.script) {
                    parser.script += "</" + parser.tagName;
                    parser.tagName = "";
                    parser.state = S.SCRIPT;
                  } else {
                    if (!isWhitespace(c)) {
                      strictFail(parser, "Invalid tagname in closing tag");
                    }
                    parser.state = S.CLOSE_TAG_SAW_WHITE;
                  }
                  continue;
                case S.CLOSE_TAG_SAW_WHITE:
                  if (isWhitespace(c)) {
                    continue;
                  }
                  if (c === ">") {
                    closeTag(parser);
                  } else {
                    strictFail(parser, "Invalid characters in closing tag");
                  }
                  continue;
                case S.TEXT_ENTITY:
                case S.ATTRIB_VALUE_ENTITY_Q:
                case S.ATTRIB_VALUE_ENTITY_U:
                  var returnState;
                  var buffer22;
                  switch (parser.state) {
                    case S.TEXT_ENTITY:
                      returnState = S.TEXT;
                      buffer22 = "textNode";
                      break;
                    case S.ATTRIB_VALUE_ENTITY_Q:
                      returnState = S.ATTRIB_VALUE_QUOTED;
                      buffer22 = "attribValue";
                      break;
                    case S.ATTRIB_VALUE_ENTITY_U:
                      returnState = S.ATTRIB_VALUE_UNQUOTED;
                      buffer22 = "attribValue";
                      break;
                  }
                  if (c === ";") {
                    parser[buffer22] += parseEntity(parser);
                    parser.entity = "";
                    parser.state = returnState;
                  } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
                    parser.entity += c;
                  } else {
                    strictFail(parser, "Invalid character in entity name");
                    parser[buffer22] += "&" + parser.entity + c;
                    parser.entity = "";
                    parser.state = returnState;
                  }
                  continue;
                default:
                  throw new Error(parser, "Unknown state: " + parser.state);
              }
            }
            if (parser.position >= parser.bufferCheckPosition) {
              checkBufferLength(parser);
            }
            return parser;
          }
          if (!String.fromCodePoint) {
            (function() {
              var stringFromCharCode = String.fromCharCode;
              var floor22 = Math.floor;
              var fromCodePoint = function() {
                var MAX_SIZE = 16384;
                var codeUnits = [];
                var highSurrogate;
                var lowSurrogate;
                var index = -1;
                var length = arguments.length;
                if (!length) {
                  return "";
                }
                var result = "";
                while (++index < length) {
                  var codePoint = Number(arguments[index]);
                  if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
                  codePoint < 0 || // not a valid Unicode code point
                  codePoint > 1114111 || // not a valid Unicode code point
                  floor22(codePoint) !== codePoint) {
                    throw RangeError("Invalid code point: " + codePoint);
                  }
                  if (codePoint <= 65535) {
                    codeUnits.push(codePoint);
                  } else {
                    codePoint -= 65536;
                    highSurrogate = (codePoint >> 10) + 55296;
                    lowSurrogate = codePoint % 1024 + 56320;
                    codeUnits.push(highSurrogate, lowSurrogate);
                  }
                  if (index + 1 === length || codeUnits.length > MAX_SIZE) {
                    result += stringFromCharCode.apply(null, codeUnits);
                    codeUnits.length = 0;
                  }
                }
                return result;
              };
              if (Object.defineProperty) {
                Object.defineProperty(String, "fromCodePoint", {
                  value: fromCodePoint,
                  configurable: true,
                  writable: true
                });
              } else {
                String.fromCodePoint = fromCodePoint;
              }
            })();
          }
        })(exports22);
      })(sax2);
      return sax2;
    }
    var arrayHelper2;
    var hasRequiredArrayHelper2;
    function requireArrayHelper2() {
      if (hasRequiredArrayHelper2) return arrayHelper2;
      hasRequiredArrayHelper2 = 1;
      arrayHelper2 = {
        isArray: function(value) {
          if (Array.isArray) {
            return Array.isArray(value);
          }
          return Object.prototype.toString.call(value) === "[object Array]";
        }
      };
      return arrayHelper2;
    }
    var optionsHelper2;
    var hasRequiredOptionsHelper2;
    function requireOptionsHelper2() {
      if (hasRequiredOptionsHelper2) return optionsHelper2;
      hasRequiredOptionsHelper2 = 1;
      var isArray = requireArrayHelper2().isArray;
      optionsHelper2 = {
        copyOptions: function(options) {
          var key, copy = {};
          for (key in options) {
            if (options.hasOwnProperty(key)) {
              copy[key] = options[key];
            }
          }
          return copy;
        },
        ensureFlagExists: function(item, options) {
          if (!(item in options) || typeof options[item] !== "boolean") {
            options[item] = false;
          }
        },
        ensureSpacesExists: function(options) {
          if (!("spaces" in options) || typeof options.spaces !== "number" && typeof options.spaces !== "string") {
            options.spaces = 0;
          }
        },
        ensureAlwaysArrayExists: function(options) {
          if (!("alwaysArray" in options) || typeof options.alwaysArray !== "boolean" && !isArray(options.alwaysArray)) {
            options.alwaysArray = false;
          }
        },
        ensureKeyExists: function(key, options) {
          if (!(key + "Key" in options) || typeof options[key + "Key"] !== "string") {
            options[key + "Key"] = options.compact ? "_" + key : key;
          }
        },
        checkFnExists: function(key, options) {
          return key + "Fn" in options;
        }
      };
      return optionsHelper2;
    }
    var xml2js2;
    var hasRequiredXml2js2;
    function requireXml2js2() {
      if (hasRequiredXml2js2) return xml2js2;
      hasRequiredXml2js2 = 1;
      var sax22 = requireSax2();
      var helper = requireOptionsHelper2();
      var isArray = requireArrayHelper2().isArray;
      var options;
      var currentElement;
      function validateOptions(userOptions) {
        options = helper.copyOptions(userOptions);
        helper.ensureFlagExists("ignoreDeclaration", options);
        helper.ensureFlagExists("ignoreInstruction", options);
        helper.ensureFlagExists("ignoreAttributes", options);
        helper.ensureFlagExists("ignoreText", options);
        helper.ensureFlagExists("ignoreComment", options);
        helper.ensureFlagExists("ignoreCdata", options);
        helper.ensureFlagExists("ignoreDoctype", options);
        helper.ensureFlagExists("compact", options);
        helper.ensureFlagExists("alwaysChildren", options);
        helper.ensureFlagExists("addParent", options);
        helper.ensureFlagExists("trim", options);
        helper.ensureFlagExists("nativeType", options);
        helper.ensureFlagExists("nativeTypeAttributes", options);
        helper.ensureFlagExists("sanitize", options);
        helper.ensureFlagExists("instructionHasAttributes", options);
        helper.ensureFlagExists("captureSpacesBetweenElements", options);
        helper.ensureAlwaysArrayExists(options);
        helper.ensureKeyExists("declaration", options);
        helper.ensureKeyExists("instruction", options);
        helper.ensureKeyExists("attributes", options);
        helper.ensureKeyExists("text", options);
        helper.ensureKeyExists("comment", options);
        helper.ensureKeyExists("cdata", options);
        helper.ensureKeyExists("doctype", options);
        helper.ensureKeyExists("type", options);
        helper.ensureKeyExists("name", options);
        helper.ensureKeyExists("elements", options);
        helper.ensureKeyExists("parent", options);
        helper.checkFnExists("doctype", options);
        helper.checkFnExists("instruction", options);
        helper.checkFnExists("cdata", options);
        helper.checkFnExists("comment", options);
        helper.checkFnExists("text", options);
        helper.checkFnExists("instructionName", options);
        helper.checkFnExists("elementName", options);
        helper.checkFnExists("attributeName", options);
        helper.checkFnExists("attributeValue", options);
        helper.checkFnExists("attributes", options);
        return options;
      }
      function nativeType(value) {
        var nValue = Number(value);
        if (!isNaN(nValue)) {
          return nValue;
        }
        var bValue = value.toLowerCase();
        if (bValue === "true") {
          return true;
        } else if (bValue === "false") {
          return false;
        }
        return value;
      }
      function addField(type22, value) {
        var key;
        if (options.compact) {
          if (!currentElement[options[type22 + "Key"]] && (isArray(options.alwaysArray) ? options.alwaysArray.indexOf(options[type22 + "Key"]) !== -1 : options.alwaysArray)) {
            currentElement[options[type22 + "Key"]] = [];
          }
          if (currentElement[options[type22 + "Key"]] && !isArray(currentElement[options[type22 + "Key"]])) {
            currentElement[options[type22 + "Key"]] = [currentElement[options[type22 + "Key"]]];
          }
          if (type22 + "Fn" in options && typeof value === "string") {
            value = options[type22 + "Fn"](value, currentElement);
          }
          if (type22 === "instruction" && ("instructionFn" in options || "instructionNameFn" in options)) {
            for (key in value) {
              if (value.hasOwnProperty(key)) {
                if ("instructionFn" in options) {
                  value[key] = options.instructionFn(value[key], key, currentElement);
                } else {
                  var temp = value[key];
                  delete value[key];
                  value[options.instructionNameFn(key, temp, currentElement)] = temp;
                }
              }
            }
          }
          if (isArray(currentElement[options[type22 + "Key"]])) {
            currentElement[options[type22 + "Key"]].push(value);
          } else {
            currentElement[options[type22 + "Key"]] = value;
          }
        } else {
          if (!currentElement[options.elementsKey]) {
            currentElement[options.elementsKey] = [];
          }
          var element = {};
          element[options.typeKey] = type22;
          if (type22 === "instruction") {
            for (key in value) {
              if (value.hasOwnProperty(key)) {
                break;
              }
            }
            element[options.nameKey] = "instructionNameFn" in options ? options.instructionNameFn(key, value, currentElement) : key;
            if (options.instructionHasAttributes) {
              element[options.attributesKey] = value[key][options.attributesKey];
              if ("instructionFn" in options) {
                element[options.attributesKey] = options.instructionFn(element[options.attributesKey], key, currentElement);
              }
            } else {
              if ("instructionFn" in options) {
                value[key] = options.instructionFn(value[key], key, currentElement);
              }
              element[options.instructionKey] = value[key];
            }
          } else {
            if (type22 + "Fn" in options) {
              value = options[type22 + "Fn"](value, currentElement);
            }
            element[options[type22 + "Key"]] = value;
          }
          if (options.addParent) {
            element[options.parentKey] = currentElement;
          }
          currentElement[options.elementsKey].push(element);
        }
      }
      function manipulateAttributes(attributes) {
        if ("attributesFn" in options && attributes) {
          attributes = options.attributesFn(attributes, currentElement);
        }
        if ((options.trim || "attributeValueFn" in options || "attributeNameFn" in options || options.nativeTypeAttributes) && attributes) {
          var key;
          for (key in attributes) {
            if (attributes.hasOwnProperty(key)) {
              if (options.trim) attributes[key] = attributes[key].trim();
              if (options.nativeTypeAttributes) {
                attributes[key] = nativeType(attributes[key]);
              }
              if ("attributeValueFn" in options) attributes[key] = options.attributeValueFn(attributes[key], key, currentElement);
              if ("attributeNameFn" in options) {
                var temp = attributes[key];
                delete attributes[key];
                attributes[options.attributeNameFn(key, attributes[key], currentElement)] = temp;
              }
            }
          }
        }
        return attributes;
      }
      function onInstruction(instruction) {
        var attributes = {};
        if (instruction.body && (instruction.name.toLowerCase() === "xml" || options.instructionHasAttributes)) {
          var attrsRegExp = /([\w:-]+)\s*=\s*(?:"([^"]*)"|'([^']*)'|(\w+))\s*/g;
          var match;
          while ((match = attrsRegExp.exec(instruction.body)) !== null) {
            attributes[match[1]] = match[2] || match[3] || match[4];
          }
          attributes = manipulateAttributes(attributes);
        }
        if (instruction.name.toLowerCase() === "xml") {
          if (options.ignoreDeclaration) {
            return;
          }
          currentElement[options.declarationKey] = {};
          if (Object.keys(attributes).length) {
            currentElement[options.declarationKey][options.attributesKey] = attributes;
          }
          if (options.addParent) {
            currentElement[options.declarationKey][options.parentKey] = currentElement;
          }
        } else {
          if (options.ignoreInstruction) {
            return;
          }
          if (options.trim) {
            instruction.body = instruction.body.trim();
          }
          var value = {};
          if (options.instructionHasAttributes && Object.keys(attributes).length) {
            value[instruction.name] = {};
            value[instruction.name][options.attributesKey] = attributes;
          } else {
            value[instruction.name] = instruction.body;
          }
          addField("instruction", value);
        }
      }
      function onStartElement(name, attributes) {
        var element;
        if (typeof name === "object") {
          attributes = name.attributes;
          name = name.name;
        }
        attributes = manipulateAttributes(attributes);
        if ("elementNameFn" in options) {
          name = options.elementNameFn(name, currentElement);
        }
        if (options.compact) {
          element = {};
          if (!options.ignoreAttributes && attributes && Object.keys(attributes).length) {
            element[options.attributesKey] = {};
            var key;
            for (key in attributes) {
              if (attributes.hasOwnProperty(key)) {
                element[options.attributesKey][key] = attributes[key];
              }
            }
          }
          if (!(name in currentElement) && (isArray(options.alwaysArray) ? options.alwaysArray.indexOf(name) !== -1 : options.alwaysArray)) {
            currentElement[name] = [];
          }
          if (currentElement[name] && !isArray(currentElement[name])) {
            currentElement[name] = [currentElement[name]];
          }
          if (isArray(currentElement[name])) {
            currentElement[name].push(element);
          } else {
            currentElement[name] = element;
          }
        } else {
          if (!currentElement[options.elementsKey]) {
            currentElement[options.elementsKey] = [];
          }
          element = {};
          element[options.typeKey] = "element";
          element[options.nameKey] = name;
          if (!options.ignoreAttributes && attributes && Object.keys(attributes).length) {
            element[options.attributesKey] = attributes;
          }
          if (options.alwaysChildren) {
            element[options.elementsKey] = [];
          }
          currentElement[options.elementsKey].push(element);
        }
        element[options.parentKey] = currentElement;
        currentElement = element;
      }
      function onText(text) {
        if (options.ignoreText) {
          return;
        }
        if (!text.trim() && !options.captureSpacesBetweenElements) {
          return;
        }
        if (options.trim) {
          text = text.trim();
        }
        if (options.nativeType) {
          text = nativeType(text);
        }
        if (options.sanitize) {
          text = text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
        }
        addField("text", text);
      }
      function onComment(comment) {
        if (options.ignoreComment) {
          return;
        }
        if (options.trim) {
          comment = comment.trim();
        }
        addField("comment", comment);
      }
      function onEndElement(name) {
        var parentElement = currentElement[options.parentKey];
        if (!options.addParent) {
          delete currentElement[options.parentKey];
        }
        currentElement = parentElement;
      }
      function onCdata(cdata) {
        if (options.ignoreCdata) {
          return;
        }
        if (options.trim) {
          cdata = cdata.trim();
        }
        addField("cdata", cdata);
      }
      function onDoctype(doctype) {
        if (options.ignoreDoctype) {
          return;
        }
        doctype = doctype.replace(/^ /, "");
        if (options.trim) {
          doctype = doctype.trim();
        }
        addField("doctype", doctype);
      }
      function onError(error) {
        error.note = error;
      }
      xml2js2 = function(xml22, userOptions) {
        var parser = sax22.parser(true, {});
        var result = {};
        currentElement = result;
        options = validateOptions(userOptions);
        {
          parser.opt = { strictEntities: true };
          parser.onopentag = onStartElement;
          parser.ontext = onText;
          parser.oncomment = onComment;
          parser.onclosetag = onEndElement;
          parser.onerror = onError;
          parser.oncdata = onCdata;
          parser.ondoctype = onDoctype;
          parser.onprocessinginstruction = onInstruction;
        }
        {
          parser.write(xml22).close();
        }
        if (result[options.elementsKey]) {
          var temp = result[options.elementsKey];
          delete result[options.elementsKey];
          result[options.elementsKey] = temp;
          delete result.text;
        }
        return result;
      };
      return xml2js2;
    }
    var xml2json2;
    var hasRequiredXml2json2;
    function requireXml2json2() {
      if (hasRequiredXml2json2) return xml2json2;
      hasRequiredXml2json2 = 1;
      var helper = requireOptionsHelper2();
      var xml2js22 = requireXml2js2();
      function validateOptions(userOptions) {
        var options = helper.copyOptions(userOptions);
        helper.ensureSpacesExists(options);
        return options;
      }
      xml2json2 = function(xml22, userOptions) {
        var options, js, json, parentKey;
        options = validateOptions(userOptions);
        js = xml2js22(xml22, options);
        parentKey = "compact" in options && options.compact ? "_parent" : "parent";
        if ("addParent" in options && options.addParent) {
          json = JSON.stringify(js, function(k, v) {
            return k === parentKey ? "_" : v;
          }, options.spaces);
        } else {
          json = JSON.stringify(js, null, options.spaces);
        }
        return json.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
      };
      return xml2json2;
    }
    var js2xml2;
    var hasRequiredJs2xml2;
    function requireJs2xml2() {
      if (hasRequiredJs2xml2) return js2xml2;
      hasRequiredJs2xml2 = 1;
      var helper = requireOptionsHelper2();
      var isArray = requireArrayHelper2().isArray;
      var currentElement, currentElementName;
      function validateOptions(userOptions) {
        var options = helper.copyOptions(userOptions);
        helper.ensureFlagExists("ignoreDeclaration", options);
        helper.ensureFlagExists("ignoreInstruction", options);
        helper.ensureFlagExists("ignoreAttributes", options);
        helper.ensureFlagExists("ignoreText", options);
        helper.ensureFlagExists("ignoreComment", options);
        helper.ensureFlagExists("ignoreCdata", options);
        helper.ensureFlagExists("ignoreDoctype", options);
        helper.ensureFlagExists("compact", options);
        helper.ensureFlagExists("indentText", options);
        helper.ensureFlagExists("indentCdata", options);
        helper.ensureFlagExists("indentAttributes", options);
        helper.ensureFlagExists("indentInstruction", options);
        helper.ensureFlagExists("fullTagEmptyElement", options);
        helper.ensureFlagExists("noQuotesForNativeAttributes", options);
        helper.ensureSpacesExists(options);
        if (typeof options.spaces === "number") {
          options.spaces = Array(options.spaces + 1).join(" ");
        }
        helper.ensureKeyExists("declaration", options);
        helper.ensureKeyExists("instruction", options);
        helper.ensureKeyExists("attributes", options);
        helper.ensureKeyExists("text", options);
        helper.ensureKeyExists("comment", options);
        helper.ensureKeyExists("cdata", options);
        helper.ensureKeyExists("doctype", options);
        helper.ensureKeyExists("type", options);
        helper.ensureKeyExists("name", options);
        helper.ensureKeyExists("elements", options);
        helper.checkFnExists("doctype", options);
        helper.checkFnExists("instruction", options);
        helper.checkFnExists("cdata", options);
        helper.checkFnExists("comment", options);
        helper.checkFnExists("text", options);
        helper.checkFnExists("instructionName", options);
        helper.checkFnExists("elementName", options);
        helper.checkFnExists("attributeName", options);
        helper.checkFnExists("attributeValue", options);
        helper.checkFnExists("attributes", options);
        helper.checkFnExists("fullTagEmptyElement", options);
        return options;
      }
      function writeIndentation(options, depth, firstLine) {
        return (!firstLine && options.spaces ? "\n" : "") + Array(depth + 1).join(options.spaces);
      }
      function writeAttributes(attributes, options, depth) {
        if (options.ignoreAttributes) {
          return "";
        }
        if ("attributesFn" in options) {
          attributes = options.attributesFn(attributes, currentElementName, currentElement);
        }
        var key, attr, attrName, quote, result = [];
        for (key in attributes) {
          if (attributes.hasOwnProperty(key) && attributes[key] !== null && attributes[key] !== void 0) {
            quote = options.noQuotesForNativeAttributes && typeof attributes[key] !== "string" ? "" : '"';
            attr = "" + attributes[key];
            attr = attr.replace(/"/g, "&quot;");
            attrName = "attributeNameFn" in options ? options.attributeNameFn(key, attr, currentElementName, currentElement) : key;
            result.push(options.spaces && options.indentAttributes ? writeIndentation(options, depth + 1, false) : " ");
            result.push(attrName + "=" + quote + ("attributeValueFn" in options ? options.attributeValueFn(attr, key, currentElementName, currentElement) : attr) + quote);
          }
        }
        if (attributes && Object.keys(attributes).length && options.spaces && options.indentAttributes) {
          result.push(writeIndentation(options, depth, false));
        }
        return result.join("");
      }
      function writeDeclaration(declaration, options, depth) {
        currentElement = declaration;
        currentElementName = "xml";
        return options.ignoreDeclaration ? "" : "<?xml" + writeAttributes(declaration[options.attributesKey], options, depth) + "?>";
      }
      function writeInstruction(instruction, options, depth) {
        if (options.ignoreInstruction) {
          return "";
        }
        var key;
        for (key in instruction) {
          if (instruction.hasOwnProperty(key)) {
            break;
          }
        }
        var instructionName = "instructionNameFn" in options ? options.instructionNameFn(key, instruction[key], currentElementName, currentElement) : key;
        if (typeof instruction[key] === "object") {
          currentElement = instruction;
          currentElementName = instructionName;
          return "<?" + instructionName + writeAttributes(instruction[key][options.attributesKey], options, depth) + "?>";
        } else {
          var instructionValue = instruction[key] ? instruction[key] : "";
          if ("instructionFn" in options) instructionValue = options.instructionFn(instructionValue, key, currentElementName, currentElement);
          return "<?" + instructionName + (instructionValue ? " " + instructionValue : "") + "?>";
        }
      }
      function writeComment(comment, options) {
        return options.ignoreComment ? "" : "<!--" + ("commentFn" in options ? options.commentFn(comment, currentElementName, currentElement) : comment) + "-->";
      }
      function writeCdata(cdata, options) {
        return options.ignoreCdata ? "" : "<![CDATA[" + ("cdataFn" in options ? options.cdataFn(cdata, currentElementName, currentElement) : cdata.replace("]]>", "]]]]><![CDATA[>")) + "]]>";
      }
      function writeDoctype(doctype, options) {
        return options.ignoreDoctype ? "" : "<!DOCTYPE " + ("doctypeFn" in options ? options.doctypeFn(doctype, currentElementName, currentElement) : doctype) + ">";
      }
      function writeText(text, options) {
        if (options.ignoreText) return "";
        text = "" + text;
        text = text.replace(/&amp;/g, "&");
        text = text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
        return "textFn" in options ? options.textFn(text, currentElementName, currentElement) : text;
      }
      function hasContent(element, options) {
        var i;
        if (element.elements && element.elements.length) {
          for (i = 0; i < element.elements.length; ++i) {
            switch (element.elements[i][options.typeKey]) {
              case "text":
                if (options.indentText) {
                  return true;
                }
                break;
              // skip to next key
              case "cdata":
                if (options.indentCdata) {
                  return true;
                }
                break;
              // skip to next key
              case "instruction":
                if (options.indentInstruction) {
                  return true;
                }
                break;
              // skip to next key
              case "doctype":
              case "comment":
              case "element":
                return true;
              default:
                return true;
            }
          }
        }
        return false;
      }
      function writeElement(element, options, depth) {
        currentElement = element;
        currentElementName = element.name;
        var xml22 = [], elementName = "elementNameFn" in options ? options.elementNameFn(element.name, element) : element.name;
        xml22.push("<" + elementName);
        if (element[options.attributesKey]) {
          xml22.push(writeAttributes(element[options.attributesKey], options, depth));
        }
        var withClosingTag = element[options.elementsKey] && element[options.elementsKey].length || element[options.attributesKey] && element[options.attributesKey]["xml:space"] === "preserve";
        if (!withClosingTag) {
          if ("fullTagEmptyElementFn" in options) {
            withClosingTag = options.fullTagEmptyElementFn(element.name, element);
          } else {
            withClosingTag = options.fullTagEmptyElement;
          }
        }
        if (withClosingTag) {
          xml22.push(">");
          if (element[options.elementsKey] && element[options.elementsKey].length) {
            xml22.push(writeElements(element[options.elementsKey], options, depth + 1));
            currentElement = element;
            currentElementName = element.name;
          }
          xml22.push(options.spaces && hasContent(element, options) ? "\n" + Array(depth + 1).join(options.spaces) : "");
          xml22.push("</" + elementName + ">");
        } else {
          xml22.push("/>");
        }
        return xml22.join("");
      }
      function writeElements(elements, options, depth, firstLine) {
        return elements.reduce(function(xml22, element) {
          var indent = writeIndentation(options, depth, firstLine && !xml22);
          switch (element.type) {
            case "element":
              return xml22 + indent + writeElement(element, options, depth);
            case "comment":
              return xml22 + indent + writeComment(element[options.commentKey], options);
            case "doctype":
              return xml22 + indent + writeDoctype(element[options.doctypeKey], options);
            case "cdata":
              return xml22 + (options.indentCdata ? indent : "") + writeCdata(element[options.cdataKey], options);
            case "text":
              return xml22 + (options.indentText ? indent : "") + writeText(element[options.textKey], options);
            case "instruction":
              var instruction = {};
              instruction[element[options.nameKey]] = element[options.attributesKey] ? element : element[options.instructionKey];
              return xml22 + (options.indentInstruction ? indent : "") + writeInstruction(instruction, options, depth);
          }
        }, "");
      }
      function hasContentCompact(element, options, anyContent) {
        var key;
        for (key in element) {
          if (element.hasOwnProperty(key)) {
            switch (key) {
              case options.parentKey:
              case options.attributesKey:
                break;
              // skip to next key
              case options.textKey:
                if (options.indentText || anyContent) {
                  return true;
                }
                break;
              // skip to next key
              case options.cdataKey:
                if (options.indentCdata || anyContent) {
                  return true;
                }
                break;
              // skip to next key
              case options.instructionKey:
                if (options.indentInstruction || anyContent) {
                  return true;
                }
                break;
              // skip to next key
              case options.doctypeKey:
              case options.commentKey:
                return true;
              default:
                return true;
            }
          }
        }
        return false;
      }
      function writeElementCompact(element, name, options, depth, indent) {
        currentElement = element;
        currentElementName = name;
        var elementName = "elementNameFn" in options ? options.elementNameFn(name, element) : name;
        if (typeof element === "undefined" || element === null || element === "") {
          return "fullTagEmptyElementFn" in options && options.fullTagEmptyElementFn(name, element) || options.fullTagEmptyElement ? "<" + elementName + "></" + elementName + ">" : "<" + elementName + "/>";
        }
        var xml22 = [];
        if (name) {
          xml22.push("<" + elementName);
          if (typeof element !== "object") {
            xml22.push(">" + writeText(element, options) + "</" + elementName + ">");
            return xml22.join("");
          }
          if (element[options.attributesKey]) {
            xml22.push(writeAttributes(element[options.attributesKey], options, depth));
          }
          var withClosingTag = hasContentCompact(element, options, true) || element[options.attributesKey] && element[options.attributesKey]["xml:space"] === "preserve";
          if (!withClosingTag) {
            if ("fullTagEmptyElementFn" in options) {
              withClosingTag = options.fullTagEmptyElementFn(name, element);
            } else {
              withClosingTag = options.fullTagEmptyElement;
            }
          }
          if (withClosingTag) {
            xml22.push(">");
          } else {
            xml22.push("/>");
            return xml22.join("");
          }
        }
        xml22.push(writeElementsCompact(element, options, depth + 1, false));
        currentElement = element;
        currentElementName = name;
        if (name) {
          xml22.push((indent ? writeIndentation(options, depth, false) : "") + "</" + elementName + ">");
        }
        return xml22.join("");
      }
      function writeElementsCompact(element, options, depth, firstLine) {
        var i, key, nodes, xml22 = [];
        for (key in element) {
          if (element.hasOwnProperty(key)) {
            nodes = isArray(element[key]) ? element[key] : [element[key]];
            for (i = 0; i < nodes.length; ++i) {
              switch (key) {
                case options.declarationKey:
                  xml22.push(writeDeclaration(nodes[i], options, depth));
                  break;
                case options.instructionKey:
                  xml22.push((options.indentInstruction ? writeIndentation(options, depth, firstLine) : "") + writeInstruction(nodes[i], options, depth));
                  break;
                case options.attributesKey:
                case options.parentKey:
                  break;
                // skip
                case options.textKey:
                  xml22.push((options.indentText ? writeIndentation(options, depth, firstLine) : "") + writeText(nodes[i], options));
                  break;
                case options.cdataKey:
                  xml22.push((options.indentCdata ? writeIndentation(options, depth, firstLine) : "") + writeCdata(nodes[i], options));
                  break;
                case options.doctypeKey:
                  xml22.push(writeIndentation(options, depth, firstLine) + writeDoctype(nodes[i], options));
                  break;
                case options.commentKey:
                  xml22.push(writeIndentation(options, depth, firstLine) + writeComment(nodes[i], options));
                  break;
                default:
                  xml22.push(writeIndentation(options, depth, firstLine) + writeElementCompact(nodes[i], key, options, depth, hasContentCompact(nodes[i], options)));
              }
              firstLine = firstLine && !xml22.length;
            }
          }
        }
        return xml22.join("");
      }
      js2xml2 = function(js, options) {
        options = validateOptions(options);
        var xml22 = [];
        currentElement = js;
        currentElementName = "_root_";
        if (options.compact) {
          xml22.push(writeElementsCompact(js, options, 0, true));
        } else {
          if (js[options.declarationKey]) {
            xml22.push(writeDeclaration(js[options.declarationKey], options, 0));
          }
          if (js[options.elementsKey] && js[options.elementsKey].length) {
            xml22.push(writeElements(js[options.elementsKey], options, 0, !xml22.length));
          }
        }
        return xml22.join("");
      };
      return js2xml2;
    }
    var json2xml2;
    var hasRequiredJson2xml2;
    function requireJson2xml2() {
      if (hasRequiredJson2xml2) return json2xml2;
      hasRequiredJson2xml2 = 1;
      var js2xml22 = requireJs2xml2();
      json2xml2 = function(json, options) {
        if (json instanceof Buffer) {
          json = json.toString();
        }
        var js = null;
        if (typeof json === "string") {
          try {
            js = JSON.parse(json);
          } catch (e) {
            throw new Error("The JSON structure is invalid");
          }
        } else {
          js = json;
        }
        return js2xml22(js, options);
      };
      return json2xml2;
    }
    var lib2;
    var hasRequiredLib2;
    function requireLib2() {
      if (hasRequiredLib2) return lib2;
      hasRequiredLib2 = 1;
      var xml2js22 = requireXml2js2();
      var xml2json22 = requireXml2json2();
      var js2xml22 = requireJs2xml2();
      var json2xml22 = requireJson2xml2();
      lib2 = {
        xml2js: xml2js22,
        xml2json: xml2json22,
        js2xml: js2xml22,
        json2xml: json2xml22
      };
      return lib2;
    }
    var libExports2 = requireLib2();
    var convertToXmlComponent2 = (element) => {
      switch (element.type) {
        case void 0:
        case "element":
          const xmlComponent = new ImportedXmlComponent2(element.name, element.attributes);
          const childElements = element.elements || [];
          for (const childElm of childElements) {
            const child = convertToXmlComponent2(childElm);
            if (child !== void 0) {
              xmlComponent.push(child);
            }
          }
          return xmlComponent;
        case "text":
          return element.text;
        default:
          return void 0;
      }
    };
    var ImportedXmlComponentAttributes2 = class extends XmlAttributeComponent2 {
      // noop
    };
    var ImportedXmlComponent2 = class extends XmlComponent2 {
      /**
       * Converts the xml string to a XmlComponent tree.
       *
       * @param importedContent xml content of the imported component
       */
      static fromXmlString(importedContent) {
        const xmlObj = libExports2.xml2js(importedContent, { compact: false });
        return convertToXmlComponent2(xmlObj);
      }
      /**
       * Converts the xml string to a XmlComponent tree.
       *
       * @param importedContent xml content of the imported component
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      constructor(rootKey, _attr) {
        super(rootKey);
        if (_attr) {
          this.root.push(new ImportedXmlComponentAttributes2(_attr));
        }
      }
      push(xmlComponent) {
        this.root.push(xmlComponent);
      }
    };
    var ImportedRootElementAttributes2 = class extends XmlComponent2 {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      constructor(_attr) {
        super("");
        this._attr = _attr;
      }
      prepForXml(_) {
        return {
          _attr: this._attr
        };
      }
    };
    var WORKAROUND3 = "";
    var InitializableXmlComponent2 = class extends XmlComponent2 {
      constructor(rootKey, initComponent) {
        super(rootKey);
        if (initComponent) {
          this.root = initComponent.root;
        }
      }
    };
    var decimalNumber2 = (val) => {
      if (isNaN(val)) {
        throw new Error(`Invalid value '${val}' specified. Must be an integer.`);
      }
      return Math.floor(val);
    };
    var unsignedDecimalNumber2 = (val) => {
      const value = decimalNumber2(val);
      if (value < 0) {
        throw new Error(`Invalid value '${val}' specified. Must be a positive integer.`);
      }
      return value;
    };
    var hexBinary2 = (val, length) => {
      const expectedLength = length * 2;
      if (val.length !== expectedLength || isNaN(Number(`0x${val}`))) {
        throw new Error(`Invalid hex value '${val}'. Expected ${expectedLength} digit hex value`);
      }
      return val;
    };
    var longHexNumber = (val) => hexBinary2(val, 4);
    var shortHexNumber = (val) => hexBinary2(val, 2);
    var uCharHexNumber2 = (val) => hexBinary2(val, 1);
    var universalMeasureValue2 = (val) => {
      const unit = val.slice(-2);
      const amount = val.substring(0, val.length - 2);
      return `${Number(amount)}${unit}`;
    };
    var positiveUniversalMeasureValue2 = (val) => {
      const value = universalMeasureValue2(val);
      if (parseFloat(value) < 0) {
        throw new Error(`Invalid value '${value}' specified. Expected a positive number.`);
      }
      return value;
    };
    var hexColorValue2 = (val) => {
      if (val === "auto") {
        return val;
      }
      const color = val.charAt(0) === "#" ? val.substring(1) : val;
      return hexBinary2(color, 3);
    };
    var signedTwipsMeasureValue2 = (val) => typeof val === "string" ? universalMeasureValue2(val) : decimalNumber2(val);
    var hpsMeasureValue2 = (val) => typeof val === "string" ? positiveUniversalMeasureValue2(val) : unsignedDecimalNumber2(val);
    var signedHpsMeasureValue = (val) => typeof val === "string" ? universalMeasureValue2(val) : decimalNumber2(val);
    var twipsMeasureValue2 = (val) => typeof val === "string" ? positiveUniversalMeasureValue2(val) : unsignedDecimalNumber2(val);
    var percentageValue2 = (val) => {
      const percent = val.substring(0, val.length - 1);
      return `${Number(percent)}%`;
    };
    var measurementOrPercentValue2 = (val) => {
      if (typeof val === "number") {
        return decimalNumber2(val);
      }
      if (val.slice(-1) === "%") {
        return percentageValue2(val);
      }
      return universalMeasureValue2(val);
    };
    var eighthPointMeasureValue2 = unsignedDecimalNumber2;
    var pointMeasureValue2 = unsignedDecimalNumber2;
    var dateTimeValue2 = (val) => val.toISOString();
    var OnOffElement2 = class extends XmlComponent2 {
      constructor(name, val = true) {
        super(name);
        if (val !== true) {
          this.root.push(new Attributes2({ val }));
        }
      }
    };
    var HpsMeasureElement2 = class extends XmlComponent2 {
      constructor(name, val) {
        super(name);
        this.root.push(new Attributes2({ val: hpsMeasureValue2(val) }));
      }
    };
    var EmptyElement = class extends XmlComponent2 {
    };
    var StringValueElement2 = class extends XmlComponent2 {
      constructor(name, val) {
        super(name);
        this.root.push(new Attributes2({ val }));
      }
    };
    var createStringElement2 = (name, value) => new BuilderElement2({
      name,
      attributes: {
        value: { key: "w:val", value }
      }
    });
    var NumberValueElement2 = class extends XmlComponent2 {
      constructor(name, val) {
        super(name);
        this.root.push(new Attributes2({ val }));
      }
    };
    var StringEnumValueElement2 = class extends XmlComponent2 {
      constructor(name, val) {
        super(name);
        this.root.push(new Attributes2({ val }));
      }
    };
    var StringContainer2 = class extends XmlComponent2 {
      constructor(name, val) {
        super(name);
        this.root.push(val);
      }
    };
    var BuilderElement2 = class extends XmlComponent2 {
      constructor({
        name,
        attributes,
        children
      }) {
        super(name);
        if (attributes) {
          this.root.push(new NextAttributeComponent2(attributes));
        }
        if (children) {
          this.root.push(...children);
        }
      }
    };
    var AlignmentType2 = {
      /** Align Start */
      START: "start",
      /** Align Center */
      CENTER: "center",
      /** End */
      END: "end",
      /** Justified */
      BOTH: "both",
      /** Medium Kashida Length */
      MEDIUM_KASHIDA: "mediumKashida",
      /** Distribute All Characters Equally */
      DISTRIBUTE: "distribute",
      /** Align to List Tab */
      NUM_TAB: "numTab",
      /** Widest Kashida Length */
      HIGH_KASHIDA: "highKashida",
      /** Low Kashida Length */
      LOW_KASHIDA: "lowKashida",
      /** Thai Language Justification */
      THAI_DISTRIBUTE: "thaiDistribute",
      /** Align Left */
      LEFT: "left",
      /** Align Right */
      RIGHT: "right",
      /** Justified */
      JUSTIFIED: "both"
    };
    var AlignmentAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", { val: "w:val" });
      }
    };
    var Alignment2 = class extends XmlComponent2 {
      constructor(type22) {
        super("w:jc");
        this.root.push(new AlignmentAttributes2({ val: type22 }));
      }
    };
    var BorderElement2 = class extends XmlComponent2 {
      constructor(elementName, { color, size, space, style }) {
        super(elementName);
        this.root.push(
          new BordersAttributes2({
            style,
            color: color === void 0 ? void 0 : hexColorValue2(color),
            size: size === void 0 ? void 0 : eighthPointMeasureValue2(size),
            space: space === void 0 ? void 0 : pointMeasureValue2(space)
          })
        );
      }
    };
    var BordersAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", {
          style: "w:val",
          color: "w:color",
          size: "w:sz",
          space: "w:space"
        });
      }
    };
    var BorderStyle2 = {
      /** a single line */
      SINGLE: "single",
      /** a line with a series of alternating thin and thick strokes */
      DASH_DOT_STROKED: "dashDotStroked",
      /** a dashed line */
      DASHED: "dashed",
      /** a dashed line with small gaps */
      DASH_SMALL_GAP: "dashSmallGap",
      /** a line with alternating dots and dashes */
      DOT_DASH: "dotDash",
      /** a line with a repeating dot - dot - dash sequence */
      DOT_DOT_DASH: "dotDotDash",
      /** a dotted line */
      DOTTED: "dotted",
      /** a double line */
      DOUBLE: "double",
      /** a double wavy line */
      DOUBLE_WAVE: "doubleWave",
      /** an inset set of lines */
      INSET: "inset",
      /** no border */
      NIL: "nil",
      /** no border */
      NONE: "none",
      /** an outset set of lines */
      OUTSET: "outset",
      /** a single line */
      THICK: "thick",
      /** a thick line contained within a thin line with a large-sized intermediate gap */
      THICK_THIN_LARGE_GAP: "thickThinLargeGap",
      /** a thick line contained within a thin line with a medium-sized intermediate gap */
      THICK_THIN_MEDIUM_GAP: "thickThinMediumGap",
      /** a thick line contained within a thin line with a small intermediate gap */
      THICK_THIN_SMALL_GAP: "thickThinSmallGap",
      /** a thin line contained within a thick line with a large-sized intermediate gap */
      THIN_THICK_LARGE_GAP: "thinThickLargeGap",
      /** a thick line contained within a thin line with a medium-sized intermediate gap */
      THIN_THICK_MEDIUM_GAP: "thinThickMediumGap",
      /** a thick line contained within a thin line with a small intermediate gap */
      THIN_THICK_SMALL_GAP: "thinThickSmallGap",
      /** a thin-thick-thin line with a large gap */
      THIN_THICK_THIN_LARGE_GAP: "thinThickThinLargeGap",
      /** a thin-thick-thin line with a medium gap */
      THIN_THICK_THIN_MEDIUM_GAP: "thinThickThinMediumGap",
      /** a thin-thick-thin line with a small gap */
      THIN_THICK_THIN_SMALL_GAP: "thinThickThinSmallGap",
      /** a three-staged gradient line, getting darker towards the paragraph */
      THREE_D_EMBOSS: "threeDEmboss",
      /** a three-staged gradient like, getting darker away from the paragraph */
      THREE_D_ENGRAVE: "threeDEngrave",
      /** a triple line */
      TRIPLE: "triple",
      /** a wavy line */
      WAVE: "wave"
    };
    var Border2 = class extends IgnoreIfEmptyXmlComponent2 {
      constructor(options) {
        super("w:pBdr");
        if (options.top) {
          this.root.push(new BorderElement2("w:top", options.top));
        }
        if (options.bottom) {
          this.root.push(new BorderElement2("w:bottom", options.bottom));
        }
        if (options.left) {
          this.root.push(new BorderElement2("w:left", options.left));
        }
        if (options.right) {
          this.root.push(new BorderElement2("w:right", options.right));
        }
      }
    };
    var ThematicBreak2 = class extends XmlComponent2 {
      constructor() {
        super("w:pBdr");
        const bottom = new BorderElement2("w:bottom", {
          color: "auto",
          space: 1,
          style: BorderStyle2.SINGLE,
          size: 6
        });
        this.root.push(bottom);
      }
    };
    var Indent2 = class extends XmlComponent2 {
      constructor({ start, end, left, right, hanging, firstLine }) {
        super("w:ind");
        this.root.push(
          new NextAttributeComponent2({
            start: {
              key: "w:start",
              value: start === void 0 ? void 0 : signedTwipsMeasureValue2(start)
            },
            end: {
              key: "w:end",
              value: end === void 0 ? void 0 : signedTwipsMeasureValue2(end)
            },
            left: {
              key: "w:left",
              value: left === void 0 ? void 0 : signedTwipsMeasureValue2(left)
            },
            right: {
              key: "w:right",
              value: right === void 0 ? void 0 : signedTwipsMeasureValue2(right)
            },
            hanging: {
              key: "w:hanging",
              value: hanging === void 0 ? void 0 : twipsMeasureValue2(hanging)
            },
            firstLine: {
              key: "w:firstLine",
              value: firstLine === void 0 ? void 0 : twipsMeasureValue2(firstLine)
            }
          })
        );
      }
    };
    var Break$12 = class Break extends XmlComponent2 {
      constructor() {
        super("w:br");
      }
    };
    var FieldCharacterType2 = {
      BEGIN: "begin",
      END: "end",
      SEPARATE: "separate"
    };
    var FidCharAttrs2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", { type: "w:fldCharType", dirty: "w:dirty" });
      }
    };
    var Begin2 = class extends XmlComponent2 {
      constructor(dirty) {
        super("w:fldChar");
        this.root.push(new FidCharAttrs2({ type: FieldCharacterType2.BEGIN, dirty }));
      }
    };
    var Separate2 = class extends XmlComponent2 {
      constructor(dirty) {
        super("w:fldChar");
        this.root.push(new FidCharAttrs2({ type: FieldCharacterType2.SEPARATE, dirty }));
      }
    };
    var End2 = class extends XmlComponent2 {
      constructor(dirty) {
        super("w:fldChar");
        this.root.push(new FidCharAttrs2({ type: FieldCharacterType2.END, dirty }));
      }
    };
    var HorizontalPositionAlign = {
      CENTER: "center",
      INSIDE: "inside",
      LEFT: "left",
      OUTSIDE: "outside",
      RIGHT: "right"
    };
    var VerticalPositionAlign = {
      BOTTOM: "bottom",
      CENTER: "center",
      INSIDE: "inside",
      OUTSIDE: "outside",
      TOP: "top"
    };
    var NumberFormat$1 = {
      DECIMAL: "decimal",
      UPPER_ROMAN: "upperRoman",
      LOWER_ROMAN: "lowerRoman",
      UPPER_LETTER: "upperLetter",
      LOWER_LETTER: "lowerLetter",
      ORDINAL: "ordinal",
      CARDINAL_TEXT: "cardinalText",
      ORDINAL_TEXT: "ordinalText",
      HEX: "hex",
      CHICAGO: "chicago",
      IDEOGRAPH_DIGITAL: "ideographDigital",
      JAPANESE_COUNTING: "japaneseCounting",
      AIUEO: "aiueo",
      IROHA: "iroha",
      DECIMAL_FULL_WIDTH: "decimalFullWidth",
      DECIMAL_HALF_WIDTH: "decimalHalfWidth",
      JAPANESE_LEGAL: "japaneseLegal",
      JAPANESE_DIGITAL_TEN_THOUSAND: "japaneseDigitalTenThousand",
      DECIMAL_ENCLOSED_CIRCLE: "decimalEnclosedCircle",
      DECIMAL_FULL_WIDTH_2: "decimalFullWidth2",
      AIUEO_FULL_WIDTH: "aiueoFullWidth",
      IROHA_FULL_WIDTH: "irohaFullWidth",
      DECIMAL_ZERO: "decimalZero",
      BULLET: "bullet",
      GANADA: "ganada",
      CHOSUNG: "chosung",
      DECIMAL_ENCLOSED_FULL_STOP: "decimalEnclosedFullstop",
      DECIMAL_ENCLOSED_PAREN: "decimalEnclosedParen",
      DECIMAL_ENCLOSED_CIRCLE_CHINESE: "decimalEnclosedCircleChinese",
      IDEOGRAPH_ENCLOSED_CIRCLE: "ideographEnclosedCircle",
      IDEOGRAPH_TRADITIONAL: "ideographTraditional",
      IDEOGRAPH_ZODIAC: "ideographZodiac",
      IDEOGRAPH_ZODIAC_TRADITIONAL: "ideographZodiacTraditional",
      TAIWANESE_COUNTING: "taiwaneseCounting",
      IDEOGRAPH_LEGAL_TRADITIONAL: "ideographLegalTraditional",
      TAIWANESE_COUNTING_THOUSAND: "taiwaneseCountingThousand",
      TAIWANESE_DIGITAL: "taiwaneseDigital",
      CHINESE_COUNTING: "chineseCounting",
      CHINESE_LEGAL_SIMPLIFIED: "chineseLegalSimplified",
      CHINESE_COUNTING_TEN_THOUSAND: "chineseCountingThousand",
      KOREAN_DIGITAL: "koreanDigital",
      KOREAN_COUNTING: "koreanCounting",
      KOREAN_LEGAL: "koreanLegal",
      KOREAN_DIGITAL_2: "koreanDigital2",
      VIETNAMESE_COUNTING: "vietnameseCounting",
      RUSSIAN_LOWER: "russianLower",
      RUSSIAN_UPPER: "russianUpper",
      NONE: "none",
      NUMBER_IN_DASH: "numberInDash",
      HEBREW_1: "hebrew1",
      HEBREW_2: "hebrew2",
      ARABIC_ALPHA: "arabicAlpha",
      ARABIC_ABJAD: "arabicAbjad",
      HINDI_VOWELS: "hindiVowels",
      HINDI_CONSONANTS: "hindiConsonants",
      HINDI_NUMBERS: "hindiNumbers",
      HINDI_COUNTING: "hindiCounting",
      THAI_LETTERS: "thaiLetters",
      THAI_NUMBERS: "thaiNumbers",
      THAI_COUNTING: "thaiCounting",
      BAHT_TEXT: "bahtText",
      DOLLAR_TEXT: "dollarText"
      //   <xsd:enumeration value="custom"/>
    };
    var SpaceType2 = {
      DEFAULT: "default",
      PRESERVE: "preserve"
    };
    var TextAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", { space: "xml:space" });
      }
    };
    var Page2 = class extends XmlComponent2 {
      constructor() {
        super("w:instrText");
        this.root.push(new TextAttributes2({ space: SpaceType2.PRESERVE }));
        this.root.push("PAGE");
      }
    };
    var NumberOfPages2 = class extends XmlComponent2 {
      constructor() {
        super("w:instrText");
        this.root.push(new TextAttributes2({ space: SpaceType2.PRESERVE }));
        this.root.push("NUMPAGES");
      }
    };
    var NumberOfPagesSection2 = class extends XmlComponent2 {
      constructor() {
        super("w:instrText");
        this.root.push(new TextAttributes2({ space: SpaceType2.PRESERVE }));
        this.root.push("SECTIONPAGES");
      }
    };
    var CurrentSection2 = class extends XmlComponent2 {
      constructor() {
        super("w:instrText");
        this.root.push(new TextAttributes2({ space: SpaceType2.PRESERVE }));
        this.root.push("SECTION");
      }
    };
    var ShadingAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", {
          fill: "w:fill",
          color: "w:color",
          type: "w:val"
        });
      }
    };
    var Shading2 = class extends XmlComponent2 {
      constructor({ fill, color, type: type22 }) {
        super("w:shd");
        this.root.push(
          new ShadingAttributes2({
            fill: fill === void 0 ? void 0 : hexColorValue2(fill),
            color: color === void 0 ? void 0 : hexColorValue2(color),
            type: type22
          })
        );
      }
    };
    var ShadingType2 = {
      CLEAR: "clear",
      DIAGONAL_CROSS: "diagCross",
      DIAGONAL_STRIPE: "diagStripe",
      HORIZONTAL_CROSS: "horzCross",
      HORIZONTAL_STRIPE: "horzStripe",
      NIL: "nil",
      PERCENT_5: "pct5",
      PERCENT_10: "pct10",
      PERCENT_12: "pct12",
      PERCENT_15: "pct15",
      PERCENT_20: "pct20",
      PERCENT_25: "pct25",
      PERCENT_30: "pct30",
      PERCENT_35: "pct35",
      PERCENT_37: "pct37",
      PERCENT_40: "pct40",
      PERCENT_45: "pct45",
      PERCENT_50: "pct50",
      PERCENT_55: "pct55",
      PERCENT_60: "pct60",
      PERCENT_62: "pct62",
      PERCENT_65: "pct65",
      PERCENT_70: "pct70",
      PERCENT_75: "pct75",
      PERCENT_80: "pct80",
      PERCENT_85: "pct85",
      PERCENT_87: "pct87",
      PERCENT_90: "pct90",
      PERCENT_95: "pct95",
      REVERSE_DIAGONAL_STRIPE: "reverseDiagStripe",
      SOLID: "solid",
      THIN_DIAGONAL_CROSS: "thinDiagCross",
      THIN_DIAGONAL_STRIPE: "thinDiagStripe",
      THIN_HORIZONTAL_CROSS: "thinHorzCross",
      THIN_REVERSE_DIAGONAL_STRIPE: "thinReverseDiagStripe",
      THIN_VERTICAL_STRIPE: "thinVertStripe",
      VERTICAL_STRIPE: "vertStripe"
    };
    var ChangeAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", {
          id: "w:id",
          author: "w:author",
          date: "w:date"
        });
      }
    };
    var EmphasisMarkType2 = {
      DOT: "dot"
    };
    var BaseEmphasisMark2 = class extends XmlComponent2 {
      constructor(emphasisMarkType) {
        super("w:em");
        this.root.push(
          new Attributes2({
            val: emphasisMarkType
          })
        );
      }
    };
    var EmphasisMark2 = class extends BaseEmphasisMark2 {
      constructor(emphasisMarkType = EmphasisMarkType2.DOT) {
        super(emphasisMarkType);
      }
    };
    var DotEmphasisMark = class extends BaseEmphasisMark2 {
      constructor() {
        super(EmphasisMarkType2.DOT);
      }
    };
    var CharacterSpacing2 = class extends XmlComponent2 {
      constructor(value) {
        super("w:spacing");
        this.root.push(
          new Attributes2({
            val: signedTwipsMeasureValue2(value)
          })
        );
      }
    };
    var Color2 = class extends XmlComponent2 {
      constructor(color) {
        super("w:color");
        this.root.push(
          new Attributes2({
            val: hexColorValue2(color)
          })
        );
      }
    };
    var Highlight2 = class extends XmlComponent2 {
      constructor(color) {
        super("w:highlight");
        this.root.push(
          new Attributes2({
            val: color
          })
        );
      }
    };
    var HighlightComplexScript2 = class extends XmlComponent2 {
      constructor(color) {
        super("w:highlightCs");
        this.root.push(
          new Attributes2({
            val: color
          })
        );
      }
    };
    var createLanguageComponent2 = (options) => new BuilderElement2({
      name: "w:lang",
      attributes: {
        value: {
          key: "w:val",
          value: options.value
        },
        eastAsia: {
          key: "w:eastAsia",
          value: options.eastAsia
        },
        bidirectional: {
          key: "w:bidi",
          value: options.bidirectional
        }
      }
    });
    var RunFontAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", {
          ascii: "w:ascii",
          cs: "w:cs",
          eastAsia: "w:eastAsia",
          hAnsi: "w:hAnsi",
          hint: "w:hint"
        });
      }
    };
    var RunFonts2 = class extends XmlComponent2 {
      constructor(nameOrAttrs, hint) {
        super("w:rFonts");
        if (typeof nameOrAttrs === "string") {
          const name = nameOrAttrs;
          this.root.push(
            new RunFontAttributes2({
              ascii: name,
              cs: name,
              eastAsia: name,
              hAnsi: name,
              hint
            })
          );
        } else {
          const attrs = nameOrAttrs;
          this.root.push(new RunFontAttributes2(attrs));
        }
      }
    };
    var VerticalAlign$12 = class VerticalAlign extends XmlComponent2 {
      constructor(type22) {
        super("w:vertAlign");
        this.root.push(
          new Attributes2({
            val: type22
          })
        );
      }
    };
    var SuperScript2 = class extends VerticalAlign$12 {
      constructor() {
        super("superscript");
      }
    };
    var SubScript2 = class extends VerticalAlign$12 {
      constructor() {
        super("subscript");
      }
    };
    var UnderlineType2 = {
      SINGLE: "single",
      WORDS: "words",
      DOUBLE: "double",
      THICK: "thick",
      DOTTED: "dotted",
      DOTTEDHEAVY: "dottedHeavy",
      DASH: "dash",
      DASHEDHEAVY: "dashedHeavy",
      DASHLONG: "dashLong",
      DASHLONGHEAVY: "dashLongHeavy",
      DOTDASH: "dotDash",
      DASHDOTHEAVY: "dashDotHeavy",
      DOTDOTDASH: "dotDotDash",
      DASHDOTDOTHEAVY: "dashDotDotHeavy",
      WAVE: "wave",
      WAVYHEAVY: "wavyHeavy",
      WAVYDOUBLE: "wavyDouble",
      NONE: "none"
    };
    var Underline2 = class extends XmlComponent2 {
      constructor(underlineType = UnderlineType2.SINGLE, color) {
        super("w:u");
        this.root.push(
          new Attributes2({
            val: underlineType,
            color: color === void 0 ? void 0 : hexColorValue2(color)
          })
        );
      }
    };
    var TextEffect = {
      BLINK_BACKGROUND: "blinkBackground",
      LIGHTS: "lights",
      ANTS_BLACK: "antsBlack",
      ANTS_RED: "antsRed",
      SHIMMER: "shimmer",
      SPARKLE: "sparkle",
      NONE: "none"
    };
    var HighlightColor = {
      BLACK: "black",
      BLUE: "blue",
      CYAN: "cyan",
      DARK_BLUE: "darkBlue",
      DARK_CYAN: "darkCyan",
      DARK_GRAY: "darkGray",
      DARK_GREEN: "darkGreen",
      DARK_MAGENTA: "darkMagenta",
      DARK_RED: "darkRed",
      DARK_YELLOW: "darkYellow",
      GREEN: "green",
      LIGHT_GRAY: "lightGray",
      MAGENTA: "magenta",
      NONE: "none",
      RED: "red",
      WHITE: "white",
      YELLOW: "yellow"
    };
    var RunProperties2 = class extends IgnoreIfEmptyXmlComponent2 {
      constructor(options) {
        var _a, _b;
        super("w:rPr");
        if (!options) {
          return;
        }
        if (options.style) {
          this.push(new StringValueElement2("w:rStyle", options.style));
        }
        if (options.font) {
          if (typeof options.font === "string") {
            this.push(new RunFonts2(options.font));
          } else if ("name" in options.font) {
            this.push(new RunFonts2(options.font.name, options.font.hint));
          } else {
            this.push(new RunFonts2(options.font));
          }
        }
        if (options.bold !== void 0) {
          this.push(new OnOffElement2("w:b", options.bold));
        }
        if (options.boldComplexScript === void 0 && options.bold !== void 0 || options.boldComplexScript) {
          this.push(new OnOffElement2("w:bCs", (_a = options.boldComplexScript) != null ? _a : options.bold));
        }
        if (options.italics !== void 0) {
          this.push(new OnOffElement2("w:i", options.italics));
        }
        if (options.italicsComplexScript === void 0 && options.italics !== void 0 || options.italicsComplexScript) {
          this.push(new OnOffElement2("w:iCs", (_b = options.italicsComplexScript) != null ? _b : options.italics));
        }
        if (options.smallCaps !== void 0) {
          this.push(new OnOffElement2("w:smallCaps", options.smallCaps));
        } else if (options.allCaps !== void 0) {
          this.push(new OnOffElement2("w:caps", options.allCaps));
        }
        if (options.strike !== void 0) {
          this.push(new OnOffElement2("w:strike", options.strike));
        }
        if (options.doubleStrike !== void 0) {
          this.push(new OnOffElement2("w:dstrike", options.doubleStrike));
        }
        if (options.emboss !== void 0) {
          this.push(new OnOffElement2("w:emboss", options.emboss));
        }
        if (options.imprint !== void 0) {
          this.push(new OnOffElement2("w:imprint", options.imprint));
        }
        if (options.noProof !== void 0) {
          this.push(new OnOffElement2("w:noProof", options.noProof));
        }
        if (options.snapToGrid !== void 0) {
          this.push(new OnOffElement2("w:snapToGrid", options.snapToGrid));
        }
        if (options.vanish) {
          this.push(new OnOffElement2("w:vanish", options.vanish));
        }
        if (options.color) {
          this.push(new Color2(options.color));
        }
        if (options.characterSpacing) {
          this.push(new CharacterSpacing2(options.characterSpacing));
        }
        if (options.scale !== void 0) {
          this.push(new NumberValueElement2("w:w", options.scale));
        }
        if (options.kern) {
          this.push(new HpsMeasureElement2("w:kern", options.kern));
        }
        if (options.position) {
          this.push(new StringValueElement2("w:position", options.position));
        }
        if (options.size !== void 0) {
          this.push(new HpsMeasureElement2("w:sz", options.size));
        }
        const szCs = options.sizeComplexScript === void 0 || options.sizeComplexScript === true ? options.size : options.sizeComplexScript;
        if (szCs) {
          this.push(new HpsMeasureElement2("w:szCs", szCs));
        }
        if (options.highlight) {
          this.push(new Highlight2(options.highlight));
        }
        const highlightCs = options.highlightComplexScript === void 0 || options.highlightComplexScript === true ? options.highlight : options.highlightComplexScript;
        if (highlightCs) {
          this.push(new HighlightComplexScript2(highlightCs));
        }
        if (options.underline) {
          this.push(new Underline2(options.underline.type, options.underline.color));
        }
        if (options.effect) {
          this.push(new StringValueElement2("w:effect", options.effect));
        }
        if (options.border) {
          this.push(new BorderElement2("w:bdr", options.border));
        }
        if (options.shading) {
          this.push(new Shading2(options.shading));
        }
        if (options.subScript) {
          this.push(new SubScript2());
        }
        if (options.superScript) {
          this.push(new SuperScript2());
        }
        if (options.rightToLeft !== void 0) {
          this.push(new OnOffElement2("w:rtl", options.rightToLeft));
        }
        if (options.emphasisMark) {
          this.push(new EmphasisMark2(options.emphasisMark.type));
        }
        if (options.language) {
          this.push(createLanguageComponent2(options.language));
        }
        if (options.specVanish) {
          this.push(new OnOffElement2("w:specVanish", options.vanish));
        }
        if (options.math) {
          this.push(new OnOffElement2("w:oMath", options.math));
        }
        if (options.revision) {
          this.push(new RunPropertiesChange2(options.revision));
        }
      }
      push(item) {
        this.root.push(item);
      }
    };
    var RunPropertiesChange2 = class extends XmlComponent2 {
      constructor(options) {
        super("w:rPrChange");
        this.root.push(
          new ChangeAttributes2({
            id: options.id,
            author: options.author,
            date: options.date
          })
        );
        this.addChildElement(new RunProperties2(options));
      }
    };
    var Text2 = class extends XmlComponent2 {
      constructor(options) {
        var _a;
        super("w:t");
        if (typeof options === "string") {
          this.root.push(new TextAttributes2({ space: SpaceType2.PRESERVE }));
          this.root.push(options);
        } else {
          this.root.push(new TextAttributes2({ space: (_a = options.space) != null ? _a : SpaceType2.DEFAULT }));
          this.root.push(options.text);
        }
      }
    };
    var PageNumber2 = {
      CURRENT: "CURRENT",
      TOTAL_PAGES: "TOTAL_PAGES",
      TOTAL_PAGES_IN_SECTION: "TOTAL_PAGES_IN_SECTION",
      CURRENT_SECTION: "SECTION"
    };
    var Run2 = class extends XmlComponent2 {
      constructor(options) {
        super("w:r");
        __publicField2(this, "properties");
        this.properties = new RunProperties2(options);
        this.root.push(this.properties);
        if (options.break) {
          for (let i = 0; i < options.break; i++) {
            this.root.push(new Break$12());
          }
        }
        if (options.children) {
          for (const child of options.children) {
            if (typeof child === "string") {
              switch (child) {
                case PageNumber2.CURRENT:
                  this.root.push(new Begin2());
                  this.root.push(new Page2());
                  this.root.push(new Separate2());
                  this.root.push(new End2());
                  break;
                case PageNumber2.TOTAL_PAGES:
                  this.root.push(new Begin2());
                  this.root.push(new NumberOfPages2());
                  this.root.push(new Separate2());
                  this.root.push(new End2());
                  break;
                case PageNumber2.TOTAL_PAGES_IN_SECTION:
                  this.root.push(new Begin2());
                  this.root.push(new NumberOfPagesSection2());
                  this.root.push(new Separate2());
                  this.root.push(new End2());
                  break;
                case PageNumber2.CURRENT_SECTION:
                  this.root.push(new Begin2());
                  this.root.push(new CurrentSection2());
                  this.root.push(new Separate2());
                  this.root.push(new End2());
                  break;
                default:
                  this.root.push(new Text2(child));
                  break;
              }
              continue;
            }
            this.root.push(child);
          }
        } else if (options.text !== void 0) {
          this.root.push(new Text2(options.text));
        }
      }
    };
    var TextRun3 = class extends Run2 {
      constructor(options) {
        super(typeof options === "string" ? { text: options } : options);
      }
    };
    var SymbolAttributes = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", {
          char: "w:char",
          symbolfont: "w:font"
        });
      }
    };
    var Symbol$1 = class Symbol2 extends XmlComponent2 {
      constructor(char = "", symbolfont = "Wingdings") {
        super("w:sym");
        this.root.push(new SymbolAttributes({ char, symbolfont }));
      }
    };
    var SymbolRun = class extends Run2 {
      constructor(options) {
        if (typeof options === "string") {
          super({});
          this.root.push(new Symbol$1(options));
          return this;
        }
        super(options);
        this.root.push(new Symbol$1(options.char, options.symbolfont));
      }
    };
    var hash$12 = {};
    var utils2 = {};
    var minimalisticAssert2;
    var hasRequiredMinimalisticAssert2;
    function requireMinimalisticAssert2() {
      if (hasRequiredMinimalisticAssert2) return minimalisticAssert2;
      hasRequiredMinimalisticAssert2 = 1;
      minimalisticAssert2 = assert;
      function assert(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      assert.equal = function assertEqual(l, r, msg) {
        if (l != r)
          throw new Error(msg || "Assertion failed: " + l + " != " + r);
      };
      return minimalisticAssert2;
    }
    var hasRequiredUtils2;
    function requireUtils2() {
      if (hasRequiredUtils2) return utils2;
      hasRequiredUtils2 = 1;
      var assert = requireMinimalisticAssert2();
      var inherits = requireInherits_browser2();
      utils2.inherits = inherits;
      function isSurrogatePair(msg, i) {
        if ((msg.charCodeAt(i) & 64512) !== 55296) {
          return false;
        }
        if (i < 0 || i + 1 >= msg.length) {
          return false;
        }
        return (msg.charCodeAt(i + 1) & 64512) === 56320;
      }
      function toArray(msg, enc) {
        if (Array.isArray(msg))
          return msg.slice();
        if (!msg)
          return [];
        var res = [];
        if (typeof msg === "string") {
          if (!enc) {
            var p = 0;
            for (var i = 0; i < msg.length; i++) {
              var c = msg.charCodeAt(i);
              if (c < 128) {
                res[p++] = c;
              } else if (c < 2048) {
                res[p++] = c >> 6 | 192;
                res[p++] = c & 63 | 128;
              } else if (isSurrogatePair(msg, i)) {
                c = 65536 + ((c & 1023) << 10) + (msg.charCodeAt(++i) & 1023);
                res[p++] = c >> 18 | 240;
                res[p++] = c >> 12 & 63 | 128;
                res[p++] = c >> 6 & 63 | 128;
                res[p++] = c & 63 | 128;
              } else {
                res[p++] = c >> 12 | 224;
                res[p++] = c >> 6 & 63 | 128;
                res[p++] = c & 63 | 128;
              }
            }
          } else if (enc === "hex") {
            msg = msg.replace(/[^a-z0-9]+/ig, "");
            if (msg.length % 2 !== 0)
              msg = "0" + msg;
            for (i = 0; i < msg.length; i += 2)
              res.push(parseInt(msg[i] + msg[i + 1], 16));
          }
        } else {
          for (i = 0; i < msg.length; i++)
            res[i] = msg[i] | 0;
        }
        return res;
      }
      utils2.toArray = toArray;
      function toHex(msg) {
        var res = "";
        for (var i = 0; i < msg.length; i++)
          res += zero2(msg[i].toString(16));
        return res;
      }
      utils2.toHex = toHex;
      function htonl(w) {
        var res = w >>> 24 | w >>> 8 & 65280 | w << 8 & 16711680 | (w & 255) << 24;
        return res >>> 0;
      }
      utils2.htonl = htonl;
      function toHex32(msg, endian) {
        var res = "";
        for (var i = 0; i < msg.length; i++) {
          var w = msg[i];
          if (endian === "little")
            w = htonl(w);
          res += zero8(w.toString(16));
        }
        return res;
      }
      utils2.toHex32 = toHex32;
      function zero2(word) {
        if (word.length === 1)
          return "0" + word;
        else
          return word;
      }
      utils2.zero2 = zero2;
      function zero8(word) {
        if (word.length === 7)
          return "0" + word;
        else if (word.length === 6)
          return "00" + word;
        else if (word.length === 5)
          return "000" + word;
        else if (word.length === 4)
          return "0000" + word;
        else if (word.length === 3)
          return "00000" + word;
        else if (word.length === 2)
          return "000000" + word;
        else if (word.length === 1)
          return "0000000" + word;
        else
          return word;
      }
      utils2.zero8 = zero8;
      function join32(msg, start, end, endian) {
        var len = end - start;
        assert(len % 4 === 0);
        var res = new Array(len / 4);
        for (var i = 0, k = start; i < res.length; i++, k += 4) {
          var w;
          if (endian === "big")
            w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3];
          else
            w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];
          res[i] = w >>> 0;
        }
        return res;
      }
      utils2.join32 = join32;
      function split32(msg, endian) {
        var res = new Array(msg.length * 4);
        for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
          var m = msg[i];
          if (endian === "big") {
            res[k] = m >>> 24;
            res[k + 1] = m >>> 16 & 255;
            res[k + 2] = m >>> 8 & 255;
            res[k + 3] = m & 255;
          } else {
            res[k + 3] = m >>> 24;
            res[k + 2] = m >>> 16 & 255;
            res[k + 1] = m >>> 8 & 255;
            res[k] = m & 255;
          }
        }
        return res;
      }
      utils2.split32 = split32;
      function rotr32(w, b) {
        return w >>> b | w << 32 - b;
      }
      utils2.rotr32 = rotr32;
      function rotl32(w, b) {
        return w << b | w >>> 32 - b;
      }
      utils2.rotl32 = rotl32;
      function sum32(a, b) {
        return a + b >>> 0;
      }
      utils2.sum32 = sum32;
      function sum32_3(a, b, c) {
        return a + b + c >>> 0;
      }
      utils2.sum32_3 = sum32_3;
      function sum32_4(a, b, c, d) {
        return a + b + c + d >>> 0;
      }
      utils2.sum32_4 = sum32_4;
      function sum32_5(a, b, c, d, e) {
        return a + b + c + d + e >>> 0;
      }
      utils2.sum32_5 = sum32_5;
      function sum64(buf, pos, ah, al) {
        var bh = buf[pos];
        var bl = buf[pos + 1];
        var lo = al + bl >>> 0;
        var hi = (lo < al ? 1 : 0) + ah + bh;
        buf[pos] = hi >>> 0;
        buf[pos + 1] = lo;
      }
      utils2.sum64 = sum64;
      function sum64_hi(ah, al, bh, bl) {
        var lo = al + bl >>> 0;
        var hi = (lo < al ? 1 : 0) + ah + bh;
        return hi >>> 0;
      }
      utils2.sum64_hi = sum64_hi;
      function sum64_lo(ah, al, bh, bl) {
        var lo = al + bl;
        return lo >>> 0;
      }
      utils2.sum64_lo = sum64_lo;
      function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
        var carry = 0;
        var lo = al;
        lo = lo + bl >>> 0;
        carry += lo < al ? 1 : 0;
        lo = lo + cl >>> 0;
        carry += lo < cl ? 1 : 0;
        lo = lo + dl >>> 0;
        carry += lo < dl ? 1 : 0;
        var hi = ah + bh + ch + dh + carry;
        return hi >>> 0;
      }
      utils2.sum64_4_hi = sum64_4_hi;
      function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
        var lo = al + bl + cl + dl;
        return lo >>> 0;
      }
      utils2.sum64_4_lo = sum64_4_lo;
      function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
        var carry = 0;
        var lo = al;
        lo = lo + bl >>> 0;
        carry += lo < al ? 1 : 0;
        lo = lo + cl >>> 0;
        carry += lo < cl ? 1 : 0;
        lo = lo + dl >>> 0;
        carry += lo < dl ? 1 : 0;
        lo = lo + el >>> 0;
        carry += lo < el ? 1 : 0;
        var hi = ah + bh + ch + dh + eh + carry;
        return hi >>> 0;
      }
      utils2.sum64_5_hi = sum64_5_hi;
      function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
        var lo = al + bl + cl + dl + el;
        return lo >>> 0;
      }
      utils2.sum64_5_lo = sum64_5_lo;
      function rotr64_hi(ah, al, num) {
        var r = al << 32 - num | ah >>> num;
        return r >>> 0;
      }
      utils2.rotr64_hi = rotr64_hi;
      function rotr64_lo(ah, al, num) {
        var r = ah << 32 - num | al >>> num;
        return r >>> 0;
      }
      utils2.rotr64_lo = rotr64_lo;
      function shr64_hi(ah, al, num) {
        return ah >>> num;
      }
      utils2.shr64_hi = shr64_hi;
      function shr64_lo(ah, al, num) {
        var r = ah << 32 - num | al >>> num;
        return r >>> 0;
      }
      utils2.shr64_lo = shr64_lo;
      return utils2;
    }
    var common$12 = {};
    var hasRequiredCommon$12;
    function requireCommon$12() {
      if (hasRequiredCommon$12) return common$12;
      hasRequiredCommon$12 = 1;
      var utils22 = requireUtils2();
      var assert = requireMinimalisticAssert2();
      function BlockHash() {
        this.pending = null;
        this.pendingTotal = 0;
        this.blockSize = this.constructor.blockSize;
        this.outSize = this.constructor.outSize;
        this.hmacStrength = this.constructor.hmacStrength;
        this.padLength = this.constructor.padLength / 8;
        this.endian = "big";
        this._delta8 = this.blockSize / 8;
        this._delta32 = this.blockSize / 32;
      }
      common$12.BlockHash = BlockHash;
      BlockHash.prototype.update = function update(msg, enc) {
        msg = utils22.toArray(msg, enc);
        if (!this.pending)
          this.pending = msg;
        else
          this.pending = this.pending.concat(msg);
        this.pendingTotal += msg.length;
        if (this.pending.length >= this._delta8) {
          msg = this.pending;
          var r = msg.length % this._delta8;
          this.pending = msg.slice(msg.length - r, msg.length);
          if (this.pending.length === 0)
            this.pending = null;
          msg = utils22.join32(msg, 0, msg.length - r, this.endian);
          for (var i = 0; i < msg.length; i += this._delta32)
            this._update(msg, i, i + this._delta32);
        }
        return this;
      };
      BlockHash.prototype.digest = function digest(enc) {
        this.update(this._pad());
        assert(this.pending === null);
        return this._digest(enc);
      };
      BlockHash.prototype._pad = function pad() {
        var len = this.pendingTotal;
        var bytes = this._delta8;
        var k = bytes - (len + this.padLength) % bytes;
        var res = new Array(k + this.padLength);
        res[0] = 128;
        for (var i = 1; i < k; i++)
          res[i] = 0;
        len <<= 3;
        if (this.endian === "big") {
          for (var t = 8; t < this.padLength; t++)
            res[i++] = 0;
          res[i++] = 0;
          res[i++] = 0;
          res[i++] = 0;
          res[i++] = 0;
          res[i++] = len >>> 24 & 255;
          res[i++] = len >>> 16 & 255;
          res[i++] = len >>> 8 & 255;
          res[i++] = len & 255;
        } else {
          res[i++] = len & 255;
          res[i++] = len >>> 8 & 255;
          res[i++] = len >>> 16 & 255;
          res[i++] = len >>> 24 & 255;
          res[i++] = 0;
          res[i++] = 0;
          res[i++] = 0;
          res[i++] = 0;
          for (t = 8; t < this.padLength; t++)
            res[i++] = 0;
        }
        return res;
      };
      return common$12;
    }
    var sha2 = {};
    var common2 = {};
    var hasRequiredCommon2;
    function requireCommon2() {
      if (hasRequiredCommon2) return common2;
      hasRequiredCommon2 = 1;
      var utils22 = requireUtils2();
      var rotr32 = utils22.rotr32;
      function ft_1(s, x, y, z) {
        if (s === 0)
          return ch32(x, y, z);
        if (s === 1 || s === 3)
          return p32(x, y, z);
        if (s === 2)
          return maj32(x, y, z);
      }
      common2.ft_1 = ft_1;
      function ch32(x, y, z) {
        return x & y ^ ~x & z;
      }
      common2.ch32 = ch32;
      function maj32(x, y, z) {
        return x & y ^ x & z ^ y & z;
      }
      common2.maj32 = maj32;
      function p32(x, y, z) {
        return x ^ y ^ z;
      }
      common2.p32 = p32;
      function s0_256(x) {
        return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
      }
      common2.s0_256 = s0_256;
      function s1_256(x) {
        return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
      }
      common2.s1_256 = s1_256;
      function g0_256(x) {
        return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;
      }
      common2.g0_256 = g0_256;
      function g1_256(x) {
        return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;
      }
      common2.g1_256 = g1_256;
      return common2;
    }
    var _12;
    var hasRequired_12;
    function require_12() {
      if (hasRequired_12) return _12;
      hasRequired_12 = 1;
      var utils22 = requireUtils2();
      var common22 = requireCommon$12();
      var shaCommon = requireCommon2();
      var rotl32 = utils22.rotl32;
      var sum32 = utils22.sum32;
      var sum32_5 = utils22.sum32_5;
      var ft_1 = shaCommon.ft_1;
      var BlockHash = common22.BlockHash;
      var sha1_K = [
        1518500249,
        1859775393,
        2400959708,
        3395469782
      ];
      function SHA1() {
        if (!(this instanceof SHA1))
          return new SHA1();
        BlockHash.call(this);
        this.h = [
          1732584193,
          4023233417,
          2562383102,
          271733878,
          3285377520
        ];
        this.W = new Array(80);
      }
      utils22.inherits(SHA1, BlockHash);
      _12 = SHA1;
      SHA1.blockSize = 512;
      SHA1.outSize = 160;
      SHA1.hmacStrength = 80;
      SHA1.padLength = 64;
      SHA1.prototype._update = function _update(msg, start) {
        var W = this.W;
        for (var i = 0; i < 16; i++)
          W[i] = msg[start + i];
        for (; i < W.length; i++)
          W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
        var a = this.h[0];
        var b = this.h[1];
        var c = this.h[2];
        var d = this.h[3];
        var e = this.h[4];
        for (i = 0; i < W.length; i++) {
          var s = ~~(i / 20);
          var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
          e = d;
          d = c;
          c = rotl32(b, 30);
          b = a;
          a = t;
        }
        this.h[0] = sum32(this.h[0], a);
        this.h[1] = sum32(this.h[1], b);
        this.h[2] = sum32(this.h[2], c);
        this.h[3] = sum32(this.h[3], d);
        this.h[4] = sum32(this.h[4], e);
      };
      SHA1.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils22.toHex32(this.h, "big");
        else
          return utils22.split32(this.h, "big");
      };
      return _12;
    }
    var _2562;
    var hasRequired_2562;
    function require_2562() {
      if (hasRequired_2562) return _2562;
      hasRequired_2562 = 1;
      var utils22 = requireUtils2();
      var common22 = requireCommon$12();
      var shaCommon = requireCommon2();
      var assert = requireMinimalisticAssert2();
      var sum32 = utils22.sum32;
      var sum32_4 = utils22.sum32_4;
      var sum32_5 = utils22.sum32_5;
      var ch32 = shaCommon.ch32;
      var maj32 = shaCommon.maj32;
      var s0_256 = shaCommon.s0_256;
      var s1_256 = shaCommon.s1_256;
      var g0_256 = shaCommon.g0_256;
      var g1_256 = shaCommon.g1_256;
      var BlockHash = common22.BlockHash;
      var sha256_K = [
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ];
      function SHA256() {
        if (!(this instanceof SHA256))
          return new SHA256();
        BlockHash.call(this);
        this.h = [
          1779033703,
          3144134277,
          1013904242,
          2773480762,
          1359893119,
          2600822924,
          528734635,
          1541459225
        ];
        this.k = sha256_K;
        this.W = new Array(64);
      }
      utils22.inherits(SHA256, BlockHash);
      _2562 = SHA256;
      SHA256.blockSize = 512;
      SHA256.outSize = 256;
      SHA256.hmacStrength = 192;
      SHA256.padLength = 64;
      SHA256.prototype._update = function _update(msg, start) {
        var W = this.W;
        for (var i = 0; i < 16; i++)
          W[i] = msg[start + i];
        for (; i < W.length; i++)
          W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);
        var a = this.h[0];
        var b = this.h[1];
        var c = this.h[2];
        var d = this.h[3];
        var e = this.h[4];
        var f = this.h[5];
        var g = this.h[6];
        var h = this.h[7];
        assert(this.k.length === W.length);
        for (i = 0; i < W.length; i++) {
          var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
          var T2 = sum32(s0_256(a), maj32(a, b, c));
          h = g;
          g = f;
          f = e;
          e = sum32(d, T1);
          d = c;
          c = b;
          b = a;
          a = sum32(T1, T2);
        }
        this.h[0] = sum32(this.h[0], a);
        this.h[1] = sum32(this.h[1], b);
        this.h[2] = sum32(this.h[2], c);
        this.h[3] = sum32(this.h[3], d);
        this.h[4] = sum32(this.h[4], e);
        this.h[5] = sum32(this.h[5], f);
        this.h[6] = sum32(this.h[6], g);
        this.h[7] = sum32(this.h[7], h);
      };
      SHA256.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils22.toHex32(this.h, "big");
        else
          return utils22.split32(this.h, "big");
      };
      return _2562;
    }
    var _2242;
    var hasRequired_2242;
    function require_2242() {
      if (hasRequired_2242) return _2242;
      hasRequired_2242 = 1;
      var utils22 = requireUtils2();
      var SHA256 = require_2562();
      function SHA224() {
        if (!(this instanceof SHA224))
          return new SHA224();
        SHA256.call(this);
        this.h = [
          3238371032,
          914150663,
          812702999,
          4144912697,
          4290775857,
          1750603025,
          1694076839,
          3204075428
        ];
      }
      utils22.inherits(SHA224, SHA256);
      _2242 = SHA224;
      SHA224.blockSize = 512;
      SHA224.outSize = 224;
      SHA224.hmacStrength = 192;
      SHA224.padLength = 64;
      SHA224.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils22.toHex32(this.h.slice(0, 7), "big");
        else
          return utils22.split32(this.h.slice(0, 7), "big");
      };
      return _2242;
    }
    var _5122;
    var hasRequired_5122;
    function require_5122() {
      if (hasRequired_5122) return _5122;
      hasRequired_5122 = 1;
      var utils22 = requireUtils2();
      var common22 = requireCommon$12();
      var assert = requireMinimalisticAssert2();
      var rotr64_hi = utils22.rotr64_hi;
      var rotr64_lo = utils22.rotr64_lo;
      var shr64_hi = utils22.shr64_hi;
      var shr64_lo = utils22.shr64_lo;
      var sum64 = utils22.sum64;
      var sum64_hi = utils22.sum64_hi;
      var sum64_lo = utils22.sum64_lo;
      var sum64_4_hi = utils22.sum64_4_hi;
      var sum64_4_lo = utils22.sum64_4_lo;
      var sum64_5_hi = utils22.sum64_5_hi;
      var sum64_5_lo = utils22.sum64_5_lo;
      var BlockHash = common22.BlockHash;
      var sha512_K = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      function SHA512() {
        if (!(this instanceof SHA512))
          return new SHA512();
        BlockHash.call(this);
        this.h = [
          1779033703,
          4089235720,
          3144134277,
          2227873595,
          1013904242,
          4271175723,
          2773480762,
          1595750129,
          1359893119,
          2917565137,
          2600822924,
          725511199,
          528734635,
          4215389547,
          1541459225,
          327033209
        ];
        this.k = sha512_K;
        this.W = new Array(160);
      }
      utils22.inherits(SHA512, BlockHash);
      _5122 = SHA512;
      SHA512.blockSize = 1024;
      SHA512.outSize = 512;
      SHA512.hmacStrength = 192;
      SHA512.padLength = 128;
      SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
        var W = this.W;
        for (var i = 0; i < 32; i++)
          W[i] = msg[start + i];
        for (; i < W.length; i += 2) {
          var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);
          var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
          var c1_hi = W[i - 14];
          var c1_lo = W[i - 13];
          var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);
          var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
          var c3_hi = W[i - 32];
          var c3_lo = W[i - 31];
          W[i] = sum64_4_hi(
            c0_hi,
            c0_lo,
            c1_hi,
            c1_lo,
            c2_hi,
            c2_lo,
            c3_hi,
            c3_lo
          );
          W[i + 1] = sum64_4_lo(
            c0_hi,
            c0_lo,
            c1_hi,
            c1_lo,
            c2_hi,
            c2_lo,
            c3_hi,
            c3_lo
          );
        }
      };
      SHA512.prototype._update = function _update(msg, start) {
        this._prepareBlock(msg, start);
        var W = this.W;
        var ah = this.h[0];
        var al = this.h[1];
        var bh = this.h[2];
        var bl = this.h[3];
        var ch = this.h[4];
        var cl = this.h[5];
        var dh = this.h[6];
        var dl = this.h[7];
        var eh = this.h[8];
        var el = this.h[9];
        var fh = this.h[10];
        var fl = this.h[11];
        var gh = this.h[12];
        var gl = this.h[13];
        var hh = this.h[14];
        var hl = this.h[15];
        assert(this.k.length === W.length);
        for (var i = 0; i < W.length; i += 2) {
          var c0_hi = hh;
          var c0_lo = hl;
          var c1_hi = s1_512_hi(eh, el);
          var c1_lo = s1_512_lo(eh, el);
          var c2_hi = ch64_hi(eh, el, fh, fl, gh);
          var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
          var c3_hi = this.k[i];
          var c3_lo = this.k[i + 1];
          var c4_hi = W[i];
          var c4_lo = W[i + 1];
          var T1_hi = sum64_5_hi(
            c0_hi,
            c0_lo,
            c1_hi,
            c1_lo,
            c2_hi,
            c2_lo,
            c3_hi,
            c3_lo,
            c4_hi,
            c4_lo
          );
          var T1_lo = sum64_5_lo(
            c0_hi,
            c0_lo,
            c1_hi,
            c1_lo,
            c2_hi,
            c2_lo,
            c3_hi,
            c3_lo,
            c4_hi,
            c4_lo
          );
          c0_hi = s0_512_hi(ah, al);
          c0_lo = s0_512_lo(ah, al);
          c1_hi = maj64_hi(ah, al, bh, bl, ch);
          c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
          var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
          var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
          hh = gh;
          hl = gl;
          gh = fh;
          gl = fl;
          fh = eh;
          fl = el;
          eh = sum64_hi(dh, dl, T1_hi, T1_lo);
          el = sum64_lo(dl, dl, T1_hi, T1_lo);
          dh = ch;
          dl = cl;
          ch = bh;
          cl = bl;
          bh = ah;
          bl = al;
          ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
          al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
        }
        sum64(this.h, 0, ah, al);
        sum64(this.h, 2, bh, bl);
        sum64(this.h, 4, ch, cl);
        sum64(this.h, 6, dh, dl);
        sum64(this.h, 8, eh, el);
        sum64(this.h, 10, fh, fl);
        sum64(this.h, 12, gh, gl);
        sum64(this.h, 14, hh, hl);
      };
      SHA512.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils22.toHex32(this.h, "big");
        else
          return utils22.split32(this.h, "big");
      };
      function ch64_hi(xh, xl, yh, yl, zh) {
        var r = xh & yh ^ ~xh & zh;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function ch64_lo(xh, xl, yh, yl, zh, zl) {
        var r = xl & yl ^ ~xl & zl;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function maj64_hi(xh, xl, yh, yl, zh) {
        var r = xh & yh ^ xh & zh ^ yh & zh;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function maj64_lo(xh, xl, yh, yl, zh, zl) {
        var r = xl & yl ^ xl & zl ^ yl & zl;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function s0_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 28);
        var c1_hi = rotr64_hi(xl, xh, 2);
        var c2_hi = rotr64_hi(xl, xh, 7);
        var r = c0_hi ^ c1_hi ^ c2_hi;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function s0_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 28);
        var c1_lo = rotr64_lo(xl, xh, 2);
        var c2_lo = rotr64_lo(xl, xh, 7);
        var r = c0_lo ^ c1_lo ^ c2_lo;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function s1_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 14);
        var c1_hi = rotr64_hi(xh, xl, 18);
        var c2_hi = rotr64_hi(xl, xh, 9);
        var r = c0_hi ^ c1_hi ^ c2_hi;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function s1_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 14);
        var c1_lo = rotr64_lo(xh, xl, 18);
        var c2_lo = rotr64_lo(xl, xh, 9);
        var r = c0_lo ^ c1_lo ^ c2_lo;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function g0_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 1);
        var c1_hi = rotr64_hi(xh, xl, 8);
        var c2_hi = shr64_hi(xh, xl, 7);
        var r = c0_hi ^ c1_hi ^ c2_hi;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function g0_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 1);
        var c1_lo = rotr64_lo(xh, xl, 8);
        var c2_lo = shr64_lo(xh, xl, 7);
        var r = c0_lo ^ c1_lo ^ c2_lo;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function g1_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 19);
        var c1_hi = rotr64_hi(xl, xh, 29);
        var c2_hi = shr64_hi(xh, xl, 6);
        var r = c0_hi ^ c1_hi ^ c2_hi;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function g1_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 19);
        var c1_lo = rotr64_lo(xl, xh, 29);
        var c2_lo = shr64_lo(xh, xl, 6);
        var r = c0_lo ^ c1_lo ^ c2_lo;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      return _5122;
    }
    var _3842;
    var hasRequired_3842;
    function require_3842() {
      if (hasRequired_3842) return _3842;
      hasRequired_3842 = 1;
      var utils22 = requireUtils2();
      var SHA512 = require_5122();
      function SHA384() {
        if (!(this instanceof SHA384))
          return new SHA384();
        SHA512.call(this);
        this.h = [
          3418070365,
          3238371032,
          1654270250,
          914150663,
          2438529370,
          812702999,
          355462360,
          4144912697,
          1731405415,
          4290775857,
          2394180231,
          1750603025,
          3675008525,
          1694076839,
          1203062813,
          3204075428
        ];
      }
      utils22.inherits(SHA384, SHA512);
      _3842 = SHA384;
      SHA384.blockSize = 1024;
      SHA384.outSize = 384;
      SHA384.hmacStrength = 192;
      SHA384.padLength = 128;
      SHA384.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils22.toHex32(this.h.slice(0, 12), "big");
        else
          return utils22.split32(this.h.slice(0, 12), "big");
      };
      return _3842;
    }
    var hasRequiredSha2;
    function requireSha2() {
      if (hasRequiredSha2) return sha2;
      hasRequiredSha2 = 1;
      sha2.sha1 = require_12();
      sha2.sha224 = require_2242();
      sha2.sha256 = require_2562();
      sha2.sha384 = require_3842();
      sha2.sha512 = require_5122();
      return sha2;
    }
    var ripemd2 = {};
    var hasRequiredRipemd2;
    function requireRipemd2() {
      if (hasRequiredRipemd2) return ripemd2;
      hasRequiredRipemd2 = 1;
      var utils22 = requireUtils2();
      var common22 = requireCommon$12();
      var rotl32 = utils22.rotl32;
      var sum32 = utils22.sum32;
      var sum32_3 = utils22.sum32_3;
      var sum32_4 = utils22.sum32_4;
      var BlockHash = common22.BlockHash;
      function RIPEMD160() {
        if (!(this instanceof RIPEMD160))
          return new RIPEMD160();
        BlockHash.call(this);
        this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
        this.endian = "little";
      }
      utils22.inherits(RIPEMD160, BlockHash);
      ripemd2.ripemd160 = RIPEMD160;
      RIPEMD160.blockSize = 512;
      RIPEMD160.outSize = 160;
      RIPEMD160.hmacStrength = 192;
      RIPEMD160.padLength = 64;
      RIPEMD160.prototype._update = function update(msg, start) {
        var A = this.h[0];
        var B = this.h[1];
        var C = this.h[2];
        var D = this.h[3];
        var E = this.h[4];
        var Ah = A;
        var Bh = B;
        var Ch = C;
        var Dh = D;
        var Eh = E;
        for (var j = 0; j < 80; j++) {
          var T = sum32(
            rotl32(
              sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
              s[j]
            ),
            E
          );
          A = E;
          E = D;
          D = rotl32(C, 10);
          C = B;
          B = T;
          T = sum32(
            rotl32(
              sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
              sh[j]
            ),
            Eh
          );
          Ah = Eh;
          Eh = Dh;
          Dh = rotl32(Ch, 10);
          Ch = Bh;
          Bh = T;
        }
        T = sum32_3(this.h[1], C, Dh);
        this.h[1] = sum32_3(this.h[2], D, Eh);
        this.h[2] = sum32_3(this.h[3], E, Ah);
        this.h[3] = sum32_3(this.h[4], A, Bh);
        this.h[4] = sum32_3(this.h[0], B, Ch);
        this.h[0] = T;
      };
      RIPEMD160.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils22.toHex32(this.h, "little");
        else
          return utils22.split32(this.h, "little");
      };
      function f(j, x, y, z) {
        if (j <= 15)
          return x ^ y ^ z;
        else if (j <= 31)
          return x & y | ~x & z;
        else if (j <= 47)
          return (x | ~y) ^ z;
        else if (j <= 63)
          return x & z | y & ~z;
        else
          return x ^ (y | ~z);
      }
      function K(j) {
        if (j <= 15)
          return 0;
        else if (j <= 31)
          return 1518500249;
        else if (j <= 47)
          return 1859775393;
        else if (j <= 63)
          return 2400959708;
        else
          return 2840853838;
      }
      function Kh(j) {
        if (j <= 15)
          return 1352829926;
        else if (j <= 31)
          return 1548603684;
        else if (j <= 47)
          return 1836072691;
        else if (j <= 63)
          return 2053994217;
        else
          return 0;
      }
      var r = [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        7,
        4,
        13,
        1,
        10,
        6,
        15,
        3,
        12,
        0,
        9,
        5,
        2,
        14,
        11,
        8,
        3,
        10,
        14,
        4,
        9,
        15,
        8,
        1,
        2,
        7,
        0,
        6,
        13,
        11,
        5,
        12,
        1,
        9,
        11,
        10,
        0,
        8,
        12,
        4,
        13,
        3,
        7,
        15,
        14,
        5,
        6,
        2,
        4,
        0,
        5,
        9,
        7,
        12,
        2,
        10,
        14,
        1,
        3,
        8,
        11,
        6,
        15,
        13
      ];
      var rh = [
        5,
        14,
        7,
        0,
        9,
        2,
        11,
        4,
        13,
        6,
        15,
        8,
        1,
        10,
        3,
        12,
        6,
        11,
        3,
        7,
        0,
        13,
        5,
        10,
        14,
        15,
        8,
        12,
        4,
        9,
        1,
        2,
        15,
        5,
        1,
        3,
        7,
        14,
        6,
        9,
        11,
        8,
        12,
        2,
        10,
        0,
        4,
        13,
        8,
        6,
        4,
        1,
        3,
        11,
        15,
        0,
        5,
        12,
        2,
        13,
        9,
        7,
        10,
        14,
        12,
        15,
        10,
        4,
        1,
        5,
        8,
        7,
        6,
        2,
        13,
        14,
        0,
        3,
        9,
        11
      ];
      var s = [
        11,
        14,
        15,
        12,
        5,
        8,
        7,
        9,
        11,
        13,
        14,
        15,
        6,
        7,
        9,
        8,
        7,
        6,
        8,
        13,
        11,
        9,
        7,
        15,
        7,
        12,
        15,
        9,
        11,
        7,
        13,
        12,
        11,
        13,
        6,
        7,
        14,
        9,
        13,
        15,
        14,
        8,
        13,
        6,
        5,
        12,
        7,
        5,
        11,
        12,
        14,
        15,
        14,
        15,
        9,
        8,
        9,
        14,
        5,
        6,
        8,
        6,
        5,
        12,
        9,
        15,
        5,
        11,
        6,
        8,
        13,
        12,
        5,
        12,
        13,
        14,
        11,
        8,
        5,
        6
      ];
      var sh = [
        8,
        9,
        9,
        11,
        13,
        15,
        15,
        5,
        7,
        7,
        8,
        11,
        14,
        14,
        12,
        6,
        9,
        13,
        15,
        7,
        12,
        8,
        9,
        11,
        7,
        7,
        12,
        7,
        6,
        15,
        13,
        11,
        9,
        7,
        15,
        11,
        8,
        6,
        6,
        14,
        12,
        13,
        5,
        14,
        13,
        13,
        7,
        5,
        15,
        5,
        8,
        11,
        14,
        14,
        6,
        14,
        6,
        9,
        12,
        9,
        12,
        5,
        15,
        8,
        8,
        5,
        12,
        9,
        12,
        5,
        14,
        6,
        8,
        13,
        6,
        5,
        15,
        13,
        11,
        11
      ];
      return ripemd2;
    }
    var hmac2;
    var hasRequiredHmac2;
    function requireHmac2() {
      if (hasRequiredHmac2) return hmac2;
      hasRequiredHmac2 = 1;
      var utils22 = requireUtils2();
      var assert = requireMinimalisticAssert2();
      function Hmac(hash22, key, enc) {
        if (!(this instanceof Hmac))
          return new Hmac(hash22, key, enc);
        this.Hash = hash22;
        this.blockSize = hash22.blockSize / 8;
        this.outSize = hash22.outSize / 8;
        this.inner = null;
        this.outer = null;
        this._init(utils22.toArray(key, enc));
      }
      hmac2 = Hmac;
      Hmac.prototype._init = function init(key) {
        if (key.length > this.blockSize)
          key = new this.Hash().update(key).digest();
        assert(key.length <= this.blockSize);
        for (var i = key.length; i < this.blockSize; i++)
          key.push(0);
        for (i = 0; i < key.length; i++)
          key[i] ^= 54;
        this.inner = new this.Hash().update(key);
        for (i = 0; i < key.length; i++)
          key[i] ^= 106;
        this.outer = new this.Hash().update(key);
      };
      Hmac.prototype.update = function update(msg, enc) {
        this.inner.update(msg, enc);
        return this;
      };
      Hmac.prototype.digest = function digest(enc) {
        this.outer.update(this.inner.digest());
        return this.outer.digest(enc);
      };
      return hmac2;
    }
    var hasRequiredHash2;
    function requireHash2() {
      if (hasRequiredHash2) return hash$12;
      hasRequiredHash2 = 1;
      (function(exports22) {
        var hash22 = exports22;
        hash22.utils = requireUtils2();
        hash22.common = requireCommon$12();
        hash22.sha = requireSha2();
        hash22.ripemd = requireRipemd2();
        hash22.hmac = requireHmac2();
        hash22.sha1 = hash22.sha.sha1;
        hash22.sha256 = hash22.sha.sha256;
        hash22.sha224 = hash22.sha.sha224;
        hash22.sha384 = hash22.sha.sha384;
        hash22.sha512 = hash22.sha.sha512;
        hash22.ripemd160 = hash22.ripemd.ripemd160;
      })(hash$12);
      return hash$12;
    }
    var hashExports2 = requireHash2();
    var hash2 = /* @__PURE__ */ getDefaultExportFromCjs$12(hashExports2);
    var urlAlphabet2 = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
    var customAlphabet2 = (alphabet, defaultSize = 21) => {
      return (size = defaultSize) => {
        let id = "";
        let i = size | 0;
        while (i--) {
          id += alphabet[Math.random() * alphabet.length | 0];
        }
        return id;
      };
    };
    var nanoid2 = (size = 21) => {
      let id = "";
      let i = size | 0;
      while (i--) {
        id += urlAlphabet2[Math.random() * 64 | 0];
      }
      return id;
    };
    var convertMillimetersToTwip = (millimeters) => Math.floor(millimeters / 25.4 * 72 * 20);
    var convertInchesToTwip2 = (inches) => Math.floor(inches * 72 * 20);
    var uniqueNumericIdCreator2 = (initial = 0) => {
      let currentCount = initial;
      return () => ++currentCount;
    };
    var abstractNumUniqueNumericIdGen2 = () => uniqueNumericIdCreator2();
    var concreteNumUniqueNumericIdGen2 = () => uniqueNumericIdCreator2(1);
    var docPropertiesUniqueNumericIdGen2 = () => uniqueNumericIdCreator2();
    var bookmarkUniqueNumericIdGen2 = () => uniqueNumericIdCreator2();
    var uniqueId2 = () => nanoid2().toLowerCase();
    var hashedId2 = (data) => hash2.sha1().update(data instanceof ArrayBuffer ? new Uint8Array(data) : data).digest("hex");
    var generateUuidPart2 = (count) => customAlphabet2("1234567890abcdef", count)();
    var uniqueUuid2 = () => `${generateUuidPart2(8)}-${generateUuidPart2(4)}-${generateUuidPart2(4)}-${generateUuidPart2(4)}-${generateUuidPart2(12)}`;
    var HorizontalPositionRelativeFrom2 = {
      /**
       * ## Character
       *
       * Specifies that the horizontal positioning shall be relative to the position of the anchor within its run content.
       */
      CHARACTER: "character",
      /**
       * ## Column
       *
       * Specifies that the horizontal positioning shall be relative to the extents of the column which contains its anchor.
       */
      COLUMN: "column",
      /**
       * ## Inside Margin
       *
       * Specifies that the horizontal positioning shall be relative to the inside margin of the current page (the left margin on odd pages, right on even pages).
       */
      INSIDE_MARGIN: "insideMargin",
      /**
       * ## Left Margin
       *
       * Specifies that the horizontal positioning shall be relative to the left margin of the page.
       */
      LEFT_MARGIN: "leftMargin",
      /**
       * ## Page Margin
       *
       * Specifies that the horizontal positioning shall be relative to the page margins.
       */
      MARGIN: "margin",
      /**
       * ## Outside Margin
       *
       * Specifies that the horizontal positioning shall be relative to the outside margin of the current page (the right margin on odd pages, left on even pages).
       */
      OUTSIDE_MARGIN: "outsideMargin",
      /**
       * ## Page Edge
       *
       * Specifies that the horizontal positioning shall be relative to the edge of the page.
       */
      PAGE: "page",
      /**
       * ## Right Margin
       *
       * Specifies that the horizontal positioning shall be relative to the right margin of the page.
       */
      RIGHT_MARGIN: "rightMargin"
    };
    var VerticalPositionRelativeFrom2 = {
      /**
       * ## Bottom Margin
       *
       * Specifies that the vertical positioning shall be relative to the bottom margin of the current page.
       */
      BOTTOM_MARGIN: "bottomMargin",
      /**
       * ## Inside Margin
       *
       * Specifies that the vertical positioning shall be relative to the inside margin of the current page.
       */
      INSIDE_MARGIN: "insideMargin",
      /**
       * ## Line
       *
       * Specifies that the vertical positioning shall be relative to the line containing the anchor character.
       */
      LINE: "line",
      /**
       * ## Page Margin
       *
       * Specifies that the vertical positioning shall be relative to the page margins.
       */
      MARGIN: "margin",
      /**
       * ## Outside Margin
       *
       * Specifies that the vertical positioning shall be relative to the outside margin of the current page.
       */
      OUTSIDE_MARGIN: "outsideMargin",
      /**
       * ## Page Edge
       *
       * Specifies that the vertical positioning shall be relative to the edge of the page.
       */
      PAGE: "page",
      /**
       * ## Paragraph
       *
       * Specifies that the vertical positioning shall be relative to the paragraph which contains the drawing anchor.
       */
      PARAGRAPH: "paragraph",
      /**
       * ## Top Margin
       *
       * Specifies that the vertical positioning shall be relative to the top margin of the current page.
       */
      TOP_MARGIN: "topMargin"
    };
    var createSimplePos2 = () => new BuilderElement2({
      name: "wp:simplePos",
      // NOTE: It's not fully supported in Microsoft Word, but this element is needed anyway
      attributes: {
        x: { key: "x", value: 0 },
        y: { key: "y", value: 0 }
      }
    });
    var createAlign2 = (value) => new BuilderElement2({
      name: "wp:align",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      children: [value]
    });
    var createPositionOffset2 = (offsetValue) => new BuilderElement2({
      name: "wp:posOffset",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      children: [offsetValue.toString()]
    });
    var createHorizontalPosition2 = ({ relative, align, offset }) => new BuilderElement2({
      name: "wp:positionH",
      attributes: {
        relativeFrom: { key: "relativeFrom", value: relative != null ? relative : HorizontalPositionRelativeFrom2.PAGE }
      },
      children: [
        (() => {
          if (align) {
            return createAlign2(align);
          } else if (offset !== void 0) {
            return createPositionOffset2(offset);
          } else {
            throw new Error("There is no configuration provided for floating position (Align or offset)");
          }
        })()
      ]
    });
    var createVerticalPosition2 = ({ relative, align, offset }) => new BuilderElement2({
      name: "wp:positionV",
      attributes: {
        relativeFrom: { key: "relativeFrom", value: relative != null ? relative : VerticalPositionRelativeFrom2.PAGE }
      },
      children: [
        (() => {
          if (align) {
            return createAlign2(align);
          } else if (offset !== void 0) {
            return createPositionOffset2(offset);
          } else {
            throw new Error("There is no configuration provided for floating position (Align or offset)");
          }
        })()
      ]
    });
    var GraphicDataAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", {
          uri: "uri"
        });
      }
    };
    var createSvgBlip2 = (mediaData) => new BuilderElement2({
      name: "asvg:svgBlip",
      attributes: {
        asvg: {
          key: "xmlns:asvg",
          value: "http://schemas.microsoft.com/office/drawing/2016/SVG/main"
        },
        embed: {
          key: "r:embed",
          value: `rId{${mediaData.fileName}}`
        }
      }
    });
    var createExtention2 = (mediaData) => new BuilderElement2({
      name: "a:ext",
      attributes: {
        uri: {
          key: "uri",
          value: "{96DAC541-7B7A-43D3-8B79-37D633B846F1}"
        }
      },
      children: [createSvgBlip2(mediaData)]
    });
    var createExtentionList2 = (mediaData) => new BuilderElement2({
      name: "a:extLst",
      children: [createExtention2(mediaData)]
    });
    var createBlip2 = (mediaData) => new BuilderElement2({
      name: "a:blip",
      attributes: {
        embed: {
          key: "r:embed",
          value: `rId{${mediaData.type === "svg" ? mediaData.fallback.fileName : mediaData.fileName}}`
        },
        cstate: {
          key: "cstate",
          value: "none"
        }
      },
      children: mediaData.type === "svg" ? [createExtentionList2(mediaData)] : []
    });
    var SourceRectangle2 = class extends XmlComponent2 {
      constructor() {
        super("a:srcRect");
      }
    };
    var FillRectangle2 = class extends XmlComponent2 {
      constructor() {
        super("a:fillRect");
      }
    };
    var Stretch2 = class extends XmlComponent2 {
      constructor() {
        super("a:stretch");
        this.root.push(new FillRectangle2());
      }
    };
    var BlipFill2 = class extends XmlComponent2 {
      constructor(mediaData) {
        super("pic:blipFill");
        this.root.push(createBlip2(mediaData));
        this.root.push(new SourceRectangle2());
        this.root.push(new Stretch2());
      }
    };
    var PicLocksAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", {
          noChangeAspect: "noChangeAspect",
          noChangeArrowheads: "noChangeArrowheads"
        });
      }
    };
    var PicLocks2 = class extends XmlComponent2 {
      constructor() {
        super("a:picLocks");
        this.root.push(
          new PicLocksAttributes2({
            noChangeAspect: 1,
            noChangeArrowheads: 1
          })
        );
      }
    };
    var ChildNonVisualProperties2 = class extends XmlComponent2 {
      constructor() {
        super("pic:cNvPicPr");
        this.root.push(new PicLocks2());
      }
    };
    var createHyperlinkClick2 = (linkId, hasXmlNs) => new BuilderElement2({
      name: "a:hlinkClick",
      attributes: __spreadProps2(__spreadValues2({}, hasXmlNs ? {
        xmlns: {
          key: "xmlns:a",
          value: "http://schemas.openxmlformats.org/drawingml/2006/main"
        }
      } : {}), {
        id: {
          key: "r:id",
          value: `rId${linkId}`
        }
      })
    });
    var NonVisualPropertiesAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", {
          id: "id",
          name: "name",
          descr: "descr"
        });
      }
    };
    var NonVisualProperties2 = class extends XmlComponent2 {
      constructor() {
        super("pic:cNvPr");
        this.root.push(
          new NonVisualPropertiesAttributes2({
            id: 0,
            name: "",
            descr: ""
          })
        );
      }
      prepForXml(context) {
        for (let i = context.stack.length - 1; i >= 0; i--) {
          const element = context.stack[i];
          if (!(element instanceof ConcreteHyperlink2)) {
            continue;
          }
          this.root.push(createHyperlinkClick2(element.linkId, false));
          break;
        }
        return super.prepForXml(context);
      }
    };
    var NonVisualPicProperties2 = class extends XmlComponent2 {
      constructor() {
        super("pic:nvPicPr");
        this.root.push(new NonVisualProperties2());
        this.root.push(new ChildNonVisualProperties2());
      }
    };
    var PicAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", {
          xmlns: "xmlns:pic"
        });
      }
    };
    var ExtentsAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", {
          cx: "cx",
          cy: "cy"
        });
      }
    };
    var Extents2 = class extends XmlComponent2 {
      constructor(x, y) {
        super("a:ext");
        __publicField2(this, "attributes");
        this.attributes = new ExtentsAttributes2({
          cx: x,
          cy: y
        });
        this.root.push(this.attributes);
      }
    };
    var OffsetAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", {
          x: "x",
          y: "y"
        });
      }
    };
    var Offset2 = class extends XmlComponent2 {
      constructor() {
        super("a:off");
        this.root.push(
          new OffsetAttributes2({
            x: 0,
            y: 0
          })
        );
      }
    };
    var FormAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", {
          flipVertical: "flipV",
          flipHorizontal: "flipH",
          rotation: "rot"
        });
      }
    };
    var Form2 = class extends XmlComponent2 {
      constructor(options) {
        var _a, _b;
        super("a:xfrm");
        __publicField2(this, "extents");
        this.root.push(
          new FormAttributes2({
            flipVertical: (_a = options.flip) == null ? void 0 : _a.vertical,
            flipHorizontal: (_b = options.flip) == null ? void 0 : _b.horizontal,
            rotation: options.rotation
          })
        );
        this.extents = new Extents2(options.emus.x, options.emus.y);
        this.root.push(new Offset2());
        this.root.push(this.extents);
      }
    };
    var createNoFill2 = () => new BuilderElement2({ name: "a:noFill" });
    var createSolidRgbColor2 = (options) => new BuilderElement2({
      name: "a:srgbClr",
      attributes: {
        value: {
          key: "val",
          value: options.value
        }
      }
    });
    var createSchemeColor2 = (options) => new BuilderElement2({
      name: "a:schemeClr",
      attributes: {
        value: {
          key: "val",
          value: options.value
        }
      }
    });
    var createSolidFill2 = (options) => new BuilderElement2({
      name: "a:solidFill",
      children: [options.type === "rgb" ? createSolidRgbColor2(options) : createSchemeColor2(options)]
    });
    var createOutline2 = (options) => new BuilderElement2({
      name: "a:ln",
      attributes: {
        width: {
          key: "w",
          value: options.width
        },
        cap: {
          key: "cap",
          value: options.cap
        },
        compoundLine: {
          key: "cmpd",
          value: options.compoundLine
        },
        align: {
          key: "algn",
          value: options.align
        }
      },
      children: [
        options.type === "noFill" ? createNoFill2() : options.solidFillType === "rgb" ? createSolidFill2({
          type: "rgb",
          value: options.value
        }) : createSolidFill2({
          type: "scheme",
          value: options.value
        })
      ]
    });
    var AdjustmentValues2 = class extends XmlComponent2 {
      constructor() {
        super("a:avLst");
      }
    };
    var PresetGeometryAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", {
          prst: "prst"
        });
      }
    };
    var PresetGeometry2 = class extends XmlComponent2 {
      constructor() {
        super("a:prstGeom");
        this.root.push(
          new PresetGeometryAttributes2({
            prst: "rect"
          })
        );
        this.root.push(new AdjustmentValues2());
      }
    };
    var ShapePropertiesAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", {
          bwMode: "bwMode"
        });
      }
    };
    var ShapeProperties2 = class extends XmlComponent2 {
      constructor({ outline, transform }) {
        super("pic:spPr");
        __publicField2(this, "form");
        this.root.push(
          new ShapePropertiesAttributes2({
            bwMode: "auto"
          })
        );
        this.form = new Form2(transform);
        this.root.push(this.form);
        this.root.push(new PresetGeometry2());
        if (outline) {
          this.root.push(createNoFill2());
          this.root.push(createOutline2(outline));
        }
      }
    };
    var Pic2 = class extends XmlComponent2 {
      constructor({
        mediaData,
        transform,
        outline
      }) {
        super("pic:pic");
        this.root.push(
          new PicAttributes2({
            xmlns: "http://schemas.openxmlformats.org/drawingml/2006/picture"
          })
        );
        this.root.push(new NonVisualPicProperties2());
        this.root.push(new BlipFill2(mediaData));
        this.root.push(new ShapeProperties2({ transform, outline }));
      }
    };
    var GraphicData2 = class extends XmlComponent2 {
      constructor({
        mediaData,
        transform,
        outline
      }) {
        super("a:graphicData");
        __publicField2(this, "pic");
        this.root.push(
          new GraphicDataAttributes2({
            uri: "http://schemas.openxmlformats.org/drawingml/2006/picture"
          })
        );
        this.pic = new Pic2({ mediaData, transform, outline });
        this.root.push(this.pic);
      }
    };
    var GraphicAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", {
          a: "xmlns:a"
        });
      }
    };
    var Graphic2 = class extends XmlComponent2 {
      constructor({
        mediaData,
        transform,
        outline
      }) {
        super("a:graphic");
        __publicField2(this, "data");
        this.root.push(
          new GraphicAttributes2({
            a: "http://schemas.openxmlformats.org/drawingml/2006/main"
          })
        );
        this.data = new GraphicData2({ mediaData, transform, outline });
        this.root.push(this.data);
      }
    };
    var TextWrappingType2 = {
      NONE: 0,
      SQUARE: 1,
      TIGHT: 2,
      TOP_AND_BOTTOM: 3
    };
    var TextWrappingSide2 = {
      BOTH_SIDES: "bothSides",
      LEFT: "left",
      RIGHT: "right",
      LARGEST: "largest"
    };
    var WrapNone2 = class extends XmlComponent2 {
      constructor() {
        super("wp:wrapNone");
      }
    };
    var WrapSquareAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", {
          distT: "distT",
          distB: "distB",
          distL: "distL",
          distR: "distR",
          wrapText: "wrapText"
        });
      }
    };
    var WrapSquare2 = class extends XmlComponent2 {
      constructor(textWrapping, margins = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      }) {
        super("wp:wrapSquare");
        this.root.push(
          new WrapSquareAttributes2({
            wrapText: textWrapping.side || TextWrappingSide2.BOTH_SIDES,
            distT: margins.top,
            distB: margins.bottom,
            distL: margins.left,
            distR: margins.right
          })
        );
      }
    };
    var WrapTightAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", {
          distT: "distT",
          distB: "distB"
        });
      }
    };
    var WrapTight2 = class extends XmlComponent2 {
      constructor(margins = {
        top: 0,
        bottom: 0
      }) {
        super("wp:wrapTight");
        this.root.push(
          new WrapTightAttributes2({
            distT: margins.top,
            distB: margins.bottom
          })
        );
      }
    };
    var WrapTopAndBottomAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", {
          distT: "distT",
          distB: "distB"
        });
      }
    };
    var WrapTopAndBottom2 = class extends XmlComponent2 {
      constructor(margins = {
        top: 0,
        bottom: 0
      }) {
        super("wp:wrapTopAndBottom");
        this.root.push(
          new WrapTopAndBottomAttributes2({
            distT: margins.top,
            distB: margins.bottom
          })
        );
      }
    };
    var DocProperties2 = class extends XmlComponent2 {
      constructor({ name, description, title } = { name: "", description: "", title: "" }) {
        super("wp:docPr");
        __publicField2(this, "docPropertiesUniqueNumericId", docPropertiesUniqueNumericIdGen2());
        const attributes = {
          id: {
            key: "id",
            value: this.docPropertiesUniqueNumericId()
          },
          name: {
            key: "name",
            value: name
          }
        };
        if (description !== null && description !== void 0) {
          attributes.description = {
            key: "descr",
            value: description
          };
        }
        if (title !== null && title !== void 0) {
          attributes.title = {
            key: "title",
            value: title
          };
        }
        this.root.push(new NextAttributeComponent2(attributes));
      }
      prepForXml(context) {
        for (let i = context.stack.length - 1; i >= 0; i--) {
          const element = context.stack[i];
          if (!(element instanceof ConcreteHyperlink2)) {
            continue;
          }
          this.root.push(createHyperlinkClick2(element.linkId, true));
          break;
        }
        return super.prepForXml(context);
      }
    };
    var createEffectExtent2 = ({ top, right, bottom, left }) => new BuilderElement2({
      name: "wp:effectExtent",
      attributes: {
        top: {
          key: "t",
          value: top
        },
        right: {
          key: "r",
          value: right
        },
        bottom: {
          key: "b",
          value: bottom
        },
        left: {
          key: "l",
          value: left
        }
      }
    });
    var createExtent2 = ({ x, y }) => new BuilderElement2({
      name: "wp:extent",
      attributes: {
        x: { key: "cx", value: x },
        y: { key: "cy", value: y }
      }
    });
    var GraphicFrameLockAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", {
          xmlns: "xmlns:a",
          noChangeAspect: "noChangeAspect"
        });
      }
    };
    var GraphicFrameLocks2 = class extends XmlComponent2 {
      constructor() {
        super("a:graphicFrameLocks");
        this.root.push(
          new GraphicFrameLockAttributes2({
            xmlns: "http://schemas.openxmlformats.org/drawingml/2006/main",
            noChangeAspect: 1
          })
        );
      }
    };
    var createGraphicFrameProperties2 = () => new BuilderElement2({
      name: "wp:cNvGraphicFramePr",
      children: [new GraphicFrameLocks2()]
    });
    var AnchorAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", {
          distT: "distT",
          distB: "distB",
          distL: "distL",
          distR: "distR",
          allowOverlap: "allowOverlap",
          behindDoc: "behindDoc",
          layoutInCell: "layoutInCell",
          locked: "locked",
          relativeHeight: "relativeHeight",
          simplePos: "simplePos"
        });
      }
    };
    var Anchor2 = class extends XmlComponent2 {
      constructor({
        mediaData,
        transform,
        drawingOptions
      }) {
        super("wp:anchor");
        const floating = __spreadValues2({
          allowOverlap: true,
          behindDocument: false,
          lockAnchor: false,
          layoutInCell: true,
          verticalPosition: {},
          horizontalPosition: {}
        }, drawingOptions.floating);
        this.root.push(
          new AnchorAttributes2({
            distT: floating.margins ? floating.margins.top || 0 : 0,
            distB: floating.margins ? floating.margins.bottom || 0 : 0,
            distL: floating.margins ? floating.margins.left || 0 : 0,
            distR: floating.margins ? floating.margins.right || 0 : 0,
            simplePos: "0",
            // note: word doesn't fully support - so we use 0
            allowOverlap: floating.allowOverlap === true ? "1" : "0",
            behindDoc: floating.behindDocument === true ? "1" : "0",
            locked: floating.lockAnchor === true ? "1" : "0",
            layoutInCell: floating.layoutInCell === true ? "1" : "0",
            relativeHeight: floating.zIndex ? floating.zIndex : transform.emus.y
          })
        );
        this.root.push(createSimplePos2());
        this.root.push(createHorizontalPosition2(floating.horizontalPosition));
        this.root.push(createVerticalPosition2(floating.verticalPosition));
        this.root.push(createExtent2({ x: transform.emus.x, y: transform.emus.y }));
        this.root.push(createEffectExtent2({ top: 0, right: 0, bottom: 0, left: 0 }));
        if (drawingOptions.floating !== void 0 && drawingOptions.floating.wrap !== void 0) {
          switch (drawingOptions.floating.wrap.type) {
            case TextWrappingType2.SQUARE:
              this.root.push(new WrapSquare2(drawingOptions.floating.wrap, drawingOptions.floating.margins));
              break;
            case TextWrappingType2.TIGHT:
              this.root.push(new WrapTight2(drawingOptions.floating.margins));
              break;
            case TextWrappingType2.TOP_AND_BOTTOM:
              this.root.push(new WrapTopAndBottom2(drawingOptions.floating.margins));
              break;
            case TextWrappingType2.NONE:
            default:
              this.root.push(new WrapNone2());
          }
        } else {
          this.root.push(new WrapNone2());
        }
        this.root.push(new DocProperties2(drawingOptions.docProperties));
        this.root.push(createGraphicFrameProperties2());
        this.root.push(new Graphic2({ mediaData, transform, outline: drawingOptions.outline }));
      }
    };
    var createInline2 = ({ mediaData, transform, docProperties, outline }) => {
      var _a, _b, _c, _d;
      return new BuilderElement2({
        name: "wp:inline",
        attributes: {
          distanceTop: {
            key: "distT",
            value: 0
          },
          distanceBottom: {
            key: "distB",
            value: 0
          },
          distanceLeft: {
            key: "distL",
            value: 0
          },
          distanceRight: {
            key: "distR",
            value: 0
          }
        },
        children: [
          createExtent2({ x: transform.emus.x, y: transform.emus.y }),
          createEffectExtent2(
            outline ? {
              top: ((_a = outline.width) != null ? _a : 9525) * 2,
              right: ((_b = outline.width) != null ? _b : 9525) * 2,
              bottom: ((_c = outline.width) != null ? _c : 9525) * 2,
              left: ((_d = outline.width) != null ? _d : 9525) * 2
            } : { top: 0, right: 0, bottom: 0, left: 0 }
          ),
          new DocProperties2(docProperties),
          createGraphicFrameProperties2(),
          new Graphic2({ mediaData, transform, outline })
        ]
      });
    };
    var Drawing2 = class extends XmlComponent2 {
      constructor(imageData, drawingOptions = {}) {
        super("w:drawing");
        if (!drawingOptions.floating) {
          this.root.push(
            createInline2({
              mediaData: imageData,
              transform: imageData.transformation,
              docProperties: drawingOptions.docProperties,
              outline: drawingOptions.outline
            })
          );
        } else {
          this.root.push(new Anchor2({ mediaData: imageData, transform: imageData.transformation, drawingOptions }));
        }
      }
    };
    var convertDataURIToBinary2 = (dataURI) => {
      if (typeof atob === "function") {
        const BASE64_MARKER = ";base64,";
        const base64Index = dataURI.indexOf(BASE64_MARKER);
        const base64IndexWithOffset = base64Index === -1 ? 0 : base64Index + BASE64_MARKER.length;
        return new Uint8Array(
          atob(dataURI.substring(base64IndexWithOffset)).split("").map((c) => c.charCodeAt(0))
        );
      } else {
        const b = require("buffer");
        return new b.Buffer(dataURI, "base64");
      }
    };
    var standardizeData2 = (data) => typeof data === "string" ? convertDataURIToBinary2(data) : data;
    var createImageData2 = (options, key) => ({
      data: standardizeData2(options.data),
      fileName: key,
      transformation: {
        pixels: {
          x: Math.round(options.transformation.width),
          y: Math.round(options.transformation.height)
        },
        emus: {
          x: Math.round(options.transformation.width * 9525),
          y: Math.round(options.transformation.height * 9525)
        },
        flip: options.transformation.flip,
        rotation: options.transformation.rotation ? options.transformation.rotation * 6e4 : void 0
      }
    });
    var ImageRun2 = class extends Run2 {
      constructor(options) {
        super({});
        __publicField2(this, "imageData");
        const hash22 = hashedId2(options.data);
        const key = `${hash22}.${options.type}`;
        this.imageData = options.type === "svg" ? __spreadProps2(__spreadValues2({
          type: options.type
        }, createImageData2(options, key)), {
          fallback: __spreadValues2({
            type: options.fallback.type
          }, createImageData2(
            __spreadProps2(__spreadValues2({}, options.fallback), {
              transformation: options.transformation
            }),
            `${hashedId2(options.fallback.data)}.${options.fallback.type}`
          ))
        }) : __spreadValues2({
          type: options.type
        }, createImageData2(options, key));
        const drawing = new Drawing2(this.imageData, {
          floating: options.floating,
          docProperties: options.altText,
          outline: options.outline
        });
        this.root.push(drawing);
      }
      prepForXml(context) {
        context.file.Media.addImage(this.imageData.fileName, this.imageData);
        if (this.imageData.type === "svg") {
          context.file.Media.addImage(this.imageData.fallback.fileName, this.imageData.fallback);
        }
        return super.prepForXml(context);
      }
    };
    var SequentialIdentifierInstruction2 = class extends XmlComponent2 {
      constructor(identifier) {
        super("w:instrText");
        this.root.push(new TextAttributes2({ space: SpaceType2.PRESERVE }));
        this.root.push(`SEQ ${identifier}`);
      }
    };
    var SequentialIdentifier2 = class extends Run2 {
      constructor(identifier) {
        super({});
        this.root.push(new Begin2(true));
        this.root.push(new SequentialIdentifierInstruction2(identifier));
        this.root.push(new Separate2());
        this.root.push(new End2());
      }
    };
    var FldSimpleAttrs2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", { instr: "w:instr" });
      }
    };
    var SimpleField2 = class extends XmlComponent2 {
      constructor(instruction, cachedValue) {
        super("w:fldSimple");
        this.root.push(new FldSimpleAttrs2({ instr: instruction }));
        if (cachedValue !== void 0) {
          this.root.push(new TextRun3(cachedValue));
        }
      }
    };
    var SimpleMailMergeField = class extends SimpleField2 {
      constructor(fieldName) {
        super(` MERGEFIELD ${fieldName} `, `\xAB${fieldName}\xBB`);
      }
    };
    var RelationshipsAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", {
          xmlns: "xmlns"
        });
      }
    };
    var RelationshipAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", {
          id: "Id",
          type: "Type",
          target: "Target",
          targetMode: "TargetMode"
        });
      }
    };
    var TargetModeType2 = {
      EXTERNAL: "External"
    };
    var Relationship2 = class extends XmlComponent2 {
      constructor(id, type22, target, targetMode) {
        super("Relationship");
        this.root.push(
          new RelationshipAttributes2({
            id,
            type: type22,
            target,
            targetMode
          })
        );
      }
    };
    var Relationships2 = class extends XmlComponent2 {
      constructor() {
        super("Relationships");
        this.root.push(
          new RelationshipsAttributes2({
            xmlns: "http://schemas.openxmlformats.org/package/2006/relationships"
          })
        );
      }
      createRelationship(id, type22, target, targetMode) {
        const relationship = new Relationship2(`rId${id}`, type22, target, targetMode);
        this.root.push(relationship);
        return relationship;
      }
      get RelationshipCount() {
        return this.root.length - 1;
      }
    };
    var CommentAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", { id: "w:id", initials: "w:initials", author: "w:author", date: "w:date" });
      }
    };
    var CommentRangeAttributes = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", { id: "w:id" });
      }
    };
    var RootCommentsAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", {
          "xmlns:cx": "xmlns:cx",
          "xmlns:cx1": "xmlns:cx1",
          "xmlns:cx2": "xmlns:cx2",
          "xmlns:cx3": "xmlns:cx3",
          "xmlns:cx4": "xmlns:cx4",
          "xmlns:cx5": "xmlns:cx5",
          "xmlns:cx6": "xmlns:cx6",
          "xmlns:cx7": "xmlns:cx7",
          "xmlns:cx8": "xmlns:cx8",
          "xmlns:mc": "xmlns:mc",
          "xmlns:aink": "xmlns:aink",
          "xmlns:am3d": "xmlns:am3d",
          "xmlns:o": "xmlns:o",
          "xmlns:r": "xmlns:r",
          "xmlns:m": "xmlns:m",
          "xmlns:v": "xmlns:v",
          "xmlns:wp14": "xmlns:wp14",
          "xmlns:wp": "xmlns:wp",
          "xmlns:w10": "xmlns:w10",
          "xmlns:w": "xmlns:w",
          "xmlns:w14": "xmlns:w14",
          "xmlns:w15": "xmlns:w15",
          "xmlns:w16cex": "xmlns:w16cex",
          "xmlns:w16cid": "xmlns:w16cid",
          "xmlns:w16": "xmlns:w16",
          "xmlns:w16sdtdh": "xmlns:w16sdtdh",
          "xmlns:w16se": "xmlns:w16se",
          "xmlns:wpg": "xmlns:wpg",
          "xmlns:wpi": "xmlns:wpi",
          "xmlns:wne": "xmlns:wne",
          "xmlns:wps": "xmlns:wps"
        });
      }
    };
    var CommentRangeStart = class extends XmlComponent2 {
      constructor(id) {
        super("w:commentRangeStart");
        this.root.push(new CommentRangeAttributes({ id }));
      }
    };
    var CommentRangeEnd = class extends XmlComponent2 {
      constructor(id) {
        super("w:commentRangeEnd");
        this.root.push(new CommentRangeAttributes({ id }));
      }
    };
    var CommentReference = class extends XmlComponent2 {
      constructor(id) {
        super("w:commentReference");
        this.root.push(new CommentRangeAttributes({ id }));
      }
    };
    var Comment2 = class extends XmlComponent2 {
      constructor({ id, initials, author, date = /* @__PURE__ */ new Date(), children }) {
        super("w:comment");
        this.root.push(
          new CommentAttributes2({
            id,
            initials,
            author,
            date: date.toISOString()
          })
        );
        for (const child of children) {
          this.root.push(child);
        }
      }
    };
    var Comments2 = class extends XmlComponent2 {
      constructor({ children }) {
        super("w:comments");
        __publicField2(this, "relationships");
        this.root.push(
          new RootCommentsAttributes2({
            "xmlns:cx": "http://schemas.microsoft.com/office/drawing/2014/chartex",
            "xmlns:cx1": "http://schemas.microsoft.com/office/drawing/2015/9/8/chartex",
            "xmlns:cx2": "http://schemas.microsoft.com/office/drawing/2015/10/21/chartex",
            "xmlns:cx3": "http://schemas.microsoft.com/office/drawing/2016/5/9/chartex",
            "xmlns:cx4": "http://schemas.microsoft.com/office/drawing/2016/5/10/chartex",
            "xmlns:cx5": "http://schemas.microsoft.com/office/drawing/2016/5/11/chartex",
            "xmlns:cx6": "http://schemas.microsoft.com/office/drawing/2016/5/12/chartex",
            "xmlns:cx7": "http://schemas.microsoft.com/office/drawing/2016/5/13/chartex",
            "xmlns:cx8": "http://schemas.microsoft.com/office/drawing/2016/5/14/chartex",
            "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006",
            "xmlns:aink": "http://schemas.microsoft.com/office/drawing/2016/ink",
            "xmlns:am3d": "http://schemas.microsoft.com/office/drawing/2017/model3d",
            "xmlns:o": "urn:schemas-microsoft-com:office:office",
            "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
            "xmlns:m": "http://schemas.openxmlformats.org/officeDocument/2006/math",
            "xmlns:v": "urn:schemas-microsoft-com:vml",
            "xmlns:wp14": "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
            "xmlns:wp": "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
            "xmlns:w10": "urn:schemas-microsoft-com:office:word",
            "xmlns:w": "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
            "xmlns:w14": "http://schemas.microsoft.com/office/word/2010/wordml",
            "xmlns:w15": "http://schemas.microsoft.com/office/word/2012/wordml",
            "xmlns:w16cex": "http://schemas.microsoft.com/office/word/2018/wordml/cex",
            "xmlns:w16cid": "http://schemas.microsoft.com/office/word/2016/wordml/cid",
            "xmlns:w16": "http://schemas.microsoft.com/office/word/2018/wordml",
            "xmlns:w16sdtdh": "http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash",
            "xmlns:w16se": "http://schemas.microsoft.com/office/word/2015/wordml/symex",
            "xmlns:wpg": "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
            "xmlns:wpi": "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
            "xmlns:wne": "http://schemas.microsoft.com/office/word/2006/wordml",
            "xmlns:wps": "http://schemas.microsoft.com/office/word/2010/wordprocessingShape"
          })
        );
        for (const child of children) {
          this.root.push(new Comment2(child));
        }
        this.relationships = new Relationships2();
      }
      get Relationships() {
        return this.relationships;
      }
    };
    var NoBreakHyphen = class extends EmptyElement {
      constructor() {
        super("w:noBreakHyphen");
      }
    };
    var SoftHyphen = class extends EmptyElement {
      constructor() {
        super("w:softHyphen");
      }
    };
    var DayShort = class extends EmptyElement {
      constructor() {
        super("w:dayShort");
      }
    };
    var MonthShort = class extends EmptyElement {
      constructor() {
        super("w:monthShort");
      }
    };
    var YearShort = class extends EmptyElement {
      constructor() {
        super("w:yearShort");
      }
    };
    var DayLong = class extends EmptyElement {
      constructor() {
        super("w:dayLong");
      }
    };
    var MonthLong = class extends EmptyElement {
      constructor() {
        super("w:monthLong");
      }
    };
    var YearLong = class extends EmptyElement {
      constructor() {
        super("w:yearLong");
      }
    };
    var AnnotationReference = class extends EmptyElement {
      constructor() {
        super("w:annotationRef");
      }
    };
    var FootnoteReferenceElement = class extends EmptyElement {
      constructor() {
        super("w:footnoteRef");
      }
    };
    var EndnoteReference = class extends EmptyElement {
      constructor() {
        super("w:endnoteRef");
      }
    };
    var Separator = class extends EmptyElement {
      constructor() {
        super("w:separator");
      }
    };
    var ContinuationSeparator = class extends EmptyElement {
      constructor() {
        super("w:continuationSeparator");
      }
    };
    var PageNumberElement = class extends EmptyElement {
      constructor() {
        super("w:pgNum");
      }
    };
    var CarriageReturn = class extends EmptyElement {
      constructor() {
        super("w:cr");
      }
    };
    var Tab = class extends EmptyElement {
      constructor() {
        super("w:tab");
      }
    };
    var LastRenderedPageBreak = class extends EmptyElement {
      constructor() {
        super("w:lastRenderedPageBreak");
      }
    };
    var PositionalTabAlignment = {
      LEFT: "left",
      CENTER: "center",
      RIGHT: "right"
    };
    var PositionalTabRelativeTo = {
      MARGIN: "margin",
      INDENT: "indent"
    };
    var PositionalTabLeader = {
      NONE: "none",
      DOT: "dot",
      HYPHEN: "hyphen",
      UNDERSCORE: "underscore",
      MIDDLE_DOT: "middleDot"
    };
    var PositionalTab = class extends XmlComponent2 {
      constructor(options) {
        super("w:ptab");
        this.root.push(
          new NextAttributeComponent2({
            alignment: {
              key: "w:alignment",
              value: options.alignment
            },
            relativeTo: {
              key: "w:relativeTo",
              value: options.relativeTo
            },
            leader: {
              key: "w:leader",
              value: options.leader
            }
          })
        );
      }
    };
    var BreakType = {
      COLUMN: "column",
      PAGE: "page"
      // textWrapping breaks are the default and already exposed via the "Run" class
    };
    var Break2 = class extends XmlComponent2 {
      constructor(type22) {
        super("w:br");
        this.root.push(
          new Attributes2({
            type: type22
          })
        );
      }
    };
    var PageBreak = class extends Run2 {
      constructor() {
        super({});
        this.root.push(new Break2(BreakType.PAGE));
      }
    };
    var ColumnBreak = class extends Run2 {
      constructor() {
        super({});
        this.root.push(new Break2(BreakType.COLUMN));
      }
    };
    var PageBreakBefore2 = class extends XmlComponent2 {
      constructor() {
        super("w:pageBreakBefore");
      }
    };
    var LineRuleType2 = {
      AT_LEAST: "atLeast",
      EXACTLY: "exactly",
      EXACT: "exact",
      AUTO: "auto"
    };
    var SpacingAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", {
          after: "w:after",
          before: "w:before",
          line: "w:line",
          lineRule: "w:lineRule",
          beforeAutoSpacing: "w:beforeAutospacing",
          afterAutoSpacing: "w:afterAutospacing"
        });
      }
    };
    var Spacing2 = class extends XmlComponent2 {
      constructor(options) {
        super("w:spacing");
        this.root.push(new SpacingAttributes2(options));
      }
    };
    var HeadingLevel3 = {
      HEADING_1: "Heading1",
      HEADING_2: "Heading2",
      HEADING_3: "Heading3",
      HEADING_4: "Heading4",
      HEADING_5: "Heading5",
      HEADING_6: "Heading6",
      TITLE: "Title"
    };
    var Style$12 = class Style extends XmlComponent2 {
      constructor(styleId) {
        super("w:pStyle");
        this.root.push(
          new Attributes2({
            val: styleId
          })
        );
      }
    };
    var TabStop2 = class extends XmlComponent2 {
      constructor(tabDefinitions) {
        super("w:tabs");
        for (const tabDefinition of tabDefinitions) {
          this.root.push(new TabStopItem2(tabDefinition));
        }
      }
    };
    var TabStopType2 = {
      LEFT: "left",
      RIGHT: "right",
      CENTER: "center",
      BAR: "bar",
      CLEAR: "clear",
      DECIMAL: "decimal",
      END: "end",
      NUM: "num",
      START: "start"
    };
    var LeaderType = {
      DOT: "dot",
      HYPHEN: "hyphen",
      MIDDLE_DOT: "middleDot",
      NONE: "none",
      UNDERSCORE: "underscore"
    };
    var TabStopPosition2 = {
      MAX: 9026
    };
    var TabAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", { val: "w:val", pos: "w:pos", leader: "w:leader" });
      }
    };
    var TabStopItem2 = class extends XmlComponent2 {
      constructor({ type: type22, position, leader }) {
        super("w:tab");
        this.root.push(
          new TabAttributes2({
            val: type22,
            pos: position,
            leader
          })
        );
      }
    };
    var NumberProperties2 = class extends XmlComponent2 {
      constructor(numberId, indentLevel) {
        super("w:numPr");
        this.root.push(new IndentLevel2(indentLevel));
        this.root.push(new NumberId2(numberId));
      }
    };
    var IndentLevel2 = class extends XmlComponent2 {
      constructor(level) {
        super("w:ilvl");
        if (level > 9) {
          throw new Error(
            "Level cannot be greater than 9. Read more here: https://answers.microsoft.com/en-us/msoffice/forum/all/does-word-support-more-than-9-list-levels/d130fdcd-1781-446d-8c84-c6c79124e4d7"
          );
        }
        this.root.push(
          new Attributes2({
            val: level
          })
        );
      }
    };
    var NumberId2 = class extends XmlComponent2 {
      constructor(id) {
        super("w:numId");
        this.root.push(
          new Attributes2({
            val: typeof id === "string" ? `{${id}}` : id
          })
        );
      }
    };
    var FileChild2 = class extends XmlComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "fileChild", Symbol());
      }
    };
    var HyperlinkAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", {
          id: "r:id",
          history: "w:history",
          anchor: "w:anchor"
        });
      }
    };
    var HyperlinkType = {
      INTERNAL: "INTERNAL",
      EXTERNAL: "EXTERNAL"
    };
    var ConcreteHyperlink2 = class extends XmlComponent2 {
      constructor(children, relationshipId, anchor) {
        super("w:hyperlink");
        __publicField2(this, "linkId");
        this.linkId = relationshipId;
        const props = {
          history: 1,
          anchor: anchor ? anchor : void 0,
          id: !anchor ? `rId${this.linkId}` : void 0
        };
        const attributes = new HyperlinkAttributes2(props);
        this.root.push(attributes);
        children.forEach((child) => {
          this.root.push(child);
        });
      }
    };
    var InternalHyperlink2 = class extends ConcreteHyperlink2 {
      constructor(options) {
        super(options.children, uniqueId2(), options.anchor);
      }
    };
    var ExternalHyperlink2 = class extends XmlComponent2 {
      constructor(options) {
        super("w:externalHyperlink");
        this.options = options;
      }
    };
    var BookmarkStartAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", {
          id: "w:id",
          name: "w:name"
        });
      }
    };
    var BookmarkEndAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", {
          id: "w:id"
        });
      }
    };
    var Bookmark2 = class {
      constructor(options) {
        __publicField2(this, "bookmarkUniqueNumericId", bookmarkUniqueNumericIdGen2());
        __publicField2(this, "start");
        __publicField2(this, "children");
        __publicField2(this, "end");
        const linkId = this.bookmarkUniqueNumericId();
        this.start = new BookmarkStart2(options.id, linkId);
        this.children = options.children;
        this.end = new BookmarkEnd2(linkId);
      }
    };
    var BookmarkStart2 = class extends XmlComponent2 {
      constructor(id, linkId) {
        super("w:bookmarkStart");
        const attributes = new BookmarkStartAttributes2({
          name: id,
          id: linkId
        });
        this.root.push(attributes);
      }
    };
    var BookmarkEnd2 = class extends XmlComponent2 {
      constructor(linkId) {
        super("w:bookmarkEnd");
        const attributes = new BookmarkEndAttributes2({
          id: linkId
        });
        this.root.push(attributes);
      }
    };
    var OutlineLevel2 = class extends XmlComponent2 {
      constructor(level) {
        super("w:outlineLvl");
        this.level = level;
        this.root.push(
          new Attributes2({
            val: level
          })
        );
      }
    };
    var PageReferenceFieldInstruction = class extends XmlComponent2 {
      constructor(bookmarkId, options = {}) {
        super("w:instrText");
        this.root.push(new TextAttributes2({ space: SpaceType2.PRESERVE }));
        let instruction = `PAGEREF ${bookmarkId}`;
        if (options.hyperlink) {
          instruction = `${instruction} \\h`;
        }
        if (options.useRelativePosition) {
          instruction = `${instruction} \\p`;
        }
        this.root.push(instruction);
      }
    };
    var PageReference = class extends Run2 {
      constructor(bookmarkId, options = {}) {
        super({
          children: [new Begin2(true), new PageReferenceFieldInstruction(bookmarkId, options), new End2()]
        });
      }
    };
    var VerticalAlignTable2 = {
      TOP: "top",
      CENTER: "center",
      BOTTOM: "bottom"
    };
    var VerticalAlignSection2 = __spreadProps2(__spreadValues2({}, VerticalAlignTable2), {
      BOTH: "both"
    });
    var VerticalAlign2 = VerticalAlignSection2;
    var VerticalAlignAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", {
          verticalAlign: "w:val"
        });
      }
    };
    var VerticalAlignElement2 = class extends XmlComponent2 {
      constructor(value) {
        super("w:vAlign");
        this.root.push(new VerticalAlignAttributes2({ verticalAlign: value }));
      }
    };
    var Columns2 = class extends XmlComponent2 {
      constructor({ space, count, separate, equalWidth, children }) {
        super("w:cols");
        this.root.push(
          new NextAttributeComponent2({
            space: { key: "w:space", value: space === void 0 ? void 0 : twipsMeasureValue2(space) },
            count: { key: "w:num", value: count === void 0 ? void 0 : decimalNumber2(count) },
            separate: { key: "w:sep", value: separate },
            equalWidth: { key: "w:equalWidth", value: equalWidth }
          })
        );
        if (!equalWidth && children) {
          children.forEach((column) => this.addChildElement(column));
        }
      }
    };
    var DocumentGridType = {
      /**
       * Specifies that no document grid shall be applied to the contents of the current section in the document.
       */
      DEFAULT: "default",
      /**
       * Specifies that the parent section shall have additional line pitch added to each line within it (as specified on the <docGrid> element (§2.6.5)) in order to maintain the specified number of lines per page.
       */
      LINES: "lines",
      /**
       * Specifies that the parent section shall have both the additional line pitch and character pitch added to each line and character within it (as specified on the <docGrid> element (§2.6.5)) in order to maintain a specific number of lines per page and characters per line.
       *
       * When this value is set, the input specified via the user interface may be allowed in exact number of line/character pitch units. */
      LINES_AND_CHARS: "linesAndChars",
      /**
       * Specifies that the parent section shall have both the additional line pitch and character pitch added to each line and character within it (as specified on the <docGrid> element (§2.6.5)) in order to maintain a specific number of lines per page and characters per line.
       *
       * When this value is set, the input specified via the user interface may be restricted to the number of lines per page and characters per line, with the consumer or producer translating this information based on the current font data to get the resulting line and character pitch values
       */
      SNAP_TO_CHARS: "snapToChars"
    };
    var createDocumentGrid2 = ({ type: type22, linePitch, charSpace }) => new BuilderElement2({
      name: "w:docGrid",
      attributes: {
        type: { key: "w:type", value: type22 },
        linePitch: { key: "w:linePitch", value: decimalNumber2(linePitch) },
        charSpace: { key: "w:charSpace", value: charSpace ? decimalNumber2(charSpace) : void 0 }
      }
    });
    var HeaderFooterReferenceType2 = {
      /** Specifies that this header or footer shall appear on every page in this section which is not overridden with a specific `even` or `first` page header/footer. In a section with all three types specified, this type shall be used on all odd numbered pages (counting from the `first` page in the section, not the section numbering). */
      DEFAULT: "default",
      /** Specifies that this header or footer shall appear on the first page in this section. The appearance of this header or footer is contingent on the setting of the `titlePg` element (§2.10.6). */
      FIRST: "first",
      /** Specifies that this header or footer shall appear on all even numbered pages in this section (counting from the first page in the section, not the section numbering). The appearance of this header or footer is contingent on the setting of the `evenAndOddHeaders` element (§2.10.1). */
      EVEN: "even"
    };
    var FooterReferenceAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", {
          type: "w:type",
          id: "r:id"
        });
      }
    };
    var HeaderFooterType2 = {
      HEADER: "w:headerReference",
      FOOTER: "w:footerReference"
    };
    var HeaderFooterReference2 = class extends XmlComponent2 {
      constructor(type22, options) {
        super(type22);
        this.root.push(
          new FooterReferenceAttributes2({
            type: options.type || HeaderFooterReferenceType2.DEFAULT,
            id: `rId${options.id}`
          })
        );
      }
    };
    var LineNumberRestartFormat = {
      /**
       * ## Restart Line Numbering on Each Page
       *
       * Specifies that line numbering for the parent section shall restart to the starting value whenever a new page is displayed.
       */
      NEW_PAGE: "newPage",
      /**
       * ## Restart Line Numbering for Each Section
       *
       * Specifies that line numbering for the parent section shall restart to the starting value whenever the parent begins.
       */
      NEW_SECTION: "newSection",
      /**
       * ## Continue Line Numbering From Previous Section
       *
       * Specifies that line numbering for the parent section shall continue from the line numbering from the end of the previous section, if any.
       */
      CONTINUOUS: "continuous"
    };
    var createLineNumberType2 = ({ countBy, start, restart, distance }) => new BuilderElement2({
      name: "w:lnNumType",
      attributes: {
        countBy: { key: "w:countBy", value: countBy === void 0 ? void 0 : decimalNumber2(countBy) },
        start: { key: "w:start", value: start === void 0 ? void 0 : decimalNumber2(start) },
        restart: { key: "w:restart", value: restart },
        distance: {
          key: "w:distance",
          value: distance === void 0 ? void 0 : twipsMeasureValue2(distance)
        }
      }
    });
    var PageBorderDisplay = {
      ALL_PAGES: "allPages",
      FIRST_PAGE: "firstPage",
      NOT_FIRST_PAGE: "notFirstPage"
    };
    var PageBorderOffsetFrom = {
      PAGE: "page",
      TEXT: "text"
    };
    var PageBorderZOrder = {
      BACK: "back",
      FRONT: "front"
    };
    var PageBordersAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", {
          display: "w:display",
          offsetFrom: "w:offsetFrom",
          zOrder: "w:zOrder"
        });
      }
    };
    var PageBorders2 = class extends IgnoreIfEmptyXmlComponent2 {
      constructor(options) {
        super("w:pgBorders");
        if (!options) {
          return this;
        }
        if (options.pageBorders) {
          this.root.push(
            new PageBordersAttributes2({
              display: options.pageBorders.display,
              offsetFrom: options.pageBorders.offsetFrom,
              zOrder: options.pageBorders.zOrder
            })
          );
        } else {
          this.root.push(new PageBordersAttributes2({}));
        }
        if (options.pageBorderTop) {
          this.root.push(new BorderElement2("w:top", options.pageBorderTop));
        }
        if (options.pageBorderLeft) {
          this.root.push(new BorderElement2("w:left", options.pageBorderLeft));
        }
        if (options.pageBorderBottom) {
          this.root.push(new BorderElement2("w:bottom", options.pageBorderBottom));
        }
        if (options.pageBorderRight) {
          this.root.push(new BorderElement2("w:right", options.pageBorderRight));
        }
      }
    };
    var PageMargin2 = class extends XmlComponent2 {
      constructor(top, right, bottom, left, header, footer, gutter) {
        super("w:pgMar");
        this.root.push(
          new NextAttributeComponent2({
            top: { key: "w:top", value: signedTwipsMeasureValue2(top) },
            right: { key: "w:right", value: twipsMeasureValue2(right) },
            bottom: { key: "w:bottom", value: signedTwipsMeasureValue2(bottom) },
            left: { key: "w:left", value: twipsMeasureValue2(left) },
            header: { key: "w:header", value: twipsMeasureValue2(header) },
            footer: { key: "w:footer", value: twipsMeasureValue2(footer) },
            gutter: { key: "w:gutter", value: twipsMeasureValue2(gutter) }
          })
        );
      }
    };
    var PageNumberSeparator = {
      HYPHEN: "hyphen",
      PERIOD: "period",
      COLON: "colon",
      EM_DASH: "emDash",
      EN_DASH: "endash"
    };
    var PageNumberTypeAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", {
          start: "w:start",
          formatType: "w:fmt",
          separator: "w:chapSep"
        });
      }
    };
    var PageNumberType2 = class extends XmlComponent2 {
      constructor({ start, formatType, separator }) {
        super("w:pgNumType");
        this.root.push(
          new PageNumberTypeAttributes2({
            start: start === void 0 ? void 0 : decimalNumber2(start),
            formatType,
            separator
          })
        );
      }
    };
    var PageOrientation2 = {
      /**
       * ## Portrait Mode
       *
       * Specifies that pages in this section shall be printed in portrait mode.
       */
      PORTRAIT: "portrait",
      /**
       * ## Landscape Mode
       *
       * Specifies that pages in this section shall be printed in landscape mode, which prints the page contents with a 90 degree rotation with respect to the normal page orientation.
       */
      LANDSCAPE: "landscape"
    };
    var createPageSize2 = ({ width, height, orientation, code }) => {
      const widthTwips = twipsMeasureValue2(width);
      const heightTwips = twipsMeasureValue2(height);
      return new BuilderElement2({
        name: "w:pgSz",
        attributes: {
          width: { key: "w:w", value: orientation === PageOrientation2.LANDSCAPE ? heightTwips : widthTwips },
          height: { key: "w:h", value: orientation === PageOrientation2.LANDSCAPE ? widthTwips : heightTwips },
          orientation: { key: "w:orient", value: orientation },
          code: { key: "w:code", value: code }
        }
      });
    };
    var PageTextDirectionType = {
      LEFT_TO_RIGHT_TOP_TO_BOTTOM: "lrTb",
      TOP_TO_BOTTOM_RIGHT_TO_LEFT: "tbRl"
    };
    var PageTextDirectionAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", { val: "w:val" });
      }
    };
    var PageTextDirection2 = class extends XmlComponent2 {
      constructor(value) {
        super("w:textDirection");
        this.root.push(
          new PageTextDirectionAttributes2({
            val: value
          })
        );
      }
    };
    var SectionType2 = {
      NEXT_PAGE: "nextPage",
      NEXT_COLUMN: "nextColumn",
      CONTINUOUS: "continuous",
      EVEN_PAGE: "evenPage",
      ODD_PAGE: "oddPage"
    };
    var SectionTypeAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", {
          val: "w:val"
        });
      }
    };
    var Type2 = class extends XmlComponent2 {
      constructor(value) {
        super("w:type");
        this.root.push(new SectionTypeAttributes2({ val: value }));
      }
    };
    var sectionMarginDefaults2 = {
      TOP: 1440,
      RIGHT: 1440,
      BOTTOM: 1440,
      LEFT: 1440,
      HEADER: 708,
      FOOTER: 708,
      GUTTER: 0
    };
    var sectionPageSizeDefaults2 = {
      WIDTH: 11906,
      HEIGHT: 16838,
      ORIENTATION: PageOrientation2.PORTRAIT
    };
    var SectionProperties2 = class extends XmlComponent2 {
      constructor({
        page: {
          size: {
            width = sectionPageSizeDefaults2.WIDTH,
            height = sectionPageSizeDefaults2.HEIGHT,
            orientation = sectionPageSizeDefaults2.ORIENTATION
          } = {},
          margin: {
            top = sectionMarginDefaults2.TOP,
            right = sectionMarginDefaults2.RIGHT,
            bottom = sectionMarginDefaults2.BOTTOM,
            left = sectionMarginDefaults2.LEFT,
            header = sectionMarginDefaults2.HEADER,
            footer = sectionMarginDefaults2.FOOTER,
            gutter = sectionMarginDefaults2.GUTTER
          } = {},
          pageNumbers = {},
          borders,
          textDirection
        } = {},
        grid: { linePitch = 360, charSpace, type: gridType } = {},
        headerWrapperGroup = {},
        footerWrapperGroup = {},
        lineNumbers,
        titlePage,
        verticalAlign,
        column,
        type: type22
      } = {}) {
        super("w:sectPr");
        this.addHeaderFooterGroup(HeaderFooterType2.HEADER, headerWrapperGroup);
        this.addHeaderFooterGroup(HeaderFooterType2.FOOTER, footerWrapperGroup);
        if (type22) {
          this.root.push(new Type2(type22));
        }
        this.root.push(createPageSize2({ width, height, orientation }));
        this.root.push(new PageMargin2(top, right, bottom, left, header, footer, gutter));
        if (borders) {
          this.root.push(new PageBorders2(borders));
        }
        if (lineNumbers) {
          this.root.push(createLineNumberType2(lineNumbers));
        }
        this.root.push(new PageNumberType2(pageNumbers));
        if (column) {
          this.root.push(new Columns2(column));
        }
        if (verticalAlign) {
          this.root.push(new VerticalAlignElement2(verticalAlign));
        }
        if (titlePage !== void 0) {
          this.root.push(new OnOffElement2("w:titlePg", titlePage));
        }
        if (textDirection) {
          this.root.push(new PageTextDirection2(textDirection));
        }
        this.root.push(createDocumentGrid2({ linePitch, charSpace, type: gridType }));
      }
      addHeaderFooterGroup(type22, group) {
        if (group.default) {
          this.root.push(
            new HeaderFooterReference2(type22, {
              type: HeaderFooterReferenceType2.DEFAULT,
              id: group.default.View.ReferenceId
            })
          );
        }
        if (group.first) {
          this.root.push(
            new HeaderFooterReference2(type22, {
              type: HeaderFooterReferenceType2.FIRST,
              id: group.first.View.ReferenceId
            })
          );
        }
        if (group.even) {
          this.root.push(
            new HeaderFooterReference2(type22, {
              type: HeaderFooterReferenceType2.EVEN,
              id: group.even.View.ReferenceId
            })
          );
        }
      }
    };
    var Body2 = class extends XmlComponent2 {
      constructor() {
        super("w:body");
        __publicField2(this, "sections", []);
      }
      /**
       * Adds new section properties.
       * Note: Previous section is created in paragraph after the current element, and then new section will be added.
       * The spec says:
       *  - section element should be in the last paragraph of the section
       *  - last section should be direct child of body
       *
       * @param options new section options
       */
      addSection(options) {
        const currentSection = this.sections.pop();
        this.root.push(this.createSectionParagraph(currentSection));
        this.sections.push(new SectionProperties2(options));
      }
      prepForXml(context) {
        if (this.sections.length === 1) {
          this.root.splice(0, 1);
          this.root.push(this.sections.pop());
        }
        return super.prepForXml(context);
      }
      push(component) {
        this.root.push(component);
      }
      createSectionParagraph(section) {
        const paragraph = new Paragraph3({});
        const properties = new ParagraphProperties2({});
        properties.push(section);
        paragraph.addChildElement(properties);
        return paragraph;
      }
    };
    var Column = class extends XmlComponent2 {
      constructor({ width, space }) {
        super("w:col");
        this.root.push(
          new NextAttributeComponent2({
            width: { key: "w:w", value: twipsMeasureValue2(width) },
            space: { key: "w:space", value: space === void 0 ? void 0 : twipsMeasureValue2(space) }
          })
        );
      }
    };
    var DocumentAttributeNamespaces2 = {
      wpc: "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas",
      mc: "http://schemas.openxmlformats.org/markup-compatibility/2006",
      o: "urn:schemas-microsoft-com:office:office",
      r: "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
      m: "http://schemas.openxmlformats.org/officeDocument/2006/math",
      v: "urn:schemas-microsoft-com:vml",
      wp14: "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
      wp: "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
      w10: "urn:schemas-microsoft-com:office:word",
      w: "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
      w14: "http://schemas.microsoft.com/office/word/2010/wordml",
      w15: "http://schemas.microsoft.com/office/word/2012/wordml",
      wpg: "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
      wpi: "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
      wne: "http://schemas.microsoft.com/office/word/2006/wordml",
      wps: "http://schemas.microsoft.com/office/word/2010/wordprocessingShape",
      cp: "http://schemas.openxmlformats.org/package/2006/metadata/core-properties",
      dc: "http://purl.org/dc/elements/1.1/",
      dcterms: "http://purl.org/dc/terms/",
      dcmitype: "http://purl.org/dc/dcmitype/",
      xsi: "http://www.w3.org/2001/XMLSchema-instance",
      cx: "http://schemas.microsoft.com/office/drawing/2014/chartex",
      cx1: "http://schemas.microsoft.com/office/drawing/2015/9/8/chartex",
      cx2: "http://schemas.microsoft.com/office/drawing/2015/10/21/chartex",
      cx3: "http://schemas.microsoft.com/office/drawing/2016/5/9/chartex",
      cx4: "http://schemas.microsoft.com/office/drawing/2016/5/10/chartex",
      cx5: "http://schemas.microsoft.com/office/drawing/2016/5/11/chartex",
      cx6: "http://schemas.microsoft.com/office/drawing/2016/5/12/chartex",
      cx7: "http://schemas.microsoft.com/office/drawing/2016/5/13/chartex",
      cx8: "http://schemas.microsoft.com/office/drawing/2016/5/14/chartex",
      aink: "http://schemas.microsoft.com/office/drawing/2016/ink",
      am3d: "http://schemas.microsoft.com/office/drawing/2017/model3d",
      w16cex: "http://schemas.microsoft.com/office/word/2018/wordml/cex",
      w16cid: "http://schemas.microsoft.com/office/word/2016/wordml/cid",
      w16: "http://schemas.microsoft.com/office/word/2018/wordml",
      w16sdtdh: "http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash",
      w16se: "http://schemas.microsoft.com/office/word/2015/wordml/symex"
    };
    var DocumentAttributes2 = class extends XmlAttributeComponent2 {
      constructor(ns, Ignorable) {
        super(__spreadValues2({ Ignorable }, Object.fromEntries(ns.map((n) => [n, DocumentAttributeNamespaces2[n]]))));
        __publicField2(this, "xmlKeys", __spreadValues2({
          Ignorable: "mc:Ignorable"
        }, Object.fromEntries(Object.keys(DocumentAttributeNamespaces2).map((key) => [key, `xmlns:${key}`]))));
      }
    };
    var DocumentBackgroundAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", {
          color: "w:color",
          themeColor: "w:themeColor",
          themeShade: "w:themeShade",
          themeTint: "w:themeTint"
        });
      }
    };
    var DocumentBackground2 = class extends XmlComponent2 {
      constructor(options) {
        super("w:background");
        this.root.push(
          new DocumentBackgroundAttributes2({
            color: options.color === void 0 ? void 0 : hexColorValue2(options.color),
            themeColor: options.themeColor,
            themeShade: options.themeShade === void 0 ? void 0 : uCharHexNumber2(options.themeShade),
            themeTint: options.themeTint === void 0 ? void 0 : uCharHexNumber2(options.themeTint)
          })
        );
      }
    };
    var Document2 = class extends XmlComponent2 {
      constructor(options) {
        super("w:document");
        __publicField2(this, "body");
        this.root.push(
          new DocumentAttributes2(
            [
              "wpc",
              "mc",
              "o",
              "r",
              "m",
              "v",
              "wp14",
              "wp",
              "w10",
              "w",
              "w14",
              "w15",
              "wpg",
              "wpi",
              "wne",
              "wps",
              "cx",
              "cx1",
              "cx2",
              "cx3",
              "cx4",
              "cx5",
              "cx6",
              "cx7",
              "cx8",
              "aink",
              "am3d",
              "w16cex",
              "w16cid",
              "w16",
              "w16sdtdh",
              "w16se"
            ],
            "w14 w15 wp14"
          )
        );
        this.body = new Body2();
        if (options.background) {
          this.root.push(new DocumentBackground2(options.background));
        }
        this.root.push(this.body);
      }
      add(item) {
        this.body.push(item);
        return this;
      }
      get Body() {
        return this.body;
      }
    };
    var DocumentWrapper2 = class {
      constructor(options) {
        __publicField2(this, "document");
        __publicField2(this, "relationships");
        this.document = new Document2(options);
        this.relationships = new Relationships2();
      }
      get View() {
        return this.document;
      }
      get Relationships() {
        return this.relationships;
      }
    };
    var WordWrapAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", { val: "w:val" });
      }
    };
    var WordWrap2 = class extends XmlComponent2 {
      constructor() {
        super("w:wordWrap");
        this.root.push(new WordWrapAttributes2({ val: 0 }));
      }
    };
    var DropCapType = {
      NONE: "none",
      DROP: "drop",
      MARGIN: "margin"
    };
    var FrameAnchorType = {
      MARGIN: "margin",
      PAGE: "page",
      TEXT: "text"
    };
    var FrameWrap = {
      AROUND: "around",
      AUTO: "auto",
      NONE: "none",
      NOT_BESIDE: "notBeside",
      THROUGH: "through",
      TIGHT: "tight"
    };
    var createFrameProperties2 = (options) => {
      var _a, _b;
      return new BuilderElement2({
        name: "w:framePr",
        attributes: {
          anchorLock: {
            key: "w:anchorLock",
            value: options.anchorLock
          },
          dropCap: {
            key: "w:dropCap",
            value: options.dropCap
          },
          width: {
            key: "w:w",
            value: options.width
          },
          height: {
            key: "w:h",
            value: options.height
          },
          x: {
            key: "w:x",
            value: options.position ? options.position.x : void 0
          },
          y: {
            key: "w:y",
            value: options.position ? options.position.y : void 0
          },
          anchorHorizontal: {
            key: "w:hAnchor",
            value: options.anchor.horizontal
          },
          anchorVertical: {
            key: "w:vAnchor",
            value: options.anchor.vertical
          },
          spaceHorizontal: {
            key: "w:hSpace",
            value: (_a = options.space) == null ? void 0 : _a.horizontal
          },
          spaceVertical: {
            key: "w:vSpace",
            value: (_b = options.space) == null ? void 0 : _b.vertical
          },
          rule: {
            key: "w:hRule",
            value: options.rule
          },
          alignmentX: {
            key: "w:xAlign",
            value: options.alignment ? options.alignment.x : void 0
          },
          alignmentY: {
            key: "w:yAlign",
            value: options.alignment ? options.alignment.y : void 0
          },
          lines: {
            key: "w:lines",
            value: options.lines
          },
          wrap: {
            key: "w:wrap",
            value: options.wrap
          }
        }
      });
    };
    var ParagraphProperties2 = class extends IgnoreIfEmptyXmlComponent2 {
      constructor(options) {
        var _a, _b;
        super("w:pPr");
        __publicField2(this, "numberingReferences", []);
        if (!options) {
          return this;
        }
        if (options.heading) {
          this.push(new Style$12(options.heading));
        }
        if (options.bullet) {
          this.push(new Style$12("ListParagraph"));
        }
        if (options.numbering) {
          if (!options.style && !options.heading) {
            if (!options.numbering.custom) {
              this.push(new Style$12("ListParagraph"));
            }
          }
        }
        if (options.style) {
          this.push(new Style$12(options.style));
        }
        if (options.keepNext !== void 0) {
          this.push(new OnOffElement2("w:keepNext", options.keepNext));
        }
        if (options.keepLines !== void 0) {
          this.push(new OnOffElement2("w:keepLines", options.keepLines));
        }
        if (options.pageBreakBefore) {
          this.push(new PageBreakBefore2());
        }
        if (options.frame) {
          this.push(createFrameProperties2(options.frame));
        }
        if (options.widowControl !== void 0) {
          this.push(new OnOffElement2("w:widowControl", options.widowControl));
        }
        if (options.bullet) {
          this.push(new NumberProperties2(1, options.bullet.level));
        }
        if (options.numbering) {
          this.numberingReferences.push({
            reference: options.numbering.reference,
            instance: (_a = options.numbering.instance) != null ? _a : 0
          });
          this.push(new NumberProperties2(`${options.numbering.reference}-${(_b = options.numbering.instance) != null ? _b : 0}`, options.numbering.level));
        } else if (options.numbering === false) {
          this.push(new NumberProperties2(0, 0));
        }
        if (options.border) {
          this.push(new Border2(options.border));
        }
        if (options.thematicBreak) {
          this.push(new ThematicBreak2());
        }
        if (options.shading) {
          this.push(new Shading2(options.shading));
        }
        if (options.wordWrap) {
          this.push(new WordWrap2());
        }
        if (options.overflowPunctuation) {
          this.push(new OnOffElement2("w:overflowPunct", options.overflowPunctuation));
        }
        const tabDefinitions = [
          ...options.rightTabStop !== void 0 ? [{ type: TabStopType2.RIGHT, position: options.rightTabStop }] : [],
          ...options.tabStops ? options.tabStops : [],
          ...options.leftTabStop !== void 0 ? [{ type: TabStopType2.LEFT, position: options.leftTabStop }] : []
        ];
        if (tabDefinitions.length > 0) {
          this.push(new TabStop2(tabDefinitions));
        }
        if (options.bidirectional !== void 0) {
          this.push(new OnOffElement2("w:bidi", options.bidirectional));
        }
        if (options.spacing) {
          this.push(new Spacing2(options.spacing));
        }
        if (options.indent) {
          this.push(new Indent2(options.indent));
        }
        if (options.contextualSpacing !== void 0) {
          this.push(new OnOffElement2("w:contextualSpacing", options.contextualSpacing));
        }
        if (options.alignment) {
          this.push(new Alignment2(options.alignment));
        }
        if (options.outlineLevel !== void 0) {
          this.push(new OutlineLevel2(options.outlineLevel));
        }
        if (options.suppressLineNumbers !== void 0) {
          this.push(new OnOffElement2("w:suppressLineNumbers", options.suppressLineNumbers));
        }
        if (options.autoSpaceEastAsianText !== void 0) {
          this.push(new OnOffElement2("w:autoSpaceDN", options.autoSpaceEastAsianText));
        }
        if (options.run) {
          this.push(new RunProperties2(options.run));
        }
      }
      push(item) {
        this.root.push(item);
      }
      prepForXml(context) {
        if (context.viewWrapper instanceof DocumentWrapper2) {
          for (const reference of this.numberingReferences) {
            context.file.Numbering.createConcreteNumberingInstance(reference.reference, reference.instance);
          }
        }
        return super.prepForXml(context);
      }
    };
    var Paragraph3 = class extends FileChild2 {
      constructor(options) {
        super("w:p");
        __publicField2(this, "properties");
        if (typeof options === "string") {
          this.properties = new ParagraphProperties2({});
          this.root.push(this.properties);
          this.root.push(new TextRun3(options));
          return this;
        }
        this.properties = new ParagraphProperties2(options);
        this.root.push(this.properties);
        if (options.text) {
          this.root.push(new TextRun3(options.text));
        }
        if (options.children) {
          for (const child of options.children) {
            if (child instanceof Bookmark2) {
              this.root.push(child.start);
              for (const textRun of child.children) {
                this.root.push(textRun);
              }
              this.root.push(child.end);
              continue;
            }
            this.root.push(child);
          }
        }
      }
      prepForXml(context) {
        for (const element of this.root) {
          if (element instanceof ExternalHyperlink2) {
            const index = this.root.indexOf(element);
            const concreteHyperlink = new ConcreteHyperlink2(element.options.children, uniqueId2());
            context.viewWrapper.Relationships.createRelationship(
              concreteHyperlink.linkId,
              "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink",
              element.options.link,
              TargetModeType2.EXTERNAL
            );
            this.root[index] = concreteHyperlink;
          }
        }
        return super.prepForXml(context);
      }
      addRunToFront(run) {
        this.root.splice(1, 0, run);
        return this;
      }
    };
    var Math$12 = class Math2 extends XmlComponent2 {
      constructor(options) {
        super("m:oMath");
        for (const child of options.children) {
          this.root.push(child);
        }
      }
    };
    var MathText2 = class extends XmlComponent2 {
      constructor(text) {
        super("m:t");
        this.root.push(text);
      }
    };
    var MathRun2 = class extends XmlComponent2 {
      constructor(text) {
        super("m:r");
        this.root.push(new MathText2(text));
      }
    };
    var MathDenominator = class extends XmlComponent2 {
      constructor(children) {
        super("m:den");
        for (const child of children) {
          this.root.push(child);
        }
      }
    };
    var MathNumerator = class extends XmlComponent2 {
      constructor(children) {
        super("m:num");
        for (const child of children) {
          this.root.push(child);
        }
      }
    };
    var MathFraction = class extends XmlComponent2 {
      constructor(options) {
        super("m:f");
        this.root.push(new MathNumerator(options.numerator));
        this.root.push(new MathDenominator(options.denominator));
      }
    };
    var createMathAccentCharacter = ({ accent }) => new BuilderElement2({
      name: "m:chr",
      attributes: {
        accent: { key: "m:val", value: accent }
      }
    });
    var createMathBase = ({ children }) => new BuilderElement2({
      name: "m:e",
      children
    });
    var createMathLimitLocation = ({ value }) => new BuilderElement2({
      name: "m:limLoc",
      attributes: {
        value: { key: "m:val", value: value || "undOvr" }
      }
    });
    var createMathSubScriptHide = () => new BuilderElement2({
      name: "m:subHide",
      attributes: {
        hide: { key: "m:val", value: 1 }
      }
    });
    var createMathSuperScriptHide = () => new BuilderElement2({
      name: "m:supHide",
      attributes: {
        hide: { key: "m:val", value: 1 }
      }
    });
    var createMathNAryProperties = ({
      accent,
      hasSuperScript,
      hasSubScript,
      limitLocationVal
    }) => new BuilderElement2({
      name: "m:naryPr",
      children: [
        ...!!accent ? [createMathAccentCharacter({ accent })] : [],
        createMathLimitLocation({ value: limitLocationVal }),
        ...!hasSuperScript ? [createMathSuperScriptHide()] : [],
        ...!hasSubScript ? [createMathSubScriptHide()] : []
      ]
    });
    var createMathSubScriptElement = ({ children }) => new BuilderElement2({
      name: "m:sub",
      children
    });
    var createMathSuperScriptElement = ({ children }) => new BuilderElement2({
      name: "m:sup",
      children
    });
    var MathSum = class extends XmlComponent2 {
      constructor(options) {
        super("m:nary");
        this.root.push(
          createMathNAryProperties({
            accent: "\u2211",
            hasSuperScript: !!options.superScript,
            hasSubScript: !!options.subScript
          })
        );
        if (!!options.subScript) {
          this.root.push(createMathSubScriptElement({ children: options.subScript }));
        }
        if (!!options.superScript) {
          this.root.push(createMathSuperScriptElement({ children: options.superScript }));
        }
        this.root.push(createMathBase({ children: options.children }));
      }
    };
    var MathIntegral = class extends XmlComponent2 {
      constructor(options) {
        super("m:nary");
        this.root.push(
          createMathNAryProperties({
            accent: "",
            hasSuperScript: !!options.superScript,
            hasSubScript: !!options.subScript,
            limitLocationVal: "subSup"
          })
        );
        if (!!options.subScript) {
          this.root.push(createMathSubScriptElement({ children: options.subScript }));
        }
        if (!!options.superScript) {
          this.root.push(createMathSuperScriptElement({ children: options.superScript }));
        }
        this.root.push(createMathBase({ children: options.children }));
      }
    };
    var MathLimit = class extends XmlComponent2 {
      constructor(children) {
        super("m:lim");
        for (const child of children) {
          this.root.push(child);
        }
      }
    };
    var MathLimitUpper = class extends XmlComponent2 {
      constructor(options) {
        super("m:limUpp");
        this.root.push(createMathBase({ children: options.children }));
        this.root.push(new MathLimit(options.limit));
      }
    };
    var MathLimitLower = class extends XmlComponent2 {
      constructor(options) {
        super("m:limLow");
        this.root.push(createMathBase({ children: options.children }));
        this.root.push(new MathLimit(options.limit));
      }
    };
    var createMathSuperScriptProperties = () => new BuilderElement2({
      name: "m:sSupPr"
    });
    var MathSuperScript = class extends XmlComponent2 {
      constructor(options) {
        super("m:sSup");
        this.root.push(createMathSuperScriptProperties());
        this.root.push(createMathBase({ children: options.children }));
        this.root.push(createMathSuperScriptElement({ children: options.superScript }));
      }
    };
    var createMathSubScriptProperties = () => new BuilderElement2({
      name: "m:sSubPr"
    });
    var MathSubScript = class extends XmlComponent2 {
      constructor(options) {
        super("m:sSub");
        this.root.push(createMathSubScriptProperties());
        this.root.push(createMathBase({ children: options.children }));
        this.root.push(createMathSubScriptElement({ children: options.subScript }));
      }
    };
    var createMathSubSuperScriptProperties = () => new BuilderElement2({
      name: "m:sSubSupPr"
    });
    var MathSubSuperScript = class extends XmlComponent2 {
      constructor(options) {
        super("m:sSubSup");
        this.root.push(createMathSubSuperScriptProperties());
        this.root.push(createMathBase({ children: options.children }));
        this.root.push(createMathSubScriptElement({ children: options.subScript }));
        this.root.push(createMathSuperScriptElement({ children: options.superScript }));
      }
    };
    var createMathPreSubSuperScriptProperties = () => new BuilderElement2({
      name: "m:sPrePr"
    });
    var MathPreSubSuperScript = class extends BuilderElement2 {
      constructor({ children, subScript, superScript }) {
        super({
          name: "m:sPre",
          children: [
            createMathPreSubSuperScriptProperties(),
            createMathBase({ children }),
            createMathSubScriptElement({ children: subScript }),
            createMathSuperScriptElement({ children: superScript })
          ]
        });
      }
    };
    var WORKAROUND4 = "";
    var MathDegree = class extends XmlComponent2 {
      constructor(children) {
        super("m:deg");
        if (!!children) {
          for (const child of children) {
            this.root.push(child);
          }
        }
      }
    };
    var MathDegreeHideAttributes = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", { hide: "m:val" });
      }
    };
    var MathDegreeHide = class extends XmlComponent2 {
      constructor() {
        super("m:degHide");
        this.root.push(new MathDegreeHideAttributes({ hide: 1 }));
      }
    };
    var MathRadicalProperties = class extends XmlComponent2 {
      constructor(hasDegree) {
        super("m:radPr");
        if (!hasDegree) {
          this.root.push(new MathDegreeHide());
        }
      }
    };
    var MathRadical = class extends XmlComponent2 {
      constructor(options) {
        super("m:rad");
        this.root.push(new MathRadicalProperties(!!options.degree));
        this.root.push(new MathDegree(options.degree));
        this.root.push(createMathBase({ children: options.children }));
      }
    };
    var MathFunctionName = class extends XmlComponent2 {
      constructor(children) {
        super("m:fName");
        for (const child of children) {
          this.root.push(child);
        }
      }
    };
    var MathFunctionProperties = class extends XmlComponent2 {
      constructor() {
        super("m:funcPr");
      }
    };
    var MathFunction = class extends XmlComponent2 {
      constructor(options) {
        super("m:func");
        this.root.push(new MathFunctionProperties());
        this.root.push(new MathFunctionName(options.name));
        this.root.push(createMathBase({ children: options.children }));
      }
    };
    var createMathBeginningCharacter = ({ character }) => new BuilderElement2({
      name: "m:begChr",
      attributes: {
        character: { key: "m:val", value: character }
      }
    });
    var createMathEndingCharacter = ({ character }) => new BuilderElement2({
      name: "m:endChr",
      attributes: {
        character: { key: "m:val", value: character }
      }
    });
    var createMathBracketProperties = ({ characters }) => new BuilderElement2({
      name: "m:dPr",
      children: !!characters ? [
        createMathBeginningCharacter({ character: characters.beginningCharacter }),
        createMathEndingCharacter({ character: characters.endingCharacter })
      ] : []
    });
    var MathRoundBrackets = class extends XmlComponent2 {
      constructor(options) {
        super("m:d");
        this.root.push(createMathBracketProperties({}));
        this.root.push(createMathBase({ children: options.children }));
      }
    };
    var MathSquareBrackets = class extends XmlComponent2 {
      constructor(options) {
        super("m:d");
        this.root.push(
          createMathBracketProperties({
            characters: {
              beginningCharacter: "[",
              endingCharacter: "]"
            }
          })
        );
        this.root.push(createMathBase({ children: options.children }));
      }
    };
    var MathCurlyBrackets = class extends XmlComponent2 {
      constructor(options) {
        super("m:d");
        this.root.push(
          createMathBracketProperties({
            characters: {
              beginningCharacter: "{",
              endingCharacter: "}"
            }
          })
        );
        this.root.push(createMathBase({ children: options.children }));
      }
    };
    var MathAngledBrackets = class extends XmlComponent2 {
      constructor(options) {
        super("m:d");
        this.root.push(
          createMathBracketProperties({
            characters: {
              beginningCharacter: "\u2329",
              endingCharacter: "\u232A"
            }
          })
        );
        this.root.push(createMathBase({ children: options.children }));
      }
    };
    var TableGrid2 = class extends XmlComponent2 {
      constructor(widths) {
        super("w:tblGrid");
        for (const width of widths) {
          this.root.push(new GridCol2(width));
        }
      }
    };
    var GridCol2 = class extends XmlComponent2 {
      constructor(width) {
        super("w:gridCol");
        if (width !== void 0) {
          this.root.push(
            new NextAttributeComponent2({
              width: { key: "w:w", value: twipsMeasureValue2(width) }
            })
          );
        }
      }
    };
    var TableCellMarginElementType2 = {
      TABLE: "w:tblCellMar",
      TABLE_CELL: "w:tcMar"
    };
    var TableCellMargin2 = class extends IgnoreIfEmptyXmlComponent2 {
      constructor(type22, { marginUnitType = WidthType2.DXA, top, left, bottom, right }) {
        super(type22);
        if (top !== void 0) {
          this.root.push(new TableWidthElement2("w:top", { type: marginUnitType, size: top }));
        }
        if (left !== void 0) {
          this.root.push(new TableWidthElement2("w:left", { type: marginUnitType, size: left }));
        }
        if (bottom !== void 0) {
          this.root.push(new TableWidthElement2("w:bottom", { type: marginUnitType, size: bottom }));
        }
        if (right !== void 0) {
          this.root.push(new TableWidthElement2("w:right", { type: marginUnitType, size: right }));
        }
      }
    };
    var WidthType2 = {
      /** Auto. */
      AUTO: "auto",
      /** Value is in twentieths of a point */
      DXA: "dxa",
      /** No (empty) value. */
      NIL: "nil",
      /** Value is in percentage. */
      PERCENTAGE: "pct"
    };
    var TableWidthElement2 = class extends XmlComponent2 {
      constructor(name, { type: type22 = WidthType2.AUTO, size }) {
        super(name);
        let tableWidthValue = size;
        if (type22 === WidthType2.PERCENTAGE && typeof size === "number") {
          tableWidthValue = `${size}%`;
        }
        this.root.push(
          new NextAttributeComponent2({
            type: { key: "w:type", value: type22 },
            size: { key: "w:w", value: measurementOrPercentValue2(tableWidthValue) }
          })
        );
      }
    };
    var TableCellBorders2 = class extends IgnoreIfEmptyXmlComponent2 {
      constructor(options) {
        super("w:tcBorders");
        if (options.top) {
          this.root.push(new BorderElement2("w:top", options.top));
        }
        if (options.start) {
          this.root.push(new BorderElement2("w:start", options.start));
        }
        if (options.left) {
          this.root.push(new BorderElement2("w:left", options.left));
        }
        if (options.bottom) {
          this.root.push(new BorderElement2("w:bottom", options.bottom));
        }
        if (options.end) {
          this.root.push(new BorderElement2("w:end", options.end));
        }
        if (options.right) {
          this.root.push(new BorderElement2("w:right", options.right));
        }
      }
    };
    var GridSpanAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", { val: "w:val" });
      }
    };
    var GridSpan2 = class extends XmlComponent2 {
      constructor(value) {
        super("w:gridSpan");
        this.root.push(
          new GridSpanAttributes2({
            val: decimalNumber2(value)
          })
        );
      }
    };
    var VerticalMergeType2 = {
      /**
       * Cell that is merged with upper one.
       */
      CONTINUE: "continue",
      /**
       * Cell that is starting the vertical merge.
       */
      RESTART: "restart"
    };
    var VerticalMergeAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", { val: "w:val" });
      }
    };
    var VerticalMerge2 = class extends XmlComponent2 {
      constructor(value) {
        super("w:vMerge");
        this.root.push(
          new VerticalMergeAttributes2({
            val: value
          })
        );
      }
    };
    var TextDirection = {
      BOTTOM_TO_TOP_LEFT_TO_RIGHT: "btLr",
      LEFT_TO_RIGHT_TOP_TO_BOTTOM: "lrTb",
      TOP_TO_BOTTOM_RIGHT_TO_LEFT: "tbRl"
    };
    var TDirectionAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", { val: "w:val" });
      }
    };
    var TDirection2 = class extends XmlComponent2 {
      constructor(value) {
        super("w:textDirection");
        this.root.push(
          new TDirectionAttributes2({
            val: value
          })
        );
      }
    };
    var TableCellProperties2 = class extends IgnoreIfEmptyXmlComponent2 {
      constructor(options) {
        super("w:tcPr");
        if (options.width) {
          this.root.push(new TableWidthElement2("w:tcW", options.width));
        }
        if (options.columnSpan) {
          this.root.push(new GridSpan2(options.columnSpan));
        }
        if (options.verticalMerge) {
          this.root.push(new VerticalMerge2(options.verticalMerge));
        } else if (options.rowSpan && options.rowSpan > 1) {
          this.root.push(new VerticalMerge2(VerticalMergeType2.RESTART));
        }
        if (options.borders) {
          this.root.push(new TableCellBorders2(options.borders));
        }
        if (options.shading) {
          this.root.push(new Shading2(options.shading));
        }
        if (options.margins) {
          this.root.push(new TableCellMargin2(TableCellMarginElementType2.TABLE_CELL, options.margins));
        }
        if (options.textDirection) {
          this.root.push(new TDirection2(options.textDirection));
        }
        if (options.verticalAlign) {
          this.root.push(new VerticalAlignElement2(options.verticalAlign));
        }
      }
    };
    var TableCell2 = class extends XmlComponent2 {
      constructor(options) {
        super("w:tc");
        this.options = options;
        this.root.push(new TableCellProperties2(options));
        for (const child of options.children) {
          this.root.push(child);
        }
      }
      prepForXml(context) {
        if (!(this.root[this.root.length - 1] instanceof Paragraph3)) {
          this.root.push(new Paragraph3({}));
        }
        return super.prepForXml(context);
      }
    };
    var NONE_BORDER2 = {
      style: BorderStyle2.NONE,
      size: 0,
      color: "auto"
    };
    var DEFAULT_BORDER2 = {
      style: BorderStyle2.SINGLE,
      size: 4,
      color: "auto"
    };
    var TableBorders2 = class extends XmlComponent2 {
      constructor(options) {
        super("w:tblBorders");
        if (options.top) {
          this.root.push(new BorderElement2("w:top", options.top));
        } else {
          this.root.push(new BorderElement2("w:top", DEFAULT_BORDER2));
        }
        if (options.left) {
          this.root.push(new BorderElement2("w:left", options.left));
        } else {
          this.root.push(new BorderElement2("w:left", DEFAULT_BORDER2));
        }
        if (options.bottom) {
          this.root.push(new BorderElement2("w:bottom", options.bottom));
        } else {
          this.root.push(new BorderElement2("w:bottom", DEFAULT_BORDER2));
        }
        if (options.right) {
          this.root.push(new BorderElement2("w:right", options.right));
        } else {
          this.root.push(new BorderElement2("w:right", DEFAULT_BORDER2));
        }
        if (options.insideHorizontal) {
          this.root.push(new BorderElement2("w:insideH", options.insideHorizontal));
        } else {
          this.root.push(new BorderElement2("w:insideH", DEFAULT_BORDER2));
        }
        if (options.insideVertical) {
          this.root.push(new BorderElement2("w:insideV", options.insideVertical));
        } else {
          this.root.push(new BorderElement2("w:insideV", DEFAULT_BORDER2));
        }
      }
    };
    __publicField2(TableBorders2, "NONE", {
      top: NONE_BORDER2,
      bottom: NONE_BORDER2,
      left: NONE_BORDER2,
      right: NONE_BORDER2,
      insideHorizontal: NONE_BORDER2,
      insideVertical: NONE_BORDER2
    });
    var TableAnchorType = {
      MARGIN: "margin",
      PAGE: "page",
      TEXT: "text"
    };
    var RelativeHorizontalPosition = {
      CENTER: "center",
      INSIDE: "inside",
      LEFT: "left",
      OUTSIDE: "outside",
      RIGHT: "right"
    };
    var RelativeVerticalPosition = {
      CENTER: "center",
      INSIDE: "inside",
      BOTTOM: "bottom",
      OUTSIDE: "outside",
      INLINE: "inline",
      TOP: "top"
    };
    var OverlapType = {
      NEVER: "never",
      OVERLAP: "overlap"
    };
    var TableFloatProperties2 = class extends XmlComponent2 {
      constructor({
        horizontalAnchor,
        verticalAnchor,
        absoluteHorizontalPosition,
        relativeHorizontalPosition,
        absoluteVerticalPosition,
        relativeVerticalPosition,
        bottomFromText,
        topFromText,
        leftFromText,
        rightFromText,
        overlap
      }) {
        super("w:tblpPr");
        this.root.push(
          new NextAttributeComponent2({
            leftFromText: {
              key: "w:leftFromText",
              value: leftFromText === void 0 ? void 0 : twipsMeasureValue2(leftFromText)
            },
            rightFromText: {
              key: "w:rightFromText",
              value: rightFromText === void 0 ? void 0 : twipsMeasureValue2(rightFromText)
            },
            topFromText: {
              key: "w:topFromText",
              value: topFromText === void 0 ? void 0 : twipsMeasureValue2(topFromText)
            },
            bottomFromText: {
              key: "w:bottomFromText",
              value: bottomFromText === void 0 ? void 0 : twipsMeasureValue2(bottomFromText)
            },
            absoluteHorizontalPosition: {
              key: "w:tblpX",
              value: absoluteHorizontalPosition === void 0 ? void 0 : signedTwipsMeasureValue2(absoluteHorizontalPosition)
            },
            absoluteVerticalPosition: {
              key: "w:tblpY",
              value: absoluteVerticalPosition === void 0 ? void 0 : signedTwipsMeasureValue2(absoluteVerticalPosition)
            },
            horizontalAnchor: {
              key: "w:horzAnchor",
              value: horizontalAnchor === void 0 ? void 0 : horizontalAnchor
            },
            relativeHorizontalPosition: {
              key: "w:tblpXSpec",
              value: relativeHorizontalPosition
            },
            relativeVerticalPosition: {
              key: "w:tblpYSpec",
              value: relativeVerticalPosition
            },
            verticalAnchor: {
              key: "w:vertAnchor",
              value: verticalAnchor
            }
          })
        );
        if (overlap) {
          this.root.push(new StringEnumValueElement2("w:tblOverlap", overlap));
        }
      }
    };
    var TableLayoutType = {
      AUTOFIT: "autofit",
      FIXED: "fixed"
    };
    var TableLayoutAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", { type: "w:type" });
      }
    };
    var TableLayout2 = class extends XmlComponent2 {
      constructor(type22) {
        super("w:tblLayout");
        this.root.push(new TableLayoutAttributes2({ type: type22 }));
      }
    };
    var CellSpacingType2 = {
      /** Value is in twentieths of a point */
      DXA: "dxa"
    };
    var TableCellSpacingElement2 = class extends XmlComponent2 {
      constructor({ type: type22 = CellSpacingType2.DXA, value }) {
        super("w:tblCellSpacing");
        this.root.push(
          new NextAttributeComponent2({
            type: { key: "w:type", value: type22 },
            value: { key: "w:w", value: measurementOrPercentValue2(value) }
          })
        );
      }
    };
    var TableProperties2 = class extends IgnoreIfEmptyXmlComponent2 {
      constructor(options) {
        super("w:tblPr");
        if (options.style) {
          this.root.push(new StringValueElement2("w:tblStyle", options.style));
        }
        if (options.float) {
          this.root.push(new TableFloatProperties2(options.float));
        }
        if (options.visuallyRightToLeft !== void 0) {
          this.root.push(new OnOffElement2("w:bidiVisual", options.visuallyRightToLeft));
        }
        if (options.width) {
          this.root.push(new TableWidthElement2("w:tblW", options.width));
        }
        if (options.alignment) {
          this.root.push(new Alignment2(options.alignment));
        }
        if (options.indent) {
          this.root.push(new TableWidthElement2("w:tblInd", options.indent));
        }
        if (options.borders) {
          this.root.push(new TableBorders2(options.borders));
        }
        if (options.shading) {
          this.root.push(new Shading2(options.shading));
        }
        if (options.layout) {
          this.root.push(new TableLayout2(options.layout));
        }
        if (options.cellMargin) {
          this.root.push(new TableCellMargin2(TableCellMarginElementType2.TABLE, options.cellMargin));
        }
        if (options.cellSpacing) {
          this.root.push(new TableCellSpacingElement2(options.cellSpacing));
        }
      }
    };
    var Table2 = class extends FileChild2 {
      constructor({
        rows,
        width,
        // eslint-disable-next-line functional/immutable-data
        columnWidths = Array(Math.max(...rows.map((row) => row.CellCount))).fill(100),
        margins,
        indent,
        float,
        layout,
        style,
        borders,
        alignment,
        visuallyRightToLeft,
        cellSpacing
      }) {
        super("w:tbl");
        this.root.push(
          new TableProperties2({
            borders: borders != null ? borders : {},
            width: width != null ? width : { size: 100 },
            indent,
            float,
            layout,
            style,
            alignment,
            cellMargin: margins,
            visuallyRightToLeft,
            cellSpacing
          })
        );
        this.root.push(new TableGrid2(columnWidths));
        for (const row of rows) {
          this.root.push(row);
        }
        rows.forEach((row, rowIndex) => {
          if (rowIndex === rows.length - 1) {
            return;
          }
          let columnIndex = 0;
          row.cells.forEach((cell) => {
            if (cell.options.rowSpan && cell.options.rowSpan > 1) {
              const continueCell = new TableCell2({
                // the inserted CONTINUE cell has rowSpan, and will be handled when process the next row
                rowSpan: cell.options.rowSpan - 1,
                columnSpan: cell.options.columnSpan,
                borders: cell.options.borders,
                children: [],
                verticalMerge: VerticalMergeType2.CONTINUE
              });
              rows[rowIndex + 1].addCellToColumnIndex(continueCell, columnIndex);
            }
            columnIndex += cell.options.columnSpan || 1;
          });
        });
      }
    };
    var HeightRule = {
      /** Height is determined based on the content, so value is ignored. */
      AUTO: "auto",
      /** At least the value specified */
      ATLEAST: "atLeast",
      /** Exactly the value specified */
      EXACT: "exact"
    };
    var TableRowHeightAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", { value: "w:val", rule: "w:hRule" });
      }
    };
    var TableRowHeight2 = class extends XmlComponent2 {
      constructor(value, rule) {
        super("w:trHeight");
        this.root.push(
          new TableRowHeightAttributes2({
            value: twipsMeasureValue2(value),
            rule
          })
        );
      }
    };
    var TableRowProperties2 = class extends IgnoreIfEmptyXmlComponent2 {
      constructor(options) {
        super("w:trPr");
        if (options.cantSplit !== void 0) {
          this.root.push(new OnOffElement2("w:cantSplit", options.cantSplit));
        }
        if (options.tableHeader !== void 0) {
          this.root.push(new OnOffElement2("w:tblHeader", options.tableHeader));
        }
        if (options.height) {
          this.root.push(new TableRowHeight2(options.height.value, options.height.rule));
        }
        if (options.cellSpacing) {
          this.root.push(new TableCellSpacingElement2(options.cellSpacing));
        }
      }
    };
    var TableRow2 = class extends XmlComponent2 {
      constructor(options) {
        super("w:tr");
        this.options = options;
        this.root.push(new TableRowProperties2(options));
        for (const child of options.children) {
          this.root.push(child);
        }
      }
      get CellCount() {
        return this.options.children.length;
      }
      get cells() {
        return this.root.filter((xmlComponent) => xmlComponent instanceof TableCell2);
      }
      addCellToIndex(cell, index) {
        this.root.splice(index + 1, 0, cell);
      }
      addCellToColumnIndex(cell, columnIndex) {
        const rootIndex = this.columnIndexToRootIndex(columnIndex, true);
        this.addCellToIndex(cell, rootIndex - 1);
      }
      rootIndexToColumnIndex(rootIndex) {
        if (rootIndex < 1 || rootIndex >= this.root.length) {
          throw new Error(`cell 'rootIndex' should between 1 to ${this.root.length - 1}`);
        }
        let colIdx = 0;
        for (let rootIdx = 1; rootIdx < rootIndex; rootIdx++) {
          const cell = this.root[rootIdx];
          colIdx += cell.options.columnSpan || 1;
        }
        return colIdx;
      }
      columnIndexToRootIndex(columnIndex, allowEndNewCell = false) {
        if (columnIndex < 0) {
          throw new Error(`cell 'columnIndex' should not less than zero`);
        }
        let colIdx = 0;
        let rootIdx = 1;
        while (colIdx <= columnIndex) {
          if (rootIdx >= this.root.length) {
            if (allowEndNewCell) {
              return this.root.length;
            } else {
              throw new Error(`cell 'columnIndex' should not great than ${colIdx - 1}`);
            }
          }
          const cell = this.root[rootIdx];
          rootIdx += 1;
          colIdx += cell && cell.options.columnSpan || 1;
        }
        return rootIdx - 1;
      }
    };
    var AppPropertiesAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", {
          xmlns: "xmlns",
          vt: "xmlns:vt"
        });
      }
    };
    var AppProperties2 = class extends XmlComponent2 {
      constructor() {
        super("Properties");
        this.root.push(
          new AppPropertiesAttributes2({
            xmlns: "http://schemas.openxmlformats.org/officeDocument/2006/extended-properties",
            vt: "http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes"
          })
        );
      }
    };
    var ContentTypeAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", {
          xmlns: "xmlns"
        });
      }
    };
    var DefaultAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", {
          contentType: "ContentType",
          extension: "Extension"
        });
      }
    };
    var Default2 = class extends XmlComponent2 {
      constructor(contentType, extension) {
        super("Default");
        this.root.push(
          new DefaultAttributes2({
            contentType,
            extension
          })
        );
      }
    };
    var OverrideAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", {
          contentType: "ContentType",
          partName: "PartName"
        });
      }
    };
    var Override2 = class extends XmlComponent2 {
      constructor(contentType, partName) {
        super("Override");
        this.root.push(
          new OverrideAttributes2({
            contentType,
            partName
          })
        );
      }
    };
    var ContentTypes2 = class extends XmlComponent2 {
      constructor() {
        super("Types");
        this.root.push(
          new ContentTypeAttributes2({
            xmlns: "http://schemas.openxmlformats.org/package/2006/content-types"
          })
        );
        this.root.push(new Default2("image/png", "png"));
        this.root.push(new Default2("image/jpeg", "jpeg"));
        this.root.push(new Default2("image/jpeg", "jpg"));
        this.root.push(new Default2("image/bmp", "bmp"));
        this.root.push(new Default2("image/gif", "gif"));
        this.root.push(new Default2("image/svg+xml", "svg"));
        this.root.push(new Default2("application/vnd.openxmlformats-package.relationships+xml", "rels"));
        this.root.push(new Default2("application/xml", "xml"));
        this.root.push(new Default2("application/vnd.openxmlformats-officedocument.obfuscatedFont", "odttf"));
        this.root.push(
          new Override2("application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml", "/word/document.xml")
        );
        this.root.push(new Override2("application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml", "/word/styles.xml"));
        this.root.push(new Override2("application/vnd.openxmlformats-package.core-properties+xml", "/docProps/core.xml"));
        this.root.push(new Override2("application/vnd.openxmlformats-officedocument.custom-properties+xml", "/docProps/custom.xml"));
        this.root.push(new Override2("application/vnd.openxmlformats-officedocument.extended-properties+xml", "/docProps/app.xml"));
        this.root.push(new Override2("application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml", "/word/numbering.xml"));
        this.root.push(new Override2("application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml", "/word/footnotes.xml"));
        this.root.push(new Override2("application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml", "/word/settings.xml"));
        this.root.push(new Override2("application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml", "/word/comments.xml"));
        this.root.push(new Override2("application/vnd.openxmlformats-officedocument.wordprocessingml.fontTable+xml", "/word/fontTable.xml"));
      }
      addFooter(index) {
        this.root.push(
          new Override2("application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml", `/word/footer${index}.xml`)
        );
      }
      addHeader(index) {
        this.root.push(
          new Override2("application/vnd.openxmlformats-officedocument.wordprocessingml.header+xml", `/word/header${index}.xml`)
        );
      }
    };
    var CoreProperties2 = class extends XmlComponent2 {
      constructor(options) {
        super("cp:coreProperties");
        this.root.push(new DocumentAttributes2(["cp", "dc", "dcterms", "dcmitype", "xsi"]));
        if (options.title) {
          this.root.push(new StringContainer2("dc:title", options.title));
        }
        if (options.subject) {
          this.root.push(new StringContainer2("dc:subject", options.subject));
        }
        if (options.creator) {
          this.root.push(new StringContainer2("dc:creator", options.creator));
        }
        if (options.keywords) {
          this.root.push(new StringContainer2("cp:keywords", options.keywords));
        }
        if (options.description) {
          this.root.push(new StringContainer2("dc:description", options.description));
        }
        if (options.lastModifiedBy) {
          this.root.push(new StringContainer2("cp:lastModifiedBy", options.lastModifiedBy));
        }
        if (options.revision) {
          this.root.push(new StringContainer2("cp:revision", String(options.revision)));
        }
        this.root.push(new TimestampElement2("dcterms:created"));
        this.root.push(new TimestampElement2("dcterms:modified"));
      }
    };
    var TimestampElementProperties2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", { type: "xsi:type" });
      }
    };
    var TimestampElement2 = class extends XmlComponent2 {
      constructor(name) {
        super(name);
        this.root.push(
          new TimestampElementProperties2({
            type: "dcterms:W3CDTF"
          })
        );
        this.root.push(dateTimeValue2(/* @__PURE__ */ new Date()));
      }
    };
    var CustomPropertiesAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", {
          xmlns: "xmlns",
          vt: "xmlns:vt"
        });
      }
    };
    var CustomPropertyAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", {
          fmtid: "fmtid",
          pid: "pid",
          name: "name"
        });
      }
    };
    var CustomProperty2 = class extends XmlComponent2 {
      constructor(id, properties) {
        super("property");
        this.root.push(
          new CustomPropertyAttributes2({
            fmtid: "{D5CDD505-2E9C-101B-9397-08002B2CF9AE}",
            pid: id.toString(),
            name: properties.name
          })
        );
        this.root.push(new CustomPropertyValue2(properties.value));
      }
    };
    var CustomPropertyValue2 = class extends XmlComponent2 {
      constructor(value) {
        super("vt:lpwstr");
        this.root.push(value);
      }
    };
    var CustomProperties2 = class extends XmlComponent2 {
      constructor(properties) {
        super("Properties");
        __publicField2(this, "nextId");
        __publicField2(this, "properties", []);
        this.root.push(
          new CustomPropertiesAttributes2({
            xmlns: "http://schemas.openxmlformats.org/officeDocument/2006/custom-properties",
            vt: "http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes"
          })
        );
        this.nextId = 2;
        for (const property of properties) {
          this.addCustomProperty(property);
        }
      }
      prepForXml(context) {
        this.properties.forEach((x) => this.root.push(x));
        return super.prepForXml(context);
      }
      addCustomProperty(property) {
        this.properties.push(new CustomProperty2(this.nextId++, property));
      }
    };
    var CharacterSet = {
      ANSI: "00",
      DEFAULT: "01",
      SYMBOL: "02",
      MAC: "4D",
      JIS: "80",
      HANGUL: "81",
      JOHAB: "82",
      GB_2312: "86",
      CHINESEBIG5: "88",
      GREEK: "A1",
      TURKISH: "A2",
      VIETNAMESE: "A3",
      HEBREW: "B1",
      ARABIC: "B2",
      BALTIC: "BA",
      RUSSIAN: "CC",
      THAI: "DE",
      EASTEUROPE: "EE",
      OEM: "FF"
    };
    var createFontRelationship2 = ({ id, fontKey, subsetted }, name) => new BuilderElement2({
      name,
      attributes: __spreadValues2({
        id: { key: "r:id", value: id }
      }, fontKey ? { fontKey: { key: "w:fontKey", value: `{${fontKey}}` } } : {}),
      children: [...subsetted ? [new OnOffElement2("w:subsetted", subsetted)] : []]
    });
    var createFont2 = ({
      name,
      altName,
      panose1,
      charset,
      family,
      notTrueType,
      pitch,
      sig,
      embedRegular,
      embedBold,
      embedItalic,
      embedBoldItalic
    }) => (
      // http://www.datypic.com/sc/ooxml/e-w_font-1.html
      new BuilderElement2({
        name: "w:font",
        attributes: {
          name: { key: "w:name", value: name }
        },
        children: [
          // http://www.datypic.com/sc/ooxml/e-w_altName-1.html
          ...altName ? [createStringElement2("w:altName", altName)] : [],
          // http://www.datypic.com/sc/ooxml/e-w_panose1-1.html
          ...panose1 ? [createStringElement2("w:panose1", panose1)] : [],
          // http://www.datypic.com/sc/ooxml/e-w_charset-1.html
          ...charset ? [createStringElement2("w:charset", charset)] : [],
          // http://www.datypic.com/sc/ooxml/e-w_family-1.html
          ...[createStringElement2("w:family", family)],
          // http://www.datypic.com/sc/ooxml/e-w_notTrueType-1.html
          ...notTrueType ? [new OnOffElement2("w:notTrueType", notTrueType)] : [],
          ...[createStringElement2("w:pitch", pitch)],
          // http://www.datypic.com/sc/ooxml/e-w_sig-1.html
          ...sig ? [
            new BuilderElement2({
              name: "w:sig",
              attributes: {
                usb0: { key: "w:usb0", value: sig.usb0 },
                usb1: { key: "w:usb1", value: sig.usb1 },
                usb2: { key: "w:usb2", value: sig.usb2 },
                usb3: { key: "w:usb3", value: sig.usb3 },
                csb0: { key: "w:csb0", value: sig.csb0 },
                csb1: { key: "w:csb1", value: sig.csb1 }
              }
            })
          ] : [],
          // http://www.datypic.com/sc/ooxml/e-w_embedRegular-1.html
          ...embedRegular ? [createFontRelationship2(embedRegular, "w:embedRegular")] : [],
          // http://www.datypic.com/sc/ooxml/e-w_embedBold-1.html
          ...embedBold ? [createFontRelationship2(embedBold, "w:embedBold")] : [],
          // http://www.datypic.com/sc/ooxml/e-w_embedItalic-1.html
          ...embedItalic ? [createFontRelationship2(embedItalic, "w:embedItalic")] : [],
          // http://www.datypic.com/sc/ooxml/e-w_embedBoldItalic-1.html
          ...embedBoldItalic ? [createFontRelationship2(embedBoldItalic, "w:embedBoldItalic")] : []
        ]
      })
    );
    var createRegularFont2 = ({
      name,
      index,
      fontKey,
      characterSet
    }) => createFont2({
      name,
      sig: {
        usb0: "E0002AFF",
        usb1: "C000247B",
        usb2: "00000009",
        usb3: "00000000",
        csb0: "000001FF",
        csb1: "00000000"
      },
      charset: characterSet,
      family: "auto",
      pitch: "variable",
      embedRegular: {
        fontKey,
        id: `rId${index}`
      }
    });
    var createFontTable2 = (fonts) => (
      // https://c-rex.net/projects/samples/ooxml/e1/Part4/OOXML_P4_DOCX_Font_topic_ID0ERNCU.html
      // http://www.datypic.com/sc/ooxml/e-w_fonts.html
      new BuilderElement2({
        name: "w:fonts",
        attributes: {
          mc: { key: "xmlns:mc", value: "http://schemas.openxmlformats.org/markup-compatibility/2006" },
          r: { key: "xmlns:r", value: "http://schemas.openxmlformats.org/officeDocument/2006/relationships" },
          w: { key: "xmlns:w", value: "http://schemas.openxmlformats.org/wordprocessingml/2006/main" },
          w14: { key: "xmlns:w14", value: "http://schemas.microsoft.com/office/word/2010/wordml" },
          w15: { key: "xmlns:w15", value: "http://schemas.microsoft.com/office/word/2012/wordml" },
          w16cex: { key: "xmlns:w16cex", value: "http://schemas.microsoft.com/office/word/2018/wordml/cex" },
          w16cid: { key: "xmlns:w16cid", value: "http://schemas.microsoft.com/office/word/2016/wordml/cid" },
          w16: { key: "xmlns:w16", value: "http://schemas.microsoft.com/office/word/2018/wordml" },
          w16sdtdh: { key: "xmlns:w16sdtdh", value: "http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash" },
          w16se: { key: "xmlns:w16se", value: "http://schemas.microsoft.com/office/word/2015/wordml/symex" },
          Ignorable: { key: "mc:Ignorable", value: "w14 w15 w16se w16cid w16 w16cex w16sdtdh" }
        },
        children: fonts.map(
          (font, i) => createRegularFont2({
            name: font.name,
            index: i + 1,
            fontKey: font.fontKey
          })
        )
      })
    );
    var FontWrapper2 = class {
      constructor(options) {
        __publicField2(this, "fontTable");
        __publicField2(this, "relationships");
        __publicField2(this, "fontOptionsWithKey", []);
        this.options = options;
        this.fontOptionsWithKey = options.map((o) => __spreadProps2(__spreadValues2({}, o), { fontKey: uniqueUuid2() }));
        this.fontTable = createFontTable2(this.fontOptionsWithKey);
        this.relationships = new Relationships2();
        for (let i = 0; i < options.length; i++) {
          this.relationships.createRelationship(
            i + 1,
            "http://schemas.openxmlformats.org/officeDocument/2006/relationships/font",
            `fonts/${options[i].name}.odttf`
          );
        }
      }
      get View() {
        return this.fontTable;
      }
      get Relationships() {
        return this.relationships;
      }
    };
    var FooterAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", {
          wpc: "xmlns:wpc",
          mc: "xmlns:mc",
          o: "xmlns:o",
          r: "xmlns:r",
          m: "xmlns:m",
          v: "xmlns:v",
          wp14: "xmlns:wp14",
          wp: "xmlns:wp",
          w10: "xmlns:w10",
          w: "xmlns:w",
          w14: "xmlns:w14",
          w15: "xmlns:w15",
          wpg: "xmlns:wpg",
          wpi: "xmlns:wpi",
          wne: "xmlns:wne",
          wps: "xmlns:wps",
          cp: "xmlns:cp",
          dc: "xmlns:dc",
          dcterms: "xmlns:dcterms",
          dcmitype: "xmlns:dcmitype",
          xsi: "xmlns:xsi",
          type: "xsi:type"
        });
      }
    };
    var Footer$12 = class Footer extends InitializableXmlComponent2 {
      constructor(referenceNumber, initContent) {
        super("w:ftr", initContent);
        __publicField2(this, "refId");
        this.refId = referenceNumber;
        if (!initContent) {
          this.root.push(
            new FooterAttributes2({
              wpc: "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas",
              mc: "http://schemas.openxmlformats.org/markup-compatibility/2006",
              o: "urn:schemas-microsoft-com:office:office",
              r: "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
              m: "http://schemas.openxmlformats.org/officeDocument/2006/math",
              v: "urn:schemas-microsoft-com:vml",
              wp14: "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
              wp: "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
              w10: "urn:schemas-microsoft-com:office:word",
              w: "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
              w14: "http://schemas.microsoft.com/office/word/2010/wordml",
              w15: "http://schemas.microsoft.com/office/word/2012/wordml",
              wpg: "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
              wpi: "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
              wne: "http://schemas.microsoft.com/office/word/2006/wordml",
              wps: "http://schemas.microsoft.com/office/word/2010/wordprocessingShape"
            })
          );
        }
      }
      get ReferenceId() {
        return this.refId;
      }
      add(item) {
        this.root.push(item);
      }
    };
    var FooterWrapper2 = class {
      constructor(media, referenceId, initContent) {
        __publicField2(this, "footer");
        __publicField2(this, "relationships");
        this.media = media;
        this.footer = new Footer$12(referenceId, initContent);
        this.relationships = new Relationships2();
      }
      add(item) {
        this.footer.add(item);
      }
      addChildElement(childElement) {
        this.footer.addChildElement(childElement);
      }
      get View() {
        return this.footer;
      }
      get Relationships() {
        return this.relationships;
      }
      get Media() {
        return this.media;
      }
    };
    var FootnoteAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", {
          type: "w:type",
          id: "w:id"
        });
      }
    };
    var FootnoteRef2 = class extends XmlComponent2 {
      constructor() {
        super("w:footnoteRef");
      }
    };
    var FootnoteRefRun2 = class extends Run2 {
      constructor() {
        super({
          style: "FootnoteReference"
        });
        this.root.push(new FootnoteRef2());
      }
    };
    var FootnoteType2 = {
      SEPERATOR: "separator",
      CONTINUATION_SEPERATOR: "continuationSeparator"
    };
    var Footnote2 = class extends XmlComponent2 {
      constructor(options) {
        super("w:footnote");
        this.root.push(
          new FootnoteAttributes2({
            type: options.type,
            id: options.id
          })
        );
        for (let i = 0; i < options.children.length; i++) {
          const child = options.children[i];
          if (i === 0) {
            child.addRunToFront(new FootnoteRefRun2());
          }
          this.root.push(child);
        }
      }
    };
    var ContinuationSeperator2 = class extends XmlComponent2 {
      constructor() {
        super("w:continuationSeparator");
      }
    };
    var ContinuationSeperatorRun2 = class extends Run2 {
      constructor() {
        super({});
        this.root.push(new ContinuationSeperator2());
      }
    };
    var Seperator2 = class extends XmlComponent2 {
      constructor() {
        super("w:separator");
      }
    };
    var SeperatorRun2 = class extends Run2 {
      constructor() {
        super({});
        this.root.push(new Seperator2());
      }
    };
    var FootnotesAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", {
          wpc: "xmlns:wpc",
          mc: "xmlns:mc",
          o: "xmlns:o",
          r: "xmlns:r",
          m: "xmlns:m",
          v: "xmlns:v",
          wp14: "xmlns:wp14",
          wp: "xmlns:wp",
          w10: "xmlns:w10",
          w: "xmlns:w",
          w14: "xmlns:w14",
          w15: "xmlns:w15",
          wpg: "xmlns:wpg",
          wpi: "xmlns:wpi",
          wne: "xmlns:wne",
          wps: "xmlns:wps",
          Ignorable: "mc:Ignorable"
        });
      }
    };
    var FootNotes2 = class extends XmlComponent2 {
      constructor() {
        super("w:footnotes");
        this.root.push(
          new FootnotesAttributes2({
            wpc: "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas",
            mc: "http://schemas.openxmlformats.org/markup-compatibility/2006",
            o: "urn:schemas-microsoft-com:office:office",
            r: "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
            m: "http://schemas.openxmlformats.org/officeDocument/2006/math",
            v: "urn:schemas-microsoft-com:vml",
            wp14: "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
            wp: "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
            w10: "urn:schemas-microsoft-com:office:word",
            w: "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
            w14: "http://schemas.microsoft.com/office/word/2010/wordml",
            w15: "http://schemas.microsoft.com/office/word/2012/wordml",
            wpg: "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
            wpi: "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
            wne: "http://schemas.microsoft.com/office/word/2006/wordml",
            wps: "http://schemas.microsoft.com/office/word/2010/wordprocessingShape",
            Ignorable: "w14 w15 wp14"
          })
        );
        const begin = new Footnote2({
          id: -1,
          type: FootnoteType2.SEPERATOR,
          children: [
            new Paragraph3({
              spacing: {
                after: 0,
                line: 240,
                lineRule: LineRuleType2.AUTO
              },
              children: [new SeperatorRun2()]
            })
          ]
        });
        this.root.push(begin);
        const spacing = new Footnote2({
          id: 0,
          type: FootnoteType2.CONTINUATION_SEPERATOR,
          children: [
            new Paragraph3({
              spacing: {
                after: 0,
                line: 240,
                lineRule: LineRuleType2.AUTO
              },
              children: [new ContinuationSeperatorRun2()]
            })
          ]
        });
        this.root.push(spacing);
      }
      createFootNote(id, paragraph) {
        const footnote = new Footnote2({
          id,
          children: paragraph
        });
        this.root.push(footnote);
      }
    };
    var FootnotesWrapper2 = class {
      constructor() {
        __publicField2(this, "footnotess");
        __publicField2(this, "relationships");
        this.footnotess = new FootNotes2();
        this.relationships = new Relationships2();
      }
      get View() {
        return this.footnotess;
      }
      get Relationships() {
        return this.relationships;
      }
    };
    var HeaderAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", {
          wpc: "xmlns:wpc",
          mc: "xmlns:mc",
          o: "xmlns:o",
          r: "xmlns:r",
          m: "xmlns:m",
          v: "xmlns:v",
          wp14: "xmlns:wp14",
          wp: "xmlns:wp",
          w10: "xmlns:w10",
          w: "xmlns:w",
          w14: "xmlns:w14",
          w15: "xmlns:w15",
          wpg: "xmlns:wpg",
          wpi: "xmlns:wpi",
          wne: "xmlns:wne",
          wps: "xmlns:wps",
          cp: "xmlns:cp",
          dc: "xmlns:dc",
          dcterms: "xmlns:dcterms",
          dcmitype: "xmlns:dcmitype",
          xsi: "xmlns:xsi",
          type: "xsi:type",
          cx: "xmlns:cx",
          cx1: "xmlns:cx1",
          cx2: "xmlns:cx2",
          cx3: "xmlns:cx3",
          cx4: "xmlns:cx4",
          cx5: "xmlns:cx5",
          cx6: "xmlns:cx6",
          cx7: "xmlns:cx7",
          cx8: "xmlns:cx8",
          w16cid: "xmlns:w16cid",
          w16se: "xmlns:w16se"
        });
      }
    };
    var Header$12 = class Header extends InitializableXmlComponent2 {
      constructor(referenceNumber, initContent) {
        super("w:hdr", initContent);
        __publicField2(this, "refId");
        this.refId = referenceNumber;
        if (!initContent) {
          this.root.push(
            new HeaderAttributes2({
              wpc: "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas",
              mc: "http://schemas.openxmlformats.org/markup-compatibility/2006",
              o: "urn:schemas-microsoft-com:office:office",
              r: "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
              m: "http://schemas.openxmlformats.org/officeDocument/2006/math",
              v: "urn:schemas-microsoft-com:vml",
              wp14: "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
              wp: "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
              w10: "urn:schemas-microsoft-com:office:word",
              w: "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
              w14: "http://schemas.microsoft.com/office/word/2010/wordml",
              w15: "http://schemas.microsoft.com/office/word/2012/wordml",
              wpg: "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
              wpi: "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
              wne: "http://schemas.microsoft.com/office/word/2006/wordml",
              wps: "http://schemas.microsoft.com/office/word/2010/wordprocessingShape",
              cx: "http://schemas.microsoft.com/office/drawing/2014/chartex",
              cx1: "http://schemas.microsoft.com/office/drawing/2015/9/8/chartex",
              cx2: "http://schemas.microsoft.com/office/drawing/2015/10/21/chartex",
              cx3: "http://schemas.microsoft.com/office/drawing/2016/5/9/chartex",
              cx4: "http://schemas.microsoft.com/office/drawing/2016/5/10/chartex",
              cx5: "http://schemas.microsoft.com/office/drawing/2016/5/11/chartex",
              cx6: "http://schemas.microsoft.com/office/drawing/2016/5/12/chartex",
              cx7: "http://schemas.microsoft.com/office/drawing/2016/5/13/chartex",
              cx8: "http://schemas.microsoft.com/office/drawing/2016/5/14/chartex",
              w16cid: "http://schemas.microsoft.com/office/word/2016/wordml/cid",
              w16se: "http://schemas.microsoft.com/office/word/2015/wordml/symex"
            })
          );
        }
      }
      get ReferenceId() {
        return this.refId;
      }
      add(item) {
        this.root.push(item);
      }
    };
    var HeaderWrapper2 = class {
      constructor(media, referenceId, initContent) {
        __publicField2(this, "header");
        __publicField2(this, "relationships");
        this.media = media;
        this.header = new Header$12(referenceId, initContent);
        this.relationships = new Relationships2();
      }
      add(item) {
        this.header.add(item);
        return this;
      }
      addChildElement(childElement) {
        this.header.addChildElement(childElement);
      }
      get View() {
        return this.header;
      }
      get Relationships() {
        return this.relationships;
      }
      get Media() {
        return this.media;
      }
    };
    var Media2 = class {
      constructor() {
        __publicField2(this, "map");
        this.map = /* @__PURE__ */ new Map();
      }
      addImage(key, mediaData) {
        this.map.set(key, mediaData);
      }
      get Array() {
        return Array.from(this.map.values());
      }
    };
    var WORKAROUND2 = "";
    var LevelFormat2 = {
      DECIMAL: "decimal",
      UPPER_ROMAN: "upperRoman",
      LOWER_ROMAN: "lowerRoman",
      UPPER_LETTER: "upperLetter",
      LOWER_LETTER: "lowerLetter",
      ORDINAL: "ordinal",
      CARDINAL_TEXT: "cardinalText",
      ORDINAL_TEXT: "ordinalText",
      HEX: "hex",
      CHICAGO: "chicago",
      IDEOGRAPH__DIGITAL: "ideographDigital",
      JAPANESE_COUNTING: "japaneseCounting",
      AIUEO: "aiueo",
      IROHA: "iroha",
      DECIMAL_FULL_WIDTH: "decimalFullWidth",
      DECIMAL_HALF_WIDTH: "decimalHalfWidth",
      JAPANESE_LEGAL: "japaneseLegal",
      JAPANESE_DIGITAL_TEN_THOUSAND: "japaneseDigitalTenThousand",
      DECIMAL_ENCLOSED_CIRCLE: "decimalEnclosedCircle",
      DECIMAL_FULL_WIDTH2: "decimalFullWidth2",
      AIUEO_FULL_WIDTH: "aiueoFullWidth",
      IROHA_FULL_WIDTH: "irohaFullWidth",
      DECIMAL_ZERO: "decimalZero",
      BULLET: "bullet",
      GANADA: "ganada",
      CHOSUNG: "chosung",
      DECIMAL_ENCLOSED_FULLSTOP: "decimalEnclosedFullstop",
      DECIMAL_ENCLOSED_PARENTHESES: "decimalEnclosedParen",
      DECIMAL_ENCLOSED_CIRCLE_CHINESE: "decimalEnclosedCircleChinese",
      IDEOGRAPH_ENCLOSED_CIRCLE: "ideographEnclosedCircle",
      IDEOGRAPH_TRADITIONAL: "ideographTraditional",
      IDEOGRAPH_ZODIAC: "ideographZodiac",
      IDEOGRAPH_ZODIAC_TRADITIONAL: "ideographZodiacTraditional",
      TAIWANESE_COUNTING: "taiwaneseCounting",
      IDEOGRAPH_LEGAL_TRADITIONAL: "ideographLegalTraditional",
      TAIWANESE_COUNTING_THOUSAND: "taiwaneseCountingThousand",
      TAIWANESE_DIGITAL: "taiwaneseDigital",
      CHINESE_COUNTING: "chineseCounting",
      CHINESE_LEGAL_SIMPLIFIED: "chineseLegalSimplified",
      CHINESE_COUNTING_THOUSAND: "chineseCountingThousand",
      KOREAN_DIGITAL: "koreanDigital",
      KOREAN_COUNTING: "koreanCounting",
      KOREAN_LEGAL: "koreanLegal",
      KOREAN_DIGITAL2: "koreanDigital2",
      VIETNAMESE_COUNTING: "vietnameseCounting",
      RUSSIAN_LOWER: "russianLower",
      RUSSIAN_UPPER: "russianUpper",
      NONE: "none",
      NUMBER_IN_DASH: "numberInDash",
      HEBREW1: "hebrew1",
      HEBREW2: "hebrew2",
      ARABIC_ALPHA: "arabicAlpha",
      ARABIC_ABJAD: "arabicAbjad",
      HINDI_VOWELS: "hindiVowels",
      HINDI_CONSONANTS: "hindiConsonants",
      HINDI_NUMBERS: "hindiNumbers",
      HINDI_COUNTING: "hindiCounting",
      THAI_LETTERS: "thaiLetters",
      THAI_NUMBERS: "thaiNumbers",
      THAI_COUNTING: "thaiCounting",
      BAHT_TEXT: "bahtText",
      DOLLAR_TEXT: "dollarText",
      CUSTOM: "custom"
    };
    var LevelAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", {
          ilvl: "w:ilvl",
          tentative: "w15:tentative"
        });
      }
    };
    var NumberFormat2 = class extends XmlComponent2 {
      constructor(value) {
        super("w:numFmt");
        this.root.push(
          new Attributes2({
            val: value
          })
        );
      }
    };
    var LevelText2 = class extends XmlComponent2 {
      constructor(value) {
        super("w:lvlText");
        this.root.push(
          new Attributes2({
            val: value
          })
        );
      }
    };
    var LevelJc2 = class extends XmlComponent2 {
      constructor(value) {
        super("w:lvlJc");
        this.root.push(
          new Attributes2({
            val: value
          })
        );
      }
    };
    var LevelSuffix = {
      NOTHING: "nothing",
      SPACE: "space",
      TAB: "tab"
    };
    var Suffix2 = class extends XmlComponent2 {
      constructor(value) {
        super("w:suff");
        this.root.push(
          new Attributes2({
            val: value
          })
        );
      }
    };
    var IsLegalNumberingStyle2 = class extends XmlComponent2 {
      constructor() {
        super("w:isLgl");
      }
    };
    var LevelBase2 = class extends XmlComponent2 {
      constructor({
        level,
        format,
        text,
        alignment = AlignmentType2.START,
        start = 1,
        style,
        suffix,
        isLegalNumberingStyle
      }) {
        super("w:lvl");
        __publicField2(this, "paragraphProperties");
        __publicField2(this, "runProperties");
        this.root.push(new NumberValueElement2("w:start", decimalNumber2(start)));
        if (format) {
          this.root.push(new NumberFormat2(format));
        }
        if (suffix) {
          this.root.push(new Suffix2(suffix));
        }
        if (isLegalNumberingStyle) {
          this.root.push(new IsLegalNumberingStyle2());
        }
        if (text) {
          this.root.push(new LevelText2(text));
        }
        this.root.push(new LevelJc2(alignment));
        this.paragraphProperties = new ParagraphProperties2(style && style.paragraph);
        this.runProperties = new RunProperties2(style && style.run);
        this.root.push(this.paragraphProperties);
        this.root.push(this.runProperties);
        if (level > 9) {
          throw new Error(
            "Level cannot be greater than 9. Read more here: https://answers.microsoft.com/en-us/msoffice/forum/all/does-word-support-more-than-9-list-levels/d130fdcd-1781-446d-8c84-c6c79124e4d7"
          );
        }
        this.root.push(
          new LevelAttributes2({
            ilvl: decimalNumber2(level),
            tentative: 1
          })
        );
      }
    };
    var Level2 = class extends LevelBase2 {
      // This is the level that sits under abstractNum. We make a
      // handful of properties required
    };
    var LevelForOverride = class extends LevelBase2 {
    };
    var MultiLevelType2 = class extends XmlComponent2 {
      constructor(value) {
        super("w:multiLevelType");
        this.root.push(
          new Attributes2({
            val: value
          })
        );
      }
    };
    var AbstractNumberingAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", {
          abstractNumId: "w:abstractNumId",
          restartNumberingAfterBreak: "w15:restartNumberingAfterBreak"
        });
      }
    };
    var AbstractNumbering2 = class extends XmlComponent2 {
      constructor(id, levelOptions) {
        super("w:abstractNum");
        __publicField2(this, "id");
        this.root.push(
          new AbstractNumberingAttributes2({
            abstractNumId: decimalNumber2(id),
            restartNumberingAfterBreak: 0
          })
        );
        this.root.push(new MultiLevelType2("hybridMultilevel"));
        this.id = id;
        for (const option of levelOptions) {
          this.root.push(new Level2(option));
        }
      }
    };
    var AbstractNumId2 = class extends XmlComponent2 {
      constructor(value) {
        super("w:abstractNumId");
        this.root.push(
          new Attributes2({
            val: value
          })
        );
      }
    };
    var NumAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", { numId: "w:numId" });
      }
    };
    var ConcreteNumbering2 = class extends XmlComponent2 {
      constructor(options) {
        super("w:num");
        __publicField2(this, "numId");
        __publicField2(this, "reference");
        __publicField2(this, "instance");
        this.numId = options.numId;
        this.reference = options.reference;
        this.instance = options.instance;
        this.root.push(
          new NumAttributes2({
            numId: decimalNumber2(options.numId)
          })
        );
        this.root.push(new AbstractNumId2(decimalNumber2(options.abstractNumId)));
        if (options.overrideLevels && options.overrideLevels.length) {
          for (const level of options.overrideLevels) {
            this.root.push(new LevelOverride2(level.num, level.start));
          }
        }
      }
    };
    var LevelOverrideAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", { ilvl: "w:ilvl" });
      }
    };
    var LevelOverride2 = class extends XmlComponent2 {
      constructor(levelNum, start) {
        super("w:lvlOverride");
        this.root.push(new LevelOverrideAttributes2({ ilvl: levelNum }));
        if (start !== void 0) {
          this.root.push(new StartOverride2(start));
        }
      }
    };
    var StartOverrideAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", { val: "w:val" });
      }
    };
    var StartOverride2 = class extends XmlComponent2 {
      constructor(start) {
        super("w:startOverride");
        this.root.push(new StartOverrideAttributes2({ val: start }));
      }
    };
    var Numbering2 = class extends XmlComponent2 {
      constructor(options) {
        super("w:numbering");
        __publicField2(this, "abstractNumberingMap", /* @__PURE__ */ new Map());
        __publicField2(this, "concreteNumberingMap", /* @__PURE__ */ new Map());
        __publicField2(this, "referenceConfigMap", /* @__PURE__ */ new Map());
        __publicField2(this, "abstractNumUniqueNumericId", abstractNumUniqueNumericIdGen2());
        __publicField2(this, "concreteNumUniqueNumericId", concreteNumUniqueNumericIdGen2());
        this.root.push(
          new DocumentAttributes2(
            ["wpc", "mc", "o", "r", "m", "v", "wp14", "wp", "w10", "w", "w14", "w15", "wpg", "wpi", "wne", "wps"],
            "w14 w15 wp14"
          )
        );
        const abstractNumbering = new AbstractNumbering2(this.abstractNumUniqueNumericId(), [
          {
            level: 0,
            format: LevelFormat2.BULLET,
            text: "\u25CF",
            alignment: AlignmentType2.LEFT,
            style: {
              paragraph: {
                indent: { left: convertInchesToTwip2(0.5), hanging: convertInchesToTwip2(0.25) }
              }
            }
          },
          {
            level: 1,
            format: LevelFormat2.BULLET,
            text: "\u25CB",
            alignment: AlignmentType2.LEFT,
            style: {
              paragraph: {
                indent: { left: convertInchesToTwip2(1), hanging: convertInchesToTwip2(0.25) }
              }
            }
          },
          {
            level: 2,
            format: LevelFormat2.BULLET,
            text: "\u25A0",
            alignment: AlignmentType2.LEFT,
            style: {
              paragraph: {
                indent: { left: 2160, hanging: convertInchesToTwip2(0.25) }
              }
            }
          },
          {
            level: 3,
            format: LevelFormat2.BULLET,
            text: "\u25CF",
            alignment: AlignmentType2.LEFT,
            style: {
              paragraph: {
                indent: { left: 2880, hanging: convertInchesToTwip2(0.25) }
              }
            }
          },
          {
            level: 4,
            format: LevelFormat2.BULLET,
            text: "\u25CB",
            alignment: AlignmentType2.LEFT,
            style: {
              paragraph: {
                indent: { left: 3600, hanging: convertInchesToTwip2(0.25) }
              }
            }
          },
          {
            level: 5,
            format: LevelFormat2.BULLET,
            text: "\u25A0",
            alignment: AlignmentType2.LEFT,
            style: {
              paragraph: {
                indent: { left: 4320, hanging: convertInchesToTwip2(0.25) }
              }
            }
          },
          {
            level: 6,
            format: LevelFormat2.BULLET,
            text: "\u25CF",
            alignment: AlignmentType2.LEFT,
            style: {
              paragraph: {
                indent: { left: 5040, hanging: convertInchesToTwip2(0.25) }
              }
            }
          },
          {
            level: 7,
            format: LevelFormat2.BULLET,
            text: "\u25CF",
            alignment: AlignmentType2.LEFT,
            style: {
              paragraph: {
                indent: { left: 5760, hanging: convertInchesToTwip2(0.25) }
              }
            }
          },
          {
            level: 8,
            format: LevelFormat2.BULLET,
            text: "\u25CF",
            alignment: AlignmentType2.LEFT,
            style: {
              paragraph: {
                indent: { left: 6480, hanging: convertInchesToTwip2(0.25) }
              }
            }
          }
        ]);
        this.concreteNumberingMap.set(
          "default-bullet-numbering",
          new ConcreteNumbering2({
            numId: 1,
            abstractNumId: abstractNumbering.id,
            reference: "default-bullet-numbering",
            instance: 0,
            overrideLevels: [
              {
                num: 0,
                start: 1
              }
            ]
          })
        );
        this.abstractNumberingMap.set("default-bullet-numbering", abstractNumbering);
        for (const con of options.config) {
          this.abstractNumberingMap.set(con.reference, new AbstractNumbering2(this.abstractNumUniqueNumericId(), con.levels));
          this.referenceConfigMap.set(con.reference, con.levels);
        }
      }
      prepForXml(context) {
        for (const numbering of this.abstractNumberingMap.values()) {
          this.root.push(numbering);
        }
        for (const numbering of this.concreteNumberingMap.values()) {
          this.root.push(numbering);
        }
        return super.prepForXml(context);
      }
      createConcreteNumberingInstance(reference, instance) {
        const abstractNumbering = this.abstractNumberingMap.get(reference);
        if (!abstractNumbering) {
          return;
        }
        const fullReference = `${reference}-${instance}`;
        if (this.concreteNumberingMap.has(fullReference)) {
          return;
        }
        const referenceConfigLevels = this.referenceConfigMap.get(reference);
        const firstLevelStartNumber = referenceConfigLevels && referenceConfigLevels[0].start;
        const concreteNumberingSettings = {
          numId: this.concreteNumUniqueNumericId(),
          abstractNumId: abstractNumbering.id,
          reference,
          instance,
          overrideLevels: [
            firstLevelStartNumber && Number.isInteger(firstLevelStartNumber) ? {
              num: 0,
              start: firstLevelStartNumber
            } : {
              num: 0,
              start: 1
            }
          ]
        };
        this.concreteNumberingMap.set(fullReference, new ConcreteNumbering2(concreteNumberingSettings));
      }
      get ConcreteNumbering() {
        return Array.from(this.concreteNumberingMap.values());
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      get ReferenceConfig() {
        return Array.from(this.referenceConfigMap.values());
      }
    };
    var CompatibilitySettingAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", {
          version: "w:val",
          name: "w:name",
          uri: "w:uri"
        });
      }
    };
    var CompatibilitySetting2 = class extends XmlComponent2 {
      constructor(version) {
        super("w:compatSetting");
        this.root.push(
          new CompatibilitySettingAttributes2({
            version,
            uri: "http://schemas.microsoft.com/office/word",
            name: "compatibilityMode"
          })
        );
      }
    };
    var Compatibility2 = class extends XmlComponent2 {
      constructor(options) {
        super("w:compat");
        if (options.version) {
          this.root.push(new CompatibilitySetting2(options.version));
        }
        if (options.useSingleBorderforContiguousCells) {
          this.root.push(new OnOffElement2("w:useSingleBorderforContiguousCells", options.useSingleBorderforContiguousCells));
        }
        if (options.wordPerfectJustification) {
          this.root.push(new OnOffElement2("w:wpJustification", options.wordPerfectJustification));
        }
        if (options.noTabStopForHangingIndent) {
          this.root.push(new OnOffElement2("w:noTabHangInd", options.noTabStopForHangingIndent));
        }
        if (options.noLeading) {
          this.root.push(new OnOffElement2("w:noLeading", options.noLeading));
        }
        if (options.spaceForUnderline) {
          this.root.push(new OnOffElement2("w:spaceForUL", options.spaceForUnderline));
        }
        if (options.noColumnBalance) {
          this.root.push(new OnOffElement2("w:noColumnBalance", options.noColumnBalance));
        }
        if (options.balanceSingleByteDoubleByteWidth) {
          this.root.push(new OnOffElement2("w:balanceSingleByteDoubleByteWidth", options.balanceSingleByteDoubleByteWidth));
        }
        if (options.noExtraLineSpacing) {
          this.root.push(new OnOffElement2("w:noExtraLineSpacing", options.noExtraLineSpacing));
        }
        if (options.doNotLeaveBackslashAlone) {
          this.root.push(new OnOffElement2("w:doNotLeaveBackslashAlone", options.doNotLeaveBackslashAlone));
        }
        if (options.underlineTrailingSpaces) {
          this.root.push(new OnOffElement2("w:ulTrailSpace", options.underlineTrailingSpaces));
        }
        if (options.doNotExpandShiftReturn) {
          this.root.push(new OnOffElement2("w:doNotExpandShiftReturn", options.doNotExpandShiftReturn));
        }
        if (options.spacingInWholePoints) {
          this.root.push(new OnOffElement2("w:spacingInWholePoints", options.spacingInWholePoints));
        }
        if (options.lineWrapLikeWord6) {
          this.root.push(new OnOffElement2("w:lineWrapLikeWord6", options.lineWrapLikeWord6));
        }
        if (options.printBodyTextBeforeHeader) {
          this.root.push(new OnOffElement2("w:printBodyTextBeforeHeader", options.printBodyTextBeforeHeader));
        }
        if (options.printColorsBlack) {
          this.root.push(new OnOffElement2("w:printColBlack", options.printColorsBlack));
        }
        if (options.spaceWidth) {
          this.root.push(new OnOffElement2("w:wpSpaceWidth", options.spaceWidth));
        }
        if (options.showBreaksInFrames) {
          this.root.push(new OnOffElement2("w:showBreaksInFrames", options.showBreaksInFrames));
        }
        if (options.subFontBySize) {
          this.root.push(new OnOffElement2("w:subFontBySize", options.subFontBySize));
        }
        if (options.suppressBottomSpacing) {
          this.root.push(new OnOffElement2("w:suppressBottomSpacing", options.suppressBottomSpacing));
        }
        if (options.suppressTopSpacing) {
          this.root.push(new OnOffElement2("w:suppressTopSpacing", options.suppressTopSpacing));
        }
        if (options.suppressSpacingAtTopOfPage) {
          this.root.push(new OnOffElement2("w:suppressSpacingAtTopOfPage", options.suppressSpacingAtTopOfPage));
        }
        if (options.suppressTopSpacingWP) {
          this.root.push(new OnOffElement2("w:suppressTopSpacingWP", options.suppressTopSpacingWP));
        }
        if (options.suppressSpBfAfterPgBrk) {
          this.root.push(new OnOffElement2("w:suppressSpBfAfterPgBrk", options.suppressSpBfAfterPgBrk));
        }
        if (options.swapBordersFacingPages) {
          this.root.push(new OnOffElement2("w:swapBordersFacingPages", options.swapBordersFacingPages));
        }
        if (options.convertMailMergeEsc) {
          this.root.push(new OnOffElement2("w:convMailMergeEsc", options.convertMailMergeEsc));
        }
        if (options.truncateFontHeightsLikeWP6) {
          this.root.push(new OnOffElement2("w:truncateFontHeightsLikeWP6", options.truncateFontHeightsLikeWP6));
        }
        if (options.macWordSmallCaps) {
          this.root.push(new OnOffElement2("w:mwSmallCaps", options.macWordSmallCaps));
        }
        if (options.usePrinterMetrics) {
          this.root.push(new OnOffElement2("w:usePrinterMetrics", options.usePrinterMetrics));
        }
        if (options.doNotSuppressParagraphBorders) {
          this.root.push(new OnOffElement2("w:doNotSuppressParagraphBorders", options.doNotSuppressParagraphBorders));
        }
        if (options.wrapTrailSpaces) {
          this.root.push(new OnOffElement2("w:wrapTrailSpaces", options.wrapTrailSpaces));
        }
        if (options.footnoteLayoutLikeWW8) {
          this.root.push(new OnOffElement2("w:footnoteLayoutLikeWW8", options.footnoteLayoutLikeWW8));
        }
        if (options.shapeLayoutLikeWW8) {
          this.root.push(new OnOffElement2("w:shapeLayoutLikeWW8", options.shapeLayoutLikeWW8));
        }
        if (options.alignTablesRowByRow) {
          this.root.push(new OnOffElement2("w:alignTablesRowByRow", options.alignTablesRowByRow));
        }
        if (options.forgetLastTabAlignment) {
          this.root.push(new OnOffElement2("w:forgetLastTabAlignment", options.forgetLastTabAlignment));
        }
        if (options.adjustLineHeightInTable) {
          this.root.push(new OnOffElement2("w:adjustLineHeightInTable", options.adjustLineHeightInTable));
        }
        if (options.autoSpaceLikeWord95) {
          this.root.push(new OnOffElement2("w:autoSpaceLikeWord95", options.autoSpaceLikeWord95));
        }
        if (options.noSpaceRaiseLower) {
          this.root.push(new OnOffElement2("w:noSpaceRaiseLower", options.noSpaceRaiseLower));
        }
        if (options.doNotUseHTMLParagraphAutoSpacing) {
          this.root.push(new OnOffElement2("w:doNotUseHTMLParagraphAutoSpacing", options.doNotUseHTMLParagraphAutoSpacing));
        }
        if (options.layoutRawTableWidth) {
          this.root.push(new OnOffElement2("w:layoutRawTableWidth", options.layoutRawTableWidth));
        }
        if (options.layoutTableRowsApart) {
          this.root.push(new OnOffElement2("w:layoutTableRowsApart", options.layoutTableRowsApart));
        }
        if (options.useWord97LineBreakRules) {
          this.root.push(new OnOffElement2("w:useWord97LineBreakRules", options.useWord97LineBreakRules));
        }
        if (options.doNotBreakWrappedTables) {
          this.root.push(new OnOffElement2("w:doNotBreakWrappedTables", options.doNotBreakWrappedTables));
        }
        if (options.doNotSnapToGridInCell) {
          this.root.push(new OnOffElement2("w:doNotSnapToGridInCell", options.doNotSnapToGridInCell));
        }
        if (options.selectFieldWithFirstOrLastCharacter) {
          this.root.push(new OnOffElement2("w:selectFldWithFirstOrLastChar", options.selectFieldWithFirstOrLastCharacter));
        }
        if (options.applyBreakingRules) {
          this.root.push(new OnOffElement2("w:applyBreakingRules", options.applyBreakingRules));
        }
        if (options.doNotWrapTextWithPunctuation) {
          this.root.push(new OnOffElement2("w:doNotWrapTextWithPunct", options.doNotWrapTextWithPunctuation));
        }
        if (options.doNotUseEastAsianBreakRules) {
          this.root.push(new OnOffElement2("w:doNotUseEastAsianBreakRules", options.doNotUseEastAsianBreakRules));
        }
        if (options.useWord2002TableStyleRules) {
          this.root.push(new OnOffElement2("w:useWord2002TableStyleRules", options.useWord2002TableStyleRules));
        }
        if (options.growAutofit) {
          this.root.push(new OnOffElement2("w:growAutofit", options.growAutofit));
        }
        if (options.useFELayout) {
          this.root.push(new OnOffElement2("w:useFELayout", options.useFELayout));
        }
        if (options.useNormalStyleForList) {
          this.root.push(new OnOffElement2("w:useNormalStyleForList", options.useNormalStyleForList));
        }
        if (options.doNotUseIndentAsNumberingTabStop) {
          this.root.push(new OnOffElement2("w:doNotUseIndentAsNumberingTabStop", options.doNotUseIndentAsNumberingTabStop));
        }
        if (options.useAlternateEastAsianLineBreakRules) {
          this.root.push(new OnOffElement2("w:useAltKinsokuLineBreakRules", options.useAlternateEastAsianLineBreakRules));
        }
        if (options.allowSpaceOfSameStyleInTable) {
          this.root.push(new OnOffElement2("w:allowSpaceOfSameStyleInTable", options.allowSpaceOfSameStyleInTable));
        }
        if (options.doNotSuppressIndentation) {
          this.root.push(new OnOffElement2("w:doNotSuppressIndentation", options.doNotSuppressIndentation));
        }
        if (options.doNotAutofitConstrainedTables) {
          this.root.push(new OnOffElement2("w:doNotAutofitConstrainedTables", options.doNotAutofitConstrainedTables));
        }
        if (options.autofitToFirstFixedWidthCell) {
          this.root.push(new OnOffElement2("w:autofitToFirstFixedWidthCell", options.autofitToFirstFixedWidthCell));
        }
        if (options.underlineTabInNumberingList) {
          this.root.push(new OnOffElement2("w:underlineTabInNumList", options.underlineTabInNumberingList));
        }
        if (options.displayHangulFixedWidth) {
          this.root.push(new OnOffElement2("w:displayHangulFixedWidth", options.displayHangulFixedWidth));
        }
        if (options.splitPgBreakAndParaMark) {
          this.root.push(new OnOffElement2("w:splitPgBreakAndParaMark", options.splitPgBreakAndParaMark));
        }
        if (options.doNotVerticallyAlignCellWithSp) {
          this.root.push(new OnOffElement2("w:doNotVertAlignCellWithSp", options.doNotVerticallyAlignCellWithSp));
        }
        if (options.doNotBreakConstrainedForcedTable) {
          this.root.push(new OnOffElement2("w:doNotBreakConstrainedForcedTable", options.doNotBreakConstrainedForcedTable));
        }
        if (options.ignoreVerticalAlignmentInTextboxes) {
          this.root.push(new OnOffElement2("w:doNotVertAlignInTxbx", options.ignoreVerticalAlignmentInTextboxes));
        }
        if (options.useAnsiKerningPairs) {
          this.root.push(new OnOffElement2("w:useAnsiKerningPairs", options.useAnsiKerningPairs));
        }
        if (options.cachedColumnBalance) {
          this.root.push(new OnOffElement2("w:cachedColBalance", options.cachedColumnBalance));
        }
      }
    };
    var SettingsAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", {
          wpc: "xmlns:wpc",
          mc: "xmlns:mc",
          o: "xmlns:o",
          r: "xmlns:r",
          m: "xmlns:m",
          v: "xmlns:v",
          wp14: "xmlns:wp14",
          wp: "xmlns:wp",
          w10: "xmlns:w10",
          w: "xmlns:w",
          w14: "xmlns:w14",
          w15: "xmlns:w15",
          wpg: "xmlns:wpg",
          wpi: "xmlns:wpi",
          wne: "xmlns:wne",
          wps: "xmlns:wps",
          Ignorable: "mc:Ignorable"
        });
      }
    };
    var Settings2 = class extends XmlComponent2 {
      constructor(options) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        super("w:settings");
        this.root.push(
          new SettingsAttributes2({
            wpc: "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas",
            mc: "http://schemas.openxmlformats.org/markup-compatibility/2006",
            o: "urn:schemas-microsoft-com:office:office",
            r: "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
            m: "http://schemas.openxmlformats.org/officeDocument/2006/math",
            v: "urn:schemas-microsoft-com:vml",
            wp14: "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
            wp: "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
            w10: "urn:schemas-microsoft-com:office:word",
            w: "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
            w14: "http://schemas.microsoft.com/office/word/2010/wordml",
            w15: "http://schemas.microsoft.com/office/word/2012/wordml",
            wpg: "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
            wpi: "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
            wne: "http://schemas.microsoft.com/office/word/2006/wordml",
            wps: "http://schemas.microsoft.com/office/word/2010/wordprocessingShape",
            Ignorable: "w14 w15 wp14"
          })
        );
        this.root.push(new OnOffElement2("w:displayBackgroundShape", true));
        if (options.trackRevisions !== void 0) {
          this.root.push(new OnOffElement2("w:trackRevisions", options.trackRevisions));
        }
        if (options.evenAndOddHeaders !== void 0) {
          this.root.push(new OnOffElement2("w:evenAndOddHeaders", options.evenAndOddHeaders));
        }
        if (options.updateFields !== void 0) {
          this.root.push(new OnOffElement2("w:updateFields", options.updateFields));
        }
        if (options.defaultTabStop !== void 0) {
          this.root.push(new NumberValueElement2("w:defaultTabStop", options.defaultTabStop));
        }
        if (((_a = options.hyphenation) == null ? void 0 : _a.autoHyphenation) !== void 0) {
          this.root.push(new OnOffElement2("w:autoHyphenation", options.hyphenation.autoHyphenation));
        }
        if (((_b = options.hyphenation) == null ? void 0 : _b.hyphenationZone) !== void 0) {
          this.root.push(new NumberValueElement2("w:hyphenationZone", options.hyphenation.hyphenationZone));
        }
        if (((_c = options.hyphenation) == null ? void 0 : _c.consecutiveHyphenLimit) !== void 0) {
          this.root.push(new NumberValueElement2("w:consecutiveHyphenLimit", options.hyphenation.consecutiveHyphenLimit));
        }
        if (((_d = options.hyphenation) == null ? void 0 : _d.doNotHyphenateCaps) !== void 0) {
          this.root.push(new OnOffElement2("w:doNotHyphenateCaps", options.hyphenation.doNotHyphenateCaps));
        }
        this.root.push(
          new Compatibility2(__spreadProps2(__spreadValues2({}, (_e = options.compatibility) != null ? _e : {}), {
            version: (_h = (_g = (_f = options.compatibility) == null ? void 0 : _f.version) != null ? _g : options.compatibilityModeVersion) != null ? _h : 15
          }))
        );
      }
    };
    var ComponentAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", { val: "w:val" });
      }
    };
    var Name2 = class extends XmlComponent2 {
      constructor(value) {
        super("w:name");
        this.root.push(new ComponentAttributes2({ val: value }));
      }
    };
    var UiPriority2 = class extends XmlComponent2 {
      constructor(value) {
        super("w:uiPriority");
        this.root.push(new ComponentAttributes2({ val: decimalNumber2(value) }));
      }
    };
    var StyleAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", {
          type: "w:type",
          styleId: "w:styleId",
          default: "w:default",
          customStyle: "w:customStyle"
        });
      }
    };
    var Style22 = class extends XmlComponent2 {
      constructor(attributes, options) {
        super("w:style");
        this.root.push(new StyleAttributes2(attributes));
        if (options.name) {
          this.root.push(new Name2(options.name));
        }
        if (options.basedOn) {
          this.root.push(new StringValueElement2("w:basedOn", options.basedOn));
        }
        if (options.next) {
          this.root.push(new StringValueElement2("w:next", options.next));
        }
        if (options.link) {
          this.root.push(new StringValueElement2("w:link", options.link));
        }
        if (options.uiPriority !== void 0) {
          this.root.push(new UiPriority2(options.uiPriority));
        }
        if (options.semiHidden !== void 0) {
          this.root.push(new OnOffElement2("w:semiHidden", options.semiHidden));
        }
        if (options.unhideWhenUsed !== void 0) {
          this.root.push(new OnOffElement2("w:unhideWhenUsed", options.unhideWhenUsed));
        }
        if (options.quickFormat !== void 0) {
          this.root.push(new OnOffElement2("w:qFormat", options.quickFormat));
        }
      }
    };
    var StyleForParagraph2 = class extends Style22 {
      constructor(options) {
        super({ type: "paragraph", styleId: options.id }, options);
        __publicField2(this, "paragraphProperties");
        __publicField2(this, "runProperties");
        this.paragraphProperties = new ParagraphProperties2(options.paragraph);
        this.runProperties = new RunProperties2(options.run);
        this.root.push(this.paragraphProperties);
        this.root.push(this.runProperties);
      }
    };
    var StyleForCharacter2 = class extends Style22 {
      constructor(options) {
        super(
          { type: "character", styleId: options.id },
          __spreadValues2({
            uiPriority: 99,
            unhideWhenUsed: true
          }, options)
        );
        __publicField2(this, "runProperties");
        this.runProperties = new RunProperties2(options.run);
        this.root.push(this.runProperties);
      }
    };
    var HeadingStyle2 = class extends StyleForParagraph2 {
      constructor(options) {
        super(__spreadValues2({
          basedOn: "Normal",
          next: "Normal",
          quickFormat: true
        }, options));
      }
    };
    var TitleStyle2 = class extends HeadingStyle2 {
      constructor(options) {
        super(__spreadValues2({
          id: "Title",
          name: "Title"
        }, options));
      }
    };
    var Heading1Style2 = class extends HeadingStyle2 {
      constructor(options) {
        super(__spreadValues2({
          id: "Heading1",
          name: "Heading 1"
        }, options));
      }
    };
    var Heading2Style2 = class extends HeadingStyle2 {
      constructor(options) {
        super(__spreadValues2({
          id: "Heading2",
          name: "Heading 2"
        }, options));
      }
    };
    var Heading3Style2 = class extends HeadingStyle2 {
      constructor(options) {
        super(__spreadValues2({
          id: "Heading3",
          name: "Heading 3"
        }, options));
      }
    };
    var Heading4Style2 = class extends HeadingStyle2 {
      constructor(options) {
        super(__spreadValues2({
          id: "Heading4",
          name: "Heading 4"
        }, options));
      }
    };
    var Heading5Style2 = class extends HeadingStyle2 {
      constructor(options) {
        super(__spreadValues2({
          id: "Heading5",
          name: "Heading 5"
        }, options));
      }
    };
    var Heading6Style2 = class extends HeadingStyle2 {
      constructor(options) {
        super(__spreadValues2({
          id: "Heading6",
          name: "Heading 6"
        }, options));
      }
    };
    var StrongStyle2 = class extends HeadingStyle2 {
      constructor(options) {
        super(__spreadValues2({
          id: "Strong",
          name: "Strong"
        }, options));
      }
    };
    var ListParagraph2 = class extends StyleForParagraph2 {
      constructor(options) {
        super(__spreadValues2({
          id: "ListParagraph",
          name: "List Paragraph",
          basedOn: "Normal",
          quickFormat: true
        }, options));
      }
    };
    var FootnoteText2 = class extends StyleForParagraph2 {
      constructor(options) {
        super(__spreadValues2({
          id: "FootnoteText",
          name: "footnote text",
          link: "FootnoteTextChar",
          basedOn: "Normal",
          uiPriority: 99,
          semiHidden: true,
          unhideWhenUsed: true,
          paragraph: {
            spacing: {
              after: 0,
              line: 240,
              lineRule: LineRuleType2.AUTO
            }
          },
          run: {
            size: 20
          }
        }, options));
      }
    };
    var FootnoteReferenceStyle2 = class extends StyleForCharacter2 {
      constructor(options) {
        super(__spreadValues2({
          id: "FootnoteReference",
          name: "footnote reference",
          basedOn: "DefaultParagraphFont",
          semiHidden: true,
          run: {
            superScript: true
          }
        }, options));
      }
    };
    var FootnoteTextChar2 = class extends StyleForCharacter2 {
      constructor(options) {
        super(__spreadValues2({
          id: "FootnoteTextChar",
          name: "Footnote Text Char",
          basedOn: "DefaultParagraphFont",
          link: "FootnoteText",
          semiHidden: true,
          run: {
            size: 20
          }
        }, options));
      }
    };
    var HyperlinkStyle2 = class extends StyleForCharacter2 {
      constructor(options) {
        super(__spreadValues2({
          id: "Hyperlink",
          name: "Hyperlink",
          basedOn: "DefaultParagraphFont",
          run: {
            color: "0563C1",
            underline: {
              type: UnderlineType2.SINGLE
            }
          }
        }, options));
      }
    };
    var Styles2 = class extends XmlComponent2 {
      constructor(options) {
        super("w:styles");
        if (options.initialStyles) {
          this.root.push(options.initialStyles);
        }
        if (options.importedStyles) {
          for (const style of options.importedStyles) {
            this.root.push(style);
          }
        }
        if (options.paragraphStyles) {
          for (const style of options.paragraphStyles) {
            this.root.push(new StyleForParagraph2(style));
          }
        }
        if (options.characterStyles) {
          for (const style of options.characterStyles) {
            this.root.push(new StyleForCharacter2(style));
          }
        }
      }
    };
    var ParagraphPropertiesDefaults2 = class extends XmlComponent2 {
      constructor(options) {
        super("w:pPrDefault");
        this.root.push(new ParagraphProperties2(options));
      }
    };
    var RunPropertiesDefaults2 = class extends XmlComponent2 {
      constructor(options) {
        super("w:rPrDefault");
        this.root.push(new RunProperties2(options));
      }
    };
    var DocumentDefaults2 = class extends XmlComponent2 {
      constructor(options) {
        super("w:docDefaults");
        __publicField2(this, "runPropertiesDefaults");
        __publicField2(this, "paragraphPropertiesDefaults");
        this.runPropertiesDefaults = new RunPropertiesDefaults2(options.run);
        this.paragraphPropertiesDefaults = new ParagraphPropertiesDefaults2(options.paragraph);
        this.root.push(this.runPropertiesDefaults);
        this.root.push(this.paragraphPropertiesDefaults);
      }
    };
    var ExternalStylesFactory2 = class {
      /**
       * Creates new Style based on the given styles.
       * Parses the styles and convert them to XmlComponent.
       * Example content from styles.xml:
       * <?xml version="1.0">
       * <w:styles xmlns:mc="some schema" ...>
       *
       *   <w:style w:type="paragraph" w:styleId="Heading1">
       *           <w:name w:val="heading 1"/>
       *           .....
       *   </w:style>
       *
       *   <w:style w:type="paragraph" w:styleId="Heading2">
       *           <w:name w:val="heading 2"/>
       *           .....
       *   </w:style>
       *
       *   <w:docDefaults>Or any other element will be parsed to</w:docDefaults>
       *
       * </w:styles>
       *
       * @param externalStyles context from styles.xml
       */
      newInstance(xmlData) {
        const xmlObj = libExports2.xml2js(xmlData, { compact: false });
        let stylesXmlElement;
        for (const xmlElm of xmlObj.elements || []) {
          if (xmlElm.name === "w:styles") {
            stylesXmlElement = xmlElm;
          }
        }
        if (stylesXmlElement === void 0) {
          throw new Error("can not find styles element");
        }
        const stylesElements = stylesXmlElement.elements || [];
        const importedStyle = new Styles2({
          initialStyles: new ImportedRootElementAttributes2(stylesXmlElement.attributes),
          importedStyles: stylesElements.map((childElm) => convertToXmlComponent2(childElm))
        });
        return importedStyle;
      }
    };
    var DefaultStylesFactory2 = class {
      newInstance(options = {}) {
        var _a;
        const documentAttributes = new DocumentAttributes2(["mc", "r", "w", "w14", "w15"], "w14 w15");
        return {
          initialStyles: documentAttributes,
          importedStyles: [
            new DocumentDefaults2((_a = options.document) != null ? _a : {}),
            new TitleStyle2(__spreadValues2({
              run: {
                size: 56
              }
            }, options.title)),
            new Heading1Style2(__spreadValues2({
              run: {
                color: "2E74B5",
                size: 32
              }
            }, options.heading1)),
            new Heading2Style2(__spreadValues2({
              run: {
                color: "2E74B5",
                size: 26
              }
            }, options.heading2)),
            new Heading3Style2(__spreadValues2({
              run: {
                color: "1F4D78",
                size: 24
              }
            }, options.heading3)),
            new Heading4Style2(__spreadValues2({
              run: {
                color: "2E74B5",
                italics: true
              }
            }, options.heading4)),
            new Heading5Style2(__spreadValues2({
              run: {
                color: "2E74B5"
              }
            }, options.heading5)),
            new Heading6Style2(__spreadValues2({
              run: {
                color: "1F4D78"
              }
            }, options.heading6)),
            new StrongStyle2(__spreadValues2({
              run: {
                bold: true
              }
            }, options.strong)),
            new ListParagraph2(options.listParagraph || {}),
            new HyperlinkStyle2(options.hyperlink || {}),
            new FootnoteReferenceStyle2(options.footnoteReference || {}),
            new FootnoteText2(options.footnoteText || {}),
            new FootnoteTextChar2(options.footnoteTextChar || {})
          ]
        };
      }
    };
    var File2 = class {
      constructor(options) {
        __publicField2(this, "currentRelationshipId", 1);
        __publicField2(this, "documentWrapper");
        __publicField2(this, "headers", []);
        __publicField2(this, "footers", []);
        __publicField2(this, "coreProperties");
        __publicField2(this, "numbering");
        __publicField2(this, "media");
        __publicField2(this, "fileRelationships");
        __publicField2(this, "footnotesWrapper");
        __publicField2(this, "settings");
        __publicField2(this, "contentTypes");
        __publicField2(this, "customProperties");
        __publicField2(this, "appProperties");
        __publicField2(this, "styles");
        __publicField2(this, "comments");
        __publicField2(this, "fontWrapper");
        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
        this.coreProperties = new CoreProperties2(__spreadProps2(__spreadValues2({}, options), {
          creator: (_a = options.creator) != null ? _a : "Un-named",
          revision: (_b = options.revision) != null ? _b : 1,
          lastModifiedBy: (_c = options.lastModifiedBy) != null ? _c : "Un-named"
        }));
        this.numbering = new Numbering2(options.numbering ? options.numbering : { config: [] });
        this.comments = new Comments2((_d = options.comments) != null ? _d : { children: [] });
        this.fileRelationships = new Relationships2();
        this.customProperties = new CustomProperties2((_e = options.customProperties) != null ? _e : []);
        this.appProperties = new AppProperties2();
        this.footnotesWrapper = new FootnotesWrapper2();
        this.contentTypes = new ContentTypes2();
        this.documentWrapper = new DocumentWrapper2({ background: options.background });
        this.settings = new Settings2({
          compatibilityModeVersion: options.compatabilityModeVersion,
          compatibility: options.compatibility,
          evenAndOddHeaders: options.evenAndOddHeaderAndFooters ? true : false,
          trackRevisions: (_f = options.features) == null ? void 0 : _f.trackRevisions,
          updateFields: (_g = options.features) == null ? void 0 : _g.updateFields,
          defaultTabStop: options.defaultTabStop,
          hyphenation: {
            autoHyphenation: (_h = options.hyphenation) == null ? void 0 : _h.autoHyphenation,
            hyphenationZone: (_i = options.hyphenation) == null ? void 0 : _i.hyphenationZone,
            consecutiveHyphenLimit: (_j = options.hyphenation) == null ? void 0 : _j.consecutiveHyphenLimit,
            doNotHyphenateCaps: (_k = options.hyphenation) == null ? void 0 : _k.doNotHyphenateCaps
          }
        });
        this.media = new Media2();
        if (options.externalStyles !== void 0) {
          const stylesFactory = new ExternalStylesFactory2();
          this.styles = stylesFactory.newInstance(options.externalStyles);
        } else if (options.styles) {
          const stylesFactory = new DefaultStylesFactory2();
          const defaultStyles = stylesFactory.newInstance(options.styles.default);
          this.styles = new Styles2(__spreadValues2(__spreadValues2({}, defaultStyles), options.styles));
        } else {
          const stylesFactory = new DefaultStylesFactory2();
          this.styles = new Styles2(stylesFactory.newInstance());
        }
        this.addDefaultRelationships();
        for (const section of options.sections) {
          this.addSection(section);
        }
        if (options.footnotes) {
          for (const key in options.footnotes) {
            this.footnotesWrapper.View.createFootNote(parseFloat(key), options.footnotes[key].children);
          }
        }
        this.fontWrapper = new FontWrapper2((_l = options.fonts) != null ? _l : []);
      }
      addSection({ headers = {}, footers = {}, children, properties }) {
        this.documentWrapper.View.Body.addSection(__spreadProps2(__spreadValues2({}, properties), {
          headerWrapperGroup: {
            default: headers.default ? this.createHeader(headers.default) : void 0,
            first: headers.first ? this.createHeader(headers.first) : void 0,
            even: headers.even ? this.createHeader(headers.even) : void 0
          },
          footerWrapperGroup: {
            default: footers.default ? this.createFooter(footers.default) : void 0,
            first: footers.first ? this.createFooter(footers.first) : void 0,
            even: footers.even ? this.createFooter(footers.even) : void 0
          }
        }));
        for (const child of children) {
          this.documentWrapper.View.add(child);
        }
      }
      createHeader(header) {
        const wrapper = new HeaderWrapper2(this.media, this.currentRelationshipId++);
        for (const child of header.options.children) {
          wrapper.add(child);
        }
        this.addHeaderToDocument(wrapper);
        return wrapper;
      }
      createFooter(footer) {
        const wrapper = new FooterWrapper2(this.media, this.currentRelationshipId++);
        for (const child of footer.options.children) {
          wrapper.add(child);
        }
        this.addFooterToDocument(wrapper);
        return wrapper;
      }
      addHeaderToDocument(header, type22 = HeaderFooterReferenceType2.DEFAULT) {
        this.headers.push({ header, type: type22 });
        this.documentWrapper.Relationships.createRelationship(
          header.View.ReferenceId,
          "http://schemas.openxmlformats.org/officeDocument/2006/relationships/header",
          `header${this.headers.length}.xml`
        );
        this.contentTypes.addHeader(this.headers.length);
      }
      addFooterToDocument(footer, type22 = HeaderFooterReferenceType2.DEFAULT) {
        this.footers.push({ footer, type: type22 });
        this.documentWrapper.Relationships.createRelationship(
          footer.View.ReferenceId,
          "http://schemas.openxmlformats.org/officeDocument/2006/relationships/footer",
          `footer${this.footers.length}.xml`
        );
        this.contentTypes.addFooter(this.footers.length);
      }
      addDefaultRelationships() {
        this.fileRelationships.createRelationship(
          1,
          "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
          "word/document.xml"
        );
        this.fileRelationships.createRelationship(
          2,
          "http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties",
          "docProps/core.xml"
        );
        this.fileRelationships.createRelationship(
          3,
          "http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties",
          "docProps/app.xml"
        );
        this.fileRelationships.createRelationship(
          4,
          "http://schemas.openxmlformats.org/officeDocument/2006/relationships/custom-properties",
          "docProps/custom.xml"
        );
        this.documentWrapper.Relationships.createRelationship(
          // eslint-disable-next-line functional/immutable-data
          this.currentRelationshipId++,
          "http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles",
          "styles.xml"
        );
        this.documentWrapper.Relationships.createRelationship(
          // eslint-disable-next-line functional/immutable-data
          this.currentRelationshipId++,
          "http://schemas.openxmlformats.org/officeDocument/2006/relationships/numbering",
          "numbering.xml"
        );
        this.documentWrapper.Relationships.createRelationship(
          // eslint-disable-next-line functional/immutable-data
          this.currentRelationshipId++,
          "http://schemas.openxmlformats.org/officeDocument/2006/relationships/footnotes",
          "footnotes.xml"
        );
        this.documentWrapper.Relationships.createRelationship(
          // eslint-disable-next-line functional/immutable-data
          this.currentRelationshipId++,
          "http://schemas.openxmlformats.org/officeDocument/2006/relationships/settings",
          "settings.xml"
        );
        this.documentWrapper.Relationships.createRelationship(
          // eslint-disable-next-line functional/immutable-data
          this.currentRelationshipId++,
          "http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments",
          "comments.xml"
        );
      }
      get Document() {
        return this.documentWrapper;
      }
      get Styles() {
        return this.styles;
      }
      get CoreProperties() {
        return this.coreProperties;
      }
      get Numbering() {
        return this.numbering;
      }
      get Media() {
        return this.media;
      }
      get FileRelationships() {
        return this.fileRelationships;
      }
      get Headers() {
        return this.headers.map((item) => item.header);
      }
      get Footers() {
        return this.footers.map((item) => item.footer);
      }
      get ContentTypes() {
        return this.contentTypes;
      }
      get CustomProperties() {
        return this.customProperties;
      }
      get AppProperties() {
        return this.appProperties;
      }
      get FootNotes() {
        return this.footnotesWrapper;
      }
      get Settings() {
        return this.settings;
      }
      get Comments() {
        return this.comments;
      }
      get FontTable() {
        return this.fontWrapper;
      }
    };
    var FieldInstruction = class extends XmlComponent2 {
      constructor(properties = {}) {
        super("w:instrText");
        __publicField2(this, "properties");
        this.properties = properties;
        this.root.push(new TextAttributes2({ space: SpaceType2.PRESERVE }));
        let instruction = "TOC";
        if (this.properties.captionLabel) {
          instruction = `${instruction} \\a "${this.properties.captionLabel}"`;
        }
        if (this.properties.entriesFromBookmark) {
          instruction = `${instruction} \\b "${this.properties.entriesFromBookmark}"`;
        }
        if (this.properties.captionLabelIncludingNumbers) {
          instruction = `${instruction} \\c "${this.properties.captionLabelIncludingNumbers}"`;
        }
        if (this.properties.sequenceAndPageNumbersSeparator) {
          instruction = `${instruction} \\d "${this.properties.sequenceAndPageNumbersSeparator}"`;
        }
        if (this.properties.tcFieldIdentifier) {
          instruction = `${instruction} \\f "${this.properties.tcFieldIdentifier}"`;
        }
        if (this.properties.hyperlink) {
          instruction = `${instruction} \\h`;
        }
        if (this.properties.tcFieldLevelRange) {
          instruction = `${instruction} \\l "${this.properties.tcFieldLevelRange}"`;
        }
        if (this.properties.pageNumbersEntryLevelsRange) {
          instruction = `${instruction} \\n "${this.properties.pageNumbersEntryLevelsRange}"`;
        }
        if (this.properties.headingStyleRange) {
          instruction = `${instruction} \\o "${this.properties.headingStyleRange}"`;
        }
        if (this.properties.entryAndPageNumberSeparator) {
          instruction = `${instruction} \\p "${this.properties.entryAndPageNumberSeparator}"`;
        }
        if (this.properties.seqFieldIdentifierForPrefix) {
          instruction = `${instruction} \\s "${this.properties.seqFieldIdentifierForPrefix}"`;
        }
        if (this.properties.stylesWithLevels && this.properties.stylesWithLevels.length) {
          const styles2 = this.properties.stylesWithLevels.map((sl) => `${sl.styleName},${sl.level}`).join(",");
          instruction = `${instruction} \\t "${styles2}"`;
        }
        if (this.properties.useAppliedParagraphOutlineLevel) {
          instruction = `${instruction} \\u`;
        }
        if (this.properties.preserveTabInEntries) {
          instruction = `${instruction} \\w`;
        }
        if (this.properties.preserveNewLineInEntries) {
          instruction = `${instruction} \\x`;
        }
        if (this.properties.hideTabAndPageNumbersInWebView) {
          instruction = `${instruction} \\z`;
        }
        this.root.push(instruction);
      }
    };
    var StructuredDocumentTagContent = class extends XmlComponent2 {
      constructor() {
        super("w:sdtContent");
      }
    };
    var StructuredDocumentTagProperties = class extends XmlComponent2 {
      constructor(alias) {
        super("w:sdtPr");
        if (alias) {
          this.root.push(new StringValueElement2("w:alias", alias));
        }
      }
    };
    var TableOfContents = class extends FileChild2 {
      constructor(alias = "Table of Contents", properties) {
        super("w:sdt");
        this.root.push(new StructuredDocumentTagProperties(alias));
        const content = new StructuredDocumentTagContent();
        const beginParagraph = new Paragraph3({
          children: [
            new Run2({
              children: [new Begin2(true), new FieldInstruction(properties), new Separate2()]
            })
          ]
        });
        content.addChildElement(beginParagraph);
        const endParagraph = new Paragraph3({
          children: [
            new Run2({
              children: [new End2()]
            })
          ]
        });
        content.addChildElement(endParagraph);
        this.root.push(content);
      }
    };
    var StyleLevel2 = class {
      constructor(styleName, level) {
        __publicField2(this, "styleName");
        __publicField2(this, "level");
        this.styleName = styleName;
        this.level = level;
      }
    };
    var Header2 = class {
      constructor(options = { children: [] }) {
        __publicField2(this, "options");
        this.options = options;
      }
    };
    var Footer2 = class {
      constructor(options = { children: [] }) {
        __publicField2(this, "options");
        this.options = options;
      }
    };
    var FootNoteReferenceRunAttributes2 = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", {
          id: "w:id"
        });
      }
    };
    var FootnoteReference2 = class extends XmlComponent2 {
      constructor(id) {
        super("w:footnoteReference");
        this.root.push(
          new FootNoteReferenceRunAttributes2({
            id
          })
        );
      }
    };
    var FootnoteReferenceRun3 = class extends Run2 {
      constructor(id) {
        super({ style: "FootnoteReference" });
        this.root.push(new FootnoteReference2(id));
      }
    };
    var InsertedTextRun = class extends XmlComponent2 {
      constructor(options) {
        super("w:ins");
        this.root.push(
          new ChangeAttributes2({
            id: options.id,
            author: options.author,
            date: options.date
          })
        );
        this.addChildElement(new TextRun3(options));
      }
    };
    var DeletedPage = class extends XmlComponent2 {
      constructor() {
        super("w:delInstrText");
        this.root.push(new TextAttributes2({ space: SpaceType2.PRESERVE }));
        this.root.push("PAGE");
      }
    };
    var DeletedNumberOfPages = class extends XmlComponent2 {
      constructor() {
        super("w:delInstrText");
        this.root.push(new TextAttributes2({ space: SpaceType2.PRESERVE }));
        this.root.push("NUMPAGES");
      }
    };
    var DeletedNumberOfPagesSection = class extends XmlComponent2 {
      constructor() {
        super("w:delInstrText");
        this.root.push(new TextAttributes2({ space: SpaceType2.PRESERVE }));
        this.root.push("SECTIONPAGES");
      }
    };
    var DeletedText = class extends XmlComponent2 {
      constructor(text) {
        super("w:delText");
        this.root.push(new TextAttributes2({ space: SpaceType2.PRESERVE }));
        this.root.push(text);
      }
    };
    var DeletedTextRun = class extends XmlComponent2 {
      constructor(options) {
        super("w:del");
        __publicField2(this, "deletedTextRunWrapper");
        this.root.push(
          new ChangeAttributes2({
            id: options.id,
            author: options.author,
            date: options.date
          })
        );
        this.deletedTextRunWrapper = new DeletedTextRunWrapper(options);
        this.addChildElement(this.deletedTextRunWrapper);
      }
    };
    var DeletedTextRunWrapper = class extends XmlComponent2 {
      constructor(options) {
        super("w:r");
        this.root.push(new RunProperties2(options));
        if (options.children) {
          for (const child of options.children) {
            if (typeof child === "string") {
              switch (child) {
                case PageNumber2.CURRENT:
                  this.root.push(new Begin2());
                  this.root.push(new DeletedPage());
                  this.root.push(new Separate2());
                  this.root.push(new End2());
                  break;
                case PageNumber2.TOTAL_PAGES:
                  this.root.push(new Begin2());
                  this.root.push(new DeletedNumberOfPages());
                  this.root.push(new Separate2());
                  this.root.push(new End2());
                  break;
                case PageNumber2.TOTAL_PAGES_IN_SECTION:
                  this.root.push(new Begin2());
                  this.root.push(new DeletedNumberOfPagesSection());
                  this.root.push(new Separate2());
                  this.root.push(new End2());
                  break;
                default:
                  this.root.push(new DeletedText(child));
                  break;
              }
              continue;
            }
            this.root.push(child);
          }
        } else if (options.text) {
          this.root.push(new DeletedText(options.text));
        }
        if (options.break) {
          for (let i = 0; i < options.break; i++) {
            this.root.splice(1, 0, new Break$12());
          }
        }
      }
    };
    var CheckboxSymbolAttributes = class extends XmlAttributeComponent2 {
      constructor() {
        super(...arguments);
        __publicField2(this, "xmlKeys", {
          val: "w14:val",
          symbolfont: "w14:font"
        });
      }
    };
    var CheckBoxSymbolElement = class extends XmlComponent2 {
      constructor(name, val, font) {
        super(name);
        if (font) {
          this.root.push(new CheckboxSymbolAttributes({ val: shortHexNumber(val), symbolfont: font }));
        } else {
          this.root.push(new CheckboxSymbolAttributes({ val }));
        }
      }
    };
    var CheckBoxUtil = class extends XmlComponent2 {
      constructor(options) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        super("w14:checkbox");
        __publicField2(this, "DEFAULT_UNCHECKED_SYMBOL", "2610");
        __publicField2(this, "DEFAULT_CHECKED_SYMBOL", "2612");
        __publicField2(this, "DEFAULT_FONT", "MS Gothic");
        const value = (options == null ? void 0 : options.checked) ? "1" : "0";
        let symbol;
        let font;
        this.root.push(new CheckBoxSymbolElement("w14:checked", value));
        symbol = ((_a = options == null ? void 0 : options.checkedState) == null ? void 0 : _a.value) ? (_b = options == null ? void 0 : options.checkedState) == null ? void 0 : _b.value : this.DEFAULT_CHECKED_SYMBOL;
        font = ((_c = options == null ? void 0 : options.checkedState) == null ? void 0 : _c.font) ? (_d = options == null ? void 0 : options.checkedState) == null ? void 0 : _d.font : this.DEFAULT_FONT;
        this.root.push(new CheckBoxSymbolElement("w14:checkedState", symbol, font));
        symbol = ((_e = options == null ? void 0 : options.uncheckedState) == null ? void 0 : _e.value) ? (_f = options == null ? void 0 : options.uncheckedState) == null ? void 0 : _f.value : this.DEFAULT_UNCHECKED_SYMBOL;
        font = ((_g = options == null ? void 0 : options.uncheckedState) == null ? void 0 : _g.font) ? (_h = options == null ? void 0 : options.uncheckedState) == null ? void 0 : _h.font : this.DEFAULT_FONT;
        this.root.push(new CheckBoxSymbolElement("w14:uncheckedState", symbol, font));
      }
    };
    var CheckBox = class extends XmlComponent2 {
      constructor(options) {
        var _a, _b, _c, _d;
        super("w:sdt");
        __publicField2(this, "DEFAULT_UNCHECKED_SYMBOL", "2610");
        __publicField2(this, "DEFAULT_CHECKED_SYMBOL", "2612");
        __publicField2(this, "DEFAULT_FONT", "MS Gothic");
        const properties = new StructuredDocumentTagProperties(options == null ? void 0 : options.alias);
        properties.addChildElement(new CheckBoxUtil(options));
        this.root.push(properties);
        const content = new StructuredDocumentTagContent();
        const checkedFont = (_a = options == null ? void 0 : options.checkedState) == null ? void 0 : _a.font;
        const checkedText = (_b = options == null ? void 0 : options.checkedState) == null ? void 0 : _b.value;
        const uncheckedFont = (_c = options == null ? void 0 : options.uncheckedState) == null ? void 0 : _c.font;
        const uncheckedText = (_d = options == null ? void 0 : options.uncheckedState) == null ? void 0 : _d.value;
        let symbolFont;
        let char;
        if (options == null ? void 0 : options.checked) {
          symbolFont = checkedFont ? checkedFont : this.DEFAULT_FONT;
          char = checkedText ? checkedText : this.DEFAULT_CHECKED_SYMBOL;
        } else {
          symbolFont = uncheckedFont ? uncheckedFont : this.DEFAULT_FONT;
          char = uncheckedText ? uncheckedText : this.DEFAULT_UNCHECKED_SYMBOL;
        }
        const initialRenderedChar = new SymbolRun({
          char,
          symbolfont: symbolFont
        });
        content.addChildElement(initialRenderedChar);
        this.root.push(content);
      }
    };
    var createPictElement = ({ shape }) => new BuilderElement2({
      name: "w:pict",
      children: [shape]
    });
    var createTextboxContent = ({ children = [] }) => new BuilderElement2({
      name: "w:txbxContent",
      children
    });
    var createVmlTextbox = ({ style, children, inset }) => new BuilderElement2({
      name: "v:textbox",
      attributes: {
        style: {
          key: "style",
          value: style
        },
        insetMode: {
          key: "insetmode",
          value: inset ? "custom" : "auto"
        },
        inset: {
          key: "inset",
          value: inset ? `${inset.left}, ${inset.top}, ${inset.right}, ${inset.bottom}` : void 0
        }
      },
      children: [createTextboxContent({ children })]
    });
    var SHAPE_TYPE = "#_x0000_t202";
    var styleToKeyMap = {
      flip: "flip",
      height: "height",
      left: "left",
      marginBottom: "margin-bottom",
      marginLeft: "margin-left",
      marginRight: "margin-right",
      marginTop: "margin-top",
      positionHorizontal: "mso-position-horizontal",
      positionHorizontalRelative: "mso-position-horizontal-relative",
      positionVertical: "mso-position-vertical",
      positionVerticalRelative: "mso-position-vertical-relative",
      wrapDistanceBottom: "mso-wrap-distance-bottom",
      wrapDistanceLeft: "mso-wrap-distance-left",
      wrapDistanceRight: "mso-wrap-distance-right",
      wrapDistanceTop: "mso-wrap-distance-top",
      wrapEdited: "mso-wrap-edited",
      wrapStyle: "mso-wrap-style",
      position: "position",
      rotation: "rotation",
      top: "top",
      visibility: "visibility",
      width: "width",
      zIndex: "z-index"
    };
    var formatShapeStyle = (style) => style ? Object.entries(style).map(([key, value]) => `${styleToKeyMap[key]}:${value}`).join(";") : void 0;
    var createShape = ({ id, children, type: type22 = SHAPE_TYPE, style }) => new BuilderElement2({
      name: "v:shape",
      attributes: {
        id: {
          key: "id",
          value: id
        },
        type: {
          key: "type",
          value: type22
        },
        style: {
          key: "style",
          value: formatShapeStyle(style)
        }
      },
      children: [createVmlTextbox({ style: "mso-fit-shape-to-text:t;", children })]
    });
    var Textbox = class extends FileChild2 {
      constructor(_a) {
        var _b = _a, { style, children } = _b, rest = __objRest(_b, ["style", "children"]);
        super("w:p");
        this.root.push(new ParagraphProperties2(rest));
        this.root.push(
          createPictElement({
            shape: createShape({
              children,
              id: uniqueId2(),
              style
            })
          })
        );
      }
    };
    var streamBrowserifyExports2 = requireStreamBrowserify2();
    function commonjsRequire2(path) {
      throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
    }
    var jszip_min2 = { exports: {} };
    var hasRequiredJszip_min2;
    function requireJszip_min2() {
      if (hasRequiredJszip_min2) return jszip_min2.exports;
      hasRequiredJszip_min2 = 1;
      (function(module22, exports22) {
        !(function(e) {
          module22.exports = e();
        })(function() {
          return (function s(a, o, h) {
            function u(r, e2) {
              if (!o[r]) {
                if (!a[r]) {
                  var t = "function" == typeof commonjsRequire2 && commonjsRequire2;
                  if (!e2 && t) return t(r, true);
                  if (l) return l(r, true);
                  var n = new Error("Cannot find module '" + r + "'");
                  throw n.code = "MODULE_NOT_FOUND", n;
                }
                var i = o[r] = { exports: {} };
                a[r][0].call(i.exports, function(e3) {
                  var t2 = a[r][1][e3];
                  return u(t2 || e3);
                }, i, i.exports, s, a, o, h);
              }
              return o[r].exports;
            }
            for (var l = "function" == typeof commonjsRequire2 && commonjsRequire2, e = 0; e < h.length; e++) u(h[e]);
            return u;
          })({ 1: [function(e, t, r) {
            var d = e("./utils"), c = e("./support"), p = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
            r.encode = function(e2) {
              for (var t2, r2, n, i, s, a, o, h = [], u = 0, l = e2.length, f = l, c2 = "string" !== d.getTypeOf(e2); u < e2.length; ) f = l - u, n = c2 ? (t2 = e2[u++], r2 = u < l ? e2[u++] : 0, u < l ? e2[u++] : 0) : (t2 = e2.charCodeAt(u++), r2 = u < l ? e2.charCodeAt(u++) : 0, u < l ? e2.charCodeAt(u++) : 0), i = t2 >> 2, s = (3 & t2) << 4 | r2 >> 4, a = 1 < f ? (15 & r2) << 2 | n >> 6 : 64, o = 2 < f ? 63 & n : 64, h.push(p.charAt(i) + p.charAt(s) + p.charAt(a) + p.charAt(o));
              return h.join("");
            }, r.decode = function(e2) {
              var t2, r2, n, i, s, a, o = 0, h = 0, u = "data:";
              if (e2.substr(0, u.length) === u) throw new Error("Invalid base64 input, it looks like a data url.");
              var l, f = 3 * (e2 = e2.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
              if (e2.charAt(e2.length - 1) === p.charAt(64) && f--, e2.charAt(e2.length - 2) === p.charAt(64) && f--, f % 1 != 0) throw new Error("Invalid base64 input, bad content length.");
              for (l = c.uint8array ? new Uint8Array(0 | f) : new Array(0 | f); o < e2.length; ) t2 = p.indexOf(e2.charAt(o++)) << 2 | (i = p.indexOf(e2.charAt(o++))) >> 4, r2 = (15 & i) << 4 | (s = p.indexOf(e2.charAt(o++))) >> 2, n = (3 & s) << 6 | (a = p.indexOf(e2.charAt(o++))), l[h++] = t2, 64 !== s && (l[h++] = r2), 64 !== a && (l[h++] = n);
              return l;
            };
          }, { "./support": 30, "./utils": 32 }], 2: [function(e, t, r) {
            var n = e("./external"), i = e("./stream/DataWorker"), s = e("./stream/Crc32Probe"), a = e("./stream/DataLengthProbe");
            function o(e2, t2, r2, n2, i2) {
              this.compressedSize = e2, this.uncompressedSize = t2, this.crc32 = r2, this.compression = n2, this.compressedContent = i2;
            }
            o.prototype = { getContentWorker: function() {
              var e2 = new i(n.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a("data_length")), t2 = this;
              return e2.on("end", function() {
                if (this.streamInfo.data_length !== t2.uncompressedSize) throw new Error("Bug : uncompressed data size mismatch");
              }), e2;
            }, getCompressedWorker: function() {
              return new i(n.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
            } }, o.createWorkerFrom = function(e2, t2, r2) {
              return e2.pipe(new s()).pipe(new a("uncompressedSize")).pipe(t2.compressWorker(r2)).pipe(new a("compressedSize")).withStreamInfo("compression", t2);
            }, t.exports = o;
          }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(e, t, r) {
            var n = e("./stream/GenericWorker");
            r.STORE = { magic: "\0\0", compressWorker: function() {
              return new n("STORE compression");
            }, uncompressWorker: function() {
              return new n("STORE decompression");
            } }, r.DEFLATE = e("./flate");
          }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(e, t, r) {
            var n = e("./utils");
            var o = (function() {
              for (var e2, t2 = [], r2 = 0; r2 < 256; r2++) {
                e2 = r2;
                for (var n2 = 0; n2 < 8; n2++) e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
                t2[r2] = e2;
              }
              return t2;
            })();
            t.exports = function(e2, t2) {
              return void 0 !== e2 && e2.length ? "string" !== n.getTypeOf(e2) ? (function(e3, t3, r2, n2) {
                var i = o, s = n2 + r2;
                e3 ^= -1;
                for (var a = n2; a < s; a++) e3 = e3 >>> 8 ^ i[255 & (e3 ^ t3[a])];
                return -1 ^ e3;
              })(0 | t2, e2, e2.length, 0) : (function(e3, t3, r2, n2) {
                var i = o, s = n2 + r2;
                e3 ^= -1;
                for (var a = n2; a < s; a++) e3 = e3 >>> 8 ^ i[255 & (e3 ^ t3.charCodeAt(a))];
                return -1 ^ e3;
              })(0 | t2, e2, e2.length, 0) : 0;
            };
          }, { "./utils": 32 }], 5: [function(e, t, r) {
            r.base64 = false, r.binary = false, r.dir = false, r.createFolders = true, r.date = null, r.compression = null, r.compressionOptions = null, r.comment = null, r.unixPermissions = null, r.dosPermissions = null;
          }, {}], 6: [function(e, t, r) {
            var n = null;
            n = "undefined" != typeof Promise ? Promise : e("lie"), t.exports = { Promise: n };
          }, { lie: 37 }], 7: [function(e, t, r) {
            var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Uint32Array, i = e("pako"), s = e("./utils"), a = e("./stream/GenericWorker"), o = n ? "uint8array" : "array";
            function h(e2, t2) {
              a.call(this, "FlateWorker/" + e2), this._pako = null, this._pakoAction = e2, this._pakoOptions = t2, this.meta = {};
            }
            r.magic = "\b\0", s.inherits(h, a), h.prototype.processChunk = function(e2) {
              this.meta = e2.meta, null === this._pako && this._createPako(), this._pako.push(s.transformTo(o, e2.data), false);
            }, h.prototype.flush = function() {
              a.prototype.flush.call(this), null === this._pako && this._createPako(), this._pako.push([], true);
            }, h.prototype.cleanUp = function() {
              a.prototype.cleanUp.call(this), this._pako = null;
            }, h.prototype._createPako = function() {
              this._pako = new i[this._pakoAction]({ raw: true, level: this._pakoOptions.level || -1 });
              var t2 = this;
              this._pako.onData = function(e2) {
                t2.push({ data: e2, meta: t2.meta });
              };
            }, r.compressWorker = function(e2) {
              return new h("Deflate", e2);
            }, r.uncompressWorker = function() {
              return new h("Inflate", {});
            };
          }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(e, t, r) {
            function A(e2, t2) {
              var r2, n2 = "";
              for (r2 = 0; r2 < t2; r2++) n2 += String.fromCharCode(255 & e2), e2 >>>= 8;
              return n2;
            }
            function n(e2, t2, r2, n2, i2, s2) {
              var a, o, h = e2.file, u = e2.compression, l = s2 !== O.utf8encode, f = I.transformTo("string", s2(h.name)), c = I.transformTo("string", O.utf8encode(h.name)), d = h.comment, p = I.transformTo("string", s2(d)), m = I.transformTo("string", O.utf8encode(d)), _ = c.length !== h.name.length, g = m.length !== d.length, b = "", v = "", y = "", w = h.dir, k = h.date, x = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
              t2 && !r2 || (x.crc32 = e2.crc32, x.compressedSize = e2.compressedSize, x.uncompressedSize = e2.uncompressedSize);
              var S = 0;
              t2 && (S |= 8), l || !_ && !g || (S |= 2048);
              var z = 0, C = 0;
              w && (z |= 16), "UNIX" === i2 ? (C = 798, z |= (function(e3, t3) {
                var r3 = e3;
                return e3 || (r3 = t3 ? 16893 : 33204), (65535 & r3) << 16;
              })(h.unixPermissions, w)) : (C = 20, z |= (function(e3) {
                return 63 & (e3 || 0);
              })(h.dosPermissions)), a = k.getUTCHours(), a <<= 6, a |= k.getUTCMinutes(), a <<= 5, a |= k.getUTCSeconds() / 2, o = k.getUTCFullYear() - 1980, o <<= 4, o |= k.getUTCMonth() + 1, o <<= 5, o |= k.getUTCDate(), _ && (v = A(1, 1) + A(B(f), 4) + c, b += "up" + A(v.length, 2) + v), g && (y = A(1, 1) + A(B(p), 4) + m, b += "uc" + A(y.length, 2) + y);
              var E = "";
              return E += "\n\0", E += A(S, 2), E += u.magic, E += A(a, 2), E += A(o, 2), E += A(x.crc32, 4), E += A(x.compressedSize, 4), E += A(x.uncompressedSize, 4), E += A(f.length, 2), E += A(b.length, 2), { fileRecord: R.LOCAL_FILE_HEADER + E + f + b, dirRecord: R.CENTRAL_FILE_HEADER + A(C, 2) + E + A(p.length, 2) + "\0\0\0\0" + A(z, 4) + A(n2, 4) + f + b + p };
            }
            var I = e("../utils"), i = e("../stream/GenericWorker"), O = e("../utf8"), B = e("../crc32"), R = e("../signature");
            function s(e2, t2, r2, n2) {
              i.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = t2, this.zipPlatform = r2, this.encodeFileName = n2, this.streamFiles = e2, this.accumulate = false, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
            }
            I.inherits(s, i), s.prototype.push = function(e2) {
              var t2 = e2.meta.percent || 0, r2 = this.entriesCount, n2 = this._sources.length;
              this.accumulate ? this.contentBuffer.push(e2) : (this.bytesWritten += e2.data.length, i.prototype.push.call(this, { data: e2.data, meta: { currentFile: this.currentFile, percent: r2 ? (t2 + 100 * (r2 - n2 - 1)) / r2 : 100 } }));
            }, s.prototype.openedSource = function(e2) {
              this.currentSourceOffset = this.bytesWritten, this.currentFile = e2.file.name;
              var t2 = this.streamFiles && !e2.file.dir;
              if (t2) {
                var r2 = n(e2, t2, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
                this.push({ data: r2.fileRecord, meta: { percent: 0 } });
              } else this.accumulate = true;
            }, s.prototype.closedSource = function(e2) {
              this.accumulate = false;
              var t2 = this.streamFiles && !e2.file.dir, r2 = n(e2, t2, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
              if (this.dirRecords.push(r2.dirRecord), t2) this.push({ data: (function(e3) {
                return R.DATA_DESCRIPTOR + A(e3.crc32, 4) + A(e3.compressedSize, 4) + A(e3.uncompressedSize, 4);
              })(e2), meta: { percent: 100 } });
              else for (this.push({ data: r2.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; ) this.push(this.contentBuffer.shift());
              this.currentFile = null;
            }, s.prototype.flush = function() {
              for (var e2 = this.bytesWritten, t2 = 0; t2 < this.dirRecords.length; t2++) this.push({ data: this.dirRecords[t2], meta: { percent: 100 } });
              var r2 = this.bytesWritten - e2, n2 = (function(e3, t3, r3, n3, i2) {
                var s2 = I.transformTo("string", i2(n3));
                return R.CENTRAL_DIRECTORY_END + "\0\0\0\0" + A(e3, 2) + A(e3, 2) + A(t3, 4) + A(r3, 4) + A(s2.length, 2) + s2;
              })(this.dirRecords.length, r2, e2, this.zipComment, this.encodeFileName);
              this.push({ data: n2, meta: { percent: 100 } });
            }, s.prototype.prepareNextSource = function() {
              this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
            }, s.prototype.registerPrevious = function(e2) {
              this._sources.push(e2);
              var t2 = this;
              return e2.on("data", function(e3) {
                t2.processChunk(e3);
              }), e2.on("end", function() {
                t2.closedSource(t2.previous.streamInfo), t2._sources.length ? t2.prepareNextSource() : t2.end();
              }), e2.on("error", function(e3) {
                t2.error(e3);
              }), this;
            }, s.prototype.resume = function() {
              return !!i.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), true) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), true));
            }, s.prototype.error = function(e2) {
              var t2 = this._sources;
              if (!i.prototype.error.call(this, e2)) return false;
              for (var r2 = 0; r2 < t2.length; r2++) try {
                t2[r2].error(e2);
              } catch (e3) {
              }
              return true;
            }, s.prototype.lock = function() {
              i.prototype.lock.call(this);
              for (var e2 = this._sources, t2 = 0; t2 < e2.length; t2++) e2[t2].lock();
            }, t.exports = s;
          }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(e, t, r) {
            var u = e("../compressions"), n = e("./ZipFileWorker");
            r.generateWorker = function(e2, a, t2) {
              var o = new n(a.streamFiles, t2, a.platform, a.encodeFileName), h = 0;
              try {
                e2.forEach(function(e3, t3) {
                  h++;
                  var r2 = (function(e4, t4) {
                    var r3 = e4 || t4, n3 = u[r3];
                    if (!n3) throw new Error(r3 + " is not a valid compression method !");
                    return n3;
                  })(t3.options.compression, a.compression), n2 = t3.options.compressionOptions || a.compressionOptions || {}, i = t3.dir, s = t3.date;
                  t3._compressWorker(r2, n2).withStreamInfo("file", { name: e3, dir: i, date: s, comment: t3.comment || "", unixPermissions: t3.unixPermissions, dosPermissions: t3.dosPermissions }).pipe(o);
                }), o.entriesCount = h;
              } catch (e3) {
                o.error(e3);
              }
              return o;
            };
          }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(e, t, r) {
            function n() {
              if (!(this instanceof n)) return new n();
              if (arguments.length) throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
              this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
                var e2 = new n();
                for (var t2 in this) "function" != typeof this[t2] && (e2[t2] = this[t2]);
                return e2;
              };
            }
            (n.prototype = e("./object")).loadAsync = e("./load"), n.support = e("./support"), n.defaults = e("./defaults"), n.version = "3.10.1", n.loadAsync = function(e2, t2) {
              return new n().loadAsync(e2, t2);
            }, n.external = e("./external"), t.exports = n;
          }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(e, t, r) {
            var u = e("./utils"), i = e("./external"), n = e("./utf8"), s = e("./zipEntries"), a = e("./stream/Crc32Probe"), l = e("./nodejsUtils");
            function f(n2) {
              return new i.Promise(function(e2, t2) {
                var r2 = n2.decompressed.getContentWorker().pipe(new a());
                r2.on("error", function(e3) {
                  t2(e3);
                }).on("end", function() {
                  r2.streamInfo.crc32 !== n2.decompressed.crc32 ? t2(new Error("Corrupted zip : CRC32 mismatch")) : e2();
                }).resume();
              });
            }
            t.exports = function(e2, o) {
              var h = this;
              return o = u.extend(o || {}, { base64: false, checkCRC32: false, optimizedBinaryString: false, createFolders: false, decodeFileName: n.utf8decode }), l.isNode && l.isStream(e2) ? i.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : u.prepareContent("the loaded zip file", e2, true, o.optimizedBinaryString, o.base64).then(function(e3) {
                var t2 = new s(o);
                return t2.load(e3), t2;
              }).then(function(e3) {
                var t2 = [i.Promise.resolve(e3)], r2 = e3.files;
                if (o.checkCRC32) for (var n2 = 0; n2 < r2.length; n2++) t2.push(f(r2[n2]));
                return i.Promise.all(t2);
              }).then(function(e3) {
                for (var t2 = e3.shift(), r2 = t2.files, n2 = 0; n2 < r2.length; n2++) {
                  var i2 = r2[n2], s2 = i2.fileNameStr, a2 = u.resolve(i2.fileNameStr);
                  h.file(a2, i2.decompressed, { binary: true, optimizedBinaryString: true, date: i2.date, dir: i2.dir, comment: i2.fileCommentStr.length ? i2.fileCommentStr : null, unixPermissions: i2.unixPermissions, dosPermissions: i2.dosPermissions, createFolders: o.createFolders }), i2.dir || (h.file(a2).unsafeOriginalName = s2);
                }
                return t2.zipComment.length && (h.comment = t2.zipComment), h;
              });
            };
          }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(e, t, r) {
            var n = e("../utils"), i = e("../stream/GenericWorker");
            function s(e2, t2) {
              i.call(this, "Nodejs stream input adapter for " + e2), this._upstreamEnded = false, this._bindStream(t2);
            }
            n.inherits(s, i), s.prototype._bindStream = function(e2) {
              var t2 = this;
              (this._stream = e2).pause(), e2.on("data", function(e3) {
                t2.push({ data: e3, meta: { percent: 0 } });
              }).on("error", function(e3) {
                t2.isPaused ? this.generatedError = e3 : t2.error(e3);
              }).on("end", function() {
                t2.isPaused ? t2._upstreamEnded = true : t2.end();
              });
            }, s.prototype.pause = function() {
              return !!i.prototype.pause.call(this) && (this._stream.pause(), true);
            }, s.prototype.resume = function() {
              return !!i.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), true);
            }, t.exports = s;
          }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(e, t, r) {
            var i = e("readable-stream").Readable;
            function n(e2, t2, r2) {
              i.call(this, t2), this._helper = e2;
              var n2 = this;
              e2.on("data", function(e3, t3) {
                n2.push(e3) || n2._helper.pause(), r2 && r2(t3);
              }).on("error", function(e3) {
                n2.emit("error", e3);
              }).on("end", function() {
                n2.push(null);
              });
            }
            e("../utils").inherits(n, i), n.prototype._read = function() {
              this._helper.resume();
            }, t.exports = n;
          }, { "../utils": 32, "readable-stream": 16 }], 14: [function(e, t, r) {
            t.exports = { isNode: "undefined" != typeof Buffer, newBufferFrom: function(e2, t2) {
              if (Buffer.from && Buffer.from !== Uint8Array.from) return Buffer.from(e2, t2);
              if ("number" == typeof e2) throw new Error('The "data" argument must not be a number');
              return new Buffer(e2, t2);
            }, allocBuffer: function(e2) {
              if (Buffer.alloc) return Buffer.alloc(e2);
              var t2 = new Buffer(e2);
              return t2.fill(0), t2;
            }, isBuffer: function(e2) {
              return Buffer.isBuffer(e2);
            }, isStream: function(e2) {
              return e2 && "function" == typeof e2.on && "function" == typeof e2.pause && "function" == typeof e2.resume;
            } };
          }, {}], 15: [function(e, t, r) {
            function s(e2, t2, r2) {
              var n2, i2 = u.getTypeOf(t2), s2 = u.extend(r2 || {}, f);
              s2.date = s2.date || /* @__PURE__ */ new Date(), null !== s2.compression && (s2.compression = s2.compression.toUpperCase()), "string" == typeof s2.unixPermissions && (s2.unixPermissions = parseInt(s2.unixPermissions, 8)), s2.unixPermissions && 16384 & s2.unixPermissions && (s2.dir = true), s2.dosPermissions && 16 & s2.dosPermissions && (s2.dir = true), s2.dir && (e2 = g(e2)), s2.createFolders && (n2 = _(e2)) && b.call(this, n2, true);
              var a2 = "string" === i2 && false === s2.binary && false === s2.base64;
              r2 && void 0 !== r2.binary || (s2.binary = !a2), (t2 instanceof c && 0 === t2.uncompressedSize || s2.dir || !t2 || 0 === t2.length) && (s2.base64 = false, s2.binary = true, t2 = "", s2.compression = "STORE", i2 = "string");
              var o2 = null;
              o2 = t2 instanceof c || t2 instanceof l ? t2 : p.isNode && p.isStream(t2) ? new m(e2, t2) : u.prepareContent(e2, t2, s2.binary, s2.optimizedBinaryString, s2.base64);
              var h2 = new d(e2, o2, s2);
              this.files[e2] = h2;
            }
            var i = e("./utf8"), u = e("./utils"), l = e("./stream/GenericWorker"), a = e("./stream/StreamHelper"), f = e("./defaults"), c = e("./compressedObject"), d = e("./zipObject"), o = e("./generate"), p = e("./nodejsUtils"), m = e("./nodejs/NodejsStreamInputAdapter"), _ = function(e2) {
              "/" === e2.slice(-1) && (e2 = e2.substring(0, e2.length - 1));
              var t2 = e2.lastIndexOf("/");
              return 0 < t2 ? e2.substring(0, t2) : "";
            }, g = function(e2) {
              return "/" !== e2.slice(-1) && (e2 += "/"), e2;
            }, b = function(e2, t2) {
              return t2 = void 0 !== t2 ? t2 : f.createFolders, e2 = g(e2), this.files[e2] || s.call(this, e2, null, { dir: true, createFolders: t2 }), this.files[e2];
            };
            function h(e2) {
              return "[object RegExp]" === Object.prototype.toString.call(e2);
            }
            var n = { load: function() {
              throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
            }, forEach: function(e2) {
              var t2, r2, n2;
              for (t2 in this.files) n2 = this.files[t2], (r2 = t2.slice(this.root.length, t2.length)) && t2.slice(0, this.root.length) === this.root && e2(r2, n2);
            }, filter: function(r2) {
              var n2 = [];
              return this.forEach(function(e2, t2) {
                r2(e2, t2) && n2.push(t2);
              }), n2;
            }, file: function(e2, t2, r2) {
              if (1 !== arguments.length) return e2 = this.root + e2, s.call(this, e2, t2, r2), this;
              if (h(e2)) {
                var n2 = e2;
                return this.filter(function(e3, t3) {
                  return !t3.dir && n2.test(e3);
                });
              }
              var i2 = this.files[this.root + e2];
              return i2 && !i2.dir ? i2 : null;
            }, folder: function(r2) {
              if (!r2) return this;
              if (h(r2)) return this.filter(function(e3, t3) {
                return t3.dir && r2.test(e3);
              });
              var e2 = this.root + r2, t2 = b.call(this, e2), n2 = this.clone();
              return n2.root = t2.name, n2;
            }, remove: function(r2) {
              r2 = this.root + r2;
              var e2 = this.files[r2];
              if (e2 || ("/" !== r2.slice(-1) && (r2 += "/"), e2 = this.files[r2]), e2 && !e2.dir) delete this.files[r2];
              else for (var t2 = this.filter(function(e3, t3) {
                return t3.name.slice(0, r2.length) === r2;
              }), n2 = 0; n2 < t2.length; n2++) delete this.files[t2[n2].name];
              return this;
            }, generate: function() {
              throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
            }, generateInternalStream: function(e2) {
              var t2, r2 = {};
              try {
                if ((r2 = u.extend(e2 || {}, { streamFiles: false, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: i.utf8encode })).type = r2.type.toLowerCase(), r2.compression = r2.compression.toUpperCase(), "binarystring" === r2.type && (r2.type = "string"), !r2.type) throw new Error("No output type specified.");
                u.checkSupport(r2.type), "darwin" !== r2.platform && "freebsd" !== r2.platform && "linux" !== r2.platform && "sunos" !== r2.platform || (r2.platform = "UNIX"), "win32" === r2.platform && (r2.platform = "DOS");
                var n2 = r2.comment || this.comment || "";
                t2 = o.generateWorker(this, r2, n2);
              } catch (e3) {
                (t2 = new l("error")).error(e3);
              }
              return new a(t2, r2.type || "string", r2.mimeType);
            }, generateAsync: function(e2, t2) {
              return this.generateInternalStream(e2).accumulate(t2);
            }, generateNodeStream: function(e2, t2) {
              return (e2 = e2 || {}).type || (e2.type = "nodebuffer"), this.generateInternalStream(e2).toNodejsStream(t2);
            } };
            t.exports = n;
          }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(e, t, r) {
            t.exports = e("stream");
          }, { stream: void 0 }], 17: [function(e, t, r) {
            var n = e("./DataReader");
            function i(e2) {
              n.call(this, e2);
              for (var t2 = 0; t2 < this.data.length; t2++) e2[t2] = 255 & e2[t2];
            }
            e("../utils").inherits(i, n), i.prototype.byteAt = function(e2) {
              return this.data[this.zero + e2];
            }, i.prototype.lastIndexOfSignature = function(e2) {
              for (var t2 = e2.charCodeAt(0), r2 = e2.charCodeAt(1), n2 = e2.charCodeAt(2), i2 = e2.charCodeAt(3), s = this.length - 4; 0 <= s; --s) if (this.data[s] === t2 && this.data[s + 1] === r2 && this.data[s + 2] === n2 && this.data[s + 3] === i2) return s - this.zero;
              return -1;
            }, i.prototype.readAndCheckSignature = function(e2) {
              var t2 = e2.charCodeAt(0), r2 = e2.charCodeAt(1), n2 = e2.charCodeAt(2), i2 = e2.charCodeAt(3), s = this.readData(4);
              return t2 === s[0] && r2 === s[1] && n2 === s[2] && i2 === s[3];
            }, i.prototype.readData = function(e2) {
              if (this.checkOffset(e2), 0 === e2) return [];
              var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
              return this.index += e2, t2;
            }, t.exports = i;
          }, { "../utils": 32, "./DataReader": 18 }], 18: [function(e, t, r) {
            var n = e("../utils");
            function i(e2) {
              this.data = e2, this.length = e2.length, this.index = 0, this.zero = 0;
            }
            i.prototype = { checkOffset: function(e2) {
              this.checkIndex(this.index + e2);
            }, checkIndex: function(e2) {
              if (this.length < this.zero + e2 || e2 < 0) throw new Error("End of data reached (data length = " + this.length + ", asked index = " + e2 + "). Corrupted zip ?");
            }, setIndex: function(e2) {
              this.checkIndex(e2), this.index = e2;
            }, skip: function(e2) {
              this.setIndex(this.index + e2);
            }, byteAt: function() {
            }, readInt: function(e2) {
              var t2, r2 = 0;
              for (this.checkOffset(e2), t2 = this.index + e2 - 1; t2 >= this.index; t2--) r2 = (r2 << 8) + this.byteAt(t2);
              return this.index += e2, r2;
            }, readString: function(e2) {
              return n.transformTo("string", this.readData(e2));
            }, readData: function() {
            }, lastIndexOfSignature: function() {
            }, readAndCheckSignature: function() {
            }, readDate: function() {
              var e2 = this.readInt(4);
              return new Date(Date.UTC(1980 + (e2 >> 25 & 127), (e2 >> 21 & 15) - 1, e2 >> 16 & 31, e2 >> 11 & 31, e2 >> 5 & 63, (31 & e2) << 1));
            } }, t.exports = i;
          }, { "../utils": 32 }], 19: [function(e, t, r) {
            var n = e("./Uint8ArrayReader");
            function i(e2) {
              n.call(this, e2);
            }
            e("../utils").inherits(i, n), i.prototype.readData = function(e2) {
              this.checkOffset(e2);
              var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
              return this.index += e2, t2;
            }, t.exports = i;
          }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(e, t, r) {
            var n = e("./DataReader");
            function i(e2) {
              n.call(this, e2);
            }
            e("../utils").inherits(i, n), i.prototype.byteAt = function(e2) {
              return this.data.charCodeAt(this.zero + e2);
            }, i.prototype.lastIndexOfSignature = function(e2) {
              return this.data.lastIndexOf(e2) - this.zero;
            }, i.prototype.readAndCheckSignature = function(e2) {
              return e2 === this.readData(4);
            }, i.prototype.readData = function(e2) {
              this.checkOffset(e2);
              var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
              return this.index += e2, t2;
            }, t.exports = i;
          }, { "../utils": 32, "./DataReader": 18 }], 21: [function(e, t, r) {
            var n = e("./ArrayReader");
            function i(e2) {
              n.call(this, e2);
            }
            e("../utils").inherits(i, n), i.prototype.readData = function(e2) {
              if (this.checkOffset(e2), 0 === e2) return new Uint8Array(0);
              var t2 = this.data.subarray(this.zero + this.index, this.zero + this.index + e2);
              return this.index += e2, t2;
            }, t.exports = i;
          }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(e, t, r) {
            var n = e("../utils"), i = e("../support"), s = e("./ArrayReader"), a = e("./StringReader"), o = e("./NodeBufferReader"), h = e("./Uint8ArrayReader");
            t.exports = function(e2) {
              var t2 = n.getTypeOf(e2);
              return n.checkSupport(t2), "string" !== t2 || i.uint8array ? "nodebuffer" === t2 ? new o(e2) : i.uint8array ? new h(n.transformTo("uint8array", e2)) : new s(n.transformTo("array", e2)) : new a(e2);
            };
          }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(e, t, r) {
            r.LOCAL_FILE_HEADER = "PK", r.CENTRAL_FILE_HEADER = "PK", r.CENTRAL_DIRECTORY_END = "PK", r.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", r.ZIP64_CENTRAL_DIRECTORY_END = "PK", r.DATA_DESCRIPTOR = "PK\x07\b";
          }, {}], 24: [function(e, t, r) {
            var n = e("./GenericWorker"), i = e("../utils");
            function s(e2) {
              n.call(this, "ConvertWorker to " + e2), this.destType = e2;
            }
            i.inherits(s, n), s.prototype.processChunk = function(e2) {
              this.push({ data: i.transformTo(this.destType, e2.data), meta: e2.meta });
            }, t.exports = s;
          }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(e, t, r) {
            var n = e("./GenericWorker"), i = e("../crc32");
            function s() {
              n.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
            }
            e("../utils").inherits(s, n), s.prototype.processChunk = function(e2) {
              this.streamInfo.crc32 = i(e2.data, this.streamInfo.crc32 || 0), this.push(e2);
            }, t.exports = s;
          }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(e, t, r) {
            var n = e("../utils"), i = e("./GenericWorker");
            function s(e2) {
              i.call(this, "DataLengthProbe for " + e2), this.propName = e2, this.withStreamInfo(e2, 0);
            }
            n.inherits(s, i), s.prototype.processChunk = function(e2) {
              if (e2) {
                var t2 = this.streamInfo[this.propName] || 0;
                this.streamInfo[this.propName] = t2 + e2.data.length;
              }
              i.prototype.processChunk.call(this, e2);
            }, t.exports = s;
          }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(e, t, r) {
            var n = e("../utils"), i = e("./GenericWorker");
            function s(e2) {
              i.call(this, "DataWorker");
              var t2 = this;
              this.dataIsReady = false, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = false, e2.then(function(e3) {
                t2.dataIsReady = true, t2.data = e3, t2.max = e3 && e3.length || 0, t2.type = n.getTypeOf(e3), t2.isPaused || t2._tickAndRepeat();
              }, function(e3) {
                t2.error(e3);
              });
            }
            n.inherits(s, i), s.prototype.cleanUp = function() {
              i.prototype.cleanUp.call(this), this.data = null;
            }, s.prototype.resume = function() {
              return !!i.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = true, n.delay(this._tickAndRepeat, [], this)), true);
            }, s.prototype._tickAndRepeat = function() {
              this._tickScheduled = false, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (n.delay(this._tickAndRepeat, [], this), this._tickScheduled = true));
            }, s.prototype._tick = function() {
              if (this.isPaused || this.isFinished) return false;
              var e2 = null, t2 = Math.min(this.max, this.index + 16384);
              if (this.index >= this.max) return this.end();
              switch (this.type) {
                case "string":
                  e2 = this.data.substring(this.index, t2);
                  break;
                case "uint8array":
                  e2 = this.data.subarray(this.index, t2);
                  break;
                case "array":
                case "nodebuffer":
                  e2 = this.data.slice(this.index, t2);
              }
              return this.index = t2, this.push({ data: e2, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
            }, t.exports = s;
          }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(e, t, r) {
            function n(e2) {
              this.name = e2 || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = true, this.isFinished = false, this.isLocked = false, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
            }
            n.prototype = { push: function(e2) {
              this.emit("data", e2);
            }, end: function() {
              if (this.isFinished) return false;
              this.flush();
              try {
                this.emit("end"), this.cleanUp(), this.isFinished = true;
              } catch (e2) {
                this.emit("error", e2);
              }
              return true;
            }, error: function(e2) {
              return !this.isFinished && (this.isPaused ? this.generatedError = e2 : (this.isFinished = true, this.emit("error", e2), this.previous && this.previous.error(e2), this.cleanUp()), true);
            }, on: function(e2, t2) {
              return this._listeners[e2].push(t2), this;
            }, cleanUp: function() {
              this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
            }, emit: function(e2, t2) {
              if (this._listeners[e2]) for (var r2 = 0; r2 < this._listeners[e2].length; r2++) this._listeners[e2][r2].call(this, t2);
            }, pipe: function(e2) {
              return e2.registerPrevious(this);
            }, registerPrevious: function(e2) {
              if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
              this.streamInfo = e2.streamInfo, this.mergeStreamInfo(), this.previous = e2;
              var t2 = this;
              return e2.on("data", function(e3) {
                t2.processChunk(e3);
              }), e2.on("end", function() {
                t2.end();
              }), e2.on("error", function(e3) {
                t2.error(e3);
              }), this;
            }, pause: function() {
              return !this.isPaused && !this.isFinished && (this.isPaused = true, this.previous && this.previous.pause(), true);
            }, resume: function() {
              if (!this.isPaused || this.isFinished) return false;
              var e2 = this.isPaused = false;
              return this.generatedError && (this.error(this.generatedError), e2 = true), this.previous && this.previous.resume(), !e2;
            }, flush: function() {
            }, processChunk: function(e2) {
              this.push(e2);
            }, withStreamInfo: function(e2, t2) {
              return this.extraStreamInfo[e2] = t2, this.mergeStreamInfo(), this;
            }, mergeStreamInfo: function() {
              for (var e2 in this.extraStreamInfo) Object.prototype.hasOwnProperty.call(this.extraStreamInfo, e2) && (this.streamInfo[e2] = this.extraStreamInfo[e2]);
            }, lock: function() {
              if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
              this.isLocked = true, this.previous && this.previous.lock();
            }, toString: function() {
              var e2 = "Worker " + this.name;
              return this.previous ? this.previous + " -> " + e2 : e2;
            } }, t.exports = n;
          }, {}], 29: [function(e, t, r) {
            var h = e("../utils"), i = e("./ConvertWorker"), s = e("./GenericWorker"), u = e("../base64"), n = e("../support"), a = e("../external"), o = null;
            if (n.nodestream) try {
              o = e("../nodejs/NodejsStreamOutputAdapter");
            } catch (e2) {
            }
            function l(e2, o2) {
              return new a.Promise(function(t2, r2) {
                var n2 = [], i2 = e2._internalType, s2 = e2._outputType, a2 = e2._mimeType;
                e2.on("data", function(e3, t3) {
                  n2.push(e3), o2 && o2(t3);
                }).on("error", function(e3) {
                  n2 = [], r2(e3);
                }).on("end", function() {
                  try {
                    var e3 = (function(e4, t3, r3) {
                      switch (e4) {
                        case "blob":
                          return h.newBlob(h.transformTo("arraybuffer", t3), r3);
                        case "base64":
                          return u.encode(t3);
                        default:
                          return h.transformTo(e4, t3);
                      }
                    })(s2, (function(e4, t3) {
                      var r3, n3 = 0, i3 = null, s3 = 0;
                      for (r3 = 0; r3 < t3.length; r3++) s3 += t3[r3].length;
                      switch (e4) {
                        case "string":
                          return t3.join("");
                        case "array":
                          return Array.prototype.concat.apply([], t3);
                        case "uint8array":
                          for (i3 = new Uint8Array(s3), r3 = 0; r3 < t3.length; r3++) i3.set(t3[r3], n3), n3 += t3[r3].length;
                          return i3;
                        case "nodebuffer":
                          return Buffer.concat(t3);
                        default:
                          throw new Error("concat : unsupported type '" + e4 + "'");
                      }
                    })(i2, n2), a2);
                    t2(e3);
                  } catch (e4) {
                    r2(e4);
                  }
                  n2 = [];
                }).resume();
              });
            }
            function f(e2, t2, r2) {
              var n2 = t2;
              switch (t2) {
                case "blob":
                case "arraybuffer":
                  n2 = "uint8array";
                  break;
                case "base64":
                  n2 = "string";
              }
              try {
                this._internalType = n2, this._outputType = t2, this._mimeType = r2, h.checkSupport(n2), this._worker = e2.pipe(new i(n2)), e2.lock();
              } catch (e3) {
                this._worker = new s("error"), this._worker.error(e3);
              }
            }
            f.prototype = { accumulate: function(e2) {
              return l(this, e2);
            }, on: function(e2, t2) {
              var r2 = this;
              return "data" === e2 ? this._worker.on(e2, function(e3) {
                t2.call(r2, e3.data, e3.meta);
              }) : this._worker.on(e2, function() {
                h.delay(t2, arguments, r2);
              }), this;
            }, resume: function() {
              return h.delay(this._worker.resume, [], this._worker), this;
            }, pause: function() {
              return this._worker.pause(), this;
            }, toNodejsStream: function(e2) {
              if (h.checkSupport("nodestream"), "nodebuffer" !== this._outputType) throw new Error(this._outputType + " is not supported by this method");
              return new o(this, { objectMode: "nodebuffer" !== this._outputType }, e2);
            } }, t.exports = f;
          }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(e, t, r) {
            if (r.base64 = true, r.array = true, r.string = true, r.arraybuffer = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array, r.nodebuffer = "undefined" != typeof Buffer, r.uint8array = "undefined" != typeof Uint8Array, "undefined" == typeof ArrayBuffer) r.blob = false;
            else {
              var n = new ArrayBuffer(0);
              try {
                r.blob = 0 === new Blob([n], { type: "application/zip" }).size;
              } catch (e2) {
                try {
                  var i = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
                  i.append(n), r.blob = 0 === i.getBlob("application/zip").size;
                } catch (e3) {
                  r.blob = false;
                }
              }
            }
            try {
              r.nodestream = !!e("readable-stream").Readable;
            } catch (e2) {
              r.nodestream = false;
            }
          }, { "readable-stream": 16 }], 31: [function(e, t, s) {
            for (var o = e("./utils"), h = e("./support"), r = e("./nodejsUtils"), n = e("./stream/GenericWorker"), u = new Array(256), i = 0; i < 256; i++) u[i] = 252 <= i ? 6 : 248 <= i ? 5 : 240 <= i ? 4 : 224 <= i ? 3 : 192 <= i ? 2 : 1;
            u[254] = u[254] = 1;
            function a() {
              n.call(this, "utf-8 decode"), this.leftOver = null;
            }
            function l() {
              n.call(this, "utf-8 encode");
            }
            s.utf8encode = function(e2) {
              return h.nodebuffer ? r.newBufferFrom(e2, "utf-8") : (function(e3) {
                var t2, r2, n2, i2, s2, a2 = e3.length, o2 = 0;
                for (i2 = 0; i2 < a2; i2++) 55296 == (64512 & (r2 = e3.charCodeAt(i2))) && i2 + 1 < a2 && 56320 == (64512 & (n2 = e3.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), o2 += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
                for (t2 = h.uint8array ? new Uint8Array(o2) : new Array(o2), i2 = s2 = 0; s2 < o2; i2++) 55296 == (64512 & (r2 = e3.charCodeAt(i2))) && i2 + 1 < a2 && 56320 == (64512 & (n2 = e3.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), r2 < 128 ? t2[s2++] = r2 : (r2 < 2048 ? t2[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? t2[s2++] = 224 | r2 >>> 12 : (t2[s2++] = 240 | r2 >>> 18, t2[s2++] = 128 | r2 >>> 12 & 63), t2[s2++] = 128 | r2 >>> 6 & 63), t2[s2++] = 128 | 63 & r2);
                return t2;
              })(e2);
            }, s.utf8decode = function(e2) {
              return h.nodebuffer ? o.transformTo("nodebuffer", e2).toString("utf-8") : (function(e3) {
                var t2, r2, n2, i2, s2 = e3.length, a2 = new Array(2 * s2);
                for (t2 = r2 = 0; t2 < s2; ) if ((n2 = e3[t2++]) < 128) a2[r2++] = n2;
                else if (4 < (i2 = u[n2])) a2[r2++] = 65533, t2 += i2 - 1;
                else {
                  for (n2 &= 2 === i2 ? 31 : 3 === i2 ? 15 : 7; 1 < i2 && t2 < s2; ) n2 = n2 << 6 | 63 & e3[t2++], i2--;
                  1 < i2 ? a2[r2++] = 65533 : n2 < 65536 ? a2[r2++] = n2 : (n2 -= 65536, a2[r2++] = 55296 | n2 >> 10 & 1023, a2[r2++] = 56320 | 1023 & n2);
                }
                return a2.length !== r2 && (a2.subarray ? a2 = a2.subarray(0, r2) : a2.length = r2), o.applyFromCharCode(a2);
              })(e2 = o.transformTo(h.uint8array ? "uint8array" : "array", e2));
            }, o.inherits(a, n), a.prototype.processChunk = function(e2) {
              var t2 = o.transformTo(h.uint8array ? "uint8array" : "array", e2.data);
              if (this.leftOver && this.leftOver.length) {
                if (h.uint8array) {
                  var r2 = t2;
                  (t2 = new Uint8Array(r2.length + this.leftOver.length)).set(this.leftOver, 0), t2.set(r2, this.leftOver.length);
                } else t2 = this.leftOver.concat(t2);
                this.leftOver = null;
              }
              var n2 = (function(e3, t3) {
                var r3;
                for ((t3 = t3 || e3.length) > e3.length && (t3 = e3.length), r3 = t3 - 1; 0 <= r3 && 128 == (192 & e3[r3]); ) r3--;
                return r3 < 0 ? t3 : 0 === r3 ? t3 : r3 + u[e3[r3]] > t3 ? r3 : t3;
              })(t2), i2 = t2;
              n2 !== t2.length && (h.uint8array ? (i2 = t2.subarray(0, n2), this.leftOver = t2.subarray(n2, t2.length)) : (i2 = t2.slice(0, n2), this.leftOver = t2.slice(n2, t2.length))), this.push({ data: s.utf8decode(i2), meta: e2.meta });
            }, a.prototype.flush = function() {
              this.leftOver && this.leftOver.length && (this.push({ data: s.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
            }, s.Utf8DecodeWorker = a, o.inherits(l, n), l.prototype.processChunk = function(e2) {
              this.push({ data: s.utf8encode(e2.data), meta: e2.meta });
            }, s.Utf8EncodeWorker = l;
          }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(e, t, a) {
            var o = e("./support"), h = e("./base64"), r = e("./nodejsUtils"), u = e("./external");
            function n(e2) {
              return e2;
            }
            function l(e2, t2) {
              for (var r2 = 0; r2 < e2.length; ++r2) t2[r2] = 255 & e2.charCodeAt(r2);
              return t2;
            }
            e("setimmediate"), a.newBlob = function(t2, r2) {
              a.checkSupport("blob");
              try {
                return new Blob([t2], { type: r2 });
              } catch (e2) {
                try {
                  var n2 = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
                  return n2.append(t2), n2.getBlob(r2);
                } catch (e3) {
                  throw new Error("Bug : can't construct the Blob.");
                }
              }
            };
            var i = { stringifyByChunk: function(e2, t2, r2) {
              var n2 = [], i2 = 0, s2 = e2.length;
              if (s2 <= r2) return String.fromCharCode.apply(null, e2);
              for (; i2 < s2; ) "array" === t2 || "nodebuffer" === t2 ? n2.push(String.fromCharCode.apply(null, e2.slice(i2, Math.min(i2 + r2, s2)))) : n2.push(String.fromCharCode.apply(null, e2.subarray(i2, Math.min(i2 + r2, s2)))), i2 += r2;
              return n2.join("");
            }, stringifyByChar: function(e2) {
              for (var t2 = "", r2 = 0; r2 < e2.length; r2++) t2 += String.fromCharCode(e2[r2]);
              return t2;
            }, applyCanBeUsed: { uint8array: (function() {
              try {
                return o.uint8array && 1 === String.fromCharCode.apply(null, new Uint8Array(1)).length;
              } catch (e2) {
                return false;
              }
            })(), nodebuffer: (function() {
              try {
                return o.nodebuffer && 1 === String.fromCharCode.apply(null, r.allocBuffer(1)).length;
              } catch (e2) {
                return false;
              }
            })() } };
            function s(e2) {
              var t2 = 65536, r2 = a.getTypeOf(e2), n2 = true;
              if ("uint8array" === r2 ? n2 = i.applyCanBeUsed.uint8array : "nodebuffer" === r2 && (n2 = i.applyCanBeUsed.nodebuffer), n2) for (; 1 < t2; ) try {
                return i.stringifyByChunk(e2, r2, t2);
              } catch (e3) {
                t2 = Math.floor(t2 / 2);
              }
              return i.stringifyByChar(e2);
            }
            function f(e2, t2) {
              for (var r2 = 0; r2 < e2.length; r2++) t2[r2] = e2[r2];
              return t2;
            }
            a.applyFromCharCode = s;
            var c = {};
            c.string = { string: n, array: function(e2) {
              return l(e2, new Array(e2.length));
            }, arraybuffer: function(e2) {
              return c.string.uint8array(e2).buffer;
            }, uint8array: function(e2) {
              return l(e2, new Uint8Array(e2.length));
            }, nodebuffer: function(e2) {
              return l(e2, r.allocBuffer(e2.length));
            } }, c.array = { string: s, array: n, arraybuffer: function(e2) {
              return new Uint8Array(e2).buffer;
            }, uint8array: function(e2) {
              return new Uint8Array(e2);
            }, nodebuffer: function(e2) {
              return r.newBufferFrom(e2);
            } }, c.arraybuffer = { string: function(e2) {
              return s(new Uint8Array(e2));
            }, array: function(e2) {
              return f(new Uint8Array(e2), new Array(e2.byteLength));
            }, arraybuffer: n, uint8array: function(e2) {
              return new Uint8Array(e2);
            }, nodebuffer: function(e2) {
              return r.newBufferFrom(new Uint8Array(e2));
            } }, c.uint8array = { string: s, array: function(e2) {
              return f(e2, new Array(e2.length));
            }, arraybuffer: function(e2) {
              return e2.buffer;
            }, uint8array: n, nodebuffer: function(e2) {
              return r.newBufferFrom(e2);
            } }, c.nodebuffer = { string: s, array: function(e2) {
              return f(e2, new Array(e2.length));
            }, arraybuffer: function(e2) {
              return c.nodebuffer.uint8array(e2).buffer;
            }, uint8array: function(e2) {
              return f(e2, new Uint8Array(e2.length));
            }, nodebuffer: n }, a.transformTo = function(e2, t2) {
              if (t2 = t2 || "", !e2) return t2;
              a.checkSupport(e2);
              var r2 = a.getTypeOf(t2);
              return c[r2][e2](t2);
            }, a.resolve = function(e2) {
              for (var t2 = e2.split("/"), r2 = [], n2 = 0; n2 < t2.length; n2++) {
                var i2 = t2[n2];
                "." === i2 || "" === i2 && 0 !== n2 && n2 !== t2.length - 1 || (".." === i2 ? r2.pop() : r2.push(i2));
              }
              return r2.join("/");
            }, a.getTypeOf = function(e2) {
              return "string" == typeof e2 ? "string" : "[object Array]" === Object.prototype.toString.call(e2) ? "array" : o.nodebuffer && r.isBuffer(e2) ? "nodebuffer" : o.uint8array && e2 instanceof Uint8Array ? "uint8array" : o.arraybuffer && e2 instanceof ArrayBuffer ? "arraybuffer" : void 0;
            }, a.checkSupport = function(e2) {
              if (!o[e2.toLowerCase()]) throw new Error(e2 + " is not supported by this platform");
            }, a.MAX_VALUE_16BITS = 65535, a.MAX_VALUE_32BITS = -1, a.pretty = function(e2) {
              var t2, r2, n2 = "";
              for (r2 = 0; r2 < (e2 || "").length; r2++) n2 += "\\x" + ((t2 = e2.charCodeAt(r2)) < 16 ? "0" : "") + t2.toString(16).toUpperCase();
              return n2;
            }, a.delay = function(e2, t2, r2) {
              setImmediate(function() {
                e2.apply(r2 || null, t2 || []);
              });
            }, a.inherits = function(e2, t2) {
              function r2() {
              }
              r2.prototype = t2.prototype, e2.prototype = new r2();
            }, a.extend = function() {
              var e2, t2, r2 = {};
              for (e2 = 0; e2 < arguments.length; e2++) for (t2 in arguments[e2]) Object.prototype.hasOwnProperty.call(arguments[e2], t2) && void 0 === r2[t2] && (r2[t2] = arguments[e2][t2]);
              return r2;
            }, a.prepareContent = function(r2, e2, n2, i2, s2) {
              return u.Promise.resolve(e2).then(function(n3) {
                return o.blob && (n3 instanceof Blob || -1 !== ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(n3))) && "undefined" != typeof FileReader ? new u.Promise(function(t2, r3) {
                  var e3 = new FileReader();
                  e3.onload = function(e4) {
                    t2(e4.target.result);
                  }, e3.onerror = function(e4) {
                    r3(e4.target.error);
                  }, e3.readAsArrayBuffer(n3);
                }) : n3;
              }).then(function(e3) {
                var t2 = a.getTypeOf(e3);
                return t2 ? ("arraybuffer" === t2 ? e3 = a.transformTo("uint8array", e3) : "string" === t2 && (s2 ? e3 = h.decode(e3) : n2 && true !== i2 && (e3 = (function(e4) {
                  return l(e4, o.uint8array ? new Uint8Array(e4.length) : new Array(e4.length));
                })(e3))), e3) : u.Promise.reject(new Error("Can't read the data of '" + r2 + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
              });
            };
          }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(e, t, r) {
            var n = e("./reader/readerFor"), i = e("./utils"), s = e("./signature"), a = e("./zipEntry"), o = e("./support");
            function h(e2) {
              this.files = [], this.loadOptions = e2;
            }
            h.prototype = { checkSignature: function(e2) {
              if (!this.reader.readAndCheckSignature(e2)) {
                this.reader.index -= 4;
                var t2 = this.reader.readString(4);
                throw new Error("Corrupted zip or bug: unexpected signature (" + i.pretty(t2) + ", expected " + i.pretty(e2) + ")");
              }
            }, isSignature: function(e2, t2) {
              var r2 = this.reader.index;
              this.reader.setIndex(e2);
              var n2 = this.reader.readString(4) === t2;
              return this.reader.setIndex(r2), n2;
            }, readBlockEndOfCentral: function() {
              this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
              var e2 = this.reader.readData(this.zipCommentLength), t2 = o.uint8array ? "uint8array" : "array", r2 = i.transformTo(t2, e2);
              this.zipComment = this.loadOptions.decodeFileName(r2);
            }, readBlockZip64EndOfCentral: function() {
              this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
              for (var e2, t2, r2, n2 = this.zip64EndOfCentralSize - 44; 0 < n2; ) e2 = this.reader.readInt(2), t2 = this.reader.readInt(4), r2 = this.reader.readData(t2), this.zip64ExtensibleData[e2] = { id: e2, length: t2, value: r2 };
            }, readBlockZip64EndOfCentralLocator: function() {
              if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount) throw new Error("Multi-volumes zip are not supported");
            }, readLocalFiles: function() {
              var e2, t2;
              for (e2 = 0; e2 < this.files.length; e2++) t2 = this.files[e2], this.reader.setIndex(t2.localHeaderOffset), this.checkSignature(s.LOCAL_FILE_HEADER), t2.readLocalPart(this.reader), t2.handleUTF8(), t2.processAttributes();
            }, readCentralDir: function() {
              var e2;
              for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER); ) (e2 = new a({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(e2);
              if (this.centralDirRecords !== this.files.length && 0 !== this.centralDirRecords && 0 === this.files.length) throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
            }, readEndOfCentral: function() {
              var e2 = this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END);
              if (e2 < 0) throw !this.isSignature(0, s.LOCAL_FILE_HEADER) ? new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html") : new Error("Corrupted zip: can't find end of central directory");
              this.reader.setIndex(e2);
              var t2 = e2;
              if (this.checkSignature(s.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === i.MAX_VALUE_16BITS || this.diskWithCentralDirStart === i.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === i.MAX_VALUE_16BITS || this.centralDirRecords === i.MAX_VALUE_16BITS || this.centralDirSize === i.MAX_VALUE_32BITS || this.centralDirOffset === i.MAX_VALUE_32BITS) {
                if (this.zip64 = true, (e2 = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
                if (this.reader.setIndex(e2), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, s.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0)) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
                this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
              }
              var r2 = this.centralDirOffset + this.centralDirSize;
              this.zip64 && (r2 += 20, r2 += 12 + this.zip64EndOfCentralSize);
              var n2 = t2 - r2;
              if (0 < n2) this.isSignature(t2, s.CENTRAL_FILE_HEADER) || (this.reader.zero = n2);
              else if (n2 < 0) throw new Error("Corrupted zip: missing " + Math.abs(n2) + " bytes.");
            }, prepareReader: function(e2) {
              this.reader = n(e2);
            }, load: function(e2) {
              this.prepareReader(e2), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
            } }, t.exports = h;
          }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(e, t, r) {
            var n = e("./reader/readerFor"), s = e("./utils"), i = e("./compressedObject"), a = e("./crc32"), o = e("./utf8"), h = e("./compressions"), u = e("./support");
            function l(e2, t2) {
              this.options = e2, this.loadOptions = t2;
            }
            l.prototype = { isEncrypted: function() {
              return 1 == (1 & this.bitFlag);
            }, useUTF8: function() {
              return 2048 == (2048 & this.bitFlag);
            }, readLocalPart: function(e2) {
              var t2, r2;
              if (e2.skip(22), this.fileNameLength = e2.readInt(2), r2 = e2.readInt(2), this.fileName = e2.readData(this.fileNameLength), e2.skip(r2), -1 === this.compressedSize || -1 === this.uncompressedSize) throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
              if (null === (t2 = (function(e3) {
                for (var t3 in h) if (Object.prototype.hasOwnProperty.call(h, t3) && h[t3].magic === e3) return h[t3];
                return null;
              })(this.compressionMethod))) throw new Error("Corrupted zip : compression " + s.pretty(this.compressionMethod) + " unknown (inner file : " + s.transformTo("string", this.fileName) + ")");
              this.decompressed = new i(this.compressedSize, this.uncompressedSize, this.crc32, t2, e2.readData(this.compressedSize));
            }, readCentralPart: function(e2) {
              this.versionMadeBy = e2.readInt(2), e2.skip(2), this.bitFlag = e2.readInt(2), this.compressionMethod = e2.readString(2), this.date = e2.readDate(), this.crc32 = e2.readInt(4), this.compressedSize = e2.readInt(4), this.uncompressedSize = e2.readInt(4);
              var t2 = e2.readInt(2);
              if (this.extraFieldsLength = e2.readInt(2), this.fileCommentLength = e2.readInt(2), this.diskNumberStart = e2.readInt(2), this.internalFileAttributes = e2.readInt(2), this.externalFileAttributes = e2.readInt(4), this.localHeaderOffset = e2.readInt(4), this.isEncrypted()) throw new Error("Encrypted zip are not supported");
              e2.skip(t2), this.readExtraFields(e2), this.parseZIP64ExtraField(e2), this.fileComment = e2.readData(this.fileCommentLength);
            }, processAttributes: function() {
              this.unixPermissions = null, this.dosPermissions = null;
              var e2 = this.versionMadeBy >> 8;
              this.dir = !!(16 & this.externalFileAttributes), 0 == e2 && (this.dosPermissions = 63 & this.externalFileAttributes), 3 == e2 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || "/" !== this.fileNameStr.slice(-1) || (this.dir = true);
            }, parseZIP64ExtraField: function() {
              if (this.extraFields[1]) {
                var e2 = n(this.extraFields[1].value);
                this.uncompressedSize === s.MAX_VALUE_32BITS && (this.uncompressedSize = e2.readInt(8)), this.compressedSize === s.MAX_VALUE_32BITS && (this.compressedSize = e2.readInt(8)), this.localHeaderOffset === s.MAX_VALUE_32BITS && (this.localHeaderOffset = e2.readInt(8)), this.diskNumberStart === s.MAX_VALUE_32BITS && (this.diskNumberStart = e2.readInt(4));
              }
            }, readExtraFields: function(e2) {
              var t2, r2, n2, i2 = e2.index + this.extraFieldsLength;
              for (this.extraFields || (this.extraFields = {}); e2.index + 4 < i2; ) t2 = e2.readInt(2), r2 = e2.readInt(2), n2 = e2.readData(r2), this.extraFields[t2] = { id: t2, length: r2, value: n2 };
              e2.setIndex(i2);
            }, handleUTF8: function() {
              var e2 = u.uint8array ? "uint8array" : "array";
              if (this.useUTF8()) this.fileNameStr = o.utf8decode(this.fileName), this.fileCommentStr = o.utf8decode(this.fileComment);
              else {
                var t2 = this.findExtraFieldUnicodePath();
                if (null !== t2) this.fileNameStr = t2;
                else {
                  var r2 = s.transformTo(e2, this.fileName);
                  this.fileNameStr = this.loadOptions.decodeFileName(r2);
                }
                var n2 = this.findExtraFieldUnicodeComment();
                if (null !== n2) this.fileCommentStr = n2;
                else {
                  var i2 = s.transformTo(e2, this.fileComment);
                  this.fileCommentStr = this.loadOptions.decodeFileName(i2);
                }
              }
            }, findExtraFieldUnicodePath: function() {
              var e2 = this.extraFields[28789];
              if (e2) {
                var t2 = n(e2.value);
                return 1 !== t2.readInt(1) ? null : a(this.fileName) !== t2.readInt(4) ? null : o.utf8decode(t2.readData(e2.length - 5));
              }
              return null;
            }, findExtraFieldUnicodeComment: function() {
              var e2 = this.extraFields[25461];
              if (e2) {
                var t2 = n(e2.value);
                return 1 !== t2.readInt(1) ? null : a(this.fileComment) !== t2.readInt(4) ? null : o.utf8decode(t2.readData(e2.length - 5));
              }
              return null;
            } }, t.exports = l;
          }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(e, t, r) {
            function n(e2, t2, r2) {
              this.name = e2, this.dir = r2.dir, this.date = r2.date, this.comment = r2.comment, this.unixPermissions = r2.unixPermissions, this.dosPermissions = r2.dosPermissions, this._data = t2, this._dataBinary = r2.binary, this.options = { compression: r2.compression, compressionOptions: r2.compressionOptions };
            }
            var s = e("./stream/StreamHelper"), i = e("./stream/DataWorker"), a = e("./utf8"), o = e("./compressedObject"), h = e("./stream/GenericWorker");
            n.prototype = { internalStream: function(e2) {
              var t2 = null, r2 = "string";
              try {
                if (!e2) throw new Error("No output type specified.");
                var n2 = "string" === (r2 = e2.toLowerCase()) || "text" === r2;
                "binarystring" !== r2 && "text" !== r2 || (r2 = "string"), t2 = this._decompressWorker();
                var i2 = !this._dataBinary;
                i2 && !n2 && (t2 = t2.pipe(new a.Utf8EncodeWorker())), !i2 && n2 && (t2 = t2.pipe(new a.Utf8DecodeWorker()));
              } catch (e3) {
                (t2 = new h("error")).error(e3);
              }
              return new s(t2, r2, "");
            }, async: function(e2, t2) {
              return this.internalStream(e2).accumulate(t2);
            }, nodeStream: function(e2, t2) {
              return this.internalStream(e2 || "nodebuffer").toNodejsStream(t2);
            }, _compressWorker: function(e2, t2) {
              if (this._data instanceof o && this._data.compression.magic === e2.magic) return this._data.getCompressedWorker();
              var r2 = this._decompressWorker();
              return this._dataBinary || (r2 = r2.pipe(new a.Utf8EncodeWorker())), o.createWorkerFrom(r2, e2, t2);
            }, _decompressWorker: function() {
              return this._data instanceof o ? this._data.getContentWorker() : this._data instanceof h ? this._data : new i(this._data);
            } };
            for (var u = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], l = function() {
              throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
            }, f = 0; f < u.length; f++) n.prototype[u[f]] = l;
            t.exports = n;
          }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(e, l, t) {
            (function(t2) {
              var r, n, e2 = t2.MutationObserver || t2.WebKitMutationObserver;
              if (e2) {
                var i = 0, s = new e2(u), a = t2.document.createTextNode("");
                s.observe(a, { characterData: true }), r = function() {
                  a.data = i = ++i % 2;
                };
              } else if (t2.setImmediate || void 0 === t2.MessageChannel) r = "document" in t2 && "onreadystatechange" in t2.document.createElement("script") ? function() {
                var e3 = t2.document.createElement("script");
                e3.onreadystatechange = function() {
                  u(), e3.onreadystatechange = null, e3.parentNode.removeChild(e3), e3 = null;
                }, t2.document.documentElement.appendChild(e3);
              } : function() {
                setTimeout(u, 0);
              };
              else {
                var o = new t2.MessageChannel();
                o.port1.onmessage = u, r = function() {
                  o.port2.postMessage(0);
                };
              }
              var h = [];
              function u() {
                var e3, t3;
                n = true;
                for (var r2 = h.length; r2; ) {
                  for (t3 = h, h = [], e3 = -1; ++e3 < r2; ) t3[e3]();
                  r2 = h.length;
                }
                n = false;
              }
              l.exports = function(e3) {
                1 !== h.push(e3) || n || r();
              };
            }).call(this, "undefined" != typeof commonjsGlobal2 ? commonjsGlobal2 : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
          }, {}], 37: [function(e, t, r) {
            var i = e("immediate");
            function u() {
            }
            var l = {}, s = ["REJECTED"], a = ["FULFILLED"], n = ["PENDING"];
            function o(e2) {
              if ("function" != typeof e2) throw new TypeError("resolver must be a function");
              this.state = n, this.queue = [], this.outcome = void 0, e2 !== u && d(this, e2);
            }
            function h(e2, t2, r2) {
              this.promise = e2, "function" == typeof t2 && (this.onFulfilled = t2, this.callFulfilled = this.otherCallFulfilled), "function" == typeof r2 && (this.onRejected = r2, this.callRejected = this.otherCallRejected);
            }
            function f(t2, r2, n2) {
              i(function() {
                var e2;
                try {
                  e2 = r2(n2);
                } catch (e3) {
                  return l.reject(t2, e3);
                }
                e2 === t2 ? l.reject(t2, new TypeError("Cannot resolve promise with itself")) : l.resolve(t2, e2);
              });
            }
            function c(e2) {
              var t2 = e2 && e2.then;
              if (e2 && ("object" == typeof e2 || "function" == typeof e2) && "function" == typeof t2) return function() {
                t2.apply(e2, arguments);
              };
            }
            function d(t2, e2) {
              var r2 = false;
              function n2(e3) {
                r2 || (r2 = true, l.reject(t2, e3));
              }
              function i2(e3) {
                r2 || (r2 = true, l.resolve(t2, e3));
              }
              var s2 = p(function() {
                e2(i2, n2);
              });
              "error" === s2.status && n2(s2.value);
            }
            function p(e2, t2) {
              var r2 = {};
              try {
                r2.value = e2(t2), r2.status = "success";
              } catch (e3) {
                r2.status = "error", r2.value = e3;
              }
              return r2;
            }
            (t.exports = o).prototype.finally = function(t2) {
              if ("function" != typeof t2) return this;
              var r2 = this.constructor;
              return this.then(function(e2) {
                return r2.resolve(t2()).then(function() {
                  return e2;
                });
              }, function(e2) {
                return r2.resolve(t2()).then(function() {
                  throw e2;
                });
              });
            }, o.prototype.catch = function(e2) {
              return this.then(null, e2);
            }, o.prototype.then = function(e2, t2) {
              if ("function" != typeof e2 && this.state === a || "function" != typeof t2 && this.state === s) return this;
              var r2 = new this.constructor(u);
              this.state !== n ? f(r2, this.state === a ? e2 : t2, this.outcome) : this.queue.push(new h(r2, e2, t2));
              return r2;
            }, h.prototype.callFulfilled = function(e2) {
              l.resolve(this.promise, e2);
            }, h.prototype.otherCallFulfilled = function(e2) {
              f(this.promise, this.onFulfilled, e2);
            }, h.prototype.callRejected = function(e2) {
              l.reject(this.promise, e2);
            }, h.prototype.otherCallRejected = function(e2) {
              f(this.promise, this.onRejected, e2);
            }, l.resolve = function(e2, t2) {
              var r2 = p(c, t2);
              if ("error" === r2.status) return l.reject(e2, r2.value);
              var n2 = r2.value;
              if (n2) d(e2, n2);
              else {
                e2.state = a, e2.outcome = t2;
                for (var i2 = -1, s2 = e2.queue.length; ++i2 < s2; ) e2.queue[i2].callFulfilled(t2);
              }
              return e2;
            }, l.reject = function(e2, t2) {
              e2.state = s, e2.outcome = t2;
              for (var r2 = -1, n2 = e2.queue.length; ++r2 < n2; ) e2.queue[r2].callRejected(t2);
              return e2;
            }, o.resolve = function(e2) {
              if (e2 instanceof this) return e2;
              return l.resolve(new this(u), e2);
            }, o.reject = function(e2) {
              var t2 = new this(u);
              return l.reject(t2, e2);
            }, o.all = function(e2) {
              var r2 = this;
              if ("[object Array]" !== Object.prototype.toString.call(e2)) return this.reject(new TypeError("must be an array"));
              var n2 = e2.length, i2 = false;
              if (!n2) return this.resolve([]);
              var s2 = new Array(n2), a2 = 0, t2 = -1, o2 = new this(u);
              for (; ++t2 < n2; ) h2(e2[t2], t2);
              return o2;
              function h2(e3, t3) {
                r2.resolve(e3).then(function(e4) {
                  s2[t3] = e4, ++a2 !== n2 || i2 || (i2 = true, l.resolve(o2, s2));
                }, function(e4) {
                  i2 || (i2 = true, l.reject(o2, e4));
                });
              }
            }, o.race = function(e2) {
              var t2 = this;
              if ("[object Array]" !== Object.prototype.toString.call(e2)) return this.reject(new TypeError("must be an array"));
              var r2 = e2.length, n2 = false;
              if (!r2) return this.resolve([]);
              var i2 = -1, s2 = new this(u);
              for (; ++i2 < r2; ) a2 = e2[i2], t2.resolve(a2).then(function(e3) {
                n2 || (n2 = true, l.resolve(s2, e3));
              }, function(e3) {
                n2 || (n2 = true, l.reject(s2, e3));
              });
              var a2;
              return s2;
            };
          }, { immediate: 36 }], 38: [function(e, t, r) {
            var n = {};
            (0, e("./lib/utils/common").assign)(n, e("./lib/deflate"), e("./lib/inflate"), e("./lib/zlib/constants")), t.exports = n;
          }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(e, t, r) {
            var a = e("./zlib/deflate"), o = e("./utils/common"), h = e("./utils/strings"), i = e("./zlib/messages"), s = e("./zlib/zstream"), u = Object.prototype.toString, l = 0, f = -1, c = 0, d = 8;
            function p(e2) {
              if (!(this instanceof p)) return new p(e2);
              this.options = o.assign({ level: f, method: d, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: c, to: "" }, e2 || {});
              var t2 = this.options;
              t2.raw && 0 < t2.windowBits ? t2.windowBits = -t2.windowBits : t2.gzip && 0 < t2.windowBits && t2.windowBits < 16 && (t2.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new s(), this.strm.avail_out = 0;
              var r2 = a.deflateInit2(this.strm, t2.level, t2.method, t2.windowBits, t2.memLevel, t2.strategy);
              if (r2 !== l) throw new Error(i[r2]);
              if (t2.header && a.deflateSetHeader(this.strm, t2.header), t2.dictionary) {
                var n2;
                if (n2 = "string" == typeof t2.dictionary ? h.string2buf(t2.dictionary) : "[object ArrayBuffer]" === u.call(t2.dictionary) ? new Uint8Array(t2.dictionary) : t2.dictionary, (r2 = a.deflateSetDictionary(this.strm, n2)) !== l) throw new Error(i[r2]);
                this._dict_set = true;
              }
            }
            function n(e2, t2) {
              var r2 = new p(t2);
              if (r2.push(e2, true), r2.err) throw r2.msg || i[r2.err];
              return r2.result;
            }
            p.prototype.push = function(e2, t2) {
              var r2, n2, i2 = this.strm, s2 = this.options.chunkSize;
              if (this.ended) return false;
              n2 = t2 === ~~t2 ? t2 : true === t2 ? 4 : 0, "string" == typeof e2 ? i2.input = h.string2buf(e2) : "[object ArrayBuffer]" === u.call(e2) ? i2.input = new Uint8Array(e2) : i2.input = e2, i2.next_in = 0, i2.avail_in = i2.input.length;
              do {
                if (0 === i2.avail_out && (i2.output = new o.Buf8(s2), i2.next_out = 0, i2.avail_out = s2), 1 !== (r2 = a.deflate(i2, n2)) && r2 !== l) return this.onEnd(r2), !(this.ended = true);
                0 !== i2.avail_out && (0 !== i2.avail_in || 4 !== n2 && 2 !== n2) || ("string" === this.options.to ? this.onData(h.buf2binstring(o.shrinkBuf(i2.output, i2.next_out))) : this.onData(o.shrinkBuf(i2.output, i2.next_out)));
              } while ((0 < i2.avail_in || 0 === i2.avail_out) && 1 !== r2);
              return 4 === n2 ? (r2 = a.deflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === l) : 2 !== n2 || (this.onEnd(l), !(i2.avail_out = 0));
            }, p.prototype.onData = function(e2) {
              this.chunks.push(e2);
            }, p.prototype.onEnd = function(e2) {
              e2 === l && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
            }, r.Deflate = p, r.deflate = n, r.deflateRaw = function(e2, t2) {
              return (t2 = t2 || {}).raw = true, n(e2, t2);
            }, r.gzip = function(e2, t2) {
              return (t2 = t2 || {}).gzip = true, n(e2, t2);
            };
          }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(e, t, r) {
            var c = e("./zlib/inflate"), d = e("./utils/common"), p = e("./utils/strings"), m = e("./zlib/constants"), n = e("./zlib/messages"), i = e("./zlib/zstream"), s = e("./zlib/gzheader"), _ = Object.prototype.toString;
            function a(e2) {
              if (!(this instanceof a)) return new a(e2);
              this.options = d.assign({ chunkSize: 16384, windowBits: 0, to: "" }, e2 || {});
              var t2 = this.options;
              t2.raw && 0 <= t2.windowBits && t2.windowBits < 16 && (t2.windowBits = -t2.windowBits, 0 === t2.windowBits && (t2.windowBits = -15)), !(0 <= t2.windowBits && t2.windowBits < 16) || e2 && e2.windowBits || (t2.windowBits += 32), 15 < t2.windowBits && t2.windowBits < 48 && 0 == (15 & t2.windowBits) && (t2.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new i(), this.strm.avail_out = 0;
              var r2 = c.inflateInit2(this.strm, t2.windowBits);
              if (r2 !== m.Z_OK) throw new Error(n[r2]);
              this.header = new s(), c.inflateGetHeader(this.strm, this.header);
            }
            function o(e2, t2) {
              var r2 = new a(t2);
              if (r2.push(e2, true), r2.err) throw r2.msg || n[r2.err];
              return r2.result;
            }
            a.prototype.push = function(e2, t2) {
              var r2, n2, i2, s2, a2, o2, h = this.strm, u = this.options.chunkSize, l = this.options.dictionary, f = false;
              if (this.ended) return false;
              n2 = t2 === ~~t2 ? t2 : true === t2 ? m.Z_FINISH : m.Z_NO_FLUSH, "string" == typeof e2 ? h.input = p.binstring2buf(e2) : "[object ArrayBuffer]" === _.call(e2) ? h.input = new Uint8Array(e2) : h.input = e2, h.next_in = 0, h.avail_in = h.input.length;
              do {
                if (0 === h.avail_out && (h.output = new d.Buf8(u), h.next_out = 0, h.avail_out = u), (r2 = c.inflate(h, m.Z_NO_FLUSH)) === m.Z_NEED_DICT && l && (o2 = "string" == typeof l ? p.string2buf(l) : "[object ArrayBuffer]" === _.call(l) ? new Uint8Array(l) : l, r2 = c.inflateSetDictionary(this.strm, o2)), r2 === m.Z_BUF_ERROR && true === f && (r2 = m.Z_OK, f = false), r2 !== m.Z_STREAM_END && r2 !== m.Z_OK) return this.onEnd(r2), !(this.ended = true);
                h.next_out && (0 !== h.avail_out && r2 !== m.Z_STREAM_END && (0 !== h.avail_in || n2 !== m.Z_FINISH && n2 !== m.Z_SYNC_FLUSH) || ("string" === this.options.to ? (i2 = p.utf8border(h.output, h.next_out), s2 = h.next_out - i2, a2 = p.buf2string(h.output, i2), h.next_out = s2, h.avail_out = u - s2, s2 && d.arraySet(h.output, h.output, i2, s2, 0), this.onData(a2)) : this.onData(d.shrinkBuf(h.output, h.next_out)))), 0 === h.avail_in && 0 === h.avail_out && (f = true);
              } while ((0 < h.avail_in || 0 === h.avail_out) && r2 !== m.Z_STREAM_END);
              return r2 === m.Z_STREAM_END && (n2 = m.Z_FINISH), n2 === m.Z_FINISH ? (r2 = c.inflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === m.Z_OK) : n2 !== m.Z_SYNC_FLUSH || (this.onEnd(m.Z_OK), !(h.avail_out = 0));
            }, a.prototype.onData = function(e2) {
              this.chunks.push(e2);
            }, a.prototype.onEnd = function(e2) {
              e2 === m.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = d.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
            }, r.Inflate = a, r.inflate = o, r.inflateRaw = function(e2, t2) {
              return (t2 = t2 || {}).raw = true, o(e2, t2);
            }, r.ungzip = o;
          }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(e, t, r) {
            var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
            r.assign = function(e2) {
              for (var t2 = Array.prototype.slice.call(arguments, 1); t2.length; ) {
                var r2 = t2.shift();
                if (r2) {
                  if ("object" != typeof r2) throw new TypeError(r2 + "must be non-object");
                  for (var n2 in r2) r2.hasOwnProperty(n2) && (e2[n2] = r2[n2]);
                }
              }
              return e2;
            }, r.shrinkBuf = function(e2, t2) {
              return e2.length === t2 ? e2 : e2.subarray ? e2.subarray(0, t2) : (e2.length = t2, e2);
            };
            var i = { arraySet: function(e2, t2, r2, n2, i2) {
              if (t2.subarray && e2.subarray) e2.set(t2.subarray(r2, r2 + n2), i2);
              else for (var s2 = 0; s2 < n2; s2++) e2[i2 + s2] = t2[r2 + s2];
            }, flattenChunks: function(e2) {
              var t2, r2, n2, i2, s2, a;
              for (t2 = n2 = 0, r2 = e2.length; t2 < r2; t2++) n2 += e2[t2].length;
              for (a = new Uint8Array(n2), t2 = i2 = 0, r2 = e2.length; t2 < r2; t2++) s2 = e2[t2], a.set(s2, i2), i2 += s2.length;
              return a;
            } }, s = { arraySet: function(e2, t2, r2, n2, i2) {
              for (var s2 = 0; s2 < n2; s2++) e2[i2 + s2] = t2[r2 + s2];
            }, flattenChunks: function(e2) {
              return [].concat.apply([], e2);
            } };
            r.setTyped = function(e2) {
              e2 ? (r.Buf8 = Uint8Array, r.Buf16 = Uint16Array, r.Buf32 = Int32Array, r.assign(r, i)) : (r.Buf8 = Array, r.Buf16 = Array, r.Buf32 = Array, r.assign(r, s));
            }, r.setTyped(n);
          }, {}], 42: [function(e, t, r) {
            var h = e("./common"), i = true, s = true;
            try {
              String.fromCharCode.apply(null, [0]);
            } catch (e2) {
              i = false;
            }
            try {
              String.fromCharCode.apply(null, new Uint8Array(1));
            } catch (e2) {
              s = false;
            }
            for (var u = new h.Buf8(256), n = 0; n < 256; n++) u[n] = 252 <= n ? 6 : 248 <= n ? 5 : 240 <= n ? 4 : 224 <= n ? 3 : 192 <= n ? 2 : 1;
            function l(e2, t2) {
              if (t2 < 65537 && (e2.subarray && s || !e2.subarray && i)) return String.fromCharCode.apply(null, h.shrinkBuf(e2, t2));
              for (var r2 = "", n2 = 0; n2 < t2; n2++) r2 += String.fromCharCode(e2[n2]);
              return r2;
            }
            u[254] = u[254] = 1, r.string2buf = function(e2) {
              var t2, r2, n2, i2, s2, a = e2.length, o = 0;
              for (i2 = 0; i2 < a; i2++) 55296 == (64512 & (r2 = e2.charCodeAt(i2))) && i2 + 1 < a && 56320 == (64512 & (n2 = e2.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), o += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
              for (t2 = new h.Buf8(o), i2 = s2 = 0; s2 < o; i2++) 55296 == (64512 & (r2 = e2.charCodeAt(i2))) && i2 + 1 < a && 56320 == (64512 & (n2 = e2.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), r2 < 128 ? t2[s2++] = r2 : (r2 < 2048 ? t2[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? t2[s2++] = 224 | r2 >>> 12 : (t2[s2++] = 240 | r2 >>> 18, t2[s2++] = 128 | r2 >>> 12 & 63), t2[s2++] = 128 | r2 >>> 6 & 63), t2[s2++] = 128 | 63 & r2);
              return t2;
            }, r.buf2binstring = function(e2) {
              return l(e2, e2.length);
            }, r.binstring2buf = function(e2) {
              for (var t2 = new h.Buf8(e2.length), r2 = 0, n2 = t2.length; r2 < n2; r2++) t2[r2] = e2.charCodeAt(r2);
              return t2;
            }, r.buf2string = function(e2, t2) {
              var r2, n2, i2, s2, a = t2 || e2.length, o = new Array(2 * a);
              for (r2 = n2 = 0; r2 < a; ) if ((i2 = e2[r2++]) < 128) o[n2++] = i2;
              else if (4 < (s2 = u[i2])) o[n2++] = 65533, r2 += s2 - 1;
              else {
                for (i2 &= 2 === s2 ? 31 : 3 === s2 ? 15 : 7; 1 < s2 && r2 < a; ) i2 = i2 << 6 | 63 & e2[r2++], s2--;
                1 < s2 ? o[n2++] = 65533 : i2 < 65536 ? o[n2++] = i2 : (i2 -= 65536, o[n2++] = 55296 | i2 >> 10 & 1023, o[n2++] = 56320 | 1023 & i2);
              }
              return l(o, n2);
            }, r.utf8border = function(e2, t2) {
              var r2;
              for ((t2 = t2 || e2.length) > e2.length && (t2 = e2.length), r2 = t2 - 1; 0 <= r2 && 128 == (192 & e2[r2]); ) r2--;
              return r2 < 0 ? t2 : 0 === r2 ? t2 : r2 + u[e2[r2]] > t2 ? r2 : t2;
            };
          }, { "./common": 41 }], 43: [function(e, t, r) {
            t.exports = function(e2, t2, r2, n) {
              for (var i = 65535 & e2 | 0, s = e2 >>> 16 & 65535 | 0, a = 0; 0 !== r2; ) {
                for (r2 -= a = 2e3 < r2 ? 2e3 : r2; s = s + (i = i + t2[n++] | 0) | 0, --a; ) ;
                i %= 65521, s %= 65521;
              }
              return i | s << 16 | 0;
            };
          }, {}], 44: [function(e, t, r) {
            t.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
          }, {}], 45: [function(e, t, r) {
            var o = (function() {
              for (var e2, t2 = [], r2 = 0; r2 < 256; r2++) {
                e2 = r2;
                for (var n = 0; n < 8; n++) e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
                t2[r2] = e2;
              }
              return t2;
            })();
            t.exports = function(e2, t2, r2, n) {
              var i = o, s = n + r2;
              e2 ^= -1;
              for (var a = n; a < s; a++) e2 = e2 >>> 8 ^ i[255 & (e2 ^ t2[a])];
              return -1 ^ e2;
            };
          }, {}], 46: [function(e, t, r) {
            var h, c = e("../utils/common"), u = e("./trees"), d = e("./adler32"), p = e("./crc32"), n = e("./messages"), l = 0, f = 4, m = 0, _ = -2, g = -1, b = 4, i = 2, v = 8, y = 9, s = 286, a = 30, o = 19, w = 2 * s + 1, k = 15, x = 3, S = 258, z = S + x + 1, C = 42, E = 113, A = 1, I = 2, O = 3, B = 4;
            function R(e2, t2) {
              return e2.msg = n[t2], t2;
            }
            function T(e2) {
              return (e2 << 1) - (4 < e2 ? 9 : 0);
            }
            function D(e2) {
              for (var t2 = e2.length; 0 <= --t2; ) e2[t2] = 0;
            }
            function F(e2) {
              var t2 = e2.state, r2 = t2.pending;
              r2 > e2.avail_out && (r2 = e2.avail_out), 0 !== r2 && (c.arraySet(e2.output, t2.pending_buf, t2.pending_out, r2, e2.next_out), e2.next_out += r2, t2.pending_out += r2, e2.total_out += r2, e2.avail_out -= r2, t2.pending -= r2, 0 === t2.pending && (t2.pending_out = 0));
            }
            function N(e2, t2) {
              u._tr_flush_block(e2, 0 <= e2.block_start ? e2.block_start : -1, e2.strstart - e2.block_start, t2), e2.block_start = e2.strstart, F(e2.strm);
            }
            function U(e2, t2) {
              e2.pending_buf[e2.pending++] = t2;
            }
            function P(e2, t2) {
              e2.pending_buf[e2.pending++] = t2 >>> 8 & 255, e2.pending_buf[e2.pending++] = 255 & t2;
            }
            function L(e2, t2) {
              var r2, n2, i2 = e2.max_chain_length, s2 = e2.strstart, a2 = e2.prev_length, o2 = e2.nice_match, h2 = e2.strstart > e2.w_size - z ? e2.strstart - (e2.w_size - z) : 0, u2 = e2.window, l2 = e2.w_mask, f2 = e2.prev, c2 = e2.strstart + S, d2 = u2[s2 + a2 - 1], p2 = u2[s2 + a2];
              e2.prev_length >= e2.good_match && (i2 >>= 2), o2 > e2.lookahead && (o2 = e2.lookahead);
              do {
                if (u2[(r2 = t2) + a2] === p2 && u2[r2 + a2 - 1] === d2 && u2[r2] === u2[s2] && u2[++r2] === u2[s2 + 1]) {
                  s2 += 2, r2++;
                  do {
                  } while (u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && s2 < c2);
                  if (n2 = S - (c2 - s2), s2 = c2 - S, a2 < n2) {
                    if (e2.match_start = t2, o2 <= (a2 = n2)) break;
                    d2 = u2[s2 + a2 - 1], p2 = u2[s2 + a2];
                  }
                }
              } while ((t2 = f2[t2 & l2]) > h2 && 0 != --i2);
              return a2 <= e2.lookahead ? a2 : e2.lookahead;
            }
            function j(e2) {
              var t2, r2, n2, i2, s2, a2, o2, h2, u2, l2, f2 = e2.w_size;
              do {
                if (i2 = e2.window_size - e2.lookahead - e2.strstart, e2.strstart >= f2 + (f2 - z)) {
                  for (c.arraySet(e2.window, e2.window, f2, f2, 0), e2.match_start -= f2, e2.strstart -= f2, e2.block_start -= f2, t2 = r2 = e2.hash_size; n2 = e2.head[--t2], e2.head[t2] = f2 <= n2 ? n2 - f2 : 0, --r2; ) ;
                  for (t2 = r2 = f2; n2 = e2.prev[--t2], e2.prev[t2] = f2 <= n2 ? n2 - f2 : 0, --r2; ) ;
                  i2 += f2;
                }
                if (0 === e2.strm.avail_in) break;
                if (a2 = e2.strm, o2 = e2.window, h2 = e2.strstart + e2.lookahead, u2 = i2, l2 = void 0, l2 = a2.avail_in, u2 < l2 && (l2 = u2), r2 = 0 === l2 ? 0 : (a2.avail_in -= l2, c.arraySet(o2, a2.input, a2.next_in, l2, h2), 1 === a2.state.wrap ? a2.adler = d(a2.adler, o2, l2, h2) : 2 === a2.state.wrap && (a2.adler = p(a2.adler, o2, l2, h2)), a2.next_in += l2, a2.total_in += l2, l2), e2.lookahead += r2, e2.lookahead + e2.insert >= x) for (s2 = e2.strstart - e2.insert, e2.ins_h = e2.window[s2], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s2 + 1]) & e2.hash_mask; e2.insert && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s2 + x - 1]) & e2.hash_mask, e2.prev[s2 & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = s2, s2++, e2.insert--, !(e2.lookahead + e2.insert < x)); ) ;
              } while (e2.lookahead < z && 0 !== e2.strm.avail_in);
            }
            function Z(e2, t2) {
              for (var r2, n2; ; ) {
                if (e2.lookahead < z) {
                  if (j(e2), e2.lookahead < z && t2 === l) return A;
                  if (0 === e2.lookahead) break;
                }
                if (r2 = 0, e2.lookahead >= x && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), 0 !== r2 && e2.strstart - r2 <= e2.w_size - z && (e2.match_length = L(e2, r2)), e2.match_length >= x) if (n2 = u._tr_tally(e2, e2.strstart - e2.match_start, e2.match_length - x), e2.lookahead -= e2.match_length, e2.match_length <= e2.max_lazy_match && e2.lookahead >= x) {
                  for (e2.match_length--; e2.strstart++, e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart, 0 != --e2.match_length; ) ;
                  e2.strstart++;
                } else e2.strstart += e2.match_length, e2.match_length = 0, e2.ins_h = e2.window[e2.strstart], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + 1]) & e2.hash_mask;
                else n2 = u._tr_tally(e2, 0, e2.window[e2.strstart]), e2.lookahead--, e2.strstart++;
                if (n2 && (N(e2, false), 0 === e2.strm.avail_out)) return A;
              }
              return e2.insert = e2.strstart < x - 1 ? e2.strstart : x - 1, t2 === f ? (N(e2, true), 0 === e2.strm.avail_out ? O : B) : e2.last_lit && (N(e2, false), 0 === e2.strm.avail_out) ? A : I;
            }
            function W(e2, t2) {
              for (var r2, n2, i2; ; ) {
                if (e2.lookahead < z) {
                  if (j(e2), e2.lookahead < z && t2 === l) return A;
                  if (0 === e2.lookahead) break;
                }
                if (r2 = 0, e2.lookahead >= x && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), e2.prev_length = e2.match_length, e2.prev_match = e2.match_start, e2.match_length = x - 1, 0 !== r2 && e2.prev_length < e2.max_lazy_match && e2.strstart - r2 <= e2.w_size - z && (e2.match_length = L(e2, r2), e2.match_length <= 5 && (1 === e2.strategy || e2.match_length === x && 4096 < e2.strstart - e2.match_start) && (e2.match_length = x - 1)), e2.prev_length >= x && e2.match_length <= e2.prev_length) {
                  for (i2 = e2.strstart + e2.lookahead - x, n2 = u._tr_tally(e2, e2.strstart - 1 - e2.prev_match, e2.prev_length - x), e2.lookahead -= e2.prev_length - 1, e2.prev_length -= 2; ++e2.strstart <= i2 && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), 0 != --e2.prev_length; ) ;
                  if (e2.match_available = 0, e2.match_length = x - 1, e2.strstart++, n2 && (N(e2, false), 0 === e2.strm.avail_out)) return A;
                } else if (e2.match_available) {
                  if ((n2 = u._tr_tally(e2, 0, e2.window[e2.strstart - 1])) && N(e2, false), e2.strstart++, e2.lookahead--, 0 === e2.strm.avail_out) return A;
                } else e2.match_available = 1, e2.strstart++, e2.lookahead--;
              }
              return e2.match_available && (n2 = u._tr_tally(e2, 0, e2.window[e2.strstart - 1]), e2.match_available = 0), e2.insert = e2.strstart < x - 1 ? e2.strstart : x - 1, t2 === f ? (N(e2, true), 0 === e2.strm.avail_out ? O : B) : e2.last_lit && (N(e2, false), 0 === e2.strm.avail_out) ? A : I;
            }
            function M(e2, t2, r2, n2, i2) {
              this.good_length = e2, this.max_lazy = t2, this.nice_length = r2, this.max_chain = n2, this.func = i2;
            }
            function H() {
              this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = v, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new c.Buf16(2 * w), this.dyn_dtree = new c.Buf16(2 * (2 * a + 1)), this.bl_tree = new c.Buf16(2 * (2 * o + 1)), D(this.dyn_ltree), D(this.dyn_dtree), D(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new c.Buf16(k + 1), this.heap = new c.Buf16(2 * s + 1), D(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new c.Buf16(2 * s + 1), D(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
            }
            function G(e2) {
              var t2;
              return e2 && e2.state ? (e2.total_in = e2.total_out = 0, e2.data_type = i, (t2 = e2.state).pending = 0, t2.pending_out = 0, t2.wrap < 0 && (t2.wrap = -t2.wrap), t2.status = t2.wrap ? C : E, e2.adler = 2 === t2.wrap ? 0 : 1, t2.last_flush = l, u._tr_init(t2), m) : R(e2, _);
            }
            function K(e2) {
              var t2 = G(e2);
              return t2 === m && (function(e3) {
                e3.window_size = 2 * e3.w_size, D(e3.head), e3.max_lazy_match = h[e3.level].max_lazy, e3.good_match = h[e3.level].good_length, e3.nice_match = h[e3.level].nice_length, e3.max_chain_length = h[e3.level].max_chain, e3.strstart = 0, e3.block_start = 0, e3.lookahead = 0, e3.insert = 0, e3.match_length = e3.prev_length = x - 1, e3.match_available = 0, e3.ins_h = 0;
              })(e2.state), t2;
            }
            function Y(e2, t2, r2, n2, i2, s2) {
              if (!e2) return _;
              var a2 = 1;
              if (t2 === g && (t2 = 6), n2 < 0 ? (a2 = 0, n2 = -n2) : 15 < n2 && (a2 = 2, n2 -= 16), i2 < 1 || y < i2 || r2 !== v || n2 < 8 || 15 < n2 || t2 < 0 || 9 < t2 || s2 < 0 || b < s2) return R(e2, _);
              8 === n2 && (n2 = 9);
              var o2 = new H();
              return (e2.state = o2).strm = e2, o2.wrap = a2, o2.gzhead = null, o2.w_bits = n2, o2.w_size = 1 << o2.w_bits, o2.w_mask = o2.w_size - 1, o2.hash_bits = i2 + 7, o2.hash_size = 1 << o2.hash_bits, o2.hash_mask = o2.hash_size - 1, o2.hash_shift = ~~((o2.hash_bits + x - 1) / x), o2.window = new c.Buf8(2 * o2.w_size), o2.head = new c.Buf16(o2.hash_size), o2.prev = new c.Buf16(o2.w_size), o2.lit_bufsize = 1 << i2 + 6, o2.pending_buf_size = 4 * o2.lit_bufsize, o2.pending_buf = new c.Buf8(o2.pending_buf_size), o2.d_buf = 1 * o2.lit_bufsize, o2.l_buf = 3 * o2.lit_bufsize, o2.level = t2, o2.strategy = s2, o2.method = r2, K(e2);
            }
            h = [new M(0, 0, 0, 0, function(e2, t2) {
              var r2 = 65535;
              for (r2 > e2.pending_buf_size - 5 && (r2 = e2.pending_buf_size - 5); ; ) {
                if (e2.lookahead <= 1) {
                  if (j(e2), 0 === e2.lookahead && t2 === l) return A;
                  if (0 === e2.lookahead) break;
                }
                e2.strstart += e2.lookahead, e2.lookahead = 0;
                var n2 = e2.block_start + r2;
                if ((0 === e2.strstart || e2.strstart >= n2) && (e2.lookahead = e2.strstart - n2, e2.strstart = n2, N(e2, false), 0 === e2.strm.avail_out)) return A;
                if (e2.strstart - e2.block_start >= e2.w_size - z && (N(e2, false), 0 === e2.strm.avail_out)) return A;
              }
              return e2.insert = 0, t2 === f ? (N(e2, true), 0 === e2.strm.avail_out ? O : B) : (e2.strstart > e2.block_start && (N(e2, false), e2.strm.avail_out), A);
            }), new M(4, 4, 8, 4, Z), new M(4, 5, 16, 8, Z), new M(4, 6, 32, 32, Z), new M(4, 4, 16, 16, W), new M(8, 16, 32, 32, W), new M(8, 16, 128, 128, W), new M(8, 32, 128, 256, W), new M(32, 128, 258, 1024, W), new M(32, 258, 258, 4096, W)], r.deflateInit = function(e2, t2) {
              return Y(e2, t2, v, 15, 8, 0);
            }, r.deflateInit2 = Y, r.deflateReset = K, r.deflateResetKeep = G, r.deflateSetHeader = function(e2, t2) {
              return e2 && e2.state ? 2 !== e2.state.wrap ? _ : (e2.state.gzhead = t2, m) : _;
            }, r.deflate = function(e2, t2) {
              var r2, n2, i2, s2;
              if (!e2 || !e2.state || 5 < t2 || t2 < 0) return e2 ? R(e2, _) : _;
              if (n2 = e2.state, !e2.output || !e2.input && 0 !== e2.avail_in || 666 === n2.status && t2 !== f) return R(e2, 0 === e2.avail_out ? -5 : _);
              if (n2.strm = e2, r2 = n2.last_flush, n2.last_flush = t2, n2.status === C) if (2 === n2.wrap) e2.adler = 0, U(n2, 31), U(n2, 139), U(n2, 8), n2.gzhead ? (U(n2, (n2.gzhead.text ? 1 : 0) + (n2.gzhead.hcrc ? 2 : 0) + (n2.gzhead.extra ? 4 : 0) + (n2.gzhead.name ? 8 : 0) + (n2.gzhead.comment ? 16 : 0)), U(n2, 255 & n2.gzhead.time), U(n2, n2.gzhead.time >> 8 & 255), U(n2, n2.gzhead.time >> 16 & 255), U(n2, n2.gzhead.time >> 24 & 255), U(n2, 9 === n2.level ? 2 : 2 <= n2.strategy || n2.level < 2 ? 4 : 0), U(n2, 255 & n2.gzhead.os), n2.gzhead.extra && n2.gzhead.extra.length && (U(n2, 255 & n2.gzhead.extra.length), U(n2, n2.gzhead.extra.length >> 8 & 255)), n2.gzhead.hcrc && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending, 0)), n2.gzindex = 0, n2.status = 69) : (U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 9 === n2.level ? 2 : 2 <= n2.strategy || n2.level < 2 ? 4 : 0), U(n2, 3), n2.status = E);
              else {
                var a2 = v + (n2.w_bits - 8 << 4) << 8;
                a2 |= (2 <= n2.strategy || n2.level < 2 ? 0 : n2.level < 6 ? 1 : 6 === n2.level ? 2 : 3) << 6, 0 !== n2.strstart && (a2 |= 32), a2 += 31 - a2 % 31, n2.status = E, P(n2, a2), 0 !== n2.strstart && (P(n2, e2.adler >>> 16), P(n2, 65535 & e2.adler)), e2.adler = 1;
              }
              if (69 === n2.status) if (n2.gzhead.extra) {
                for (i2 = n2.pending; n2.gzindex < (65535 & n2.gzhead.extra.length) && (n2.pending !== n2.pending_buf_size || (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending !== n2.pending_buf_size)); ) U(n2, 255 & n2.gzhead.extra[n2.gzindex]), n2.gzindex++;
                n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), n2.gzindex === n2.gzhead.extra.length && (n2.gzindex = 0, n2.status = 73);
              } else n2.status = 73;
              if (73 === n2.status) if (n2.gzhead.name) {
                i2 = n2.pending;
                do {
                  if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending === n2.pending_buf_size)) {
                    s2 = 1;
                    break;
                  }
                  s2 = n2.gzindex < n2.gzhead.name.length ? 255 & n2.gzhead.name.charCodeAt(n2.gzindex++) : 0, U(n2, s2);
                } while (0 !== s2);
                n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), 0 === s2 && (n2.gzindex = 0, n2.status = 91);
              } else n2.status = 91;
              if (91 === n2.status) if (n2.gzhead.comment) {
                i2 = n2.pending;
                do {
                  if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending === n2.pending_buf_size)) {
                    s2 = 1;
                    break;
                  }
                  s2 = n2.gzindex < n2.gzhead.comment.length ? 255 & n2.gzhead.comment.charCodeAt(n2.gzindex++) : 0, U(n2, s2);
                } while (0 !== s2);
                n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), 0 === s2 && (n2.status = 103);
              } else n2.status = 103;
              if (103 === n2.status && (n2.gzhead.hcrc ? (n2.pending + 2 > n2.pending_buf_size && F(e2), n2.pending + 2 <= n2.pending_buf_size && (U(n2, 255 & e2.adler), U(n2, e2.adler >> 8 & 255), e2.adler = 0, n2.status = E)) : n2.status = E), 0 !== n2.pending) {
                if (F(e2), 0 === e2.avail_out) return n2.last_flush = -1, m;
              } else if (0 === e2.avail_in && T(t2) <= T(r2) && t2 !== f) return R(e2, -5);
              if (666 === n2.status && 0 !== e2.avail_in) return R(e2, -5);
              if (0 !== e2.avail_in || 0 !== n2.lookahead || t2 !== l && 666 !== n2.status) {
                var o2 = 2 === n2.strategy ? (function(e3, t3) {
                  for (var r3; ; ) {
                    if (0 === e3.lookahead && (j(e3), 0 === e3.lookahead)) {
                      if (t3 === l) return A;
                      break;
                    }
                    if (e3.match_length = 0, r3 = u._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++, r3 && (N(e3, false), 0 === e3.strm.avail_out)) return A;
                  }
                  return e3.insert = 0, t3 === f ? (N(e3, true), 0 === e3.strm.avail_out ? O : B) : e3.last_lit && (N(e3, false), 0 === e3.strm.avail_out) ? A : I;
                })(n2, t2) : 3 === n2.strategy ? (function(e3, t3) {
                  for (var r3, n3, i3, s3, a3 = e3.window; ; ) {
                    if (e3.lookahead <= S) {
                      if (j(e3), e3.lookahead <= S && t3 === l) return A;
                      if (0 === e3.lookahead) break;
                    }
                    if (e3.match_length = 0, e3.lookahead >= x && 0 < e3.strstart && (n3 = a3[i3 = e3.strstart - 1]) === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3]) {
                      s3 = e3.strstart + S;
                      do {
                      } while (n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && i3 < s3);
                      e3.match_length = S - (s3 - i3), e3.match_length > e3.lookahead && (e3.match_length = e3.lookahead);
                    }
                    if (e3.match_length >= x ? (r3 = u._tr_tally(e3, 1, e3.match_length - x), e3.lookahead -= e3.match_length, e3.strstart += e3.match_length, e3.match_length = 0) : (r3 = u._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++), r3 && (N(e3, false), 0 === e3.strm.avail_out)) return A;
                  }
                  return e3.insert = 0, t3 === f ? (N(e3, true), 0 === e3.strm.avail_out ? O : B) : e3.last_lit && (N(e3, false), 0 === e3.strm.avail_out) ? A : I;
                })(n2, t2) : h[n2.level].func(n2, t2);
                if (o2 !== O && o2 !== B || (n2.status = 666), o2 === A || o2 === O) return 0 === e2.avail_out && (n2.last_flush = -1), m;
                if (o2 === I && (1 === t2 ? u._tr_align(n2) : 5 !== t2 && (u._tr_stored_block(n2, 0, 0, false), 3 === t2 && (D(n2.head), 0 === n2.lookahead && (n2.strstart = 0, n2.block_start = 0, n2.insert = 0))), F(e2), 0 === e2.avail_out)) return n2.last_flush = -1, m;
              }
              return t2 !== f ? m : n2.wrap <= 0 ? 1 : (2 === n2.wrap ? (U(n2, 255 & e2.adler), U(n2, e2.adler >> 8 & 255), U(n2, e2.adler >> 16 & 255), U(n2, e2.adler >> 24 & 255), U(n2, 255 & e2.total_in), U(n2, e2.total_in >> 8 & 255), U(n2, e2.total_in >> 16 & 255), U(n2, e2.total_in >> 24 & 255)) : (P(n2, e2.adler >>> 16), P(n2, 65535 & e2.adler)), F(e2), 0 < n2.wrap && (n2.wrap = -n2.wrap), 0 !== n2.pending ? m : 1);
            }, r.deflateEnd = function(e2) {
              var t2;
              return e2 && e2.state ? (t2 = e2.state.status) !== C && 69 !== t2 && 73 !== t2 && 91 !== t2 && 103 !== t2 && t2 !== E && 666 !== t2 ? R(e2, _) : (e2.state = null, t2 === E ? R(e2, -3) : m) : _;
            }, r.deflateSetDictionary = function(e2, t2) {
              var r2, n2, i2, s2, a2, o2, h2, u2, l2 = t2.length;
              if (!e2 || !e2.state) return _;
              if (2 === (s2 = (r2 = e2.state).wrap) || 1 === s2 && r2.status !== C || r2.lookahead) return _;
              for (1 === s2 && (e2.adler = d(e2.adler, t2, l2, 0)), r2.wrap = 0, l2 >= r2.w_size && (0 === s2 && (D(r2.head), r2.strstart = 0, r2.block_start = 0, r2.insert = 0), u2 = new c.Buf8(r2.w_size), c.arraySet(u2, t2, l2 - r2.w_size, r2.w_size, 0), t2 = u2, l2 = r2.w_size), a2 = e2.avail_in, o2 = e2.next_in, h2 = e2.input, e2.avail_in = l2, e2.next_in = 0, e2.input = t2, j(r2); r2.lookahead >= x; ) {
                for (n2 = r2.strstart, i2 = r2.lookahead - (x - 1); r2.ins_h = (r2.ins_h << r2.hash_shift ^ r2.window[n2 + x - 1]) & r2.hash_mask, r2.prev[n2 & r2.w_mask] = r2.head[r2.ins_h], r2.head[r2.ins_h] = n2, n2++, --i2; ) ;
                r2.strstart = n2, r2.lookahead = x - 1, j(r2);
              }
              return r2.strstart += r2.lookahead, r2.block_start = r2.strstart, r2.insert = r2.lookahead, r2.lookahead = 0, r2.match_length = r2.prev_length = x - 1, r2.match_available = 0, e2.next_in = o2, e2.input = h2, e2.avail_in = a2, r2.wrap = s2, m;
            }, r.deflateInfo = "pako deflate (from Nodeca project)";
          }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(e, t, r) {
            t.exports = function() {
              this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
            };
          }, {}], 48: [function(e, t, r) {
            t.exports = function(e2, t2) {
              var r2, n, i, s, a, o, h, u, l, f, c, d, p, m, _, g, b, v, y, w, k, x, S, z, C;
              r2 = e2.state, n = e2.next_in, z = e2.input, i = n + (e2.avail_in - 5), s = e2.next_out, C = e2.output, a = s - (t2 - e2.avail_out), o = s + (e2.avail_out - 257), h = r2.dmax, u = r2.wsize, l = r2.whave, f = r2.wnext, c = r2.window, d = r2.hold, p = r2.bits, m = r2.lencode, _ = r2.distcode, g = (1 << r2.lenbits) - 1, b = (1 << r2.distbits) - 1;
              e: do {
                p < 15 && (d += z[n++] << p, p += 8, d += z[n++] << p, p += 8), v = m[d & g];
                t: for (; ; ) {
                  if (d >>>= y = v >>> 24, p -= y, 0 === (y = v >>> 16 & 255)) C[s++] = 65535 & v;
                  else {
                    if (!(16 & y)) {
                      if (0 == (64 & y)) {
                        v = m[(65535 & v) + (d & (1 << y) - 1)];
                        continue t;
                      }
                      if (32 & y) {
                        r2.mode = 12;
                        break e;
                      }
                      e2.msg = "invalid literal/length code", r2.mode = 30;
                      break e;
                    }
                    w = 65535 & v, (y &= 15) && (p < y && (d += z[n++] << p, p += 8), w += d & (1 << y) - 1, d >>>= y, p -= y), p < 15 && (d += z[n++] << p, p += 8, d += z[n++] << p, p += 8), v = _[d & b];
                    r: for (; ; ) {
                      if (d >>>= y = v >>> 24, p -= y, !(16 & (y = v >>> 16 & 255))) {
                        if (0 == (64 & y)) {
                          v = _[(65535 & v) + (d & (1 << y) - 1)];
                          continue r;
                        }
                        e2.msg = "invalid distance code", r2.mode = 30;
                        break e;
                      }
                      if (k = 65535 & v, p < (y &= 15) && (d += z[n++] << p, (p += 8) < y && (d += z[n++] << p, p += 8)), h < (k += d & (1 << y) - 1)) {
                        e2.msg = "invalid distance too far back", r2.mode = 30;
                        break e;
                      }
                      if (d >>>= y, p -= y, (y = s - a) < k) {
                        if (l < (y = k - y) && r2.sane) {
                          e2.msg = "invalid distance too far back", r2.mode = 30;
                          break e;
                        }
                        if (S = c, (x = 0) === f) {
                          if (x += u - y, y < w) {
                            for (w -= y; C[s++] = c[x++], --y; ) ;
                            x = s - k, S = C;
                          }
                        } else if (f < y) {
                          if (x += u + f - y, (y -= f) < w) {
                            for (w -= y; C[s++] = c[x++], --y; ) ;
                            if (x = 0, f < w) {
                              for (w -= y = f; C[s++] = c[x++], --y; ) ;
                              x = s - k, S = C;
                            }
                          }
                        } else if (x += f - y, y < w) {
                          for (w -= y; C[s++] = c[x++], --y; ) ;
                          x = s - k, S = C;
                        }
                        for (; 2 < w; ) C[s++] = S[x++], C[s++] = S[x++], C[s++] = S[x++], w -= 3;
                        w && (C[s++] = S[x++], 1 < w && (C[s++] = S[x++]));
                      } else {
                        for (x = s - k; C[s++] = C[x++], C[s++] = C[x++], C[s++] = C[x++], 2 < (w -= 3); ) ;
                        w && (C[s++] = C[x++], 1 < w && (C[s++] = C[x++]));
                      }
                      break;
                    }
                  }
                  break;
                }
              } while (n < i && s < o);
              n -= w = p >> 3, d &= (1 << (p -= w << 3)) - 1, e2.next_in = n, e2.next_out = s, e2.avail_in = n < i ? i - n + 5 : 5 - (n - i), e2.avail_out = s < o ? o - s + 257 : 257 - (s - o), r2.hold = d, r2.bits = p;
            };
          }, {}], 49: [function(e, t, r) {
            var I = e("../utils/common"), O = e("./adler32"), B = e("./crc32"), R = e("./inffast"), T = e("./inftrees"), D = 1, F = 2, N = 0, U = -2, P = 1, n = 852, i = 592;
            function L(e2) {
              return (e2 >>> 24 & 255) + (e2 >>> 8 & 65280) + ((65280 & e2) << 8) + ((255 & e2) << 24);
            }
            function s() {
              this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new I.Buf16(320), this.work = new I.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
            }
            function a(e2) {
              var t2;
              return e2 && e2.state ? (t2 = e2.state, e2.total_in = e2.total_out = t2.total = 0, e2.msg = "", t2.wrap && (e2.adler = 1 & t2.wrap), t2.mode = P, t2.last = 0, t2.havedict = 0, t2.dmax = 32768, t2.head = null, t2.hold = 0, t2.bits = 0, t2.lencode = t2.lendyn = new I.Buf32(n), t2.distcode = t2.distdyn = new I.Buf32(i), t2.sane = 1, t2.back = -1, N) : U;
            }
            function o(e2) {
              var t2;
              return e2 && e2.state ? ((t2 = e2.state).wsize = 0, t2.whave = 0, t2.wnext = 0, a(e2)) : U;
            }
            function h(e2, t2) {
              var r2, n2;
              return e2 && e2.state ? (n2 = e2.state, t2 < 0 ? (r2 = 0, t2 = -t2) : (r2 = 1 + (t2 >> 4), t2 < 48 && (t2 &= 15)), t2 && (t2 < 8 || 15 < t2) ? U : (null !== n2.window && n2.wbits !== t2 && (n2.window = null), n2.wrap = r2, n2.wbits = t2, o(e2))) : U;
            }
            function u(e2, t2) {
              var r2, n2;
              return e2 ? (n2 = new s(), (e2.state = n2).window = null, (r2 = h(e2, t2)) !== N && (e2.state = null), r2) : U;
            }
            var l, f, c = true;
            function j(e2) {
              if (c) {
                var t2;
                for (l = new I.Buf32(512), f = new I.Buf32(32), t2 = 0; t2 < 144; ) e2.lens[t2++] = 8;
                for (; t2 < 256; ) e2.lens[t2++] = 9;
                for (; t2 < 280; ) e2.lens[t2++] = 7;
                for (; t2 < 288; ) e2.lens[t2++] = 8;
                for (T(D, e2.lens, 0, 288, l, 0, e2.work, { bits: 9 }), t2 = 0; t2 < 32; ) e2.lens[t2++] = 5;
                T(F, e2.lens, 0, 32, f, 0, e2.work, { bits: 5 }), c = false;
              }
              e2.lencode = l, e2.lenbits = 9, e2.distcode = f, e2.distbits = 5;
            }
            function Z(e2, t2, r2, n2) {
              var i2, s2 = e2.state;
              return null === s2.window && (s2.wsize = 1 << s2.wbits, s2.wnext = 0, s2.whave = 0, s2.window = new I.Buf8(s2.wsize)), n2 >= s2.wsize ? (I.arraySet(s2.window, t2, r2 - s2.wsize, s2.wsize, 0), s2.wnext = 0, s2.whave = s2.wsize) : (n2 < (i2 = s2.wsize - s2.wnext) && (i2 = n2), I.arraySet(s2.window, t2, r2 - n2, i2, s2.wnext), (n2 -= i2) ? (I.arraySet(s2.window, t2, r2 - n2, n2, 0), s2.wnext = n2, s2.whave = s2.wsize) : (s2.wnext += i2, s2.wnext === s2.wsize && (s2.wnext = 0), s2.whave < s2.wsize && (s2.whave += i2))), 0;
            }
            r.inflateReset = o, r.inflateReset2 = h, r.inflateResetKeep = a, r.inflateInit = function(e2) {
              return u(e2, 15);
            }, r.inflateInit2 = u, r.inflate = function(e2, t2) {
              var r2, n2, i2, s2, a2, o2, h2, u2, l2, f2, c2, d, p, m, _, g, b, v, y, w, k, x, S, z, C = 0, E = new I.Buf8(4), A = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
              if (!e2 || !e2.state || !e2.output || !e2.input && 0 !== e2.avail_in) return U;
              12 === (r2 = e2.state).mode && (r2.mode = 13), a2 = e2.next_out, i2 = e2.output, h2 = e2.avail_out, s2 = e2.next_in, n2 = e2.input, o2 = e2.avail_in, u2 = r2.hold, l2 = r2.bits, f2 = o2, c2 = h2, x = N;
              e: for (; ; ) switch (r2.mode) {
                case P:
                  if (0 === r2.wrap) {
                    r2.mode = 13;
                    break;
                  }
                  for (; l2 < 16; ) {
                    if (0 === o2) break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (2 & r2.wrap && 35615 === u2) {
                    E[r2.check = 0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0), l2 = u2 = 0, r2.mode = 2;
                    break;
                  }
                  if (r2.flags = 0, r2.head && (r2.head.done = false), !(1 & r2.wrap) || (((255 & u2) << 8) + (u2 >> 8)) % 31) {
                    e2.msg = "incorrect header check", r2.mode = 30;
                    break;
                  }
                  if (8 != (15 & u2)) {
                    e2.msg = "unknown compression method", r2.mode = 30;
                    break;
                  }
                  if (l2 -= 4, k = 8 + (15 & (u2 >>>= 4)), 0 === r2.wbits) r2.wbits = k;
                  else if (k > r2.wbits) {
                    e2.msg = "invalid window size", r2.mode = 30;
                    break;
                  }
                  r2.dmax = 1 << k, e2.adler = r2.check = 1, r2.mode = 512 & u2 ? 10 : 12, l2 = u2 = 0;
                  break;
                case 2:
                  for (; l2 < 16; ) {
                    if (0 === o2) break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (r2.flags = u2, 8 != (255 & r2.flags)) {
                    e2.msg = "unknown compression method", r2.mode = 30;
                    break;
                  }
                  if (57344 & r2.flags) {
                    e2.msg = "unknown header flags set", r2.mode = 30;
                    break;
                  }
                  r2.head && (r2.head.text = u2 >> 8 & 1), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0, r2.mode = 3;
                case 3:
                  for (; l2 < 32; ) {
                    if (0 === o2) break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  r2.head && (r2.head.time = u2), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, E[2] = u2 >>> 16 & 255, E[3] = u2 >>> 24 & 255, r2.check = B(r2.check, E, 4, 0)), l2 = u2 = 0, r2.mode = 4;
                case 4:
                  for (; l2 < 16; ) {
                    if (0 === o2) break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  r2.head && (r2.head.xflags = 255 & u2, r2.head.os = u2 >> 8), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0, r2.mode = 5;
                case 5:
                  if (1024 & r2.flags) {
                    for (; l2 < 16; ) {
                      if (0 === o2) break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    r2.length = u2, r2.head && (r2.head.extra_len = u2), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0;
                  } else r2.head && (r2.head.extra = null);
                  r2.mode = 6;
                case 6:
                  if (1024 & r2.flags && (o2 < (d = r2.length) && (d = o2), d && (r2.head && (k = r2.head.extra_len - r2.length, r2.head.extra || (r2.head.extra = new Array(r2.head.extra_len)), I.arraySet(r2.head.extra, n2, s2, d, k)), 512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, r2.length -= d), r2.length)) break e;
                  r2.length = 0, r2.mode = 7;
                case 7:
                  if (2048 & r2.flags) {
                    if (0 === o2) break e;
                    for (d = 0; k = n2[s2 + d++], r2.head && k && r2.length < 65536 && (r2.head.name += String.fromCharCode(k)), k && d < o2; ) ;
                    if (512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, k) break e;
                  } else r2.head && (r2.head.name = null);
                  r2.length = 0, r2.mode = 8;
                case 8:
                  if (4096 & r2.flags) {
                    if (0 === o2) break e;
                    for (d = 0; k = n2[s2 + d++], r2.head && k && r2.length < 65536 && (r2.head.comment += String.fromCharCode(k)), k && d < o2; ) ;
                    if (512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, k) break e;
                  } else r2.head && (r2.head.comment = null);
                  r2.mode = 9;
                case 9:
                  if (512 & r2.flags) {
                    for (; l2 < 16; ) {
                      if (0 === o2) break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    if (u2 !== (65535 & r2.check)) {
                      e2.msg = "header crc mismatch", r2.mode = 30;
                      break;
                    }
                    l2 = u2 = 0;
                  }
                  r2.head && (r2.head.hcrc = r2.flags >> 9 & 1, r2.head.done = true), e2.adler = r2.check = 0, r2.mode = 12;
                  break;
                case 10:
                  for (; l2 < 32; ) {
                    if (0 === o2) break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  e2.adler = r2.check = L(u2), l2 = u2 = 0, r2.mode = 11;
                case 11:
                  if (0 === r2.havedict) return e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, 2;
                  e2.adler = r2.check = 1, r2.mode = 12;
                case 12:
                  if (5 === t2 || 6 === t2) break e;
                case 13:
                  if (r2.last) {
                    u2 >>>= 7 & l2, l2 -= 7 & l2, r2.mode = 27;
                    break;
                  }
                  for (; l2 < 3; ) {
                    if (0 === o2) break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  switch (r2.last = 1 & u2, l2 -= 1, 3 & (u2 >>>= 1)) {
                    case 0:
                      r2.mode = 14;
                      break;
                    case 1:
                      if (j(r2), r2.mode = 20, 6 !== t2) break;
                      u2 >>>= 2, l2 -= 2;
                      break e;
                    case 2:
                      r2.mode = 17;
                      break;
                    case 3:
                      e2.msg = "invalid block type", r2.mode = 30;
                  }
                  u2 >>>= 2, l2 -= 2;
                  break;
                case 14:
                  for (u2 >>>= 7 & l2, l2 -= 7 & l2; l2 < 32; ) {
                    if (0 === o2) break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if ((65535 & u2) != (u2 >>> 16 ^ 65535)) {
                    e2.msg = "invalid stored block lengths", r2.mode = 30;
                    break;
                  }
                  if (r2.length = 65535 & u2, l2 = u2 = 0, r2.mode = 15, 6 === t2) break e;
                case 15:
                  r2.mode = 16;
                case 16:
                  if (d = r2.length) {
                    if (o2 < d && (d = o2), h2 < d && (d = h2), 0 === d) break e;
                    I.arraySet(i2, n2, s2, d, a2), o2 -= d, s2 += d, h2 -= d, a2 += d, r2.length -= d;
                    break;
                  }
                  r2.mode = 12;
                  break;
                case 17:
                  for (; l2 < 14; ) {
                    if (0 === o2) break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (r2.nlen = 257 + (31 & u2), u2 >>>= 5, l2 -= 5, r2.ndist = 1 + (31 & u2), u2 >>>= 5, l2 -= 5, r2.ncode = 4 + (15 & u2), u2 >>>= 4, l2 -= 4, 286 < r2.nlen || 30 < r2.ndist) {
                    e2.msg = "too many length or distance symbols", r2.mode = 30;
                    break;
                  }
                  r2.have = 0, r2.mode = 18;
                case 18:
                  for (; r2.have < r2.ncode; ) {
                    for (; l2 < 3; ) {
                      if (0 === o2) break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    r2.lens[A[r2.have++]] = 7 & u2, u2 >>>= 3, l2 -= 3;
                  }
                  for (; r2.have < 19; ) r2.lens[A[r2.have++]] = 0;
                  if (r2.lencode = r2.lendyn, r2.lenbits = 7, S = { bits: r2.lenbits }, x = T(0, r2.lens, 0, 19, r2.lencode, 0, r2.work, S), r2.lenbits = S.bits, x) {
                    e2.msg = "invalid code lengths set", r2.mode = 30;
                    break;
                  }
                  r2.have = 0, r2.mode = 19;
                case 19:
                  for (; r2.have < r2.nlen + r2.ndist; ) {
                    for (; g = (C = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                      if (0 === o2) break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    if (b < 16) u2 >>>= _, l2 -= _, r2.lens[r2.have++] = b;
                    else {
                      if (16 === b) {
                        for (z = _ + 2; l2 < z; ) {
                          if (0 === o2) break e;
                          o2--, u2 += n2[s2++] << l2, l2 += 8;
                        }
                        if (u2 >>>= _, l2 -= _, 0 === r2.have) {
                          e2.msg = "invalid bit length repeat", r2.mode = 30;
                          break;
                        }
                        k = r2.lens[r2.have - 1], d = 3 + (3 & u2), u2 >>>= 2, l2 -= 2;
                      } else if (17 === b) {
                        for (z = _ + 3; l2 < z; ) {
                          if (0 === o2) break e;
                          o2--, u2 += n2[s2++] << l2, l2 += 8;
                        }
                        l2 -= _, k = 0, d = 3 + (7 & (u2 >>>= _)), u2 >>>= 3, l2 -= 3;
                      } else {
                        for (z = _ + 7; l2 < z; ) {
                          if (0 === o2) break e;
                          o2--, u2 += n2[s2++] << l2, l2 += 8;
                        }
                        l2 -= _, k = 0, d = 11 + (127 & (u2 >>>= _)), u2 >>>= 7, l2 -= 7;
                      }
                      if (r2.have + d > r2.nlen + r2.ndist) {
                        e2.msg = "invalid bit length repeat", r2.mode = 30;
                        break;
                      }
                      for (; d--; ) r2.lens[r2.have++] = k;
                    }
                  }
                  if (30 === r2.mode) break;
                  if (0 === r2.lens[256]) {
                    e2.msg = "invalid code -- missing end-of-block", r2.mode = 30;
                    break;
                  }
                  if (r2.lenbits = 9, S = { bits: r2.lenbits }, x = T(D, r2.lens, 0, r2.nlen, r2.lencode, 0, r2.work, S), r2.lenbits = S.bits, x) {
                    e2.msg = "invalid literal/lengths set", r2.mode = 30;
                    break;
                  }
                  if (r2.distbits = 6, r2.distcode = r2.distdyn, S = { bits: r2.distbits }, x = T(F, r2.lens, r2.nlen, r2.ndist, r2.distcode, 0, r2.work, S), r2.distbits = S.bits, x) {
                    e2.msg = "invalid distances set", r2.mode = 30;
                    break;
                  }
                  if (r2.mode = 20, 6 === t2) break e;
                case 20:
                  r2.mode = 21;
                case 21:
                  if (6 <= o2 && 258 <= h2) {
                    e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, R(e2, c2), a2 = e2.next_out, i2 = e2.output, h2 = e2.avail_out, s2 = e2.next_in, n2 = e2.input, o2 = e2.avail_in, u2 = r2.hold, l2 = r2.bits, 12 === r2.mode && (r2.back = -1);
                    break;
                  }
                  for (r2.back = 0; g = (C = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                    if (0 === o2) break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (g && 0 == (240 & g)) {
                    for (v = _, y = g, w = b; g = (C = r2.lencode[w + ((u2 & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l2); ) {
                      if (0 === o2) break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    u2 >>>= v, l2 -= v, r2.back += v;
                  }
                  if (u2 >>>= _, l2 -= _, r2.back += _, r2.length = b, 0 === g) {
                    r2.mode = 26;
                    break;
                  }
                  if (32 & g) {
                    r2.back = -1, r2.mode = 12;
                    break;
                  }
                  if (64 & g) {
                    e2.msg = "invalid literal/length code", r2.mode = 30;
                    break;
                  }
                  r2.extra = 15 & g, r2.mode = 22;
                case 22:
                  if (r2.extra) {
                    for (z = r2.extra; l2 < z; ) {
                      if (0 === o2) break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    r2.length += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l2 -= r2.extra, r2.back += r2.extra;
                  }
                  r2.was = r2.length, r2.mode = 23;
                case 23:
                  for (; g = (C = r2.distcode[u2 & (1 << r2.distbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                    if (0 === o2) break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (0 == (240 & g)) {
                    for (v = _, y = g, w = b; g = (C = r2.distcode[w + ((u2 & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l2); ) {
                      if (0 === o2) break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    u2 >>>= v, l2 -= v, r2.back += v;
                  }
                  if (u2 >>>= _, l2 -= _, r2.back += _, 64 & g) {
                    e2.msg = "invalid distance code", r2.mode = 30;
                    break;
                  }
                  r2.offset = b, r2.extra = 15 & g, r2.mode = 24;
                case 24:
                  if (r2.extra) {
                    for (z = r2.extra; l2 < z; ) {
                      if (0 === o2) break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    r2.offset += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l2 -= r2.extra, r2.back += r2.extra;
                  }
                  if (r2.offset > r2.dmax) {
                    e2.msg = "invalid distance too far back", r2.mode = 30;
                    break;
                  }
                  r2.mode = 25;
                case 25:
                  if (0 === h2) break e;
                  if (d = c2 - h2, r2.offset > d) {
                    if ((d = r2.offset - d) > r2.whave && r2.sane) {
                      e2.msg = "invalid distance too far back", r2.mode = 30;
                      break;
                    }
                    p = d > r2.wnext ? (d -= r2.wnext, r2.wsize - d) : r2.wnext - d, d > r2.length && (d = r2.length), m = r2.window;
                  } else m = i2, p = a2 - r2.offset, d = r2.length;
                  for (h2 < d && (d = h2), h2 -= d, r2.length -= d; i2[a2++] = m[p++], --d; ) ;
                  0 === r2.length && (r2.mode = 21);
                  break;
                case 26:
                  if (0 === h2) break e;
                  i2[a2++] = r2.length, h2--, r2.mode = 21;
                  break;
                case 27:
                  if (r2.wrap) {
                    for (; l2 < 32; ) {
                      if (0 === o2) break e;
                      o2--, u2 |= n2[s2++] << l2, l2 += 8;
                    }
                    if (c2 -= h2, e2.total_out += c2, r2.total += c2, c2 && (e2.adler = r2.check = r2.flags ? B(r2.check, i2, c2, a2 - c2) : O(r2.check, i2, c2, a2 - c2)), c2 = h2, (r2.flags ? u2 : L(u2)) !== r2.check) {
                      e2.msg = "incorrect data check", r2.mode = 30;
                      break;
                    }
                    l2 = u2 = 0;
                  }
                  r2.mode = 28;
                case 28:
                  if (r2.wrap && r2.flags) {
                    for (; l2 < 32; ) {
                      if (0 === o2) break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    if (u2 !== (4294967295 & r2.total)) {
                      e2.msg = "incorrect length check", r2.mode = 30;
                      break;
                    }
                    l2 = u2 = 0;
                  }
                  r2.mode = 29;
                case 29:
                  x = 1;
                  break e;
                case 30:
                  x = -3;
                  break e;
                case 31:
                  return -4;
                case 32:
                default:
                  return U;
              }
              return e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, (r2.wsize || c2 !== e2.avail_out && r2.mode < 30 && (r2.mode < 27 || 4 !== t2)) && Z(e2, e2.output, e2.next_out, c2 - e2.avail_out) ? (r2.mode = 31, -4) : (f2 -= e2.avail_in, c2 -= e2.avail_out, e2.total_in += f2, e2.total_out += c2, r2.total += c2, r2.wrap && c2 && (e2.adler = r2.check = r2.flags ? B(r2.check, i2, c2, e2.next_out - c2) : O(r2.check, i2, c2, e2.next_out - c2)), e2.data_type = r2.bits + (r2.last ? 64 : 0) + (12 === r2.mode ? 128 : 0) + (20 === r2.mode || 15 === r2.mode ? 256 : 0), (0 == f2 && 0 === c2 || 4 === t2) && x === N && (x = -5), x);
            }, r.inflateEnd = function(e2) {
              if (!e2 || !e2.state) return U;
              var t2 = e2.state;
              return t2.window && (t2.window = null), e2.state = null, N;
            }, r.inflateGetHeader = function(e2, t2) {
              var r2;
              return e2 && e2.state ? 0 == (2 & (r2 = e2.state).wrap) ? U : ((r2.head = t2).done = false, N) : U;
            }, r.inflateSetDictionary = function(e2, t2) {
              var r2, n2 = t2.length;
              return e2 && e2.state ? 0 !== (r2 = e2.state).wrap && 11 !== r2.mode ? U : 11 === r2.mode && O(1, t2, n2, 0) !== r2.check ? -3 : Z(e2, t2, n2, n2) ? (r2.mode = 31, -4) : (r2.havedict = 1, N) : U;
            }, r.inflateInfo = "pako inflate (from Nodeca project)";
          }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(e, t, r) {
            var D = e("../utils/common"), F = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], N = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], U = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], P = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
            t.exports = function(e2, t2, r2, n, i, s, a, o) {
              var h, u, l, f, c, d, p, m, _, g = o.bits, b = 0, v = 0, y = 0, w = 0, k = 0, x = 0, S = 0, z = 0, C = 0, E = 0, A = null, I = 0, O = new D.Buf16(16), B = new D.Buf16(16), R = null, T = 0;
              for (b = 0; b <= 15; b++) O[b] = 0;
              for (v = 0; v < n; v++) O[t2[r2 + v]]++;
              for (k = g, w = 15; 1 <= w && 0 === O[w]; w--) ;
              if (w < k && (k = w), 0 === w) return i[s++] = 20971520, i[s++] = 20971520, o.bits = 1, 0;
              for (y = 1; y < w && 0 === O[y]; y++) ;
              for (k < y && (k = y), b = z = 1; b <= 15; b++) if (z <<= 1, (z -= O[b]) < 0) return -1;
              if (0 < z && (0 === e2 || 1 !== w)) return -1;
              for (B[1] = 0, b = 1; b < 15; b++) B[b + 1] = B[b] + O[b];
              for (v = 0; v < n; v++) 0 !== t2[r2 + v] && (a[B[t2[r2 + v]]++] = v);
              if (d = 0 === e2 ? (A = R = a, 19) : 1 === e2 ? (A = F, I -= 257, R = N, T -= 257, 256) : (A = U, R = P, -1), b = y, c = s, S = v = E = 0, l = -1, f = (C = 1 << (x = k)) - 1, 1 === e2 && 852 < C || 2 === e2 && 592 < C) return 1;
              for (; ; ) {
                for (p = b - S, _ = a[v] < d ? (m = 0, a[v]) : a[v] > d ? (m = R[T + a[v]], A[I + a[v]]) : (m = 96, 0), h = 1 << b - S, y = u = 1 << x; i[c + (E >> S) + (u -= h)] = p << 24 | m << 16 | _ | 0, 0 !== u; ) ;
                for (h = 1 << b - 1; E & h; ) h >>= 1;
                if (0 !== h ? (E &= h - 1, E += h) : E = 0, v++, 0 == --O[b]) {
                  if (b === w) break;
                  b = t2[r2 + a[v]];
                }
                if (k < b && (E & f) !== l) {
                  for (0 === S && (S = k), c += y, z = 1 << (x = b - S); x + S < w && !((z -= O[x + S]) <= 0); ) x++, z <<= 1;
                  if (C += 1 << x, 1 === e2 && 852 < C || 2 === e2 && 592 < C) return 1;
                  i[l = E & f] = k << 24 | x << 16 | c - s | 0;
                }
              }
              return 0 !== E && (i[c + E] = b - S << 24 | 64 << 16 | 0), o.bits = k, 0;
            };
          }, { "../utils/common": 41 }], 51: [function(e, t, r) {
            t.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
          }, {}], 52: [function(e, t, r) {
            var i = e("../utils/common"), o = 0, h = 1;
            function n(e2) {
              for (var t2 = e2.length; 0 <= --t2; ) e2[t2] = 0;
            }
            var s = 0, a = 29, u = 256, l = u + 1 + a, f = 30, c = 19, _ = 2 * l + 1, g = 15, d = 16, p = 7, m = 256, b = 16, v = 17, y = 18, w = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], k = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], x = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], S = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], z = new Array(2 * (l + 2));
            n(z);
            var C = new Array(2 * f);
            n(C);
            var E = new Array(512);
            n(E);
            var A = new Array(256);
            n(A);
            var I = new Array(a);
            n(I);
            var O, B, R, T = new Array(f);
            function D(e2, t2, r2, n2, i2) {
              this.static_tree = e2, this.extra_bits = t2, this.extra_base = r2, this.elems = n2, this.max_length = i2, this.has_stree = e2 && e2.length;
            }
            function F(e2, t2) {
              this.dyn_tree = e2, this.max_code = 0, this.stat_desc = t2;
            }
            function N(e2) {
              return e2 < 256 ? E[e2] : E[256 + (e2 >>> 7)];
            }
            function U(e2, t2) {
              e2.pending_buf[e2.pending++] = 255 & t2, e2.pending_buf[e2.pending++] = t2 >>> 8 & 255;
            }
            function P(e2, t2, r2) {
              e2.bi_valid > d - r2 ? (e2.bi_buf |= t2 << e2.bi_valid & 65535, U(e2, e2.bi_buf), e2.bi_buf = t2 >> d - e2.bi_valid, e2.bi_valid += r2 - d) : (e2.bi_buf |= t2 << e2.bi_valid & 65535, e2.bi_valid += r2);
            }
            function L(e2, t2, r2) {
              P(e2, r2[2 * t2], r2[2 * t2 + 1]);
            }
            function j(e2, t2) {
              for (var r2 = 0; r2 |= 1 & e2, e2 >>>= 1, r2 <<= 1, 0 < --t2; ) ;
              return r2 >>> 1;
            }
            function Z(e2, t2, r2) {
              var n2, i2, s2 = new Array(g + 1), a2 = 0;
              for (n2 = 1; n2 <= g; n2++) s2[n2] = a2 = a2 + r2[n2 - 1] << 1;
              for (i2 = 0; i2 <= t2; i2++) {
                var o2 = e2[2 * i2 + 1];
                0 !== o2 && (e2[2 * i2] = j(s2[o2]++, o2));
              }
            }
            function W(e2) {
              var t2;
              for (t2 = 0; t2 < l; t2++) e2.dyn_ltree[2 * t2] = 0;
              for (t2 = 0; t2 < f; t2++) e2.dyn_dtree[2 * t2] = 0;
              for (t2 = 0; t2 < c; t2++) e2.bl_tree[2 * t2] = 0;
              e2.dyn_ltree[2 * m] = 1, e2.opt_len = e2.static_len = 0, e2.last_lit = e2.matches = 0;
            }
            function M(e2) {
              8 < e2.bi_valid ? U(e2, e2.bi_buf) : 0 < e2.bi_valid && (e2.pending_buf[e2.pending++] = e2.bi_buf), e2.bi_buf = 0, e2.bi_valid = 0;
            }
            function H(e2, t2, r2, n2) {
              var i2 = 2 * t2, s2 = 2 * r2;
              return e2[i2] < e2[s2] || e2[i2] === e2[s2] && n2[t2] <= n2[r2];
            }
            function G(e2, t2, r2) {
              for (var n2 = e2.heap[r2], i2 = r2 << 1; i2 <= e2.heap_len && (i2 < e2.heap_len && H(t2, e2.heap[i2 + 1], e2.heap[i2], e2.depth) && i2++, !H(t2, n2, e2.heap[i2], e2.depth)); ) e2.heap[r2] = e2.heap[i2], r2 = i2, i2 <<= 1;
              e2.heap[r2] = n2;
            }
            function K(e2, t2, r2) {
              var n2, i2, s2, a2, o2 = 0;
              if (0 !== e2.last_lit) for (; n2 = e2.pending_buf[e2.d_buf + 2 * o2] << 8 | e2.pending_buf[e2.d_buf + 2 * o2 + 1], i2 = e2.pending_buf[e2.l_buf + o2], o2++, 0 === n2 ? L(e2, i2, t2) : (L(e2, (s2 = A[i2]) + u + 1, t2), 0 !== (a2 = w[s2]) && P(e2, i2 -= I[s2], a2), L(e2, s2 = N(--n2), r2), 0 !== (a2 = k[s2]) && P(e2, n2 -= T[s2], a2)), o2 < e2.last_lit; ) ;
              L(e2, m, t2);
            }
            function Y(e2, t2) {
              var r2, n2, i2, s2 = t2.dyn_tree, a2 = t2.stat_desc.static_tree, o2 = t2.stat_desc.has_stree, h2 = t2.stat_desc.elems, u2 = -1;
              for (e2.heap_len = 0, e2.heap_max = _, r2 = 0; r2 < h2; r2++) 0 !== s2[2 * r2] ? (e2.heap[++e2.heap_len] = u2 = r2, e2.depth[r2] = 0) : s2[2 * r2 + 1] = 0;
              for (; e2.heap_len < 2; ) s2[2 * (i2 = e2.heap[++e2.heap_len] = u2 < 2 ? ++u2 : 0)] = 1, e2.depth[i2] = 0, e2.opt_len--, o2 && (e2.static_len -= a2[2 * i2 + 1]);
              for (t2.max_code = u2, r2 = e2.heap_len >> 1; 1 <= r2; r2--) G(e2, s2, r2);
              for (i2 = h2; r2 = e2.heap[1], e2.heap[1] = e2.heap[e2.heap_len--], G(e2, s2, 1), n2 = e2.heap[1], e2.heap[--e2.heap_max] = r2, e2.heap[--e2.heap_max] = n2, s2[2 * i2] = s2[2 * r2] + s2[2 * n2], e2.depth[i2] = (e2.depth[r2] >= e2.depth[n2] ? e2.depth[r2] : e2.depth[n2]) + 1, s2[2 * r2 + 1] = s2[2 * n2 + 1] = i2, e2.heap[1] = i2++, G(e2, s2, 1), 2 <= e2.heap_len; ) ;
              e2.heap[--e2.heap_max] = e2.heap[1], (function(e3, t3) {
                var r3, n3, i3, s3, a3, o3, h3 = t3.dyn_tree, u3 = t3.max_code, l2 = t3.stat_desc.static_tree, f2 = t3.stat_desc.has_stree, c2 = t3.stat_desc.extra_bits, d2 = t3.stat_desc.extra_base, p2 = t3.stat_desc.max_length, m2 = 0;
                for (s3 = 0; s3 <= g; s3++) e3.bl_count[s3] = 0;
                for (h3[2 * e3.heap[e3.heap_max] + 1] = 0, r3 = e3.heap_max + 1; r3 < _; r3++) p2 < (s3 = h3[2 * h3[2 * (n3 = e3.heap[r3]) + 1] + 1] + 1) && (s3 = p2, m2++), h3[2 * n3 + 1] = s3, u3 < n3 || (e3.bl_count[s3]++, a3 = 0, d2 <= n3 && (a3 = c2[n3 - d2]), o3 = h3[2 * n3], e3.opt_len += o3 * (s3 + a3), f2 && (e3.static_len += o3 * (l2[2 * n3 + 1] + a3)));
                if (0 !== m2) {
                  do {
                    for (s3 = p2 - 1; 0 === e3.bl_count[s3]; ) s3--;
                    e3.bl_count[s3]--, e3.bl_count[s3 + 1] += 2, e3.bl_count[p2]--, m2 -= 2;
                  } while (0 < m2);
                  for (s3 = p2; 0 !== s3; s3--) for (n3 = e3.bl_count[s3]; 0 !== n3; ) u3 < (i3 = e3.heap[--r3]) || (h3[2 * i3 + 1] !== s3 && (e3.opt_len += (s3 - h3[2 * i3 + 1]) * h3[2 * i3], h3[2 * i3 + 1] = s3), n3--);
                }
              })(e2, t2), Z(s2, u2, e2.bl_count);
            }
            function X(e2, t2, r2) {
              var n2, i2, s2 = -1, a2 = t2[1], o2 = 0, h2 = 7, u2 = 4;
              for (0 === a2 && (h2 = 138, u2 = 3), t2[2 * (r2 + 1) + 1] = 65535, n2 = 0; n2 <= r2; n2++) i2 = a2, a2 = t2[2 * (n2 + 1) + 1], ++o2 < h2 && i2 === a2 || (o2 < u2 ? e2.bl_tree[2 * i2] += o2 : 0 !== i2 ? (i2 !== s2 && e2.bl_tree[2 * i2]++, e2.bl_tree[2 * b]++) : o2 <= 10 ? e2.bl_tree[2 * v]++ : e2.bl_tree[2 * y]++, s2 = i2, u2 = (o2 = 0) === a2 ? (h2 = 138, 3) : i2 === a2 ? (h2 = 6, 3) : (h2 = 7, 4));
            }
            function V(e2, t2, r2) {
              var n2, i2, s2 = -1, a2 = t2[1], o2 = 0, h2 = 7, u2 = 4;
              for (0 === a2 && (h2 = 138, u2 = 3), n2 = 0; n2 <= r2; n2++) if (i2 = a2, a2 = t2[2 * (n2 + 1) + 1], !(++o2 < h2 && i2 === a2)) {
                if (o2 < u2) for (; L(e2, i2, e2.bl_tree), 0 != --o2; ) ;
                else 0 !== i2 ? (i2 !== s2 && (L(e2, i2, e2.bl_tree), o2--), L(e2, b, e2.bl_tree), P(e2, o2 - 3, 2)) : o2 <= 10 ? (L(e2, v, e2.bl_tree), P(e2, o2 - 3, 3)) : (L(e2, y, e2.bl_tree), P(e2, o2 - 11, 7));
                s2 = i2, u2 = (o2 = 0) === a2 ? (h2 = 138, 3) : i2 === a2 ? (h2 = 6, 3) : (h2 = 7, 4);
              }
            }
            n(T);
            var q = false;
            function J(e2, t2, r2, n2) {
              P(e2, (s << 1) + (n2 ? 1 : 0), 3), (function(e3, t3, r3, n3) {
                M(e3), U(e3, r3), U(e3, ~r3), i.arraySet(e3.pending_buf, e3.window, t3, r3, e3.pending), e3.pending += r3;
              })(e2, t2, r2);
            }
            r._tr_init = function(e2) {
              q || ((function() {
                var e3, t2, r2, n2, i2, s2 = new Array(g + 1);
                for (n2 = r2 = 0; n2 < a - 1; n2++) for (I[n2] = r2, e3 = 0; e3 < 1 << w[n2]; e3++) A[r2++] = n2;
                for (A[r2 - 1] = n2, n2 = i2 = 0; n2 < 16; n2++) for (T[n2] = i2, e3 = 0; e3 < 1 << k[n2]; e3++) E[i2++] = n2;
                for (i2 >>= 7; n2 < f; n2++) for (T[n2] = i2 << 7, e3 = 0; e3 < 1 << k[n2] - 7; e3++) E[256 + i2++] = n2;
                for (t2 = 0; t2 <= g; t2++) s2[t2] = 0;
                for (e3 = 0; e3 <= 143; ) z[2 * e3 + 1] = 8, e3++, s2[8]++;
                for (; e3 <= 255; ) z[2 * e3 + 1] = 9, e3++, s2[9]++;
                for (; e3 <= 279; ) z[2 * e3 + 1] = 7, e3++, s2[7]++;
                for (; e3 <= 287; ) z[2 * e3 + 1] = 8, e3++, s2[8]++;
                for (Z(z, l + 1, s2), e3 = 0; e3 < f; e3++) C[2 * e3 + 1] = 5, C[2 * e3] = j(e3, 5);
                O = new D(z, w, u + 1, l, g), B = new D(C, k, 0, f, g), R = new D(new Array(0), x, 0, c, p);
              })(), q = true), e2.l_desc = new F(e2.dyn_ltree, O), e2.d_desc = new F(e2.dyn_dtree, B), e2.bl_desc = new F(e2.bl_tree, R), e2.bi_buf = 0, e2.bi_valid = 0, W(e2);
            }, r._tr_stored_block = J, r._tr_flush_block = function(e2, t2, r2, n2) {
              var i2, s2, a2 = 0;
              0 < e2.level ? (2 === e2.strm.data_type && (e2.strm.data_type = (function(e3) {
                var t3, r3 = 4093624447;
                for (t3 = 0; t3 <= 31; t3++, r3 >>>= 1) if (1 & r3 && 0 !== e3.dyn_ltree[2 * t3]) return o;
                if (0 !== e3.dyn_ltree[18] || 0 !== e3.dyn_ltree[20] || 0 !== e3.dyn_ltree[26]) return h;
                for (t3 = 32; t3 < u; t3++) if (0 !== e3.dyn_ltree[2 * t3]) return h;
                return o;
              })(e2)), Y(e2, e2.l_desc), Y(e2, e2.d_desc), a2 = (function(e3) {
                var t3;
                for (X(e3, e3.dyn_ltree, e3.l_desc.max_code), X(e3, e3.dyn_dtree, e3.d_desc.max_code), Y(e3, e3.bl_desc), t3 = c - 1; 3 <= t3 && 0 === e3.bl_tree[2 * S[t3] + 1]; t3--) ;
                return e3.opt_len += 3 * (t3 + 1) + 5 + 5 + 4, t3;
              })(e2), i2 = e2.opt_len + 3 + 7 >>> 3, (s2 = e2.static_len + 3 + 7 >>> 3) <= i2 && (i2 = s2)) : i2 = s2 = r2 + 5, r2 + 4 <= i2 && -1 !== t2 ? J(e2, t2, r2, n2) : 4 === e2.strategy || s2 === i2 ? (P(e2, 2 + (n2 ? 1 : 0), 3), K(e2, z, C)) : (P(e2, 4 + (n2 ? 1 : 0), 3), (function(e3, t3, r3, n3) {
                var i3;
                for (P(e3, t3 - 257, 5), P(e3, r3 - 1, 5), P(e3, n3 - 4, 4), i3 = 0; i3 < n3; i3++) P(e3, e3.bl_tree[2 * S[i3] + 1], 3);
                V(e3, e3.dyn_ltree, t3 - 1), V(e3, e3.dyn_dtree, r3 - 1);
              })(e2, e2.l_desc.max_code + 1, e2.d_desc.max_code + 1, a2 + 1), K(e2, e2.dyn_ltree, e2.dyn_dtree)), W(e2), n2 && M(e2);
            }, r._tr_tally = function(e2, t2, r2) {
              return e2.pending_buf[e2.d_buf + 2 * e2.last_lit] = t2 >>> 8 & 255, e2.pending_buf[e2.d_buf + 2 * e2.last_lit + 1] = 255 & t2, e2.pending_buf[e2.l_buf + e2.last_lit] = 255 & r2, e2.last_lit++, 0 === t2 ? e2.dyn_ltree[2 * r2]++ : (e2.matches++, t2--, e2.dyn_ltree[2 * (A[r2] + u + 1)]++, e2.dyn_dtree[2 * N(t2)]++), e2.last_lit === e2.lit_bufsize - 1;
            }, r._tr_align = function(e2) {
              P(e2, 2, 3), L(e2, m, z), (function(e3) {
                16 === e3.bi_valid ? (U(e3, e3.bi_buf), e3.bi_buf = 0, e3.bi_valid = 0) : 8 <= e3.bi_valid && (e3.pending_buf[e3.pending++] = 255 & e3.bi_buf, e3.bi_buf >>= 8, e3.bi_valid -= 8);
              })(e2);
            };
          }, { "../utils/common": 41 }], 53: [function(e, t, r) {
            t.exports = function() {
              this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
            };
          }, {}], 54: [function(e, t, r) {
            (function(e2) {
              !(function(r2, n) {
                if (!r2.setImmediate) {
                  var i, s, t2, a, o = 1, h = {}, u = false, l = r2.document, e3 = Object.getPrototypeOf && Object.getPrototypeOf(r2);
                  e3 = e3 && e3.setTimeout ? e3 : r2, i = "[object process]" === {}.toString.call(r2.process) ? function(e4) {
                    process$12.nextTick(function() {
                      c(e4);
                    });
                  } : (function() {
                    if (r2.postMessage && !r2.importScripts) {
                      var e4 = true, t3 = r2.onmessage;
                      return r2.onmessage = function() {
                        e4 = false;
                      }, r2.postMessage("", "*"), r2.onmessage = t3, e4;
                    }
                  })() ? (a = "setImmediate$" + Math.random() + "$", r2.addEventListener ? r2.addEventListener("message", d, false) : r2.attachEvent("onmessage", d), function(e4) {
                    r2.postMessage(a + e4, "*");
                  }) : r2.MessageChannel ? ((t2 = new MessageChannel()).port1.onmessage = function(e4) {
                    c(e4.data);
                  }, function(e4) {
                    t2.port2.postMessage(e4);
                  }) : l && "onreadystatechange" in l.createElement("script") ? (s = l.documentElement, function(e4) {
                    var t3 = l.createElement("script");
                    t3.onreadystatechange = function() {
                      c(e4), t3.onreadystatechange = null, s.removeChild(t3), t3 = null;
                    }, s.appendChild(t3);
                  }) : function(e4) {
                    setTimeout(c, 0, e4);
                  }, e3.setImmediate = function(e4) {
                    "function" != typeof e4 && (e4 = new Function("" + e4));
                    for (var t3 = new Array(arguments.length - 1), r3 = 0; r3 < t3.length; r3++) t3[r3] = arguments[r3 + 1];
                    var n2 = { callback: e4, args: t3 };
                    return h[o] = n2, i(o), o++;
                  }, e3.clearImmediate = f;
                }
                function f(e4) {
                  delete h[e4];
                }
                function c(e4) {
                  if (u) setTimeout(c, 0, e4);
                  else {
                    var t3 = h[e4];
                    if (t3) {
                      u = true;
                      try {
                        !(function(e5) {
                          var t4 = e5.callback, r3 = e5.args;
                          switch (r3.length) {
                            case 0:
                              t4();
                              break;
                            case 1:
                              t4(r3[0]);
                              break;
                            case 2:
                              t4(r3[0], r3[1]);
                              break;
                            case 3:
                              t4(r3[0], r3[1], r3[2]);
                              break;
                            default:
                              t4.apply(n, r3);
                          }
                        })(t3);
                      } finally {
                        f(e4), u = false;
                      }
                    }
                  }
                }
                function d(e4) {
                  e4.source === r2 && "string" == typeof e4.data && 0 === e4.data.indexOf(a) && c(+e4.data.slice(a.length));
                }
              })("undefined" == typeof self ? void 0 === e2 ? this : e2 : self);
            }).call(this, "undefined" != typeof commonjsGlobal2 ? commonjsGlobal2 : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
          }, {}] }, {}, [10])(10);
        });
      })(jszip_min2);
      return jszip_min2.exports;
    }
    var jszip_minExports2 = requireJszip_min2();
    var JSZip2 = /* @__PURE__ */ getDefaultExportFromCjs$12(jszip_minExports2);
    var xml$12 = { exports: {} };
    var escapeForXML_12;
    var hasRequiredEscapeForXML2;
    function requireEscapeForXML2() {
      if (hasRequiredEscapeForXML2) return escapeForXML_12;
      hasRequiredEscapeForXML2 = 1;
      var XML_CHARACTER_MAP = {
        "&": "&amp;",
        '"': "&quot;",
        "'": "&apos;",
        "<": "&lt;",
        ">": "&gt;"
      };
      function escapeForXML(string) {
        return string && string.replace ? string.replace(/([&"<>'])/g, function(str, item) {
          return XML_CHARACTER_MAP[item];
        }) : string;
      }
      escapeForXML_12 = escapeForXML;
      return escapeForXML_12;
    }
    var hasRequiredXml2;
    function requireXml2() {
      if (hasRequiredXml2) return xml$12.exports;
      hasRequiredXml2 = 1;
      var escapeForXML = requireEscapeForXML2();
      var Stream = requireStreamBrowserify2().Stream;
      var DEFAULT_INDENT = "    ";
      function xml22(input, options) {
        if (typeof options !== "object") {
          options = {
            indent: options
          };
        }
        var stream = options.stream ? new Stream() : null, output = "", interrupted = false, indent = !options.indent ? "" : options.indent === true ? DEFAULT_INDENT : options.indent, instant = true;
        function delay(func) {
          if (!instant) {
            func();
          } else {
            process$12.nextTick(func);
          }
        }
        function append(interrupt, out) {
          if (out !== void 0) {
            output += out;
          }
          if (interrupt && !interrupted) {
            stream = stream || new Stream();
            interrupted = true;
          }
          if (interrupt && interrupted) {
            var data = output;
            delay(function() {
              stream.emit("data", data);
            });
            output = "";
          }
        }
        function add(value, last) {
          format(append, resolve(value, indent, indent ? 1 : 0), last);
        }
        function end() {
          if (stream) {
            var data = output;
            delay(function() {
              stream.emit("data", data);
              stream.emit("end");
              stream.readable = false;
              stream.emit("close");
            });
          }
        }
        function addXmlDeclaration(declaration) {
          var encoding = declaration.encoding || "UTF-8", attr = { version: "1.0", encoding };
          if (declaration.standalone) {
            attr.standalone = declaration.standalone;
          }
          add({ "?xml": { _attr: attr } });
          output = output.replace("/>", "?>");
        }
        delay(function() {
          instant = false;
        });
        if (options.declaration) {
          addXmlDeclaration(options.declaration);
        }
        if (input && input.forEach) {
          input.forEach(function(value, i) {
            var last;
            if (i + 1 === input.length)
              last = end;
            add(value, last);
          });
        } else {
          add(input, end);
        }
        if (stream) {
          stream.readable = true;
          return stream;
        }
        return output;
      }
      function element() {
        var input = Array.prototype.slice.call(arguments), self2 = {
          _elem: resolve(input)
        };
        self2.push = function(input2) {
          if (!this.append) {
            throw new Error("not assigned to a parent!");
          }
          var that = this;
          var indent = this._elem.indent;
          format(
            this.append,
            resolve(
              input2,
              indent,
              this._elem.icount + (indent ? 1 : 0)
            ),
            function() {
              that.append(true);
            }
          );
        };
        self2.close = function(input2) {
          if (input2 !== void 0) {
            this.push(input2);
          }
          if (this.end) {
            this.end();
          }
        };
        return self2;
      }
      function create_indent(character, count) {
        return new Array(count || 0).join(character || "");
      }
      function resolve(data, indent, indent_count) {
        indent_count = indent_count || 0;
        var indent_spaces = create_indent(indent, indent_count);
        var name;
        var values = data;
        var interrupt = false;
        if (typeof data === "object") {
          var keys = Object.keys(data);
          name = keys[0];
          values = data[name];
          if (values && values._elem) {
            values._elem.name = name;
            values._elem.icount = indent_count;
            values._elem.indent = indent;
            values._elem.indents = indent_spaces;
            values._elem.interrupt = values;
            return values._elem;
          }
        }
        var attributes = [], content = [];
        var isStringContent;
        function get_attributes(obj) {
          var keys2 = Object.keys(obj);
          keys2.forEach(function(key) {
            attributes.push(attribute(key, obj[key]));
          });
        }
        switch (typeof values) {
          case "object":
            if (values === null) break;
            if (values._attr) {
              get_attributes(values._attr);
            }
            if (values._cdata) {
              content.push(
                ("<![CDATA[" + values._cdata).replace(/\]\]>/g, "]]]]><![CDATA[>") + "]]>"
              );
            }
            if (values.forEach) {
              isStringContent = false;
              content.push("");
              values.forEach(function(value) {
                if (typeof value == "object") {
                  var _name = Object.keys(value)[0];
                  if (_name == "_attr") {
                    get_attributes(value._attr);
                  } else {
                    content.push(resolve(
                      value,
                      indent,
                      indent_count + 1
                    ));
                  }
                } else {
                  content.pop();
                  isStringContent = true;
                  content.push(escapeForXML(value));
                }
              });
              if (!isStringContent) {
                content.push("");
              }
            }
            break;
          default:
            content.push(escapeForXML(values));
        }
        return {
          name,
          interrupt,
          attributes,
          content,
          icount: indent_count,
          indents: indent_spaces,
          indent
        };
      }
      function format(append, elem, end) {
        if (typeof elem != "object") {
          return append(false, elem);
        }
        var len = elem.interrupt ? 1 : elem.content.length;
        function proceed() {
          while (elem.content.length) {
            var value = elem.content.shift();
            if (value === void 0) continue;
            if (interrupt(value)) return;
            format(append, value);
          }
          append(false, (len > 1 ? elem.indents : "") + (elem.name ? "</" + elem.name + ">" : "") + (elem.indent && !end ? "\n" : ""));
          if (end) {
            end();
          }
        }
        function interrupt(value) {
          if (value.interrupt) {
            value.interrupt.append = append;
            value.interrupt.end = proceed;
            value.interrupt = false;
            append(true);
            return true;
          }
          return false;
        }
        append(false, elem.indents + (elem.name ? "<" + elem.name : "") + (elem.attributes.length ? " " + elem.attributes.join(" ") : "") + (len ? elem.name ? ">" : "" : elem.name ? "/>" : "") + (elem.indent && len > 1 ? "\n" : ""));
        if (!len) {
          return append(false, elem.indent ? "\n" : "");
        }
        if (!interrupt(elem)) {
          proceed();
        }
      }
      function attribute(key, value) {
        return key + '="' + escapeForXML(value) + '"';
      }
      xml$12.exports = xml22;
      xml$12.exports.element = xml$12.exports.Element = element;
      return xml$12.exports;
    }
    var xmlExports2 = requireXml2();
    var xml2 = /* @__PURE__ */ getDefaultExportFromCjs$12(xmlExports2);
    var obfuscatedStartOffset2 = 0;
    var obfuscatedEndOffset2 = 32;
    var guidSize2 = 32;
    var obfuscate2 = (buf, fontKey) => {
      const guid = fontKey.replace(/-/g, "");
      if (guid.length !== guidSize2) {
        throw new Error(`Error: Cannot extract GUID from font filename: ${fontKey}`);
      }
      const hexStrings = guid.replace(/(..)/g, "$1 ").trim().split(" ");
      const hexNumbers = hexStrings.map((hexString) => parseInt(hexString, 16));
      hexNumbers.reverse();
      const bytesToObfuscate = buf.slice(obfuscatedStartOffset2, obfuscatedEndOffset2);
      const obfuscatedBytes = bytesToObfuscate.map((byte, i) => byte ^ hexNumbers[i % hexNumbers.length]);
      const out = new Uint8Array(obfuscatedStartOffset2 + obfuscatedBytes.length + Math.max(0, buf.length - obfuscatedEndOffset2));
      out.set(buf.slice(0, obfuscatedStartOffset2));
      out.set(obfuscatedBytes, obfuscatedStartOffset2);
      out.set(buf.slice(obfuscatedEndOffset2), obfuscatedStartOffset2 + obfuscatedBytes.length);
      return out;
    };
    var Formatter2 = class {
      format(input, context = { stack: [] }) {
        const output = input.prepForXml(context);
        if (output) {
          return output;
        } else {
          throw Error("XMLComponent did not format correctly");
        }
      }
    };
    var ImageReplacer2 = class {
      replace(xmlData, mediaData, offset) {
        let currentXmlData = xmlData;
        mediaData.forEach((image, i) => {
          currentXmlData = currentXmlData.replace(new RegExp(`{${image.fileName}}`, "g"), (offset + i).toString());
        });
        return currentXmlData;
      }
      getMediaData(xmlData, media) {
        return media.Array.filter((image) => xmlData.search(`{${image.fileName}}`) > 0);
      }
    };
    var NumberingReplacer2 = class {
      replace(xmlData, concreteNumberings) {
        let currentXmlData = xmlData;
        for (const concreteNumbering of concreteNumberings) {
          currentXmlData = currentXmlData.replace(
            new RegExp(`{${concreteNumbering.reference}-${concreteNumbering.instance}}`, "g"),
            concreteNumbering.numId.toString()
          );
        }
        return currentXmlData;
      }
    };
    var Compiler2 = class {
      constructor() {
        __publicField2(this, "formatter");
        __publicField2(this, "imageReplacer");
        __publicField2(this, "numberingReplacer");
        this.formatter = new Formatter2();
        this.imageReplacer = new ImageReplacer2();
        this.numberingReplacer = new NumberingReplacer2();
      }
      compile(file, prettifyXml, overrides = []) {
        const zip = new JSZip2();
        const xmlifiedFileMapping = this.xmlifyFile(file, prettifyXml);
        const map = new Map(Object.entries(xmlifiedFileMapping));
        for (const [, obj] of map) {
          if (Array.isArray(obj)) {
            for (const subFile of obj) {
              zip.file(subFile.path, subFile.data);
            }
          } else {
            zip.file(obj.path, obj.data);
          }
        }
        for (const subFile of overrides) {
          zip.file(subFile.path, subFile.data);
        }
        for (const data of file.Media.Array) {
          if (data.type !== "svg") {
            zip.file(`word/media/${data.fileName}`, data.data);
          } else {
            zip.file(`word/media/${data.fileName}`, data.data);
            zip.file(`word/media/${data.fallback.fileName}`, data.fallback.data);
          }
        }
        for (const { data: buffer22, name, fontKey } of file.FontTable.fontOptionsWithKey) {
          const [nameWithoutExtension] = name.split(".");
          zip.file(`word/fonts/${nameWithoutExtension}.odttf`, obfuscate2(buffer22, fontKey));
        }
        return zip;
      }
      xmlifyFile(file, prettify) {
        const documentRelationshipCount = file.Document.Relationships.RelationshipCount + 1;
        const documentXmlData = xml2(
          this.formatter.format(file.Document.View, {
            viewWrapper: file.Document,
            file,
            stack: []
          }),
          {
            indent: prettify,
            declaration: {
              standalone: "yes",
              encoding: "UTF-8"
            }
          }
        );
        const commentRelationshipCount = file.Comments.Relationships.RelationshipCount + 1;
        const commentXmlData = xml2(
          this.formatter.format(file.Comments, {
            viewWrapper: {
              View: file.Comments,
              Relationships: file.Comments.Relationships
            },
            file,
            stack: []
          }),
          {
            indent: prettify,
            declaration: {
              standalone: "yes",
              encoding: "UTF-8"
            }
          }
        );
        const documentMediaDatas = this.imageReplacer.getMediaData(documentXmlData, file.Media);
        const commentMediaDatas = this.imageReplacer.getMediaData(commentXmlData, file.Media);
        return {
          Relationships: {
            data: (() => {
              documentMediaDatas.forEach((mediaData, i) => {
                file.Document.Relationships.createRelationship(
                  documentRelationshipCount + i,
                  "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
                  `media/${mediaData.fileName}`
                );
              });
              file.Document.Relationships.createRelationship(
                file.Document.Relationships.RelationshipCount + 1,
                "http://schemas.openxmlformats.org/officeDocument/2006/relationships/fontTable",
                "fontTable.xml"
              );
              return xml2(
                this.formatter.format(file.Document.Relationships, {
                  viewWrapper: file.Document,
                  file,
                  stack: []
                }),
                {
                  indent: prettify,
                  declaration: {
                    encoding: "UTF-8"
                  }
                }
              );
            })(),
            path: "word/_rels/document.xml.rels"
          },
          Document: {
            data: (() => {
              const xmlData = this.imageReplacer.replace(documentXmlData, documentMediaDatas, documentRelationshipCount);
              const referenedXmlData = this.numberingReplacer.replace(xmlData, file.Numbering.ConcreteNumbering);
              return referenedXmlData;
            })(),
            path: "word/document.xml"
          },
          Styles: {
            data: (() => {
              const xmlStyles = xml2(
                this.formatter.format(file.Styles, {
                  viewWrapper: file.Document,
                  file,
                  stack: []
                }),
                {
                  indent: prettify,
                  declaration: {
                    standalone: "yes",
                    encoding: "UTF-8"
                  }
                }
              );
              const referencedXmlStyles = this.numberingReplacer.replace(xmlStyles, file.Numbering.ConcreteNumbering);
              return referencedXmlStyles;
            })(),
            path: "word/styles.xml"
          },
          Properties: {
            data: xml2(
              this.formatter.format(file.CoreProperties, {
                viewWrapper: file.Document,
                file,
                stack: []
              }),
              {
                indent: prettify,
                declaration: {
                  standalone: "yes",
                  encoding: "UTF-8"
                }
              }
            ),
            path: "docProps/core.xml"
          },
          Numbering: {
            data: xml2(
              this.formatter.format(file.Numbering, {
                viewWrapper: file.Document,
                file,
                stack: []
              }),
              {
                indent: prettify,
                declaration: {
                  standalone: "yes",
                  encoding: "UTF-8"
                }
              }
            ),
            path: "word/numbering.xml"
          },
          FileRelationships: {
            data: xml2(
              this.formatter.format(file.FileRelationships, {
                viewWrapper: file.Document,
                file,
                stack: []
              }),
              {
                indent: prettify,
                declaration: {
                  encoding: "UTF-8"
                }
              }
            ),
            path: "_rels/.rels"
          },
          HeaderRelationships: file.Headers.map((headerWrapper, index) => {
            const xmlData = xml2(
              this.formatter.format(headerWrapper.View, {
                viewWrapper: headerWrapper,
                file,
                stack: []
              }),
              {
                indent: prettify,
                declaration: {
                  encoding: "UTF-8"
                }
              }
            );
            const mediaDatas = this.imageReplacer.getMediaData(xmlData, file.Media);
            mediaDatas.forEach((mediaData, i) => {
              headerWrapper.Relationships.createRelationship(
                i,
                "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
                `media/${mediaData.fileName}`
              );
            });
            return {
              data: xml2(
                this.formatter.format(headerWrapper.Relationships, {
                  viewWrapper: headerWrapper,
                  file,
                  stack: []
                }),
                {
                  indent: prettify,
                  declaration: {
                    encoding: "UTF-8"
                  }
                }
              ),
              path: `word/_rels/header${index + 1}.xml.rels`
            };
          }),
          FooterRelationships: file.Footers.map((footerWrapper, index) => {
            const xmlData = xml2(
              this.formatter.format(footerWrapper.View, {
                viewWrapper: footerWrapper,
                file,
                stack: []
              }),
              {
                indent: prettify,
                declaration: {
                  encoding: "UTF-8"
                }
              }
            );
            const mediaDatas = this.imageReplacer.getMediaData(xmlData, file.Media);
            mediaDatas.forEach((mediaData, i) => {
              footerWrapper.Relationships.createRelationship(
                i,
                "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
                `media/${mediaData.fileName}`
              );
            });
            return {
              data: xml2(
                this.formatter.format(footerWrapper.Relationships, {
                  viewWrapper: footerWrapper,
                  file,
                  stack: []
                }),
                {
                  indent: prettify,
                  declaration: {
                    encoding: "UTF-8"
                  }
                }
              ),
              path: `word/_rels/footer${index + 1}.xml.rels`
            };
          }),
          Headers: file.Headers.map((headerWrapper, index) => {
            const tempXmlData = xml2(
              this.formatter.format(headerWrapper.View, {
                viewWrapper: headerWrapper,
                file,
                stack: []
              }),
              {
                indent: prettify,
                declaration: {
                  encoding: "UTF-8"
                }
              }
            );
            const mediaDatas = this.imageReplacer.getMediaData(tempXmlData, file.Media);
            const xmlData = this.imageReplacer.replace(tempXmlData, mediaDatas, 0);
            const referenedXmlData = this.numberingReplacer.replace(xmlData, file.Numbering.ConcreteNumbering);
            return {
              data: referenedXmlData,
              path: `word/header${index + 1}.xml`
            };
          }),
          Footers: file.Footers.map((footerWrapper, index) => {
            const tempXmlData = xml2(
              this.formatter.format(footerWrapper.View, {
                viewWrapper: footerWrapper,
                file,
                stack: []
              }),
              {
                indent: prettify,
                declaration: {
                  encoding: "UTF-8"
                }
              }
            );
            const mediaDatas = this.imageReplacer.getMediaData(tempXmlData, file.Media);
            const xmlData = this.imageReplacer.replace(tempXmlData, mediaDatas, 0);
            const referenedXmlData = this.numberingReplacer.replace(xmlData, file.Numbering.ConcreteNumbering);
            return {
              data: referenedXmlData,
              path: `word/footer${index + 1}.xml`
            };
          }),
          ContentTypes: {
            data: xml2(
              this.formatter.format(file.ContentTypes, {
                viewWrapper: file.Document,
                file,
                stack: []
              }),
              {
                indent: prettify,
                declaration: {
                  encoding: "UTF-8"
                }
              }
            ),
            path: "[Content_Types].xml"
          },
          CustomProperties: {
            data: xml2(
              this.formatter.format(file.CustomProperties, {
                viewWrapper: file.Document,
                file,
                stack: []
              }),
              {
                indent: prettify,
                declaration: {
                  standalone: "yes",
                  encoding: "UTF-8"
                }
              }
            ),
            path: "docProps/custom.xml"
          },
          AppProperties: {
            data: xml2(
              this.formatter.format(file.AppProperties, {
                viewWrapper: file.Document,
                file,
                stack: []
              }),
              {
                indent: prettify,
                declaration: {
                  standalone: "yes",
                  encoding: "UTF-8"
                }
              }
            ),
            path: "docProps/app.xml"
          },
          FootNotes: {
            data: xml2(
              this.formatter.format(file.FootNotes.View, {
                viewWrapper: file.FootNotes,
                file,
                stack: []
              }),
              {
                indent: prettify,
                declaration: {
                  encoding: "UTF-8"
                }
              }
            ),
            path: "word/footnotes.xml"
          },
          FootNotesRelationships: {
            data: xml2(
              this.formatter.format(file.FootNotes.Relationships, {
                viewWrapper: file.FootNotes,
                file,
                stack: []
              }),
              {
                indent: prettify,
                declaration: {
                  encoding: "UTF-8"
                }
              }
            ),
            path: "word/_rels/footnotes.xml.rels"
          },
          Settings: {
            data: xml2(
              this.formatter.format(file.Settings, {
                viewWrapper: file.Document,
                file,
                stack: []
              }),
              {
                indent: prettify,
                declaration: {
                  standalone: "yes",
                  encoding: "UTF-8"
                }
              }
            ),
            path: "word/settings.xml"
          },
          Comments: {
            data: (() => {
              const xmlData = this.imageReplacer.replace(commentXmlData, commentMediaDatas, commentRelationshipCount);
              const referenedXmlData = this.numberingReplacer.replace(xmlData, file.Numbering.ConcreteNumbering);
              return referenedXmlData;
            })(),
            path: "word/comments.xml"
          },
          CommentsRelationships: {
            data: (() => {
              commentMediaDatas.forEach((mediaData, i) => {
                file.Comments.Relationships.createRelationship(
                  commentRelationshipCount + i,
                  "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
                  `media/${mediaData.fileName}`
                );
              });
              return xml2(
                this.formatter.format(file.Comments.Relationships, {
                  viewWrapper: {
                    View: file.Comments,
                    Relationships: file.Comments.Relationships
                  },
                  file,
                  stack: []
                }),
                {
                  indent: prettify,
                  declaration: {
                    encoding: "UTF-8"
                  }
                }
              );
            })(),
            path: "word/_rels/comments.xml.rels"
          },
          FontTable: {
            data: xml2(
              this.formatter.format(file.FontTable.View, {
                viewWrapper: file.Document,
                file,
                stack: []
              }),
              {
                indent: prettify,
                declaration: {
                  standalone: "yes",
                  encoding: "UTF-8"
                }
              }
            ),
            path: "word/fontTable.xml"
          },
          FontTableRelationships: {
            data: (() => xml2(
              this.formatter.format(file.FontTable.Relationships, {
                viewWrapper: file.Document,
                file,
                stack: []
              }),
              {
                indent: prettify,
                declaration: {
                  encoding: "UTF-8"
                }
              }
            ))(),
            path: "word/_rels/fontTable.xml.rels"
          }
        };
      }
    };
    var PrettifyType2 = {
      NONE: "",
      WITH_2_BLANKS: "  ",
      WITH_4_BLANKS: "    ",
      WITH_TAB: "	"
    };
    var convertPrettifyType2 = (prettify) => prettify === true ? PrettifyType2.WITH_2_BLANKS : prettify === false ? void 0 : prettify;
    var _Packer3 = class _Packer4 {
      // eslint-disable-next-line require-await
      static pack(_0, _122, _2) {
        return __async2(this, arguments, function* (file, type22, prettify, overrides = []) {
          const zip = this.compiler.compile(file, convertPrettifyType2(prettify), overrides);
          return zip.generateAsync({
            type: type22,
            mimeType: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
            compression: "DEFLATE"
          });
        });
      }
      static toString(file, prettify, overrides = []) {
        return _Packer4.pack(file, "string", prettify, overrides);
      }
      static toBuffer(file, prettify, overrides = []) {
        return _Packer4.pack(file, "nodebuffer", prettify, overrides);
      }
      static toBase64String(file, prettify, overrides = []) {
        return _Packer4.pack(file, "base64", prettify, overrides);
      }
      static toBlob(file, prettify, overrides = []) {
        return _Packer4.pack(file, "blob", prettify, overrides);
      }
      static toArrayBuffer(file, prettify, overrides = []) {
        return _Packer4.pack(file, "arraybuffer", prettify, overrides);
      }
      static toStream(file, prettify, overrides = []) {
        const stream = new streamBrowserifyExports2.Stream();
        const zip = this.compiler.compile(file, convertPrettifyType2(prettify), overrides);
        zip.generateAsync({
          type: "nodebuffer",
          mimeType: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
          compression: "DEFLATE"
        }).then((z) => {
          stream.emit("data", z);
          stream.emit("end");
        });
        return stream;
      }
    };
    __publicField2(_Packer3, "compiler", new Compiler2());
    var Packer3 = _Packer3;
    var formatter$12 = new Formatter2();
    var toJson = (xmlData) => {
      const xmlObj = libExports2.xml2js(xmlData, { compact: false, captureSpacesBetweenElements: true });
      return xmlObj;
    };
    var createTextElementContents = (text) => {
      var _a;
      const textJson = toJson(xml2(formatter$12.format(new Text2({ text }))));
      return (_a = textJson.elements[0].elements) != null ? _a : [];
    };
    var patchSpaceAttribute = (element) => __spreadProps2(__spreadValues2({}, element), {
      attributes: {
        "xml:space": "preserve"
      }
    });
    var getFirstLevelElements = (relationships, id) => {
      var _a, _b;
      return (_b = (_a = relationships.elements) == null ? void 0 : _a.filter((e) => e.name === id)[0].elements) != null ? _b : [];
    };
    var appendContentType = (element, contentType, extension) => {
      const relationshipElements = getFirstLevelElements(element, "Types");
      const exist = relationshipElements.some(
        (el) => {
          var _a, _b;
          return el.type === "element" && el.name === "Default" && ((_a = el == null ? void 0 : el.attributes) == null ? void 0 : _a.ContentType) === contentType && ((_b = el == null ? void 0 : el.attributes) == null ? void 0 : _b.Extension) === extension;
        }
      );
      if (exist) {
        return;
      }
      relationshipElements.push({
        attributes: {
          ContentType: contentType,
          Extension: extension
        },
        name: "Default",
        type: "element"
      });
    };
    var getIdFromRelationshipId = (relationshipId) => {
      const output = parseInt(relationshipId.substring(3), 10);
      return isNaN(output) ? 0 : output;
    };
    var getNextRelationshipIndex = (relationships) => {
      const relationshipElements = getFirstLevelElements(relationships, "Relationships");
      return relationshipElements.map((e) => {
        var _a, _b, _c;
        return getIdFromRelationshipId((_c = (_b = (_a = e.attributes) == null ? void 0 : _a.Id) == null ? void 0 : _b.toString()) != null ? _c : "");
      }).reduce((acc, curr) => Math.max(acc, curr), 0) + 1;
    };
    var appendRelationship = (relationships, id, type22, target, targetMode) => {
      const relationshipElements = getFirstLevelElements(relationships, "Relationships");
      relationshipElements.push({
        attributes: {
          Id: `rId${id}`,
          Type: type22,
          Target: target,
          TargetMode: targetMode
        },
        name: "Relationship",
        type: "element"
      });
      return relationshipElements;
    };
    var findRunElementIndexWithToken = (paragraphElement, token) => {
      var _a, _b, _c, _d;
      for (let i = 0; i < ((_a = paragraphElement.elements) != null ? _a : []).length; i++) {
        const element = paragraphElement.elements[i];
        if (element.type === "element" && element.name === "w:r") {
          const textElement = ((_b = element.elements) != null ? _b : []).filter((e) => e.type === "element" && e.name === "w:t");
          for (const text of textElement) {
            if (!((_c = text.elements) == null ? void 0 : _c[0])) {
              continue;
            }
            if ((_d = text.elements[0].text) == null ? void 0 : _d.includes(token)) {
              return i;
            }
          }
        }
      }
      throw new Error("Token not found");
    };
    var splitRunElement = (runElement, token) => {
      var _a, _b;
      let splitIndex = 0;
      const splitElements = (_b = (_a = runElement.elements) == null ? void 0 : _a.map((e, i) => {
        var _a2, _b2, _c;
        if (e.type === "element" && e.name === "w:t") {
          const text = (_c = (_b2 = (_a2 = e.elements) == null ? void 0 : _a2[0]) == null ? void 0 : _b2.text) != null ? _c : "";
          const splitText = text.split(token);
          const newElements = splitText.map((t) => __spreadProps2(__spreadValues2(__spreadValues2({}, e), patchSpaceAttribute(e)), {
            elements: createTextElementContents(t)
          }));
          splitIndex = i;
          return newElements;
        } else {
          return e;
        }
      }).flat()) != null ? _b : [];
      const leftRunElement = __spreadProps2(__spreadValues2({}, JSON.parse(JSON.stringify(runElement))), {
        elements: splitElements.slice(0, splitIndex + 1)
      });
      const rightRunElement = __spreadProps2(__spreadValues2({}, JSON.parse(JSON.stringify(runElement))), {
        elements: splitElements.slice(splitIndex + 1)
      });
      return { left: leftRunElement, right: rightRunElement };
    };
    var ReplaceMode = {
      START: 0,
      MIDDLE: 1,
      END: 2
    };
    var replaceTokenInParagraphElement = ({
      paragraphElement,
      renderedParagraph,
      originalText,
      replacementText
    }) => {
      const startIndex = renderedParagraph.text.indexOf(originalText);
      const endIndex = startIndex + originalText.length - 1;
      let replaceMode = ReplaceMode.START;
      for (const run of renderedParagraph.runs) {
        for (const { text, index, start, end } of run.parts) {
          switch (replaceMode) {
            case ReplaceMode.START:
              if (startIndex >= start) {
                const offsetStartIndex = startIndex - start;
                const offsetEndIndex = Math.min(endIndex, end) - start;
                const partToReplace = run.text.substring(offsetStartIndex, offsetEndIndex + 1);
                if (partToReplace === "") {
                  continue;
                }
                const firstPart = text.replace(partToReplace, replacementText);
                patchTextElement(paragraphElement.elements[run.index].elements[index], firstPart);
                replaceMode = ReplaceMode.MIDDLE;
                continue;
              }
              break;
            case ReplaceMode.MIDDLE:
              if (endIndex <= end) {
                const lastPart = text.substring(endIndex - start + 1);
                patchTextElement(paragraphElement.elements[run.index].elements[index], lastPart);
                const currentElement = paragraphElement.elements[run.index].elements[index];
                paragraphElement.elements[run.index].elements[index] = patchSpaceAttribute(currentElement);
                replaceMode = ReplaceMode.END;
              } else {
                patchTextElement(paragraphElement.elements[run.index].elements[index], "");
              }
              break;
          }
        }
      }
      return paragraphElement;
    };
    var patchTextElement = (element, text) => {
      element.elements = createTextElementContents(text);
      return element;
    };
    var renderParagraphNode = (node) => {
      if (node.element.name !== "w:p") {
        throw new Error(`Invalid node type: ${node.element.name}`);
      }
      if (!node.element.elements) {
        return {
          text: "",
          runs: [],
          index: -1,
          pathToParagraph: []
        };
      }
      let currentRunStringLength = 0;
      const runs = node.element.elements.map((element, i) => ({ element, i })).filter(({ element }) => element.name === "w:r").map(({ element, i }) => {
        const renderedRunNode = renderRunNode(element, i, currentRunStringLength);
        currentRunStringLength += renderedRunNode.text.length;
        return renderedRunNode;
      }).filter((e) => !!e);
      const text = runs.reduce((acc, curr) => acc + curr.text, "");
      return {
        text,
        runs,
        index: node.index,
        pathToParagraph: buildNodePath(node)
      };
    };
    var renderRunNode = (node, index, currentRunStringIndex) => {
      if (!node.elements) {
        return {
          text: "",
          parts: [],
          index: -1,
          start: currentRunStringIndex,
          end: currentRunStringIndex
        };
      }
      let currentTextStringIndex = currentRunStringIndex;
      const parts = node.elements.map(
        (element, i) => {
          var _a, _b;
          return element.name === "w:t" && element.elements && element.elements.length > 0 ? {
            text: (_b = (_a = element.elements[0].text) == null ? void 0 : _a.toString()) != null ? _b : "",
            index: i,
            start: currentTextStringIndex,
            end: (() => {
              var _a2, _b2;
              currentTextStringIndex += ((_b2 = (_a2 = element.elements[0].text) == null ? void 0 : _a2.toString()) != null ? _b2 : "").length - 1;
              return currentTextStringIndex;
            })()
          } : void 0;
        }
      ).filter((e) => !!e).map((e) => e);
      const text = parts.reduce((acc, curr) => acc + curr.text, "");
      return {
        text,
        parts,
        index,
        start: currentRunStringIndex,
        end: currentTextStringIndex
      };
    };
    var buildNodePath = (node) => node.parent ? [...buildNodePath(node.parent), node.index] : [node.index];
    var elementsToWrapper = (wrapper) => {
      var _a, _b;
      return (_b = (_a = wrapper.element.elements) == null ? void 0 : _a.map((e, i) => ({
        element: e,
        index: i,
        parent: wrapper
      }))) != null ? _b : [];
    };
    var traverse = (node) => {
      let renderedParagraphs = [];
      const queue22 = [
        ...elementsToWrapper({
          element: node,
          index: 0,
          parent: void 0
        })
      ];
      let currentNode;
      while (queue22.length > 0) {
        currentNode = queue22.shift();
        if (currentNode.element.name === "w:p") {
          renderedParagraphs = [...renderedParagraphs, renderParagraphNode(currentNode)];
        }
        queue22.push(...elementsToWrapper(currentNode));
      }
      return renderedParagraphs;
    };
    var findLocationOfText = (node, text) => traverse(node).filter((p) => p.text.includes(text));
    var formatter2 = new Formatter2();
    var SPLIT_TOKEN = "\u0275";
    var replacer = ({
      json,
      patch,
      patchText,
      context,
      keepOriginalStyles = true
    }) => {
      const renderedParagraphs = findLocationOfText(json, patchText);
      if (renderedParagraphs.length === 0) {
        return { element: json, didFindOccurrence: false };
      }
      for (const renderedParagraph of renderedParagraphs) {
        const textJson = patch.children.map((c) => toJson(xml2(formatter2.format(c, context)))).map((c) => c.elements[0]);
        switch (patch.type) {
          case PatchType.DOCUMENT: {
            const parentElement = goToParentElementFromPath(json, renderedParagraph.pathToParagraph);
            const elementIndex = getLastElementIndexFromPath(renderedParagraph.pathToParagraph);
            parentElement.elements.splice(elementIndex, 1, ...textJson);
            break;
          }
          case PatchType.PARAGRAPH:
          default: {
            const paragraphElement = goToElementFromPath(json, renderedParagraph.pathToParagraph);
            replaceTokenInParagraphElement({
              paragraphElement,
              renderedParagraph,
              originalText: patchText,
              replacementText: SPLIT_TOKEN
            });
            const index = findRunElementIndexWithToken(paragraphElement, SPLIT_TOKEN);
            const runElementToBeReplaced = paragraphElement.elements[index];
            const { left, right } = splitRunElement(runElementToBeReplaced, SPLIT_TOKEN);
            let newRunElements = textJson;
            let patchedRightElement = right;
            if (keepOriginalStyles) {
              const runElementNonTextualElements = runElementToBeReplaced.elements.filter(
                (e) => e.type === "element" && e.name === "w:rPr"
              );
              newRunElements = textJson.map((e) => {
                var _a;
                return __spreadProps2(__spreadValues2({}, e), {
                  elements: [...runElementNonTextualElements, ...(_a = e.elements) != null ? _a : []]
                });
              });
              patchedRightElement = __spreadProps2(__spreadValues2({}, right), {
                elements: [...runElementNonTextualElements, ...right.elements]
              });
            }
            paragraphElement.elements.splice(index, 1, left, ...newRunElements, patchedRightElement);
            break;
          }
        }
      }
      return { element: json, didFindOccurrence: true };
    };
    var goToElementFromPath = (json, path) => {
      let element = json;
      for (let i = 1; i < path.length; i++) {
        const index = path[i];
        const nextElements = element.elements;
        element = nextElements[index];
      }
      return element;
    };
    var goToParentElementFromPath = (json, path) => goToElementFromPath(json, path.slice(0, path.length - 1));
    var getLastElementIndexFromPath = (path) => path[path.length - 1];
    var PatchType = {
      DOCUMENT: "file",
      PARAGRAPH: "paragraph"
    };
    var imageReplacer2 = new ImageReplacer2();
    var UTF16LE2 = new Uint8Array([255, 254]);
    var UTF16BE2 = new Uint8Array([254, 255]);
    var compareByteArrays = (a, b) => {
      if (a.length !== b.length) {
        return false;
      }
      for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
          return false;
        }
      }
      return true;
    };
    var patchDocument = (_0) => __async2(exports2, [_0], function* ({
      outputType,
      data,
      patches,
      keepOriginalStyles,
      placeholderDelimiters = { start: "{{", end: "}}" },
      /**
       * Search for occurrences over patched document
       */
      recursive = true
    }) {
      var _a, _b, _c;
      const zipContent = data instanceof JSZip2 ? data : yield JSZip2.loadAsync(data);
      const contexts = /* @__PURE__ */ new Map();
      const file = {
        Media: new Media2()
      };
      const map = /* @__PURE__ */ new Map();
      const imageRelationshipAdditions = [];
      const hyperlinkRelationshipAdditions = [];
      let hasMedia = false;
      const binaryContentMap = /* @__PURE__ */ new Map();
      for (const [key, value] of Object.entries(zipContent.files)) {
        const binaryValue = yield value.async("uint8array");
        const startBytes = binaryValue.slice(0, 2);
        if (compareByteArrays(startBytes, UTF16LE2) || compareByteArrays(startBytes, UTF16BE2)) {
          binaryContentMap.set(key, binaryValue);
          continue;
        }
        if (!key.endsWith(".xml") && !key.endsWith(".rels")) {
          binaryContentMap.set(key, binaryValue);
          continue;
        }
        const json = toJson(yield value.async("text"));
        if (key === "word/document.xml") {
          const document2 = (_a = json.elements) == null ? void 0 : _a.find((i) => i.name === "w:document");
          if (document2 && document2.attributes) {
            for (const ns of ["mc", "wp", "r", "w15", "m"]) {
              document2.attributes[`xmlns:${ns}`] = DocumentAttributeNamespaces2[ns];
            }
            document2.attributes["mc:Ignorable"] = `${document2.attributes["mc:Ignorable"] || ""} w15`.trim();
          }
        }
        if (key.startsWith("word/") && !key.endsWith(".xml.rels")) {
          const context = {
            file,
            viewWrapper: {
              Relationships: {
                createRelationship: (linkId, _, target, __) => {
                  hyperlinkRelationshipAdditions.push({
                    key,
                    hyperlink: {
                      id: linkId,
                      link: target
                    }
                  });
                }
              }
            },
            stack: []
          };
          contexts.set(key, context);
          if (!(placeholderDelimiters == null ? void 0 : placeholderDelimiters.start.trim()) || !(placeholderDelimiters == null ? void 0 : placeholderDelimiters.end.trim())) {
            throw new Error("Both start and end delimiters must be non-empty strings.");
          }
          const { start, end } = placeholderDelimiters;
          for (const [patchKey, patchValue] of Object.entries(patches)) {
            const patchText = `${start}${patchKey}${end}`;
            while (true) {
              const { didFindOccurrence } = replacer({
                json,
                patch: __spreadProps2(__spreadValues2({}, patchValue), {
                  children: patchValue.children.map((element) => {
                    if (element instanceof ExternalHyperlink2) {
                      const concreteHyperlink = new ConcreteHyperlink2(element.options.children, uniqueId2());
                      hyperlinkRelationshipAdditions.push({
                        key,
                        hyperlink: {
                          id: concreteHyperlink.linkId,
                          link: element.options.link
                        }
                      });
                      return concreteHyperlink;
                    } else {
                      return element;
                    }
                  })
                  // eslint-disable-next-line @typescript-eslint/no-explicit-any
                }),
                patchText,
                context,
                keepOriginalStyles
              });
              if (!recursive || !didFindOccurrence) {
                break;
              }
            }
          }
          const mediaDatas = imageReplacer2.getMediaData(JSON.stringify(json), context.file.Media);
          if (mediaDatas.length > 0) {
            hasMedia = true;
            imageRelationshipAdditions.push({
              key,
              mediaDatas
            });
          }
        }
        map.set(key, json);
      }
      for (const { key, mediaDatas } of imageRelationshipAdditions) {
        const relationshipKey = `word/_rels/${key.split("/").pop()}.rels`;
        const relationshipsJson = (_b = map.get(relationshipKey)) != null ? _b : createRelationshipFile();
        map.set(relationshipKey, relationshipsJson);
        const index = getNextRelationshipIndex(relationshipsJson);
        const newJson = imageReplacer2.replace(JSON.stringify(map.get(key)), mediaDatas, index);
        map.set(key, JSON.parse(newJson));
        for (let i = 0; i < mediaDatas.length; i++) {
          const { fileName } = mediaDatas[i];
          appendRelationship(
            relationshipsJson,
            index + i,
            "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
            `media/${fileName}`
          );
        }
      }
      for (const { key, hyperlink } of hyperlinkRelationshipAdditions) {
        const relationshipKey = `word/_rels/${key.split("/").pop()}.rels`;
        const relationshipsJson = (_c = map.get(relationshipKey)) != null ? _c : createRelationshipFile();
        map.set(relationshipKey, relationshipsJson);
        appendRelationship(
          relationshipsJson,
          hyperlink.id,
          "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink",
          hyperlink.link,
          TargetModeType2.EXTERNAL
        );
      }
      if (hasMedia) {
        const contentTypesJson = map.get("[Content_Types].xml");
        if (!contentTypesJson) {
          throw new Error("Could not find content types file");
        }
        appendContentType(contentTypesJson, "image/png", "png");
        appendContentType(contentTypesJson, "image/jpeg", "jpeg");
        appendContentType(contentTypesJson, "image/jpeg", "jpg");
        appendContentType(contentTypesJson, "image/bmp", "bmp");
        appendContentType(contentTypesJson, "image/gif", "gif");
        appendContentType(contentTypesJson, "image/svg+xml", "svg");
      }
      const zip = new JSZip2();
      for (const [key, value] of map) {
        const output = toXml(value);
        zip.file(key, output);
      }
      for (const [key, value] of binaryContentMap) {
        zip.file(key, value);
      }
      for (const { data: stream, fileName } of file.Media.Array) {
        zip.file(`word/media/${fileName}`, stream);
      }
      return zip.generateAsync({
        type: outputType,
        mimeType: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        compression: "DEFLATE"
      });
    });
    var toXml = (jsonObj) => {
      const output = libExports2.js2xml(jsonObj, {
        attributeValueFn: (str) => String(str).replace(/&(?!amp;|lt;|gt;|quot;|apos;)/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;")
        // cspell:words apos
      });
      return output;
    };
    var createRelationshipFile = () => ({
      declaration: {
        attributes: {
          version: "1.0",
          encoding: "UTF-8",
          standalone: "yes"
        }
      },
      elements: [
        {
          type: "element",
          name: "Relationships",
          attributes: {
            xmlns: "http://schemas.openxmlformats.org/package/2006/relationships"
          },
          elements: []
        }
      ]
    });
    var patchDetector = (_0) => __async2(exports2, [_0], function* ({ data }) {
      const zipContent = data instanceof JSZip2 ? data : yield JSZip2.loadAsync(data);
      const patches = /* @__PURE__ */ new Set();
      for (const [key, value] of Object.entries(zipContent.files)) {
        if (!key.endsWith(".xml") && !key.endsWith(".rels")) {
          continue;
        }
        if (key.startsWith("word/") && !key.endsWith(".xml.rels")) {
          const json = toJson(yield value.async("text"));
          traverse(json).forEach((p) => findPatchKeys(p.text).forEach((patch) => patches.add(patch)));
        }
      }
      return Array.from(patches);
    });
    var findPatchKeys = (text) => {
      var _a;
      const pattern = new RegExp("(?<=\\{\\{).+?(?=\\}\\})", "gs");
      return (_a = text.match(pattern)) != null ? _a : [];
    };
    exports2.AbstractNumbering = AbstractNumbering2;
    exports2.Alignment = Alignment2;
    exports2.AlignmentAttributes = AlignmentAttributes2;
    exports2.AlignmentType = AlignmentType2;
    exports2.AnnotationReference = AnnotationReference;
    exports2.Attributes = Attributes2;
    exports2.BaseEmphasisMark = BaseEmphasisMark2;
    exports2.BaseXmlComponent = BaseXmlComponent2;
    exports2.Body = Body2;
    exports2.Bookmark = Bookmark2;
    exports2.BookmarkEnd = BookmarkEnd2;
    exports2.BookmarkStart = BookmarkStart2;
    exports2.Border = Border2;
    exports2.BorderElement = BorderElement2;
    exports2.BorderStyle = BorderStyle2;
    exports2.BuilderElement = BuilderElement2;
    exports2.CarriageReturn = CarriageReturn;
    exports2.CharacterSet = CharacterSet;
    exports2.CheckBox = CheckBox;
    exports2.CheckBoxSymbolElement = CheckBoxSymbolElement;
    exports2.CheckBoxUtil = CheckBoxUtil;
    exports2.Column = Column;
    exports2.ColumnBreak = ColumnBreak;
    exports2.Columns = Columns2;
    exports2.Comment = Comment2;
    exports2.CommentRangeEnd = CommentRangeEnd;
    exports2.CommentRangeStart = CommentRangeStart;
    exports2.CommentReference = CommentReference;
    exports2.Comments = Comments2;
    exports2.ConcreteHyperlink = ConcreteHyperlink2;
    exports2.ConcreteNumbering = ConcreteNumbering2;
    exports2.ContinuationSeparator = ContinuationSeparator;
    exports2.DayLong = DayLong;
    exports2.DayShort = DayShort;
    exports2.DeletedTextRun = DeletedTextRun;
    exports2.Document = File2;
    exports2.DocumentAttributeNamespaces = DocumentAttributeNamespaces2;
    exports2.DocumentAttributes = DocumentAttributes2;
    exports2.DocumentBackground = DocumentBackground2;
    exports2.DocumentBackgroundAttributes = DocumentBackgroundAttributes2;
    exports2.DocumentDefaults = DocumentDefaults2;
    exports2.DocumentGridType = DocumentGridType;
    exports2.DotEmphasisMark = DotEmphasisMark;
    exports2.Drawing = Drawing2;
    exports2.DropCapType = DropCapType;
    exports2.EMPTY_OBJECT = EMPTY_OBJECT2;
    exports2.EmphasisMark = EmphasisMark2;
    exports2.EmphasisMarkType = EmphasisMarkType2;
    exports2.EmptyElement = EmptyElement;
    exports2.EndnoteReference = EndnoteReference;
    exports2.ExternalHyperlink = ExternalHyperlink2;
    exports2.File = File2;
    exports2.FileChild = FileChild2;
    exports2.FootNoteReferenceRunAttributes = FootNoteReferenceRunAttributes2;
    exports2.FootNotes = FootNotes2;
    exports2.Footer = Footer2;
    exports2.FooterWrapper = FooterWrapper2;
    exports2.FootnoteReference = FootnoteReference2;
    exports2.FootnoteReferenceElement = FootnoteReferenceElement;
    exports2.FootnoteReferenceRun = FootnoteReferenceRun3;
    exports2.FrameAnchorType = FrameAnchorType;
    exports2.FrameWrap = FrameWrap;
    exports2.GridSpan = GridSpan2;
    exports2.Header = Header2;
    exports2.HeaderFooterReference = HeaderFooterReference2;
    exports2.HeaderFooterReferenceType = HeaderFooterReferenceType2;
    exports2.HeaderFooterType = HeaderFooterType2;
    exports2.HeaderWrapper = HeaderWrapper2;
    exports2.HeadingLevel = HeadingLevel3;
    exports2.HeightRule = HeightRule;
    exports2.HighlightColor = HighlightColor;
    exports2.HorizontalPositionAlign = HorizontalPositionAlign;
    exports2.HorizontalPositionRelativeFrom = HorizontalPositionRelativeFrom2;
    exports2.HpsMeasureElement = HpsMeasureElement2;
    exports2.HyperlinkType = HyperlinkType;
    exports2.IgnoreIfEmptyXmlComponent = IgnoreIfEmptyXmlComponent2;
    exports2.ImageRun = ImageRun2;
    exports2.ImportedRootElementAttributes = ImportedRootElementAttributes2;
    exports2.ImportedXmlComponent = ImportedXmlComponent2;
    exports2.Indent = Indent2;
    exports2.InitializableXmlComponent = InitializableXmlComponent2;
    exports2.InsertedTextRun = InsertedTextRun;
    exports2.InternalHyperlink = InternalHyperlink2;
    exports2.LastRenderedPageBreak = LastRenderedPageBreak;
    exports2.LeaderType = LeaderType;
    exports2.Level = Level2;
    exports2.LevelBase = LevelBase2;
    exports2.LevelForOverride = LevelForOverride;
    exports2.LevelFormat = LevelFormat2;
    exports2.LevelOverride = LevelOverride2;
    exports2.LevelSuffix = LevelSuffix;
    exports2.LineNumberRestartFormat = LineNumberRestartFormat;
    exports2.LineRuleType = LineRuleType2;
    exports2.Math = Math$12;
    exports2.MathAngledBrackets = MathAngledBrackets;
    exports2.MathCurlyBrackets = MathCurlyBrackets;
    exports2.MathDegree = MathDegree;
    exports2.MathDenominator = MathDenominator;
    exports2.MathFraction = MathFraction;
    exports2.MathFunction = MathFunction;
    exports2.MathFunctionName = MathFunctionName;
    exports2.MathFunctionProperties = MathFunctionProperties;
    exports2.MathIntegral = MathIntegral;
    exports2.MathLimit = MathLimit;
    exports2.MathLimitLower = MathLimitLower;
    exports2.MathLimitUpper = MathLimitUpper;
    exports2.MathNumerator = MathNumerator;
    exports2.MathPreSubSuperScript = MathPreSubSuperScript;
    exports2.MathRadical = MathRadical;
    exports2.MathRadicalProperties = MathRadicalProperties;
    exports2.MathRoundBrackets = MathRoundBrackets;
    exports2.MathRun = MathRun2;
    exports2.MathSquareBrackets = MathSquareBrackets;
    exports2.MathSubScript = MathSubScript;
    exports2.MathSubSuperScript = MathSubSuperScript;
    exports2.MathSum = MathSum;
    exports2.MathSuperScript = MathSuperScript;
    exports2.Media = Media2;
    exports2.MonthLong = MonthLong;
    exports2.MonthShort = MonthShort;
    exports2.NextAttributeComponent = NextAttributeComponent2;
    exports2.NoBreakHyphen = NoBreakHyphen;
    exports2.NumberFormat = NumberFormat$1;
    exports2.NumberProperties = NumberProperties2;
    exports2.NumberValueElement = NumberValueElement2;
    exports2.Numbering = Numbering2;
    exports2.OnOffElement = OnOffElement2;
    exports2.OutlineLevel = OutlineLevel2;
    exports2.OverlapType = OverlapType;
    exports2.Packer = Packer3;
    exports2.PageBorderDisplay = PageBorderDisplay;
    exports2.PageBorderOffsetFrom = PageBorderOffsetFrom;
    exports2.PageBorderZOrder = PageBorderZOrder;
    exports2.PageBorders = PageBorders2;
    exports2.PageBreak = PageBreak;
    exports2.PageBreakBefore = PageBreakBefore2;
    exports2.PageMargin = PageMargin2;
    exports2.PageNumber = PageNumber2;
    exports2.PageNumberElement = PageNumberElement;
    exports2.PageNumberSeparator = PageNumberSeparator;
    exports2.PageNumberType = PageNumberType2;
    exports2.PageNumberTypeAttributes = PageNumberTypeAttributes2;
    exports2.PageOrientation = PageOrientation2;
    exports2.PageReference = PageReference;
    exports2.PageTextDirection = PageTextDirection2;
    exports2.PageTextDirectionType = PageTextDirectionType;
    exports2.Paragraph = Paragraph3;
    exports2.ParagraphProperties = ParagraphProperties2;
    exports2.ParagraphPropertiesDefaults = ParagraphPropertiesDefaults2;
    exports2.PatchType = PatchType;
    exports2.PositionalTab = PositionalTab;
    exports2.PositionalTabAlignment = PositionalTabAlignment;
    exports2.PositionalTabLeader = PositionalTabLeader;
    exports2.PositionalTabRelativeTo = PositionalTabRelativeTo;
    exports2.PrettifyType = PrettifyType2;
    exports2.RelativeHorizontalPosition = RelativeHorizontalPosition;
    exports2.RelativeVerticalPosition = RelativeVerticalPosition;
    exports2.Run = Run2;
    exports2.RunFonts = RunFonts2;
    exports2.RunProperties = RunProperties2;
    exports2.RunPropertiesChange = RunPropertiesChange2;
    exports2.RunPropertiesDefaults = RunPropertiesDefaults2;
    exports2.SectionProperties = SectionProperties2;
    exports2.SectionType = SectionType2;
    exports2.SectionTypeAttributes = SectionTypeAttributes2;
    exports2.Separator = Separator;
    exports2.SequentialIdentifier = SequentialIdentifier2;
    exports2.Shading = Shading2;
    exports2.ShadingType = ShadingType2;
    exports2.SimpleField = SimpleField2;
    exports2.SimpleMailMergeField = SimpleMailMergeField;
    exports2.SoftHyphen = SoftHyphen;
    exports2.SpaceType = SpaceType2;
    exports2.Spacing = Spacing2;
    exports2.StringContainer = StringContainer2;
    exports2.StringEnumValueElement = StringEnumValueElement2;
    exports2.StringValueElement = StringValueElement2;
    exports2.Style = Style$12;
    exports2.StyleForCharacter = StyleForCharacter2;
    exports2.StyleForParagraph = StyleForParagraph2;
    exports2.StyleLevel = StyleLevel2;
    exports2.Styles = Styles2;
    exports2.SymbolRun = SymbolRun;
    exports2.TDirection = TDirection2;
    exports2.Tab = Tab;
    exports2.TabAttributes = TabAttributes2;
    exports2.TabStop = TabStop2;
    exports2.TabStopItem = TabStopItem2;
    exports2.TabStopPosition = TabStopPosition2;
    exports2.TabStopType = TabStopType2;
    exports2.Table = Table2;
    exports2.TableAnchorType = TableAnchorType;
    exports2.TableBorders = TableBorders2;
    exports2.TableCell = TableCell2;
    exports2.TableCellBorders = TableCellBorders2;
    exports2.TableFloatProperties = TableFloatProperties2;
    exports2.TableLayout = TableLayout2;
    exports2.TableLayoutType = TableLayoutType;
    exports2.TableOfContents = TableOfContents;
    exports2.TableProperties = TableProperties2;
    exports2.TableRow = TableRow2;
    exports2.TableRowHeight = TableRowHeight2;
    exports2.TableRowHeightAttributes = TableRowHeightAttributes2;
    exports2.TableRowProperties = TableRowProperties2;
    exports2.TableWidthElement = TableWidthElement2;
    exports2.TextDirection = TextDirection;
    exports2.TextEffect = TextEffect;
    exports2.TextRun = TextRun3;
    exports2.TextWrappingSide = TextWrappingSide2;
    exports2.TextWrappingType = TextWrappingType2;
    exports2.Textbox = Textbox;
    exports2.ThematicBreak = ThematicBreak2;
    exports2.Type = Type2;
    exports2.Underline = Underline2;
    exports2.UnderlineType = UnderlineType2;
    exports2.VerticalAlign = VerticalAlign2;
    exports2.VerticalAlignAttributes = VerticalAlignAttributes2;
    exports2.VerticalAlignElement = VerticalAlignElement2;
    exports2.VerticalAlignSection = VerticalAlignSection2;
    exports2.VerticalAlignTable = VerticalAlignTable2;
    exports2.VerticalMerge = VerticalMerge2;
    exports2.VerticalMergeType = VerticalMergeType2;
    exports2.VerticalPositionAlign = VerticalPositionAlign;
    exports2.VerticalPositionRelativeFrom = VerticalPositionRelativeFrom2;
    exports2.WORKAROUND2 = WORKAROUND2;
    exports2.WORKAROUND3 = WORKAROUND3;
    exports2.WORKAROUND4 = WORKAROUND4;
    exports2.WidthType = WidthType2;
    exports2.WrapNone = WrapNone2;
    exports2.WrapSquare = WrapSquare2;
    exports2.WrapTight = WrapTight2;
    exports2.WrapTopAndBottom = WrapTopAndBottom2;
    exports2.XmlAttributeComponent = XmlAttributeComponent2;
    exports2.XmlComponent = XmlComponent2;
    exports2.YearLong = YearLong;
    exports2.YearShort = YearShort;
    exports2.abstractNumUniqueNumericIdGen = abstractNumUniqueNumericIdGen2;
    exports2.bookmarkUniqueNumericIdGen = bookmarkUniqueNumericIdGen2;
    exports2.concreteNumUniqueNumericIdGen = concreteNumUniqueNumericIdGen2;
    exports2.convertInchesToTwip = convertInchesToTwip2;
    exports2.convertMillimetersToTwip = convertMillimetersToTwip;
    exports2.convertToXmlComponent = convertToXmlComponent2;
    exports2.createDocumentGrid = createDocumentGrid2;
    exports2.createFrameProperties = createFrameProperties2;
    exports2.createHorizontalPosition = createHorizontalPosition2;
    exports2.createLineNumberType = createLineNumberType2;
    exports2.createMathAccentCharacter = createMathAccentCharacter;
    exports2.createMathBase = createMathBase;
    exports2.createMathLimitLocation = createMathLimitLocation;
    exports2.createMathNAryProperties = createMathNAryProperties;
    exports2.createMathPreSubSuperScriptProperties = createMathPreSubSuperScriptProperties;
    exports2.createMathSubScriptElement = createMathSubScriptElement;
    exports2.createMathSubScriptProperties = createMathSubScriptProperties;
    exports2.createMathSubSuperScriptProperties = createMathSubSuperScriptProperties;
    exports2.createMathSuperScriptElement = createMathSuperScriptElement;
    exports2.createMathSuperScriptProperties = createMathSuperScriptProperties;
    exports2.createPageSize = createPageSize2;
    exports2.createSimplePos = createSimplePos2;
    exports2.createStringElement = createStringElement2;
    exports2.createVerticalPosition = createVerticalPosition2;
    exports2.dateTimeValue = dateTimeValue2;
    exports2.decimalNumber = decimalNumber2;
    exports2.docPropertiesUniqueNumericIdGen = docPropertiesUniqueNumericIdGen2;
    exports2.eighthPointMeasureValue = eighthPointMeasureValue2;
    exports2.hashedId = hashedId2;
    exports2.hexColorValue = hexColorValue2;
    exports2.hpsMeasureValue = hpsMeasureValue2;
    exports2.longHexNumber = longHexNumber;
    exports2.measurementOrPercentValue = measurementOrPercentValue2;
    exports2.patchDetector = patchDetector;
    exports2.patchDocument = patchDocument;
    exports2.percentageValue = percentageValue2;
    exports2.pointMeasureValue = pointMeasureValue2;
    exports2.positiveUniversalMeasureValue = positiveUniversalMeasureValue2;
    exports2.sectionMarginDefaults = sectionMarginDefaults2;
    exports2.sectionPageSizeDefaults = sectionPageSizeDefaults2;
    exports2.shortHexNumber = shortHexNumber;
    exports2.signedHpsMeasureValue = signedHpsMeasureValue;
    exports2.signedTwipsMeasureValue = signedTwipsMeasureValue2;
    exports2.twipsMeasureValue = twipsMeasureValue2;
    exports2.uCharHexNumber = uCharHexNumber2;
    exports2.uniqueId = uniqueId2;
    exports2.uniqueNumericIdCreator = uniqueNumericIdCreator2;
    exports2.uniqueUuid = uniqueUuid2;
    exports2.universalMeasureValue = universalMeasureValue2;
    exports2.unsignedDecimalNumber = unsignedDecimalNumber2;
  }
});

// src/main.js
var { Plugin, TFolder, Notice, normalizePath, WorkspaceLeaf, PluginSettingTab, Setting } = require("obsidian");
var { ColophonView, VIEW_TYPE } = require_view2();
var { FootnoteView, FOOTNOTE_VIEW_TYPE } = require_footnote_view();
var DEFAULT_SETTINGS = {
  textColumnWidth: 1080,
  textColumnBottomPadding: 25,
  // Default to 25%
  smartQuotes: true,
  smartDashes: true,
  doubleQuoteStyle: "\u201C|\u201D",
  singleQuoteStyle: "\u2018|\u2019",
  stylesFolder: "snippets",
  enabledStyles: []
};
var { DocxSerializer: DocxSerializer2 } = (init_esm(), __toCommonJS(esm_exports));
var { Packer: Packer2, HeadingLevel: HeadingLevel2, Paragraph: Paragraph2, TextRun: TextRun2, FootnoteReferenceRun: FootnoteReferenceRun2, StyleLevel } = require_dist34();
var fs = require("fs");
var electron = require("electron");
module.exports = class ColophonPlugin extends Plugin {
  async onload() {
    await this.loadSettings();
    this.registerView(
      VIEW_TYPE,
      (leaf) => new ColophonView(leaf, this.settings, this)
    );
    const isSpellcheckEnabledForFootnotes = this.app.vault.getConfig("spellcheck");
    this.registerView(
      FOOTNOTE_VIEW_TYPE,
      (leaf) => new FootnoteView(leaf, this.settings, isSpellcheckEnabledForFootnotes)
    );
    this.addSettingTab(new ColophonSettingTab(this.app, this));
    this.patchOpenFile();
    this.registerEvent(
      this.app.workspace.on("file-open", this.handleFileOpen.bind(this))
    );
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", this.handleActiveLeafChange.bind(this))
    );
    this.addRibbonIcon("feather", "New manuscript", async () => {
      await this.createNewManuscript();
    });
    this.registerEvent(
      this.app.workspace.on("file-menu", (menu, file) => {
        const isFolder = file instanceof TFolder;
        const path = isFolder ? file.path : file.parent.path;
        menu.addItem((item) => {
          item.setTitle("New manuscript").setIcon("feather").onClick(async () => {
            await this.createNewManuscript(path);
          });
        });
      })
    );
    this.addCommand({
      id: "create-new-colophon-manuscript",
      name: "New manuscript",
      callback: () => this.createNewManuscript()
    });
    this.addCommand({
      id: "export-to-docx",
      name: "Export to DOCX",
      callback: () => this.exportToDocx()
    });
    this.addCommand({
      id: "open-colophon-footnotes",
      name: "Open Footnotes Sidebar",
      callback: async () => {
        this.activateFootnoteView();
      }
    });
    this.addCommand({
      id: "insert-colophon-footnote",
      name: "Insert Footnote",
      checkCallback: (checking) => {
        const view = this.app.workspace.getActiveViewOfType(ColophonView);
        if (view) {
          if (!checking) {
            view.insertFootnote();
          }
          return true;
        }
        return false;
      }
    });
    this.app.workspace.onLayoutReady(() => {
      const patchCommand = (commandId, action) => {
        const originalCommand = this.app.commands.commands[commandId];
        if (originalCommand) {
          const originalCheckCallback = originalCommand.checkCallback;
          originalCommand.checkCallback = (checking) => {
            const colophonLeaves = this.app.workspace.getLeavesOfType(VIEW_TYPE);
            const colophonView = colophonLeaves.length > 0 ? colophonLeaves[0].view : null;
            if (colophonView) {
              const footnoteView = this.app.workspace.getLeavesOfType(FOOTNOTE_VIEW_TYPE)[0]?.view;
              let targetEditor = null;
              const activeLeaf = this.app.workspace.activeLeaf;
              if (footnoteView && footnoteView instanceof FootnoteView && activeLeaf.view === footnoteView) {
                const focusedFootnoteEditor = footnoteView.getFocusedEditor();
                if (focusedFootnoteEditor) {
                  targetEditor = focusedFootnoteEditor;
                }
              }
              if (!targetEditor && colophonView.adapter && colophonView.adapter.editor && colophonView.adapter.editor.isFocused) {
                targetEditor = colophonView.adapter.editor;
              }
              if (targetEditor) {
                if (!checking) {
                  action(targetEditor);
                }
                return true;
              }
            }
            if (originalCheckCallback) {
              return originalCheckCallback(checking);
            }
            return false;
          };
        }
      };
      patchCommand("editor:insert-footnote", (editor) => {
        const colophonView = this.app.workspace.getActiveViewOfType(ColophonView);
        if (colophonView) colophonView.insertFootnote();
      });
      patchCommand("editor:toggle-bold", (editor) => editor.chain().focus().toggleBold().run());
      patchCommand("editor:toggle-italics", (editor) => editor.chain().focus().toggleItalic().run());
      patchCommand("editor:toggle-strikethrough", (editor) => editor.chain().focus().toggleStrike().run());
    });
  }
  async exportToDocx(view) {
    if (!view) {
      view = this.app.workspace.getActiveViewOfType(ColophonView);
    }
    if (!view || !(view instanceof ColophonView) || !view.adapter.editor) {
      new Notice("No active Colophon editor found.");
      return;
    }
    const editor = view.adapter.editor;
    const prosemirrorDoc = editor.state.doc;
    const defaultPath = (view.file?.basename || "Untitled") + ".docx";
    try {
      const nodeSerializers = {
        paragraph(state2, node) {
          state2.renderInline(node);
          state2.closeBlock(node);
        },
        heading(state2, node) {
          state2.renderInline(node);
          const heading = [
            HeadingLevel2.HEADING_1,
            HeadingLevel2.HEADING_2,
            HeadingLevel2.HEADING_3,
            HeadingLevel2.HEADING_4,
            HeadingLevel2.HEADING_5,
            HeadingLevel2.HEADING_6
          ][node.attrs.level - 1];
          state2.closeBlock(node, { heading });
        },
        text(state2, node) {
          state2.text(node.text);
        },
        hard_break(state2) {
          state2.addRunOptions({ break: 1 });
        },
        footnote(state2, node) {
          const id = node.attrs.id;
          const footnotes = view.adapter ? view.adapter.footnotes : [];
          const fnData = footnotes.find((f) => f.id === id);
          const content = fnData ? fnData.content : "";
          state2.$footnoteCounter = (state2.$footnoteCounter || 0) + 1;
          const refId = state2.$footnoteCounter;
          state2.footnotes[refId] = {
            children: [new Paragraph2({
              children: [new TextRun2(content)]
            })]
          };
          state2.current.push(new FootnoteReferenceRun2(refId));
        }
      };
      const markSerializers = {
        bold() {
          return { bold: true };
        },
        italic() {
          return { italics: true };
        },
        underline() {
          return { underline: {} };
        },
        strike() {
          return { strike: true };
        },
        superscript() {
          return { superScript: true };
        },
        subscript() {
          return { subScript: true };
        },
        internallink() {
          return {};
        },
        // Ignore links for now
        smallCaps() {
          return { smallCaps: true };
        }
        // Ignore custom marks for now
      };
      const serializer = new DocxSerializer2(nodeSerializers, markSerializers);
      const doc = serializer.serialize(prosemirrorDoc, {
        sections: [{
          properties: {},
          children: []
        }],
        styles: {
          default: {
            document: {
              run: {
                font: "Minion 3",
                size: 24
                // 12pt
              },
              paragraph: {
                spacing: {
                  line: 360
                  // 1.5 lines
                }
              }
            }
          },
          paragraphStyles: [
            {
              id: "Normal",
              name: "Normal",
              basedOn: "Normal",
              next: "Normal",
              quickFormat: true,
              run: {
                font: "Minion 3",
                size: 24
              },
              paragraph: {
                spacing: { line: 360 },
                indent: { firstLine: 720 }
                // 0.5 inch
              }
            },
            {
              id: "Heading1",
              name: "Heading 1",
              basedOn: "Normal",
              next: "Normal",
              quickFormat: true,
              run: {
                font: "Minion 3",
                size: 36,
                // 18pt
                italics: true
              },
              paragraph: {
                spacing: { before: 480, after: 240 }
              }
            },
            {
              id: "Heading2",
              name: "Heading 2",
              basedOn: "Normal",
              next: "Normal",
              quickFormat: true,
              run: {
                font: "Minion 3",
                size: 28,
                // 14pt
                smallCaps: true,
                tracking: 100
                // Letter spacing
              },
              paragraph: {
                spacing: { before: 360, after: 240 }
              }
            },
            {
              id: "Heading3",
              name: "Heading 3",
              basedOn: "Normal",
              next: "Normal",
              quickFormat: true,
              run: {
                font: "Minion 3",
                size: 24,
                // 12pt
                italics: true
              },
              paragraph: {
                alignment: "center",
                spacing: { before: 360, after: 240 }
              }
            }
          ]
        }
      });
      const buffer2 = await Packer2.toBuffer(doc);
      const result = await electron.remote.dialog.showSaveDialog({
        title: "Export to DOCX",
        defaultPath,
        filters: [{ name: "Word Document", extensions: ["docx"] }]
      });
      if (result.canceled || !result.filePath) {
        new Notice("Export cancelled.");
        return;
      }
      fs.writeFile(result.filePath, buffer2, (err) => {
        if (err) {
          console.error("Colophon: Failed to save DOCX file.", err);
          new Notice("Failed to save file. See console for details.");
        } else {
          new Notice("File saved successfully!");
        }
      });
    } catch (error) {
      console.error("Colophon: Error exporting to DOCX.", error);
      new Notice("An error occurred during DOCX export. See console for details.");
    }
  }
  async activateFootnoteView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(FOOTNOTE_VIEW_TYPE);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      await leaf.setViewState({ type: FOOTNOTE_VIEW_TYPE, active: true });
    }
    workspace.revealLeaf(leaf);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.app.workspace.getLeavesOfType(VIEW_TYPE).forEach((leaf) => {
      if (leaf.view instanceof ColophonView) {
        leaf.view.updateSettings(this.settings);
      }
    });
    this.app.workspace.getLeavesOfType(FOOTNOTE_VIEW_TYPE).forEach((leaf) => {
      if (leaf.view instanceof FootnoteView) {
        leaf.view.updateSettings(this.settings);
      }
    });
  }
  patchOpenFile() {
    const plugin = this;
    const originalOpenFile = WorkspaceLeaf.prototype.openFile;
    WorkspaceLeaf.prototype.openFile = async function(file, openState) {
      const app = this.app || plugin.app;
      const cache = app.metadataCache.getFileCache(file);
      if (cache?.frontmatter && cache.frontmatter["colophon-plugin"] === "manuscript") {
        const currentViewType = this.view.getViewType();
        if (currentViewType !== VIEW_TYPE) {
          await this.setViewState({
            type: VIEW_TYPE,
            state: openState,
            active: true
          });
        }
        if (this.view instanceof ColophonView) {
          await this.view.loadFile(file);
          if (openState && openState.eState) {
            this.view.setEphemeralState(openState.eState);
          }
          return;
        }
      }
      return originalOpenFile.call(this, file, openState);
    };
    this.register(() => {
      WorkspaceLeaf.prototype.openFile = originalOpenFile;
    });
  }
  async handleActiveLeafChange(leaf) {
    if (!leaf) return;
    this.updateFootnoteView(leaf.view);
    const file = leaf.view.file;
    if (!file) return;
    await this.ensureCorrectView(leaf, file);
  }
  async handleFileOpen(file) {
    if (!file) return;
    const leaf = this.app.workspace.activeLeaf;
    if (!leaf) return;
    this.updateFootnoteView(leaf.view);
    await this.ensureCorrectView(leaf, file);
  }
  updateFootnoteView(activeView) {
    const footnoteLeaves = this.app.workspace.getLeavesOfType(FOOTNOTE_VIEW_TYPE);
    if (footnoteLeaves.length === 0) return;
    const footnoteView = footnoteLeaves[0].view;
    if (activeView instanceof FootnoteView) {
      return;
    }
    if (activeView instanceof ColophonView && activeView.adapter) {
      footnoteView.setAdapter(activeView.adapter);
    } else {
      footnoteView.setAdapter(null);
    }
  }
  async ensureCorrectView(leaf, file) {
    const cache = this.app.metadataCache.getFileCache(file);
    const isColophon = cache?.frontmatter && cache.frontmatter["colophon-plugin"] === "manuscript";
    const currentViewType = leaf.view.getViewType();
    if (isColophon && currentViewType === "markdown") {
      const state2 = leaf.view.getState();
      await leaf.setViewState({
        type: VIEW_TYPE,
        state: state2,
        active: true
      });
    } else if (!isColophon && currentViewType === VIEW_TYPE) {
      const state2 = leaf.view.getState();
      await leaf.setViewState({
        type: "markdown",
        state: state2,
        active: true
      });
    }
  }
  async createNewManuscript(folder) {
    let target;
    if (folder) {
      target = typeof folder === "string" ? this.app.vault.getAbstractFileByPath(folder) : folder;
    } else {
      target = this.app.fileManager.getNewFileParent(
        this.app.workspace.getActiveFile()?.path || ""
      );
    }
    if (!target || !target.path) {
      new Notice("Invalid folder location");
      return;
    }
    const initialContent = `---
colophon-plugin: manuscript
---
`;
    const finalPath = await this.getUniqueFilePath(target);
    try {
      const newFile = await this.app.vault.create(finalPath, initialContent);
      await this.app.workspace.getLeaf(false).openFile(newFile);
    } catch (e) {
      new Notice(`Failed to create manuscript: ${e.toString()}`);
    }
  }
  async getUniqueFilePath(folder) {
    let counter = 0;
    while (true) {
      const suffix = counter === 0 ? "" : ` ${counter}`;
      const fileName = `Untitled${suffix}.md`;
      const filePath = normalizePath(`${folder.path}/${fileName}`);
      if (!await this.app.vault.exists(filePath)) {
        return filePath;
      }
      counter++;
    }
  }
  onunload() {
  }
};
var ColophonSettingTab = class extends PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Colophon Settings" });
    containerEl.createEl("h2", { text: "Layout" });
    new Setting(containerEl).setName("Text column width").setDesc("Adjust the width of the writing canvas (500px - 1240px).").addSlider((slider) => slider.setLimits(500, 1240, 10).setValue(this.plugin.settings.textColumnWidth).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.textColumnWidth = value;
      await this.plugin.saveSettings();
    }));
    new Setting(containerEl).setName("Text column bottom padding").setDesc("Sets the distance the cursor stays from the bottom of the screen. 50% keeps the active line in the middle.").addSlider((slider) => slider.setLimits(0, 75, 1).setValue(this.plugin.settings.textColumnBottomPadding).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.textColumnBottomPadding = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h2", { text: "Substitutions" });
    new Setting(containerEl).setName("Smart quotes").setDesc("Automatically replace straight quotes with smart quotes.").addToggle((toggle) => toggle.setValue(this.plugin.settings.smartQuotes).onChange(async (value) => {
      this.plugin.settings.smartQuotes = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.smartQuotes) {
      new Setting(containerEl).setName("Double quote style").setDesc("Choose the style for double quotes.").addDropdown((dropdown) => dropdown.addOption("\u201C|\u201D", "\u201Cabc\u201D").addOption("\u201E|\u201C", "\u201Eabc\u201C").addOption("\u201E|\u201D", "\u201Eabc\u201D").addOption("\u201D|\u201D", "\u201Dabc\u201D").addOption("\xAB|\xBB", "\xABabc\xBB").addOption("\xBB|\xAB", "\xBBabc\xAB").addOption('"|"', '"abc"').setValue(this.plugin.settings.doubleQuoteStyle).onChange(async (value) => {
        this.plugin.settings.doubleQuoteStyle = value;
        await this.plugin.saveSettings();
      }));
      new Setting(containerEl).setName("Single quote style").setDesc("Choose the style for single quotes.").addDropdown((dropdown) => dropdown.addOption("\u2018|\u2019", "\u2018abc\u2019").addOption("\u201A|\u2018", "\u201Aabc\u2018").addOption("\u201A|\u2019", "\u201Aabc\u2019").addOption("\u2019|\u2019", "\u2019abc\u2019").addOption("\u2039|\u203A", "\u2039abc\u203A").addOption("\u203A|\u2039", "\u203Aabc\u2039").addOption("'|'", "'abc'").setValue(this.plugin.settings.singleQuoteStyle).onChange(async (value) => {
        this.plugin.settings.singleQuoteStyle = value;
        await this.plugin.saveSettings();
      }));
    }
    new Setting(containerEl).setName("Smart dashes").setDesc("Replace -- with em-dash (\u2014) and --- with en-dash (\u2013).").addToggle((toggle) => toggle.setValue(this.plugin.settings.smartDashes).onChange(async (value) => {
      this.plugin.settings.smartDashes = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h2", { text: "Paragraph styles" });
    new Setting(containerEl).setName("Styles folder").setDesc("Folder containing YAML style definitions (relative to vault config directory).").addText((text) => text.setPlaceholder("snippets").setValue(this.plugin.settings.stylesFolder).onChange(async (value) => {
      this.plugin.settings.stylesFolder = value;
      await this.plugin.saveSettings();
      this.display();
    })).addExtraButton((btn) => btn.setIcon("folder-open").setTooltip("Open folder").onClick(() => {
      const path = this.plugin.app.vault.adapter.getBasePath() + "/" + this.plugin.app.vault.configDir + "/" + this.plugin.settings.stylesFolder;
      electron.shell.openPath(path);
    }));
    this.displayStyleFiles(containerEl);
  }
  async displayStyleFiles(containerEl) {
    const { app, settings } = this.plugin;
    const adapter = app.vault.adapter;
    const configDir = app.vault.configDir;
    const stylesFolder = settings.stylesFolder || "snippets";
    const folderPath = `${configDir}/${stylesFolder}`;
    if (!await adapter.exists(folderPath)) {
      new Setting(containerEl).setName("Folder not found").setDesc(`The folder "${folderPath}" does not exist.`).addButton((btn) => btn.setButtonText("Create folder").onClick(async () => {
        await adapter.mkdir(folderPath);
        this.display();
      }));
      return;
    }
    const files = await adapter.list(folderPath);
    const yamlFiles = files.files.filter((path) => path.endsWith(".yaml") || path.endsWith(".yml"));
    if (yamlFiles.length === 0) {
      containerEl.createDiv({ text: "No YAML files found in this folder.", cls: "setting-item-description" });
      return;
    }
    containerEl.createEl("h3", { text: "Enabled Styles" });
    for (const filePath of yamlFiles) {
      const fileName = filePath.split("/").pop();
      const isEnabled = settings.enabledStyles.includes(fileName);
      new Setting(containerEl).setName(fileName).addToggle((toggle) => toggle.setValue(isEnabled).onChange(async (value) => {
        if (value) {
          if (!settings.enabledStyles.includes(fileName)) {
            settings.enabledStyles.push(fileName);
          }
        } else {
          settings.enabledStyles = settings.enabledStyles.filter((f) => f !== fileName);
        }
        await this.plugin.saveSettings();
      }));
    }
  }
};
/*! Bundled license information:

docx/dist/index.mjs:
  (*! http://mths.be/fromcodepoint v0.1.0 by @mathias *)
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

docx/dist/index.cjs:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
  (*! http://mths.be/fromcodepoint v0.1.0 by @mathias *)
*/
